{"version":3,"sources":["webpack:///webpack/bootstrap 45327a95834e142484ba","webpack:///../~/gl-matrix/lib/gl-matrix/common.js","webpack:///../~/poly2tri/src/xy.js","webpack:///./lib/mesh.js","webpack:///../~/clipper-lib/clipper.js","webpack:///../~/gl-matrix/lib/gl-matrix/mat3.js","webpack:///../~/gl-matrix/lib/gl-matrix/mat4.js","webpack:///../~/gl-matrix/lib/gl-matrix/quat.js","webpack:///../~/gl-matrix/lib/gl-matrix/vec3.js","webpack:///../~/gl-matrix/lib/gl-matrix/vec4.js","webpack:///../~/snapsvg/dist/snap.svg.js","webpack:///../~/poly2tri/src/advancingfront.js","webpack:///../~/poly2tri/src/pointerror.js","webpack:///../~/poly2tri/src/triangle.js","webpack:///./lib/cam-gcode-mill.js","webpack:///./lib/cam.js","webpack:///./lib/workers/cam-mill.js","webpack:///../~/gl-matrix/lib/gl-matrix.js","webpack:///../~/gl-matrix/lib/gl-matrix/mat2.js","webpack:///../~/gl-matrix/lib/gl-matrix/mat2d.js","webpack:///../~/gl-matrix/lib/gl-matrix/quat2.js","webpack:///../~/gl-matrix/lib/gl-matrix/vec2.js","webpack:///../~/poly2tri/src/assert.js","webpack:///../~/poly2tri/src/point.js","webpack:///../~/poly2tri/src/sweep.js","webpack:///../~/poly2tri/src/sweepcontext.js","webpack:///../~/poly2tri/src/utils.js","webpack:///../~/web-cam-cpp/web-cam-cpp.js"],"names":["elementToRawPaths","pathStrToRawPaths","flipY","hasClosedRawPaths","filterClosedRawPaths","rawPathsToClipperPaths","triangulateRawPaths","clipperPathsToCPaths","cPathsToClipperPaths","cPathsToCamPaths","clipperBounds","clip","union","diff","xor","offset","inchToClipperScale","mmToClipperScale","clipperToCppScale","cleanPolyDist","arcTolerance","linearizeCubicBezier","p1x","p1y","c1x","c1y","c2x","c2y","p2x","p2y","minNumSegments","minSegmentLength","bez","p0","p1","p2","p3","t","numSegments","x","y","result","i","nextX","nextY","push","linearizeSnapPath","path","alertFn","length","subpath","elementToLinearSnapPaths","element","Snap","require","snapElement","type","attr","Number","w","h","map","transform","globalMatrix","parsePathString","snapPathToRawPaths","snapPath","pxPerInch","factor","currentPath","j","str","toCubic","allRawPaths","deltaY","rawPaths","rawPath","p","X","Y","ClipperLib","Clipper","CleanPolygons","SimplifyPolygons","PolyFillType","pftEvenOdd","clipperPathsToPolyTree","paths","c","AddPaths","PolyType","ptSubject","polyTree","PolyTree","Execute","ClipType","ctUnion","triangulatePolyTree","pointToVertex","point","contourToVertexes","nodesToVertexes","nodes","node","Contour","processNode","vertexes","holes","Childs","context","SweepContext","addHoles","triangulate","triangles","getTriangles","getPoints","hole","next","memoryBlocks","clipperPaths","doubleSize","cPaths","Module","_malloc","cPathsBase","cPathSizes","cPathSizesBase","clipperPath","cPath","pathArray","Float64Array","HEAPU32","buffer","byteOffset","cPathsRef","cNumPathsRef","cPathSizesRef","cNumPaths","pathSize","convertedPaths","convertedPath","safeToClose","Z","minX","MAX_VALUE","minY","maxX","maxY","pt","Math","min","max","paths1","paths2","clipType","clipper","ptClip","ctDifference","ctXor","amount","joinType","endType","undefined","JoinType","jtRound","EndType","etClosedPolygon","jtSquare","jtMiter","co","ClipperOffset","offsetted","getMillGcode","getMillGcodeFromOp","props","ramp","scale","useZ","offsetX","offsetY","decimal","topZ","botZ","safeZ","passDepth","plungeFeed","cutFeed","tabGeometry","tabZ","toolSpeed","useFluid","plungeFeedGcode","cutFeedGcode","retractGcode","toFixed","retractForTabGcode","gcode","getX","getY","convertPoint","pathIndex","origPath","separatedPaths","currentZ","finishedZ","nextZ","selectedPaths","selectedIndex","selectedPath","fluidOn","selectedZ","executedRamp","minPlungeTime","idealDist","end","totalDist","rampPath","slice","concat","reverse","distTravelled","newZ","fluidOff","settings","opIndex","op","geometry","openGeometry","showAlert","done","progress","ok","millStartZ","millRapidZ","toolAngle","millEndZ","toolDiameter","stepOver","plungeRate","cutRate","camPaths","margin","direction","cutWidth","camPath","round","segmentLength","feedScale","toolFeedUnits","hookOperationStart","machineFluidGcodeOn","machineFluidGcodeOff","tabDepth","hookOperationEnd","dist","pocket","insideOutside","cut","fillPath","vCarve","reduceCamPaths","getClipperPathsFromCamPaths","separateTabs","x1","y1","x2","y2","sqrt","crosses","bounds","AddPath","ctIntersection","ChildCount","child","points","pathIsClosed","closeClipperPaths","mergePaths","currentPoint","mergedPaths","numLeft","closestPathIndex","closestPointIndex","closestPointDist","closestReverse","check","pointIndex","needNew","cutterDia","stepover","climb","current","allPaths","isInside","width","allowRecutInBounds","currentWidth","eachWidth","eachOffset","needReverse","nextWidth","lineDistance","angle","cx","cy","r","m","mat3","fromTranslation","rotate","PI","translate","makePoint","vec2","transformMat3","scan","separated","cutterAngle","resultPathsRef","resultNumPathsRef","resultPathSizesRef","cGeometry","debugArg0","debugArg1","ccall","_free","minDist","minDistSqr","distSqr","newPath","sq","displayedCppTabError1","displayedCppTabError2","cutterPath","cCutterPath","cTabGeometry","errorRef","onmessage","event","data","errors","message","level","postMessage","JSON","stringify","apply"],"mappings":";AAAA;AACA;AACA,mEAA2D;AAC3D;AACA;AACA,WAAG;;AAEH,oDAA4C;AAC5C;AACA;;AAEA,kDAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAM;AACN;AACA;AACA,cAAM;AACN;AACA;AACA,cAAM;AACN;AACA;AACA;AACA,eAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAI;AACJ;;AAEA,6CAAqC;AACrC;AACA;;;;AAIA;AACA,sDAA8C;AAC9C;AACA,oCAA4B;AAC5B,qCAA6B;AAC7B,yCAAiC;;AAEjC,+CAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAM;AACN;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAAsC;AACtC;AACA;AACA,qCAA6B;AAC7B,qCAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAAoB,gBAAgB;AACpC;AACA;AACA;AACA,aAAK;AACL;AACA;AACA;AACA;AACA,4BAAoB,gBAAgB;AACpC;AACA;AACA;AACA,aAAK;AACL;AACA;AACA,aAAK;AACL;AACA;AACA,aAAK;AACL;AACA;AACA;AACA,aAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;AACA,aAAK;AACL;AACA;AACA;AACA,aAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yBAAiB,8BAA8B;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;AACA,aAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAI;AACJ;;AAEA,4DAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA,aAAK;AACL,YAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAa,4BAA4B;AACzC;AACA;AACA;AACA;AACA;AACA,cAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sBAAc,4BAA4B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAgB,uCAAuC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAe,uCAAuC;AACtD;AACA;AACA;AACA;AACA;AACA,uBAAe,sBAAsB;AACrC;AACA;AACA;AACA,eAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAa,wCAAwC;AACrD;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;AACA;AACA,eAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAM;AACN;AACA;AACA;AACA;AACA;AACA,gBAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAI;AACJ;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AAC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A;AAAA;AAAA,oGAAC;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,eAAe,SAAS;AACxB;AACA,eAAe,SAAS;;AAExB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,wCAAwC;AACxC,0CAA0C;AAC1C,2DAA2D;AAC3D;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,0BAA0B,OAAO;AACjC,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,uDAAuD;AACvD;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,sDAAsD;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,UAAU;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,UAAU;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,SAAS;AACnB,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,WAAW;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,cAAc;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA,+DAA+D,UAAU;AACzE;AACA;AACA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA,+DAA+D,UAAU;AACzE;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,WAAW;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mCAAmC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mCAAmC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mCAAmC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4BAA4B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,iBAAiB;AACjB,mBAAmB,cAAc;AACjC;AACA,sBAAsB;AACtB,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;ACrwND;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC,MAAM,sDAAmB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,KAAK;AACf,UAAU,KAAK;AACf;AACA,YAAY,KAAK;AACjB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU,KAAK;AACf,UAAU,KAAK;AACf;AACA,YAAY,KAAK;AACjB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB;AACttB;;AAEA;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO,mB;;;;;;;ACzyBP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC,MAAM,sDAAmB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,UAAU,UAAU;AAChC;AACA;AACA;AACA;;AAEA,YAAY,UAAU,WAAW;AACjC;AACA;AACA;AACA;;AAEA,aAAa,WAAW,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,eAAe,WAAW,WAAW;AACrC,eAAe,WAAW,WAAW;AACrC,eAAe,WAAW,YAAY;;AAEtC,iBAAiB,aAAa,aAAa;AAC3C,iBAAiB,aAAa,aAAa;AAC3C,iBAAiB,aAAa,cAAc;;AAE5C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,mDAAgB;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,WAAW,WAAW;AACnC,aAAa,WAAW,WAAW;AACnC,aAAa,WAAW,YAAY;;AAEpC;AACA,sBAAsB,wBAAwB;AAC9C,0BAA0B,oBAAoB;AAC9C,0BAA0B,wBAAwB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,mDAAgB;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,aAAa,KAAK;AAClB;AACO;AACP,wBAAwB,sDAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB;AACO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,YAAY,KAAK;AACjB;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,mDAAgB,+BAA+B,mDAAgB,+BAA+B,mDAAgB;AAC/I;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,uEAAuE,mDAAgB,yEAAyE,mDAAgB,yEAAyE,mDAAgB,yEAAyE,mDAAgB,yEAAyE,mDAAgB,yEAAyE,mDAAgB;AAC/zC;;AAEA;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO,mB;;;;;;;AChzDP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACN;AACA;AACA;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC,MAAM,sDAAmB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,KAAK;AACjB,YAAY,OAAO;AACnB;AACO;AACP;AACA;AACA,UAAU,mDAAgB;AAC1B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAgB;AACpC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA,WAAW,kDAAe;AAC1B,WAAW,kDAAe;AAC1B,WAAW,kDAAe;;AAE1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;AACpC;AACA,wBAAwB;AACxB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,aAAa,KAAK;AAClB;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACA;AACO,YAAY,+CAAU;;AAE7B;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACA;AACO,iBAAiB,oDAAe;;AAEvC;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACA;AACO,WAAW,8CAAS;;AAE3B;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACA;AACO,UAAU,6CAAQ;;AAEzB;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACA;AACO,UAAU,6CAAQ;;AAEzB;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACA;AACO,YAAY,+CAAU;;AAE7B;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACA;AACO,UAAU,6CAAQ;;AAEzB;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACA;AACO,WAAW,8CAAS;;AAE3B;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO,aAAa,gDAAW;;AAE/B;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACA;AACO,oBAAoB,uDAAkB;;AAE7C;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACA;AACO,gBAAgB,mDAAc;;AAErC;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;AACO,kBAAkB,qDAAgB;;AAEzC;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;AACO,aAAa,gDAAW;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,gDAAW;AAC3B,kBAAkB,oDAAe;AACjC,kBAAkB,oDAAe;;AAEjC;AACA,cAAc,6CAAQ;AACtB;AACA,MAAM,+CAAU;AAChB,UAAU,6CAAQ,sBAAsB,+CAAU;AAClD,MAAM,mDAAc;AACpB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM,+CAAU;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP,aAAa,gDAAW;;AAExB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,CAAC,G;;;;;;;ACppBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC,MAAM,sDAAmB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;;AAEA,UAAU,kDAAe;AACzB,UAAU,kDAAe;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB;AACxN;;AAEA;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,oBAAoB,OAAO;AAC3B,oBAAoB,kBAAkB;AACtC;AACA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;AACA,CAAC,G;;;;;;;AClxBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC,MAAM,sDAAmB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kDAAe;AACxB,SAAS,kDAAe;AACxB;AACA,GAAG;AACH;AACA,SAAS,kDAAe;AACxB,SAAS,kDAAe;AACxB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB;AAC7S;;AAEA;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,oBAAoB,OAAO;AAC3B,oBAAoB,kBAAkB,kBAAkB;AACxD;AACA,oBAAoB,kBAAkB,kBAAkB;AACxD;;AAEA;AACA;AACA,CAAC,G;;;;;;ACrmBD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,MAAM;AACxB;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA,qFAAqF,MAAM;AAC3F;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,KAA0C,IAAI,iCAAc,EAAE,gCAAE,YAAY,YAAY,EAAE,+CAAC;AAC5K,CAAC;;AAED;AACA;AACA,QAAQ,IAAyC;AACjD;AACA,QAAQ,iCAAO,CAAC,0BAAK,CAAC,kCAAE;AACxB;AACA,SAAS;AAAA,oGAAC;AACV,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,EAAE,YAAY,EAAE;AACnD;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,EAAE,EAAE,EAAE,EAAE,UAAU,EAAE,WAAW,EAAE,sBAAsB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,wBAAwB,KAAK,KAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,0BAA0B;AAC1E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,UAAU;AACpG;AACA,kFAAkF,WAAW;AAC7F;AACA,4FAA4F,WAAW;AACvG;AACA;AACA;AACA,4FAA4F,WAAW;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,YAAY;AACZ,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,6EAA6E;AACpG;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB,4EAA4E;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qCAAqC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,eAAe;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb,6CAA6C,EAAE;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,8BAA8B,+BAA+B;AAC7D,aAAa;AACb,8BAA8B,8BAA8B;AAC5D,aAAa;AACb,8BAA8B,uBAAuB;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4IAA4I,MAAM,WAAW,OAAO,YAAY,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE,OAAO,GAAG,SAAS;AACnN;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mBAAmB,SAAS;AAC5B,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B,gBAAgB,aAAa;AAC7B,oBAAoB,aAAa;AACjC,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,uBAAuB,YAAY;AACnC;AACA,wBAAwB,0BAA0B;AAClD;AACA,mBAAmB,YAAY;AAC/B;AACA,wBAAwB,0BAA0B;AAClD;AACA,mBAAmB,QAAQ;AAC3B,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA,gBAAgB,yDAAyD;AACzE,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAyD;AAC9E,sBAAsB,yDAAyD;AAC/E;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,gDAAgD;AAChD,gDAAgD;AAChD;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD,kDAAkD;AAClD,kDAAkD;AAClD;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,sBAAsB;AACtB,kEAAkE,QAAQ;AAC1E,uCAAuC;;AAEvC;AACA;AACA,mCAAmC;AACnC,6CAA6C;AAC7C;AACA,kDAAkD;;AAElD,mEAAmE;AACnE;AACA;;AAEA,yBAAyB;;AAEzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA,yBAAyB,+BAA+B;AACxD,yBAAyB,+BAA+B;AACxD,yBAAyB,+BAA+B;AACxD,yBAAyB;AACzB;AACA;AACA;AACA,4BAA4B;AAC5B,iBAAiB;AACjB,4BAA4B;AAC5B,iBAAiB;AACjB,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA,qBAAqB,MAAM,uBAAuB,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA,cAAc,yBAAyB;AACvC;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,QAAQ;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,EAAE;AACzC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,QAAQ;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,4DAA4D,QAAQ;AACpE;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+EAA+E;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,IAAI;AAChE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,KAAK,kBAAkB,GAAG,OAAO,GAAG,8CAA8C,MAAM,oGAAoG,QAAQ;AAChR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,EAAE,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,EAAE,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,OAAO;AAC3E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,MAAM;AAC3E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,OAAO,EAAE,QAAQ,uCAAuC,OAAO,EAAE,QAAQ,uCAAuC,OAAO,EAAE,QAAQ;AACtN;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,OAAO,kCAAkC,OAAO,kCAAkC,OAAO;AACzK;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,OAAO,cAAc,QAAQ,kCAAkC,OAAO,cAAc,QAAQ,kCAAkC,OAAO,cAAc,QAAQ;AAC3O;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uDAAuD;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qDAAqD;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qCAAqC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,CAAC;AACD,CAAC,e;;;;;;;AC17QD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEa;;;AAGb;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,WAAW,UAAU;AACrB;AACA;AACA,eAAe,GAAG;AAClB;;AAEA,eAAe,cAAc;AAC7B;;AAEA,eAAe,UAAU;AACzB;AACA,eAAe,UAAU;AACzB;;AAEA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA,eAAe,KAAK;AACpB;AACA,eAAe,KAAK;AACpB;AACA,eAAe,KAAK;AACpB;AACA;;AAEA,aAAa,KAAK;AAClB;AACA;AACA;;AAEA,YAAY,KAAK;AACjB;AACA;AACA;;AAEA,aAAa,KAAK;AAClB;AACA;AACA;;AAEA,YAAY,KAAK;AACjB;AACA;AACA;;AAEA,aAAa,KAAK;AAClB;AACA;AACA;;AAEA,YAAY,KAAK;AACjB;AACA;AACA;;AAEA,aAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,IAAI;AACf,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;;;;;;;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;;AAEA,SAAS,mBAAO,CAAC,CAAM;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEa;;;AAGb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,mBAAO,CAAC,CAAM;;;AAGvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI,wBAAwB;AACvC,WAAW,IAAI,wBAAwB;AACvC,WAAW,IAAI,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,OAAO,OAAO;AACpD;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB,GAAG,mBAAmB,GAAG,mBAAmB;AACvF;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG,4BAA4B;AAC1C,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG,yBAAyB;AACvC,WAAW,GAAG,yBAAyB;AACvC,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG,yBAAyB;AACvC,WAAW,GAAG,yBAAyB;AACvC,WAAW,SAAS;AACpB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG,wBAAwB;AACtC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,GAAG,wBAAwB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG,6BAA6B;AAC3C,WAAW,GAAG,6BAA6B;AAC3C,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG,wBAAwB;AACtC,aAAa,OAAO;AACpB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG,yBAAyB;AACvC,WAAW,GAAG,yBAAyB;AACvC,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG,wBAAwB;AACtC,WAAW,GAAG,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;;AAGA;;AAEA;;;;;;;;AChjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;;;;QAqBG6J,Y,GAAAA,Y;QA4JAC,kB,GAAAA,kB;;AA/KhB;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC,MAAM,sDAAmB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB;AAC7S;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO,mB;;;;;;;ACjbP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACO;AACP,gBAAgB,sDAAmB;AACnC,MAAM,sDAAmB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACO;AACP,gBAAgB,sDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACO;AACP,gBAAgB,sDAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB;AACvd;;AAEA;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO,mB;;;;;;;ACneP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACN;AACA;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACO;AACP,eAAe,sDAAmB;AAClC,MAAM,sDAAmB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;AACO;AACP,eAAe,sDAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACO;AACP,eAAe,sDAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACO;AACP,eAAe,sDAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACA;AACO;AACP;AACA,cAAc,gDAAW;AACzB,EAAE,qDAAgB;AAClB,cAAc,sDAAmB;AACjC,EAAE,wDAAmB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB;AACO,cAAc,8CAAS;;AAE9B;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACA;AACO,cAAc,8CAAS;;AAE9B;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,iDAAY;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,iDAAY;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,iDAAY;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACO;AACP;AACA,sBAAsB,mDAAgB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;AACO,UAAU,6CAAQ;;AAEzB;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;AACO,aAAa,gDAAW;;AAE/B;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;AACO,oBAAoB,uDAAkB;;AAE7C;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB,qEAAqE,mDAAgB;AACjoB,C;;;;;;;AC30BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC,MAAM,sDAAmB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP,gBAAgB,sDAAmB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA,UAAU,kDAAe;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB;AACO;AACP;AACA;AACA;AACA;AACA,8BAA8B,mDAAgB,qEAAqE,mDAAgB;AACnI;;AAEA;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA,cAAc;AACd;AACA;AACO;;AAEP;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA,oBAAoB,OAAO;AAC3B,oBAAoB;AACpB;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA,CAAC,G;;;;;;;AChnBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;;AAGb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,mBAAO,CAAC,CAAM;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,aAAa,OAAO,WAAW;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA,kDAAkD;AAClD,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,IAAI,mCAAmC;AAClD,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA,WAAW,IAAI,mCAAmC;AAClD,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,IAAI,mCAAmC;AAClD,WAAW,IAAI,mCAAmC;AAClD,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,IAAI,mCAAmC;AAClD,WAAW,IAAI,mCAAmC;AAClD,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,IAAI,mCAAmC;AAClD,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,UAAU;AACtB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,SAAS,IAAI;AACb;;AAEA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA,WAAW,IAAI,mCAAmC;AAClD,WAAW,IAAI,mCAAmC;AAClD,YAAY,OAAO;AACnB;AACA;AACA;AACA;;;AAGA;;AAEA;;;;;;;;AClRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEa;;AAEb;AACA;AACA;AACA,kDAAkD,2CAA2C;AAC7F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,EAAU;AAC/B,iBAAiB,mBAAO,CAAC,EAAc;AACvC,eAAe,mBAAO,CAAC,EAAY;AACnC,WAAW,mBAAO,CAAC,EAAkB;;;AAGrC;;AAEA,YAAY,mBAAO,CAAC,EAAS;;AAE7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;;AAEA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,IAAI;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;;AAEA;;;;;;;;ACj0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEa;;;AAGb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,EAAc;AACvC,YAAY,mBAAO,CAAC,EAAS;AAC7B,eAAe,mBAAO,CAAC,EAAY;AACnC,YAAY,mBAAO,CAAC,EAAS;AAC7B,qBAAqB,mBAAO,CAAC,EAAkB;AAC/C;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,WAAW;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA,eAAe,KAAK;AACpB;AACA,eAAe,KAAK;AACpB;AACA,eAAe,OAAO;AACtB;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,kBAAkB;AAC9E;AACA,4BAA4B,aAAa,GAAG,aAAa,GAAG,aAAa,GAAG,aAAa;AACzF,4DAA4D,kBAAkB;AAC9E;AACA;AACA;AACA,WAAW,WAAW,6DAA6D,gBAAgB;AACnG,yDAAyD,KAAK;AAC9D,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa,GAAG,aAAa,GAAG,aAAa;AACrE;AACA,WAAW,WAAW,gDAAgD;AACtE;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa,GAAG,aAAa,GAAG,aAAa;AAC3D,cAAc,aAAa,GAAG,aAAa,GAAG,aAAa;AAC3D;AACA;AACA;AACA,WAAW,mBAAmB,sDAAsD;AACpF;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA,gBAAgB;AAChB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA,WAAW,GAAG,uCAAuC;AACrD;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa,GAAG,aAAa,GAAG,aAAa;AACvE;AACA,WAAW,WAAW,6CAA6C;AACnE;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;AAGA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB,GAAG,mBAAmB,GAAG,mBAAmB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,oCAAoC;AACxD;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;AC5hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI,wBAAwB;AACvC,WAAW,IAAI,wBAAwB;AACvC,WAAW,IAAI,wBAAwB;AACvC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,IAAI,wBAAwB;AACvC,WAAW,IAAI,wBAAwB;AACvC,WAAW,IAAI,wBAAwB;AACvC,WAAW,IAAI,wBAAwB;AACvC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;A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","file":"45327a95834e142484ba.worker.js","sourcesContent":[" \tvar parentHotUpdateCallback = this[\"webpackHotUpdate\"];\n \tthis[\"webpackHotUpdate\"] = \r\n \tfunction webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars\r\n \t\thotAddUpdateChunk(chunkId, moreModules);\r\n \t\tif(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);\r\n \t} ;\r\n \t\r\n \tfunction hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars\r\n \t\timportScripts(__webpack_require__.p + \"\" + chunkId + \".\" + hotCurrentHash + \".hot-update.js\");\r\n \t}\r\n \t\r\n \tfunction hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars\r\n \t\treturn new Promise(function(resolve, reject) {\r\n \t\t\tif(typeof XMLHttpRequest === \"undefined\")\r\n \t\t\t\treturn reject(new Error(\"No browser support\"));\r\n \t\t\ttry {\r\n \t\t\t\tvar request = new XMLHttpRequest();\r\n \t\t\t\tvar requestPath = __webpack_require__.p + \"\" + hotCurrentHash + \".hot-update.json\";\r\n \t\t\t\trequest.open(\"GET\", requestPath, true);\r\n \t\t\t\trequest.timeout = 10000;\r\n \t\t\t\trequest.send(null);\r\n \t\t\t} catch(err) {\r\n \t\t\t\treturn reject(err);\r\n \t\t\t}\r\n \t\t\trequest.onreadystatechange = function() {\r\n \t\t\t\tif(request.readyState !== 4) return;\r\n \t\t\t\tif(request.status === 0) {\r\n \t\t\t\t\t// timeout\r\n \t\t\t\t\treject(new Error(\"Manifest request to \" + requestPath + \" timed out.\"));\r\n \t\t\t\t} else if(request.status === 404) {\r\n \t\t\t\t\t// no update available\r\n \t\t\t\t\tresolve();\r\n \t\t\t\t} else if(request.status !== 200 && request.status !== 304) {\r\n \t\t\t\t\t// other failure\r\n \t\t\t\t\treject(new Error(\"Manifest request to \" + requestPath + \" failed.\"));\r\n \t\t\t\t} else {\r\n \t\t\t\t\t// success\r\n \t\t\t\t\ttry {\r\n \t\t\t\t\t\tvar update = JSON.parse(request.responseText);\r\n \t\t\t\t\t} catch(e) {\r\n \t\t\t\t\t\treject(e);\r\n \t\t\t\t\t\treturn;\r\n \t\t\t\t\t}\r\n \t\t\t\t\tresolve(update);\r\n \t\t\t\t}\r\n \t\t\t};\r\n \t\t});\r\n \t}\r\n \t\r\n \tfunction hotDisposeChunk(chunkId) { //eslint-disable-line no-unused-vars\r\n \t\tdelete installedChunks[chunkId];\r\n \t}\r\n\n \t\r\n \t\r\n \tvar hotApplyOnUpdate = true;\r\n \tvar hotCurrentHash = \"45327a95834e142484ba\"; // eslint-disable-line no-unused-vars\r\n \tvar hotCurrentModuleData = {};\r\n \tvar hotCurrentChildModule; // eslint-disable-line no-unused-vars\r\n \tvar hotCurrentParents = []; // eslint-disable-line no-unused-vars\r\n \tvar hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars\r\n \t\r\n \tfunction hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars\r\n \t\tvar me = installedModules[moduleId];\r\n \t\tif(!me) return __webpack_require__;\r\n \t\tvar fn = function(request) {\r\n \t\t\tif(me.hot.active) {\r\n \t\t\t\tif(installedModules[request]) {\r\n \t\t\t\t\tif(installedModules[request].parents.indexOf(moduleId) < 0)\r\n \t\t\t\t\t\tinstalledModules[request].parents.push(moduleId);\r\n \t\t\t\t} else {\r\n \t\t\t\t\thotCurrentParents = [moduleId];\r\n \t\t\t\t\thotCurrentChildModule = request;\r\n \t\t\t\t}\r\n \t\t\t\tif(me.children.indexOf(request) < 0)\r\n \t\t\t\t\tme.children.push(request);\r\n \t\t\t} else {\r\n \t\t\t\tconsole.warn(\"[HMR] unexpected require(\" + request + \") from disposed module \" + moduleId);\r\n \t\t\t\thotCurrentParents = [];\r\n \t\t\t}\r\n \t\t\treturn __webpack_require__(request);\r\n \t\t};\r\n \t\tvar ObjectFactory = function ObjectFactory(name) {\r\n \t\t\treturn {\r\n \t\t\t\tconfigurable: true,\r\n \t\t\t\tenumerable: true,\r\n \t\t\t\tget: function() {\r\n \t\t\t\t\treturn __webpack_require__[name];\r\n \t\t\t\t},\r\n \t\t\t\tset: function(value) {\r\n \t\t\t\t\t__webpack_require__[name] = value;\r\n \t\t\t\t}\r\n \t\t\t};\r\n \t\t};\r\n \t\tfor(var name in __webpack_require__) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(__webpack_require__, name) && name !== \"e\") {\r\n \t\t\t\tObject.defineProperty(fn, name, ObjectFactory(name));\r\n \t\t\t}\r\n \t\t}\r\n \t\tfn.e = function(chunkId) {\r\n \t\t\tif(hotStatus === \"ready\")\r\n \t\t\t\thotSetStatus(\"prepare\");\r\n \t\t\thotChunksLoading++;\r\n \t\t\treturn __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {\r\n \t\t\t\tfinishChunkLoading();\r\n \t\t\t\tthrow err;\r\n \t\t\t});\r\n \t\r\n \t\t\tfunction finishChunkLoading() {\r\n \t\t\t\thotChunksLoading--;\r\n \t\t\t\tif(hotStatus === \"prepare\") {\r\n \t\t\t\t\tif(!hotWaitingFilesMap[chunkId]) {\r\n \t\t\t\t\t\thotEnsureUpdateChunk(chunkId);\r\n \t\t\t\t\t}\r\n \t\t\t\t\tif(hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n \t\t\t\t\t\thotUpdateDownloaded();\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t};\r\n \t\treturn fn;\r\n \t}\r\n \t\r\n \tfunction hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars\r\n \t\tvar hot = {\r\n \t\t\t// private stuff\r\n \t\t\t_acceptedDependencies: {},\r\n \t\t\t_declinedDependencies: {},\r\n \t\t\t_selfAccepted: false,\r\n \t\t\t_selfDeclined: false,\r\n \t\t\t_disposeHandlers: [],\r\n \t\t\t_main: hotCurrentChildModule !== moduleId,\r\n \t\r\n \t\t\t// Module API\r\n \t\t\tactive: true,\r\n \t\t\taccept: function(dep, callback) {\r\n \t\t\t\tif(typeof dep === \"undefined\")\r\n \t\t\t\t\thot._selfAccepted = true;\r\n \t\t\t\telse if(typeof dep === \"function\")\r\n \t\t\t\t\thot._selfAccepted = dep;\r\n \t\t\t\telse if(typeof dep === \"object\")\r\n \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n \t\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback || function() {};\r\n \t\t\t\telse\r\n \t\t\t\t\thot._acceptedDependencies[dep] = callback || function() {};\r\n \t\t\t},\r\n \t\t\tdecline: function(dep) {\r\n \t\t\t\tif(typeof dep === \"undefined\")\r\n \t\t\t\t\thot._selfDeclined = true;\r\n \t\t\t\telse if(typeof dep === \"object\")\r\n \t\t\t\t\tfor(var i = 0; i < dep.length; i++)\r\n \t\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\r\n \t\t\t\telse\r\n \t\t\t\t\thot._declinedDependencies[dep] = true;\r\n \t\t\t},\r\n \t\t\tdispose: function(callback) {\r\n \t\t\t\thot._disposeHandlers.push(callback);\r\n \t\t\t},\r\n \t\t\taddDisposeHandler: function(callback) {\r\n \t\t\t\thot._disposeHandlers.push(callback);\r\n \t\t\t},\r\n \t\t\tremoveDisposeHandler: function(callback) {\r\n \t\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\r\n \t\t\t\tif(idx >= 0) hot._disposeHandlers.splice(idx, 1);\r\n \t\t\t},\r\n \t\r\n \t\t\t// Management API\r\n \t\t\tcheck: hotCheck,\r\n \t\t\tapply: hotApply,\r\n \t\t\tstatus: function(l) {\r\n \t\t\t\tif(!l) return hotStatus;\r\n \t\t\t\thotStatusHandlers.push(l);\r\n \t\t\t},\r\n \t\t\taddStatusHandler: function(l) {\r\n \t\t\t\thotStatusHandlers.push(l);\r\n \t\t\t},\r\n \t\t\tremoveStatusHandler: function(l) {\r\n \t\t\t\tvar idx = hotStatusHandlers.indexOf(l);\r\n \t\t\t\tif(idx >= 0) hotStatusHandlers.splice(idx, 1);\r\n \t\t\t},\r\n \t\r\n \t\t\t//inherit from previous dispose call\r\n \t\t\tdata: hotCurrentModuleData[moduleId]\r\n \t\t};\r\n \t\thotCurrentChildModule = undefined;\r\n \t\treturn hot;\r\n \t}\r\n \t\r\n \tvar hotStatusHandlers = [];\r\n \tvar hotStatus = \"idle\";\r\n \t\r\n \tfunction hotSetStatus(newStatus) {\r\n \t\thotStatus = newStatus;\r\n \t\tfor(var i = 0; i < hotStatusHandlers.length; i++)\r\n \t\t\thotStatusHandlers[i].call(null, newStatus);\r\n \t}\r\n \t\r\n \t// while downloading\r\n \tvar hotWaitingFiles = 0;\r\n \tvar hotChunksLoading = 0;\r\n \tvar hotWaitingFilesMap = {};\r\n \tvar hotRequestedFilesMap = {};\r\n \tvar hotAvailableFilesMap = {};\r\n \tvar hotDeferred;\r\n \t\r\n \t// The update info\r\n \tvar hotUpdate, hotUpdateNewHash;\r\n \t\r\n \tfunction toModuleId(id) {\r\n \t\tvar isNumber = (+id) + \"\" === id;\r\n \t\treturn isNumber ? +id : id;\r\n \t}\r\n \t\r\n \tfunction hotCheck(apply) {\r\n \t\tif(hotStatus !== \"idle\") throw new Error(\"check() is only allowed in idle status\");\r\n \t\thotApplyOnUpdate = apply;\r\n \t\thotSetStatus(\"check\");\r\n \t\treturn hotDownloadManifest().then(function(update) {\r\n \t\t\tif(!update) {\r\n \t\t\t\thotSetStatus(\"idle\");\r\n \t\t\t\treturn null;\r\n \t\t\t}\r\n \t\t\thotRequestedFilesMap = {};\r\n \t\t\thotWaitingFilesMap = {};\r\n \t\t\thotAvailableFilesMap = update.c;\r\n \t\t\thotUpdateNewHash = update.h;\r\n \t\r\n \t\t\thotSetStatus(\"prepare\");\r\n \t\t\tvar promise = new Promise(function(resolve, reject) {\r\n \t\t\t\thotDeferred = {\r\n \t\t\t\t\tresolve: resolve,\r\n \t\t\t\t\treject: reject\r\n \t\t\t\t};\r\n \t\t\t});\r\n \t\t\thotUpdate = {};\r\n \t\t\tvar chunkId = 0;\r\n \t\t\t{ // eslint-disable-line no-lone-blocks\r\n \t\t\t\t/*globals chunkId */\r\n \t\t\t\thotEnsureUpdateChunk(chunkId);\r\n \t\t\t}\r\n \t\t\tif(hotStatus === \"prepare\" && hotChunksLoading === 0 && hotWaitingFiles === 0) {\r\n \t\t\t\thotUpdateDownloaded();\r\n \t\t\t}\r\n \t\t\treturn promise;\r\n \t\t});\r\n \t}\r\n \t\r\n \tfunction hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars\r\n \t\tif(!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])\r\n \t\t\treturn;\r\n \t\thotRequestedFilesMap[chunkId] = false;\r\n \t\tfor(var moduleId in moreModules) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\r\n \t\t\t\thotUpdate[moduleId] = moreModules[moduleId];\r\n \t\t\t}\r\n \t\t}\r\n \t\tif(--hotWaitingFiles === 0 && hotChunksLoading === 0) {\r\n \t\t\thotUpdateDownloaded();\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotEnsureUpdateChunk(chunkId) {\r\n \t\tif(!hotAvailableFilesMap[chunkId]) {\r\n \t\t\thotWaitingFilesMap[chunkId] = true;\r\n \t\t} else {\r\n \t\t\thotRequestedFilesMap[chunkId] = true;\r\n \t\t\thotWaitingFiles++;\r\n \t\t\thotDownloadUpdateChunk(chunkId);\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotUpdateDownloaded() {\r\n \t\thotSetStatus(\"ready\");\r\n \t\tvar deferred = hotDeferred;\r\n \t\thotDeferred = null;\r\n \t\tif(!deferred) return;\r\n \t\tif(hotApplyOnUpdate) {\r\n \t\t\thotApply(hotApplyOnUpdate).then(function(result) {\r\n \t\t\t\tdeferred.resolve(result);\r\n \t\t\t}, function(err) {\r\n \t\t\t\tdeferred.reject(err);\r\n \t\t\t});\r\n \t\t} else {\r\n \t\t\tvar outdatedModules = [];\r\n \t\t\tfor(var id in hotUpdate) {\r\n \t\t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n \t\t\t\t\toutdatedModules.push(toModuleId(id));\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t\tdeferred.resolve(outdatedModules);\r\n \t\t}\r\n \t}\r\n \t\r\n \tfunction hotApply(options) {\r\n \t\tif(hotStatus !== \"ready\") throw new Error(\"apply() is only allowed in ready status\");\r\n \t\toptions = options || {};\r\n \t\r\n \t\tvar cb;\r\n \t\tvar i;\r\n \t\tvar j;\r\n \t\tvar module;\r\n \t\tvar moduleId;\r\n \t\r\n \t\tfunction getAffectedStuff(updateModuleId) {\r\n \t\t\tvar outdatedModules = [updateModuleId];\r\n \t\t\tvar outdatedDependencies = {};\r\n \t\r\n \t\t\tvar queue = outdatedModules.slice().map(function(id) {\r\n \t\t\t\treturn {\r\n \t\t\t\t\tchain: [id],\r\n \t\t\t\t\tid: id\r\n \t\t\t\t};\r\n \t\t\t});\r\n \t\t\twhile(queue.length > 0) {\r\n \t\t\t\tvar queueItem = queue.pop();\r\n \t\t\t\tvar moduleId = queueItem.id;\r\n \t\t\t\tvar chain = queueItem.chain;\r\n \t\t\t\tmodule = installedModules[moduleId];\r\n \t\t\t\tif(!module || module.hot._selfAccepted)\r\n \t\t\t\t\tcontinue;\r\n \t\t\t\tif(module.hot._selfDeclined) {\r\n \t\t\t\t\treturn {\r\n \t\t\t\t\t\ttype: \"self-declined\",\r\n \t\t\t\t\t\tchain: chain,\r\n \t\t\t\t\t\tmoduleId: moduleId\r\n \t\t\t\t\t};\r\n \t\t\t\t}\r\n \t\t\t\tif(module.hot._main) {\r\n \t\t\t\t\treturn {\r\n \t\t\t\t\t\ttype: \"unaccepted\",\r\n \t\t\t\t\t\tchain: chain,\r\n \t\t\t\t\t\tmoduleId: moduleId\r\n \t\t\t\t\t};\r\n \t\t\t\t}\r\n \t\t\t\tfor(var i = 0; i < module.parents.length; i++) {\r\n \t\t\t\t\tvar parentId = module.parents[i];\r\n \t\t\t\t\tvar parent = installedModules[parentId];\r\n \t\t\t\t\tif(!parent) continue;\r\n \t\t\t\t\tif(parent.hot._declinedDependencies[moduleId]) {\r\n \t\t\t\t\t\treturn {\r\n \t\t\t\t\t\t\ttype: \"declined\",\r\n \t\t\t\t\t\t\tchain: chain.concat([parentId]),\r\n \t\t\t\t\t\t\tmoduleId: moduleId,\r\n \t\t\t\t\t\t\tparentId: parentId\r\n \t\t\t\t\t\t};\r\n \t\t\t\t\t}\r\n \t\t\t\t\tif(outdatedModules.indexOf(parentId) >= 0) continue;\r\n \t\t\t\t\tif(parent.hot._acceptedDependencies[moduleId]) {\r\n \t\t\t\t\t\tif(!outdatedDependencies[parentId])\r\n \t\t\t\t\t\t\toutdatedDependencies[parentId] = [];\r\n \t\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\r\n \t\t\t\t\t\tcontinue;\r\n \t\t\t\t\t}\r\n \t\t\t\t\tdelete outdatedDependencies[parentId];\r\n \t\t\t\t\toutdatedModules.push(parentId);\r\n \t\t\t\t\tqueue.push({\r\n \t\t\t\t\t\tchain: chain.concat([parentId]),\r\n \t\t\t\t\t\tid: parentId\r\n \t\t\t\t\t});\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\r\n \t\t\treturn {\r\n \t\t\t\ttype: \"accepted\",\r\n \t\t\t\tmoduleId: updateModuleId,\r\n \t\t\t\toutdatedModules: outdatedModules,\r\n \t\t\t\toutdatedDependencies: outdatedDependencies\r\n \t\t\t};\r\n \t\t}\r\n \t\r\n \t\tfunction addAllToSet(a, b) {\r\n \t\t\tfor(var i = 0; i < b.length; i++) {\r\n \t\t\t\tvar item = b[i];\r\n \t\t\t\tif(a.indexOf(item) < 0)\r\n \t\t\t\t\ta.push(item);\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// at begin all updates modules are outdated\r\n \t\t// the \"outdated\" status can propagate to parents if they don't accept the children\r\n \t\tvar outdatedDependencies = {};\r\n \t\tvar outdatedModules = [];\r\n \t\tvar appliedUpdate = {};\r\n \t\r\n \t\tvar warnUnexpectedRequire = function warnUnexpectedRequire() {\r\n \t\t\tconsole.warn(\"[HMR] unexpected require(\" + result.moduleId + \") to disposed module\");\r\n \t\t};\r\n \t\r\n \t\tfor(var id in hotUpdate) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {\r\n \t\t\t\tmoduleId = toModuleId(id);\r\n \t\t\t\tvar result;\r\n \t\t\t\tif(hotUpdate[id]) {\r\n \t\t\t\t\tresult = getAffectedStuff(moduleId);\r\n \t\t\t\t} else {\r\n \t\t\t\t\tresult = {\r\n \t\t\t\t\t\ttype: \"disposed\",\r\n \t\t\t\t\t\tmoduleId: id\r\n \t\t\t\t\t};\r\n \t\t\t\t}\r\n \t\t\t\tvar abortError = false;\r\n \t\t\t\tvar doApply = false;\r\n \t\t\t\tvar doDispose = false;\r\n \t\t\t\tvar chainInfo = \"\";\r\n \t\t\t\tif(result.chain) {\r\n \t\t\t\t\tchainInfo = \"\\nUpdate propagation: \" + result.chain.join(\" -> \");\r\n \t\t\t\t}\r\n \t\t\t\tswitch(result.type) {\r\n \t\t\t\t\tcase \"self-declined\":\r\n \t\t\t\t\t\tif(options.onDeclined)\r\n \t\t\t\t\t\t\toptions.onDeclined(result);\r\n \t\t\t\t\t\tif(!options.ignoreDeclined)\r\n \t\t\t\t\t\t\tabortError = new Error(\"Aborted because of self decline: \" + result.moduleId + chainInfo);\r\n \t\t\t\t\t\tbreak;\r\n \t\t\t\t\tcase \"declined\":\r\n \t\t\t\t\t\tif(options.onDeclined)\r\n \t\t\t\t\t\t\toptions.onDeclined(result);\r\n \t\t\t\t\t\tif(!options.ignoreDeclined)\r\n \t\t\t\t\t\t\tabortError = new Error(\"Aborted because of declined dependency: \" + result.moduleId + \" in \" + result.parentId + chainInfo);\r\n \t\t\t\t\t\tbreak;\r\n \t\t\t\t\tcase \"unaccepted\":\r\n \t\t\t\t\t\tif(options.onUnaccepted)\r\n \t\t\t\t\t\t\toptions.onUnaccepted(result);\r\n \t\t\t\t\t\tif(!options.ignoreUnaccepted)\r\n \t\t\t\t\t\t\tabortError = new Error(\"Aborted because \" + moduleId + \" is not accepted\" + chainInfo);\r\n \t\t\t\t\t\tbreak;\r\n \t\t\t\t\tcase \"accepted\":\r\n \t\t\t\t\t\tif(options.onAccepted)\r\n \t\t\t\t\t\t\toptions.onAccepted(result);\r\n \t\t\t\t\t\tdoApply = true;\r\n \t\t\t\t\t\tbreak;\r\n \t\t\t\t\tcase \"disposed\":\r\n \t\t\t\t\t\tif(options.onDisposed)\r\n \t\t\t\t\t\t\toptions.onDisposed(result);\r\n \t\t\t\t\t\tdoDispose = true;\r\n \t\t\t\t\t\tbreak;\r\n \t\t\t\t\tdefault:\r\n \t\t\t\t\t\tthrow new Error(\"Unexception type \" + result.type);\r\n \t\t\t\t}\r\n \t\t\t\tif(abortError) {\r\n \t\t\t\t\thotSetStatus(\"abort\");\r\n \t\t\t\t\treturn Promise.reject(abortError);\r\n \t\t\t\t}\r\n \t\t\t\tif(doApply) {\r\n \t\t\t\t\tappliedUpdate[moduleId] = hotUpdate[moduleId];\r\n \t\t\t\t\taddAllToSet(outdatedModules, result.outdatedModules);\r\n \t\t\t\t\tfor(moduleId in result.outdatedDependencies) {\r\n \t\t\t\t\t\tif(Object.prototype.hasOwnProperty.call(result.outdatedDependencies, moduleId)) {\r\n \t\t\t\t\t\t\tif(!outdatedDependencies[moduleId])\r\n \t\t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\r\n \t\t\t\t\t\t\taddAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t\tif(doDispose) {\r\n \t\t\t\t\taddAllToSet(outdatedModules, [result.moduleId]);\r\n \t\t\t\t\tappliedUpdate[moduleId] = warnUnexpectedRequire;\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Store self accepted outdated modules to require them later by the module system\r\n \t\tvar outdatedSelfAcceptedModules = [];\r\n \t\tfor(i = 0; i < outdatedModules.length; i++) {\r\n \t\t\tmoduleId = outdatedModules[i];\r\n \t\t\tif(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)\r\n \t\t\t\toutdatedSelfAcceptedModules.push({\r\n \t\t\t\t\tmodule: moduleId,\r\n \t\t\t\t\terrorHandler: installedModules[moduleId].hot._selfAccepted\r\n \t\t\t\t});\r\n \t\t}\r\n \t\r\n \t\t// Now in \"dispose\" phase\r\n \t\thotSetStatus(\"dispose\");\r\n \t\tObject.keys(hotAvailableFilesMap).forEach(function(chunkId) {\r\n \t\t\tif(hotAvailableFilesMap[chunkId] === false) {\r\n \t\t\t\thotDisposeChunk(chunkId);\r\n \t\t\t}\r\n \t\t});\r\n \t\r\n \t\tvar idx;\r\n \t\tvar queue = outdatedModules.slice();\r\n \t\twhile(queue.length > 0) {\r\n \t\t\tmoduleId = queue.pop();\r\n \t\t\tmodule = installedModules[moduleId];\r\n \t\t\tif(!module) continue;\r\n \t\r\n \t\t\tvar data = {};\r\n \t\r\n \t\t\t// Call dispose handlers\r\n \t\t\tvar disposeHandlers = module.hot._disposeHandlers;\r\n \t\t\tfor(j = 0; j < disposeHandlers.length; j++) {\r\n \t\t\t\tcb = disposeHandlers[j];\r\n \t\t\t\tcb(data);\r\n \t\t\t}\r\n \t\t\thotCurrentModuleData[moduleId] = data;\r\n \t\r\n \t\t\t// disable module (this disables requires from this module)\r\n \t\t\tmodule.hot.active = false;\r\n \t\r\n \t\t\t// remove module from cache\r\n \t\t\tdelete installedModules[moduleId];\r\n \t\r\n \t\t\t// remove \"parents\" references from all children\r\n \t\t\tfor(j = 0; j < module.children.length; j++) {\r\n \t\t\t\tvar child = installedModules[module.children[j]];\r\n \t\t\t\tif(!child) continue;\r\n \t\t\t\tidx = child.parents.indexOf(moduleId);\r\n \t\t\t\tif(idx >= 0) {\r\n \t\t\t\t\tchild.parents.splice(idx, 1);\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// remove outdated dependency from module children\r\n \t\tvar dependency;\r\n \t\tvar moduleOutdatedDependencies;\r\n \t\tfor(moduleId in outdatedDependencies) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n \t\t\t\tmodule = installedModules[moduleId];\r\n \t\t\t\tif(module) {\r\n \t\t\t\t\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n \t\t\t\t\tfor(j = 0; j < moduleOutdatedDependencies.length; j++) {\r\n \t\t\t\t\t\tdependency = moduleOutdatedDependencies[j];\r\n \t\t\t\t\t\tidx = module.children.indexOf(dependency);\r\n \t\t\t\t\t\tif(idx >= 0) module.children.splice(idx, 1);\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Not in \"apply\" phase\r\n \t\thotSetStatus(\"apply\");\r\n \t\r\n \t\thotCurrentHash = hotUpdateNewHash;\r\n \t\r\n \t\t// insert new code\r\n \t\tfor(moduleId in appliedUpdate) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {\r\n \t\t\t\tmodules[moduleId] = appliedUpdate[moduleId];\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// call accept handlers\r\n \t\tvar error = null;\r\n \t\tfor(moduleId in outdatedDependencies) {\r\n \t\t\tif(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {\r\n \t\t\t\tmodule = installedModules[moduleId];\r\n \t\t\t\tmoduleOutdatedDependencies = outdatedDependencies[moduleId];\r\n \t\t\t\tvar callbacks = [];\r\n \t\t\t\tfor(i = 0; i < moduleOutdatedDependencies.length; i++) {\r\n \t\t\t\t\tdependency = moduleOutdatedDependencies[i];\r\n \t\t\t\t\tcb = module.hot._acceptedDependencies[dependency];\r\n \t\t\t\t\tif(callbacks.indexOf(cb) >= 0) continue;\r\n \t\t\t\t\tcallbacks.push(cb);\r\n \t\t\t\t}\r\n \t\t\t\tfor(i = 0; i < callbacks.length; i++) {\r\n \t\t\t\t\tcb = callbacks[i];\r\n \t\t\t\t\ttry {\r\n \t\t\t\t\t\tcb(moduleOutdatedDependencies);\r\n \t\t\t\t\t} catch(err) {\r\n \t\t\t\t\t\tif(options.onErrored) {\r\n \t\t\t\t\t\t\toptions.onErrored({\r\n \t\t\t\t\t\t\t\ttype: \"accept-errored\",\r\n \t\t\t\t\t\t\t\tmoduleId: moduleId,\r\n \t\t\t\t\t\t\t\tdependencyId: moduleOutdatedDependencies[i],\r\n \t\t\t\t\t\t\t\terror: err\r\n \t\t\t\t\t\t\t});\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t\tif(!options.ignoreErrored) {\r\n \t\t\t\t\t\t\tif(!error)\r\n \t\t\t\t\t\t\t\terror = err;\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// Load self accepted modules\r\n \t\tfor(i = 0; i < outdatedSelfAcceptedModules.length; i++) {\r\n \t\t\tvar item = outdatedSelfAcceptedModules[i];\r\n \t\t\tmoduleId = item.module;\r\n \t\t\thotCurrentParents = [moduleId];\r\n \t\t\ttry {\r\n \t\t\t\t__webpack_require__(moduleId);\r\n \t\t\t} catch(err) {\r\n \t\t\t\tif(typeof item.errorHandler === \"function\") {\r\n \t\t\t\t\ttry {\r\n \t\t\t\t\t\titem.errorHandler(err);\r\n \t\t\t\t\t} catch(err2) {\r\n \t\t\t\t\t\tif(options.onErrored) {\r\n \t\t\t\t\t\t\toptions.onErrored({\r\n \t\t\t\t\t\t\t\ttype: \"self-accept-error-handler-errored\",\r\n \t\t\t\t\t\t\t\tmoduleId: moduleId,\r\n \t\t\t\t\t\t\t\terror: err2,\r\n \t\t\t\t\t\t\t\torginalError: err\r\n \t\t\t\t\t\t\t});\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t\tif(!options.ignoreErrored) {\r\n \t\t\t\t\t\t\tif(!error)\r\n \t\t\t\t\t\t\t\terror = err2;\r\n \t\t\t\t\t\t}\r\n \t\t\t\t\t\tif(!error)\r\n \t\t\t\t\t\t\terror = err;\r\n \t\t\t\t\t}\r\n \t\t\t\t} else {\r\n \t\t\t\t\tif(options.onErrored) {\r\n \t\t\t\t\t\toptions.onErrored({\r\n \t\t\t\t\t\t\ttype: \"self-accept-errored\",\r\n \t\t\t\t\t\t\tmoduleId: moduleId,\r\n \t\t\t\t\t\t\terror: err\r\n \t\t\t\t\t\t});\r\n \t\t\t\t\t}\r\n \t\t\t\t\tif(!options.ignoreErrored) {\r\n \t\t\t\t\t\tif(!error)\r\n \t\t\t\t\t\t\terror = err;\r\n \t\t\t\t\t}\r\n \t\t\t\t}\r\n \t\t\t}\r\n \t\t}\r\n \t\r\n \t\t// handle errors in accept handlers and self accepted module load\r\n \t\tif(error) {\r\n \t\t\thotSetStatus(\"fail\");\r\n \t\t\treturn Promise.reject(error);\r\n \t\t}\r\n \t\r\n \t\thotSetStatus(\"idle\");\r\n \t\treturn new Promise(function(resolve) {\r\n \t\t\tresolve(outdatedModules);\r\n \t\t});\r\n \t}\r\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {},\n \t\t\thot: hotCreateModule(moduleId),\n \t\t\tparents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),\n \t\t\tchildren: []\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// __webpack_hash__\n \t__webpack_require__.h = function() { return hotCurrentHash; };\n\n \t// Load entry module and return exports\n \treturn hotCreateRequire(15)(__webpack_require__.s = 15);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 45327a95834e142484ba","/**\r\n * Common utilities\r\n * @module glMatrix\r\n */\r\n\r\n// Configuration Constants\r\nexport var EPSILON = 0.000001;\r\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\r\nexport var RANDOM = Math.random;\r\n\r\n/**\r\n * Sets the type of array used when creating new vectors and matrices\r\n *\r\n * @param {Type} type Array type, such as Float32Array or Array\r\n */\r\nexport function setMatrixArrayType(type) {\r\n  ARRAY_TYPE = type;\r\n}\r\n\r\nvar degree = Math.PI / 180;\r\n\r\n/**\r\n * Convert Degree To Radian\r\n *\r\n * @param {Number} a Angle in Degrees\r\n */\r\nexport function toRadian(a) {\r\n  return a * degree;\r\n}\r\n\r\n/**\r\n * Tests whether or not the arguments have approximately the same value, within an absolute\r\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\r\n * than or equal to 1.0, and a relative tolerance is used for larger values)\r\n *\r\n * @param {Number} a The first number to test.\r\n * @param {Number} b The second number to test.\r\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\r\n */\r\nexport function equals(a, b) {\r\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/gl-matrix/lib/gl-matrix/common.js\n// module id = 0\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/**\n * The following functions operate on \"Point\" or any \"Point like\" object with {x,y},\n * as defined by the {@link XY} type\n * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).\n * @module\n * @private\n */\n\n/**\n * poly2tri.js supports using custom point class instead of {@linkcode Point}.\n * Any \"Point like\" object with <code>{x, y}</code> attributes is supported\n * to initialize the SweepContext polylines and points\n * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).\n *\n * poly2tri.js might add extra fields to the point objects when computing the\n * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions\n * with fields in the custom class.\n *\n * @example\n *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];\n *      var swctx = new poly2tri.SweepContext(contour);\n *\n * @typedef {Object} XY\n * @property {number} x - x coordinate\n * @property {number} y - y coordinate\n */\n\n\n/**\n * Point pretty printing : prints x and y coordinates.\n * @example\n *      xy.toStringBase({x:5, y:42})\n *      //  \"(5;42)\"\n * @protected\n * @param {!XY} p - point object with {x,y}\n * @returns {string} <code>\"(x;y)\"</code>\n */\nfunction toStringBase(p) {\n    return (\"(\" + p.x + \";\" + p.y + \")\");\n}\n\n/**\n * Point pretty printing. Delegates to the point's custom \"toString()\" method if exists,\n * else simply prints x and y coordinates.\n * @example\n *      xy.toString({x:5, y:42})\n *      //  \"(5;42)\"\n * @example\n *      xy.toString({x:5,y:42,toString:function() {return this.x+\":\"+this.y;}})\n *      //  \"5:42\"\n * @param {!XY} p - point object with {x,y}\n * @returns {string} <code>\"(x;y)\"</code>\n */\nfunction toString(p) {\n    // Try a custom toString first, and fallback to own implementation if none\n    var s = p.toString();\n    return (s === '[object Object]' ? toStringBase(p) : s);\n}\n\n\n/**\n * Compare two points component-wise. Ordered by y axis first, then x axis.\n * @param {!XY} a - point object with {x,y}\n * @param {!XY} b - point object with {x,y}\n * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,\n *         <code>&gt; 0</code> if <code>a &gt; b</code>, \n *         <code>0</code> otherwise.\n */\nfunction compare(a, b) {\n    if (a.y === b.y) {\n        return a.x - b.x;\n    } else {\n        return a.y - b.y;\n    }\n}\n\n/**\n * Test two Point objects for equality.\n * @param {!XY} a - point object with {x,y}\n * @param {!XY} b - point object with {x,y}\n * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.\n */\nfunction equals(a, b) {\n    return a.x === b.x && a.y === b.y;\n}\n\n\nmodule.exports = {\n    toString: toString,\n    toStringBase: toStringBase,\n    compare: compare,\n    equals: equals\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/xy.js\n// module id = 1\n// module chunks = 0","// Copyright 2014-2016 Todd Fleming\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// TODO: pass React elements to alertFn\n\n\"use strict\";\n\nimport ClipperLib from 'clipper-lib';\nimport SweepContext from 'poly2tri/src/sweepcontext';\n\nexport const inchToClipperScale = 1270000000;\nexport const mmToClipperScale = inchToClipperScale / 25.4; // 50000000;\nexport const clipperToCppScale = 1 / 128; // Prevent overflow for coordinates up to ~1000 mm\nexport const cleanPolyDist = 100;\nexport const arcTolerance = 10000;\n\n// Linearize a cubic bezier. Returns ['L', x2, y2, x3, y3, ...]. The return value doesn't\n// include (p1x, p1y); it's part of the previous segment.\nfunction linearizeCubicBezier(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, minNumSegments, minSegmentLength) {\n    function bez(p0, p1, p2, p3, t) {\n        return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;\n    }\n\n    if (p1x == c1x && p1y == c1y && p2x == c2x && p2y == c2y)\n        return ['L', p2x, p2y];\n\n    let numSegments = minNumSegments;\n    while (true) {\n        let x = p1x;\n        let y = p1y;\n        let result = ['L'];\n        for (let i = 1; i <= numSegments; ++i) {\n            let t = 1.0 * i / numSegments;\n            let nextX = bez(p1x, c1x, c2x, p2x, t);\n            let nextY = bez(p1y, c1y, c2y, p2y, t);\n            if ((nextX - x) * (nextX - x) + (nextY - y) * (nextY - y) > minSegmentLength * minSegmentLength) {\n                numSegments *= 2;\n                result = null;\n                break;\n            }\n            result.push(nextX, nextY);\n            x = nextX;\n            y = nextY;\n        }\n        if (result)\n            return result;\n    }\n}\n\n// Linearize a path. Both the input path and the returned path are in snap.svg's format.\n// Calls alertFn with an error message and returns null if there's a problem.\nfunction linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn) {\n    if (path.length < 2 || path[0].length != 3 || path[0][0] != 'M') {\n        alertFn('Path does not begin with M')\n        return null;\n    }\n    let x = path[0][1];\n    let y = path[0][2];\n    let result = [path[0]];\n    for (let i = 1; i < path.length; ++i) {\n        let subpath = path[i];\n        if (subpath[0] == 'C' && subpath.length == 7) {\n            result.push(linearizeCubicBezier(\n                x, y, subpath[1], subpath[2], subpath[3], subpath[4], subpath[5], subpath[6], minNumSegments, minSegmentLength));\n            x = subpath[5];\n            y = subpath[6];\n        } else if (subpath[0] == 'M' && subpath.length == 3) {\n            result.push(subpath);\n            x = subpath[1];\n            y = subpath[2];\n        } else {\n            alertFn('Subpath has an unknown prefix: ' + subpath[0]);\n            return null;\n        }\n    }\n    return result;\n};\n\n// Get linear paths (snap format) from an SVG element. Calls alertFn with an\n// error message and returns null if there's a problem.\nfunction elementToLinearSnapPaths(element, minNumSegments, minSegmentLength, alertFn) {\n    let path = null;\n    let Snap = require('snapsvg');\n    let snapElement = Snap(element);\n\n    if (snapElement.type == 'path')\n        path = snapElement.attr('d');\n    else if (snapElement.type == 'rect') {\n        let x = Number(snapElement.attr('x'));\n        let y = Number(snapElement.attr('y'));\n        let w = Number(snapElement.attr('width'));\n        let h = Number(snapElement.attr('height'));\n        path = 'm' + x + ',' + y + ' ' + w + ',' + 0 + ' ' + 0 + ',' + h + ' ' + (-w) + ',' + 0 + ' ' + 0 + ',' + (-h) + ' ';\n    }\n    else {\n        alertFn('<b>' + snapElement.type + \"</b> is not supported; try Inkscape's <strong>Object to Path</strong> command\");\n        return null;\n    }\n\n    if (snapElement.attr('clip-path') != '') {\n        alertFn('clip-path is not supported');\n        return null;\n    }\n\n    if (snapElement.attr('mask') != '') {\n        alertFn('mask is not supported');\n        return null;\n    }\n\n    if (path == null) {\n        alertFn('path is missing');\n        return;\n    }\n\n    path = Snap.path.map(path, snapElement.transform().globalMatrix);\n    path = Snap.parsePathString(path);\n    path = linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn);\n    return path;\n};\n\n// Convert a path in snap.svg format to [[x0, y0, x1, y1, ...], ...].\n// Result is in mm. Returns multiple paths. Only supports linear paths.\n// Calls alertFn with an error message and returns null if there's a problem.\nfunction snapPathToRawPaths(snapPath, pxPerInch, alertFn) {\n    let factor = 2540 / (pxPerInch * 100);\n    if (snapPath.length < 2 || snapPath[0].length != 3 || snapPath[0][0] != 'M') {\n        alertFn('Path does not begin with M');\n        return null;\n    }\n    let currentPath = [snapPath[0][1] * factor, snapPath[0][2] * factor];\n    let result = [currentPath];\n    for (let i = 1; i < snapPath.length; ++i) {\n        let subpath = snapPath[i];\n        if (subpath[0] == 'M' && subpath.length == 3) {\n            currentPath = [subpath[1] * factor, subpath[2] * factor];\n            result.push(currentPath);\n        } else if (subpath[0] == 'L') {\n            for (let j = 0; j < (subpath.length - 1) / 2; ++j)\n                currentPath.push(subpath[1 + j * 2] * factor, subpath[2 + j * 2] * factor);\n        } else {\n            alertFn('Subpath has a non-linear prefix: ' + subpath[0]);\n            return null;\n        }\n    }\n    return result;\n};\n\n// Convert a path in an SVG element to [[x0, y0, x1, y1, ...], ...].\n// Result is in mm. Returns multiple paths. Converts curves.\n// Calls alertFn with an error message and returns null if there's a problem.\nexport function elementToRawPaths(element, pxPerInch, minNumSegments, minSegmentLength, alertFn) {\n    let path = elementToLinearSnapPaths(element, minNumSegments, minSegmentLength, alertFn);\n    if (path !== null)\n        return snapPathToRawPaths(path, pxPerInch, alertFn);\n    return null;\n}\n\n// Convert an SVG path string to [[x0, y0, x1, y1, ...], ...].\n// Result is in mm. Returns multiple paths. Converts curves.\n// Calls alertFn with an error message and returns null if there's a problem.\nexport function pathStrToRawPaths(str, pxPerInch, minNumSegments, minSegmentLength, alertFn) {\n    let Snap = require('snapsvg');\n    let path = Snap.parsePathString(str);\n    path = Snap.path.toCubic(path);\n    path = linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn);\n    if (path !== null)\n        return snapPathToRawPaths(path, pxPerInch, alertFn);\n    return null;\n}\n\n// [[[x0, y0, x1, y1, ...], ...], ...]\nexport function flipY(allRawPaths, deltaY) {\n    for (let rawPaths of allRawPaths)\n        for (let rawPath of rawPaths)\n            for (let i = 0; i < rawPath.length; i += 2)\n                rawPath[i + 1] = deltaY - rawPath[i + 1];\n}\n\nexport function hasClosedRawPaths(rawPaths) {\n    for (let path of rawPaths)\n        if (path.length >= 4 && path[0] == path[path.length - 2] && path[1] == path[path.length - 1])\n            return true;\n    return false;\n}\n\nexport function filterClosedRawPaths(rawPaths) {\n    let result = [];\n    for (let path of rawPaths)\n        if (path.length >= 4 && path[0] == path[path.length - 2] && path[1] == path[path.length - 1])\n            result.push(path);\n    return result;\n}\n\nexport function rawPathsToClipperPaths(rawPaths, transform) {\n    let result = rawPaths.map(p => {\n        let result = [];\n        for (let i = 0; i < p.length; i += 2) {\n            result.push({\n                X: (transform[0] * p[i] + transform[2] * p[i + 1] + transform[4]) * mmToClipperScale,\n                Y: (transform[1] * p[i] + transform[3] * p[i + 1] + transform[5]) * mmToClipperScale,\n            });\n        }\n        return result;\n    });\n    if (hasClosedRawPaths(rawPaths)) {\n        result = ClipperLib.Clipper.CleanPolygons(result, cleanPolyDist);\n        result = ClipperLib.Clipper.SimplifyPolygons(result, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n    return result;\n}\n\nfunction clipperPathsToPolyTree(paths) {\n    let c = new ClipperLib.Clipper();\n    c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n    let polyTree = new ClipperLib.PolyTree();\n    c.Execute(ClipperLib.ClipType.ctUnion, polyTree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    return polyTree;\n}\n\nfunction triangulatePolyTree(polyTree) {\n    let result = [];\n    let pointToVertex = point => ({ x: point.X / mmToClipperScale, y: point.Y / mmToClipperScale });\n    let contourToVertexes = path => path.map(pointToVertex);\n    let nodesToVertexes = nodes => nodes.map(node => contourToVertexes(node.Contour()));\n    let processNode = node => {\n        let vertexes = contourToVertexes(node.Contour());\n        let holes = nodesToVertexes(node.Childs());\n        let context = new SweepContext(vertexes);\n        context.addHoles(holes);\n        context.triangulate();\n        let triangles = context.getTriangles();\n        for (let t of triangles) {\n            let p = t.getPoints();\n            result.push(\n                p[0].x, p[0].y,\n                p[1].x, p[1].y,\n                p[2].x, p[2].y);\n        }\n        for (let hole of node.Childs()) {\n            for (let next of hole.Childs()) {\n                processNode(next);\n            }\n        }\n    };\n    for (let node of polyTree.Childs()) {\n        processNode(node);\n    }\n    return result;\n}\n\nexport function triangulateRawPaths(rawPaths) {\n    return triangulatePolyTree(clipperPathsToPolyTree(rawPathsToClipperPaths(rawPaths, [1, 0, 0, 1, 0, 0])));\n}\n\n// Convert Clipper paths to C. Returns [double** cPaths, int cNumPaths, int* cPathSizes].\nexport function clipperPathsToCPaths(memoryBlocks, clipperPaths) {\n    let doubleSize = 8;\n\n    let cPaths = Module._malloc(clipperPaths.length * 4);\n    memoryBlocks.push(cPaths);\n    let cPathsBase = cPaths >> 2;\n\n    let cPathSizes = Module._malloc(clipperPaths.length * 4);\n    memoryBlocks.push(cPathSizes);\n    let cPathSizesBase = cPathSizes >> 2;\n\n    for (let i = 0; i < clipperPaths.length; ++i) {\n        let clipperPath = clipperPaths[i];\n\n        let cPath = Module._malloc(clipperPath.length * 2 * doubleSize + 4);\n        memoryBlocks.push(cPath);\n        if (cPath & 4)\n            cPath += 4;\n        //console.log(\"-> \" + cPath.toString(16));\n        let pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);\n\n        for (let j = 0; j < clipperPath.length; ++j) {\n            let point = clipperPath[j];\n            pathArray[j * 2] = point.X * clipperToCppScale;\n            pathArray[j * 2 + 1] = point.Y * clipperToCppScale;\n        }\n\n        Module.HEAPU32[cPathsBase + i] = cPath;\n        Module.HEAPU32[cPathSizesBase + i] = clipperPath.length;\n    }\n\n    return [cPaths, clipperPaths.length, cPathSizes];\n}\n\n// Convert C paths to Clipper paths. double**& cPathsRef, int& cNumPathsRef, int*& cPathSizesRef\n// Each point has X, Y (stride = 2).\nexport function cPathsToClipperPaths(memoryBlocks, cPathsRef, cNumPathsRef, cPathSizesRef) {\n    let cPaths = Module.HEAPU32[cPathsRef >> 2];\n    memoryBlocks.push(cPaths);\n    let cPathsBase = cPaths >> 2;\n\n    let cNumPaths = Module.HEAPU32[cNumPathsRef >> 2];\n\n    let cPathSizes = Module.HEAPU32[cPathSizesRef >> 2];\n    memoryBlocks.push(cPathSizes);\n    let cPathSizesBase = cPathSizes >> 2;\n\n    let clipperPaths = [];\n    for (let i = 0; i < cNumPaths; ++i) {\n        let pathSize = Module.HEAPU32[cPathSizesBase + i];\n        let cPath = Module.HEAPU32[cPathsBase + i];\n        // cPath contains value to pass to Module._free(). The aligned version contains the actual data.\n        memoryBlocks.push(cPath);\n        if (cPath & 4)\n            cPath += 4;\n        let pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);\n\n        let clipperPath = [];\n        clipperPaths.push(clipperPath);\n        for (let j = 0; j < pathSize; ++j)\n            clipperPath.push({\n                X: pathArray[j * 2] / clipperToCppScale,\n                Y: pathArray[j * 2 + 1] / clipperToCppScale,\n            });\n    }\n\n    return clipperPaths;\n}\n\n// Convert C paths to array of CamPath. double**& cPathsRef, int& cNumPathsRef, int*& cPathSizesRef\n// Each point has X, Y, Z (stride = 3).\nexport function cPathsToCamPaths(memoryBlocks, cPathsRef, cNumPathsRef, cPathSizesRef) {\n    let cPaths = Module.HEAPU32[cPathsRef >> 2];\n    memoryBlocks.push(cPaths);\n    let cPathsBase = cPaths >> 2;\n\n    let cNumPaths = Module.HEAPU32[cNumPathsRef >> 2];\n\n    let cPathSizes = Module.HEAPU32[cPathSizesRef >> 2];\n    memoryBlocks.push(cPathSizes);\n    let cPathSizesBase = cPathSizes >> 2;\n\n    let convertedPaths = [];\n    for (let i = 0; i < cNumPaths; ++i) {\n        let pathSize = Module.HEAPU32[cPathSizesBase + i];\n        let cPath = Module.HEAPU32[cPathsBase + i];\n        // cPath contains value to pass to Module._free(). The aligned version contains the actual data.\n        memoryBlocks.push(cPath);\n        if (cPath & 4)\n            cPath += 4;\n        let pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);\n\n        let convertedPath = [];\n        convertedPaths.push({ path: convertedPath, safeToClose: false });\n        for (let j = 0; j < pathSize; ++j)\n            convertedPath.push({\n                X: pathArray[j * 3] / clipperToCppScale,\n                Y: pathArray[j * 3 + 1] / clipperToCppScale,\n                Z: pathArray[j * 3 + 2] / clipperToCppScale,\n            });\n\n        //console.log('got: path', i, ':', pathArray[0], pathArray[1], pathArray[2]);\n    }\n\n    return convertedPaths;\n}\n\nexport function clipperBounds(paths) {\n    let minX = Number.MAX_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxX = -Number.MAX_VALUE;\n    let maxY = -Number.MAX_VALUE;\n    for (let path of paths) {\n        for (let pt of path) {\n            minX = Math.min(minX, pt.X);\n            maxX = Math.max(maxX, pt.X);\n            minY = Math.min(minY, pt.Y);\n            maxY = Math.max(maxY, pt.Y);\n        }\n    }\n    return { minX, minY, maxX, maxY };\n}\n\n// Clip Clipper geometry. clipType is a ClipperLib.ClipType constant. Returns new geometry.\nexport function clip(paths1, paths2, clipType) {\n    var clipper = new ClipperLib.Clipper();\n    clipper.AddPaths(paths1, ClipperLib.PolyType.ptSubject, true);\n    clipper.AddPaths(paths2, ClipperLib.PolyType.ptClip, true);\n    var result = [];\n    clipper.Execute(clipType, result, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    return result;\n}\n\n// Return union of two Clipper geometries. Returns new geometry.\nexport function union(paths1, paths2) {\n    return clip(paths1, paths2, ClipperLib.ClipType.ctUnion);\n}\n\n// Return difference between two Clipper geometries. Returns new geometry.\nexport function diff(paths1, paths2) {\n    return clip(paths1, paths2, ClipperLib.ClipType.ctDifference);\n}\n\n// Return xor of two Clipper geometries. Returns new geometry.\nexport function xor(paths1, paths2) {\n    return clip(paths1, paths2, ClipperLib.ClipType.ctXor);\n}\n\n// Offset Clipper geometries by amount (positive expands, negative shrinks). Returns new geometry.\nexport function offset(paths, amount, joinType, endType) {\n    if (joinType === undefined)\n        joinType = ClipperLib.JoinType.jtRound;\n    if (endType === undefined)\n        endType = ClipperLib.EndType.etClosedPolygon;\n\n    // bug workaround: join types are swapped in ClipperLib 6.1.3.2\n    if (joinType === ClipperLib.JoinType.jtSquare)\n        joinType = ClipperLib.JoinType.jtMiter;\n    else if (joinType === ClipperLib.JoinType.jtMiter)\n        joinType = ClipperLib.JoinType.jtSquare;\n\n    var co = new ClipperLib.ClipperOffset(2, arcTolerance);\n    co.AddPaths(paths, joinType, endType);\n    var offsetted = [];\n    co.Execute(offsetted, amount);\n    return offsetted;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/mesh.js","// rev 482\n/********************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.2.1                                                          *\n * Date      :  31 October 2014                                                 *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2014                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.2.1.0                                                         *\n * Date      :  17 June 2016                                                 *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n * Because Javascript lacks support for 64-bit integers, the space              *\n * is a little more restricted than in C# version.                              *\n *                                                                              *\n * C# version has support for coordinate space:                                 *\n * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n * while Javascript version has support for space:                              *\n * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n *                                                                              *\n * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n * http://jsperf.com/big-integer-library-test                                   *\n *                                                                              *\n * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Basic JavaScript BN library - subset useful for RSA encryption.              *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n * Copyright (c) 2005  Tom Wu                                                   *\n * All Rights Reserved.                                                         *\n * See \"LICENSE\" for details:                                                   *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n *                                                                              *\n *******************************************************************************/\n(function ()\n{\n  \"use strict\";\n  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n  //improve performance but coordinate values are limited to the range +/- 46340\n  var use_int32 = false;\n  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n  var use_xyz = false;\n  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n  var use_lines = true;\n\n  var ClipperLib = {};\n  var isNode = false;\n  if (typeof module !== 'undefined' && module.exports)\n  {\n    module.exports = ClipperLib;\n    isNode = true;\n  }\n  else\n  {\n    if (typeof define === 'function' && define.amd) {\n      define(ClipperLib);\n    }\n    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n    else self['ClipperLib'] = ClipperLib;\n  }\n  var navigator_appName;\n  if (!isNode)\n  {\n    var nav = navigator.userAgent.toString().toLowerCase();\n    navigator_appName = navigator.appName;\n  }\n  else\n  {\n    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n  }\n  // Browser test to speedup performance critical functions\n  var browser = {};\n  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n  else browser.chrome = 0;\n  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n  else browser.chromium = 0;\n  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n  else browser.safari = 0;\n  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n  else browser.firefox = 0;\n  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n  else browser.firefox17 = 0;\n  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n  else browser.firefox15 = 0;\n  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n  else browser.firefox3 = 0;\n  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n  else browser.opera = 0;\n  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n  else browser.msie10 = 0;\n  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n  else browser.msie9 = 0;\n  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n  else browser.msie8 = 0;\n  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n  else browser.msie7 = 0;\n  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n  else browser.msie = 0;\n  ClipperLib.biginteger_used = null;\n\n  // Copyright (c) 2005  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Basic JavaScript BN library - subset useful for RSA encryption.\n  // Bits per digit\n  var dbits;\n  // JavaScript engine analysis\n  var canary = 0xdeadbeefcafe;\n  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n  // (public) Constructor\n  function BigInteger(a, b, c)\n  {\n    // This test variable can be removed,\n    // but at least for performance tests it is useful piece of knowledge\n    // This is the only ClipperLib related variable in BigInteger library\n    ClipperLib.biginteger_used = 1;\n    if (a != null)\n      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n    else this.fromString(a, b);\n  }\n  // return new, unset BigInteger\n  function nbi()\n  {\n    return new BigInteger(null,undefined,undefined);\n  }\n  // am: Compute w_j += (x*this_i), propagate carries,\n  // c is initial carry, returns final carry.\n  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n  // We need to select the fastest one that works in this environment.\n  // am1: use a single mult and divide to get the high bits,\n  // max digit bits should be 26 because\n  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n  function am1(i, x, w, j, c, n)\n  {\n    while (--n >= 0)\n    {\n      var v = x * this[i++] + w[j] + c;\n      c = Math.floor(v / 0x4000000);\n      w[j++] = v & 0x3ffffff;\n    }\n    return c;\n  }\n  // am2 avoids a big mult-and-extract completely.\n  // Max digit bits should be <= 30 because we do bitwise ops\n  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n  function am2(i, x, w, j, c, n)\n  {\n    var xl = x & 0x7fff,\n      xh = x >> 15;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x7fff;\n      var h = this[i++] >> 15;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n      w[j++] = l & 0x3fffffff;\n    }\n    return c;\n  }\n  // Alternately, set max digit bits to 28 since some\n  // browsers slow down when dealing with 32-bit numbers.\n  function am3(i, x, w, j, c, n)\n  {\n    var xl = x & 0x3fff,\n      xh = x >> 14;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x3fff;\n      var h = this[i++] >> 14;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n      c = (l >> 28) + (m >> 14) + xh * h;\n      w[j++] = l & 0xfffffff;\n    }\n    return c;\n  }\n  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n  {\n    BigInteger.prototype.am = am2;\n    dbits = 30;\n  }\n  else if (j_lm && (navigator_appName != \"Netscape\"))\n  {\n    BigInteger.prototype.am = am1;\n    dbits = 26;\n  }\n  else\n  { // Mozilla/Netscape seems to prefer am3\n    BigInteger.prototype.am = am3;\n    dbits = 28;\n  }\n  BigInteger.prototype.DB = dbits;\n  BigInteger.prototype.DM = ((1 << dbits) - 1);\n  BigInteger.prototype.DV = (1 << dbits);\n  var BI_FP = 52;\n  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n  BigInteger.prototype.F1 = BI_FP - dbits;\n  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n  // Digit conversions\n  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n  var BI_RC = new Array();\n  var rr, vv;\n  rr = \"0\".charCodeAt(0);\n  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n  rr = \"a\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n  rr = \"A\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n  function int2char(n)\n  {\n    return BI_RM.charAt(n);\n  }\n\n  function intAt(s, i)\n  {\n    var c = BI_RC[s.charCodeAt(i)];\n    return (c == null) ? -1 : c;\n  }\n  // (protected) copy this to r\n  function bnpCopyTo(r)\n  {\n    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n    r.t = this.t;\n    r.s = this.s;\n  }\n  // (protected) set from integer value x, -DV <= x < DV\n  function bnpFromInt(x)\n  {\n    this.t = 1;\n    this.s = (x < 0) ? -1 : 0;\n    if (x > 0) this[0] = x;\n    else if (x < -1) this[0] = x + this.DV;\n    else this.t = 0;\n  }\n  // return bigint initialized to value\n  function nbv(i)\n  {\n    var r = nbi();\n    r.fromInt(i);\n    return r;\n  }\n  // (protected) set from string and radix\n  function bnpFromString(s, b)\n  {\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 256) k = 8; // byte array\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else\n    {\n      this.fromRadix(s, b);\n      return;\n    }\n    this.t = 0;\n    this.s = 0;\n    var i = s.length,\n      mi = false,\n      sh = 0;\n    while (--i >= 0)\n    {\n      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\") mi = true;\n        continue;\n      }\n      mi = false;\n      if (sh == 0)\n        this[this.t++] = x;\n      else if (sh + k > this.DB)\n      {\n        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n        this[this.t++] = (x >> (this.DB - sh));\n      }\n      else\n        this[this.t - 1] |= x << sh;\n      sh += k;\n      if (sh >= this.DB) sh -= this.DB;\n    }\n    if (k == 8 && (s[0] & 0x80) != 0)\n    {\n      this.s = -1;\n      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n    }\n    this.clamp();\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) clamp off excess high words\n  function bnpClamp()\n  {\n    var c = this.s & this.DM;\n    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n  }\n  // (public) return string representation in given radix\n  function bnToString(b)\n  {\n    if (this.s < 0) return \"-\" + this.negate().toString(b);\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else return this.toRadix(b);\n    var km = (1 << k) - 1,\n      d, m = false,\n      r = \"\",\n      i = this.t;\n    var p = this.DB - (i * this.DB) % k;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) > 0)\n      {\n        m = true;\n        r = int2char(d);\n      }\n      while (i >= 0)\n      {\n        if (p < k)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (k - p);\n          d |= this[--i] >> (p += this.DB - k);\n        }\n        else\n        {\n          d = (this[i] >> (p -= k)) & km;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if (d > 0) m = true;\n        if (m) r += int2char(d);\n      }\n    }\n    return m ? r : \"0\";\n  }\n  // (public) -this\n  function bnNegate()\n  {\n    var r = nbi();\n    BigInteger.ZERO.subTo(this, r);\n    return r;\n  }\n  // (public) |this|\n  function bnAbs()\n  {\n    return (this.s < 0) ? this.negate() : this;\n  }\n  // (public) return + if this > a, - if this < a, 0 if equal\n  function bnCompareTo(a)\n  {\n    var r = this.s - a.s;\n    if (r != 0) return r;\n    var i = this.t;\n    r = i - a.t;\n    if (r != 0) return (this.s < 0) ? -r : r;\n    while (--i >= 0)\n      if ((r = this[i] - a[i]) != 0) return r;\n    return 0;\n  }\n  // returns bit length of the integer x\n  function nbits(x)\n  {\n    var r = 1,\n      t;\n    if ((t = x >>> 16) != 0)\n    {\n      x = t;\n      r += 16;\n    }\n    if ((t = x >> 8) != 0)\n    {\n      x = t;\n      r += 8;\n    }\n    if ((t = x >> 4) != 0)\n    {\n      x = t;\n      r += 4;\n    }\n    if ((t = x >> 2) != 0)\n    {\n      x = t;\n      r += 2;\n    }\n    if ((t = x >> 1) != 0)\n    {\n      x = t;\n      r += 1;\n    }\n    return r;\n  }\n  // (public) return the number of bits in \"this\"\n  function bnBitLength()\n  {\n    if (this.t <= 0) return 0;\n    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n  }\n  // (protected) r = this << n*DB\n  function bnpDLShiftTo(n, r)\n  {\n    var i;\n    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n    for (i = n - 1; i >= 0; --i) r[i] = 0;\n    r.t = this.t + n;\n    r.s = this.s;\n  }\n  // (protected) r = this >> n*DB\n  function bnpDRShiftTo(n, r)\n  {\n    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n    r.t = Math.max(this.t - n, 0);\n    r.s = this.s;\n  }\n  // (protected) r = this << n\n  function bnpLShiftTo(n, r)\n  {\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << cbs) - 1;\n    var ds = Math.floor(n / this.DB),\n      c = (this.s << bs) & this.DM,\n      i;\n    for (i = this.t - 1; i >= 0; --i)\n    {\n      r[i + ds + 1] = (this[i] >> cbs) | c;\n      c = (this[i] & bm) << bs;\n    }\n    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n    r[ds] = c;\n    r.t = this.t + ds + 1;\n    r.s = this.s;\n    r.clamp();\n  }\n  // (protected) r = this >> n\n  function bnpRShiftTo(n, r)\n  {\n    r.s = this.s;\n    var ds = Math.floor(n / this.DB);\n    if (ds >= this.t)\n    {\n      r.t = 0;\n      return;\n    }\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << bs) - 1;\n    r[0] = this[ds] >> bs;\n    for (var i = ds + 1; i < this.t; ++i)\n    {\n      r[i - ds - 1] |= (this[i] & bm) << cbs;\n      r[i - ds] = this[i] >> bs;\n    }\n    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n    r.t = this.t - ds;\n    r.clamp();\n  }\n  // (protected) r = this - a\n  function bnpSubTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] - a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c -= a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c -= a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c -= a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c < -1) r[i++] = this.DV + c;\n    else if (c > 0) r[i++] = c;\n    r.t = i;\n    r.clamp();\n  }\n  // (protected) r = this * a, r != this,a (HAC 14.12)\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyTo(a, r)\n  {\n    var x = this.abs(),\n      y = a.abs();\n    var i = x.t;\n    r.t = i + y.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n    r.s = 0;\n    r.clamp();\n    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n  }\n  // (protected) r = this^2, r != this (HAC 14.16)\n  function bnpSquareTo(r)\n  {\n    var x = this.abs();\n    var i = r.t = 2 * x.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < x.t - 1; ++i)\n    {\n      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n      {\n        r[i + x.t] -= x.DV;\n        r[i + x.t + 1] = 1;\n      }\n    }\n    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n    r.s = 0;\n    r.clamp();\n  }\n  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n  // r != q, this != m.  q or r may be null.\n  function bnpDivRemTo(m, q, r)\n  {\n    var pm = m.abs();\n    if (pm.t <= 0) return;\n    var pt = this.abs();\n    if (pt.t < pm.t)\n    {\n      if (q != null) q.fromInt(0);\n      if (r != null) this.copyTo(r);\n      return;\n    }\n    if (r == null) r = nbi();\n    var y = nbi(),\n      ts = this.s,\n      ms = m.s;\n    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n    if (nsh > 0)\n    {\n      pm.lShiftTo(nsh, y);\n      pt.lShiftTo(nsh, r);\n    }\n    else\n    {\n      pm.copyTo(y);\n      pt.copyTo(r);\n    }\n    var ys = y.t;\n    var y0 = y[ys - 1];\n    if (y0 == 0) return;\n    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n    var d1 = this.FV / yt,\n      d2 = (1 << this.F1) / yt,\n      e = 1 << this.F2;\n    var i = r.t,\n      j = i - ys,\n      t = (q == null) ? nbi() : q;\n    y.dlShiftTo(j, t);\n    if (r.compareTo(t) >= 0)\n    {\n      r[r.t++] = 1;\n      r.subTo(t, r);\n    }\n    BigInteger.ONE.dlShiftTo(ys, t);\n    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n    while (y.t < ys) y[y.t++] = 0;\n    while (--j >= 0)\n    {\n      // Estimate quotient digit\n      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n      { // Try it out\n        y.dlShiftTo(j, t);\n        r.subTo(t, r);\n        while (r[i] < --qd) r.subTo(t, r);\n      }\n    }\n    if (q != null)\n    {\n      r.drShiftTo(ys, q);\n      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n    }\n    r.t = ys;\n    r.clamp();\n    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n  }\n  // (public) this mod a\n  function bnMod(a)\n  {\n    var r = nbi();\n    this.abs().divRemTo(a, null, r);\n    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n    return r;\n  }\n  // Modular reduction using \"classic\" algorithm\n  function Classic(m)\n  {\n    this.m = m;\n  }\n\n  function cConvert(x)\n  {\n    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n    else return x;\n  }\n\n  function cRevert(x)\n  {\n    return x;\n  }\n\n  function cReduce(x)\n  {\n    x.divRemTo(this.m, null, x);\n  }\n\n  function cMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n\n  function cSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  Classic.prototype.convert = cConvert;\n  Classic.prototype.revert = cRevert;\n  Classic.prototype.reduce = cReduce;\n  Classic.prototype.mulTo = cMulTo;\n  Classic.prototype.sqrTo = cSqrTo;\n  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n  // justification:\n  //         xy == 1 (mod m)\n  //         xy =  1+km\n  //   xy(2-xy) = (1+km)(1-km)\n  // x[y(2-xy)] = 1-k^2m^2\n  // x[y(2-xy)] == 1 (mod m^2)\n  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n  function bnpInvDigit()\n  {\n    if (this.t < 1) return 0;\n    var x = this[0];\n    if ((x & 1) == 0) return 0;\n    var y = x & 3; // y == 1/x mod 2^2\n    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n    // last step - calculate inverse mod DV directly;\n    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n    // we really want the negative inverse, and -DV < y < DV\n    return (y > 0) ? this.DV - y : -y;\n  }\n  // Montgomery reduction\n  function Montgomery(m)\n  {\n    this.m = m;\n    this.mp = m.invDigit();\n    this.mpl = this.mp & 0x7fff;\n    this.mph = this.mp >> 15;\n    this.um = (1 << (m.DB - 15)) - 1;\n    this.mt2 = 2 * m.t;\n  }\n  // xR mod m\n  function montConvert(x)\n  {\n    var r = nbi();\n    x.abs().dlShiftTo(this.m.t, r);\n    r.divRemTo(this.m, null, r);\n    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n    return r;\n  }\n  // x/R mod m\n  function montRevert(x)\n  {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n  }\n  // x = x/R mod m (HAC 14.32)\n  function montReduce(x)\n  {\n    while (x.t <= this.mt2) // pad x so am has enough room later\n      x[x.t++] = 0;\n    for (var i = 0; i < this.m.t; ++i)\n    {\n      // faster way of calculating u0 = x[i]*mp mod DV\n      var j = x[i] & 0x7fff;\n      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n      // use am to combine the multiply-shift-add into one call\n      j = i + this.m.t;\n      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n      // propagate carry\n      while (x[j] >= x.DV)\n      {\n        x[j] -= x.DV;\n        x[++j]++;\n      }\n    }\n    x.clamp();\n    x.drShiftTo(this.m.t, x);\n    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = \"x^2/R mod m\"; x != r\n  function montSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = \"xy/R mod m\"; x,y != r\n  function montMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Montgomery.prototype.convert = montConvert;\n  Montgomery.prototype.revert = montRevert;\n  Montgomery.prototype.reduce = montReduce;\n  Montgomery.prototype.mulTo = montMulTo;\n  Montgomery.prototype.sqrTo = montSqrTo;\n  // (protected) true iff this is even\n  function bnpIsEven()\n  {\n    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n  }\n  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n  function bnpExp(e, z)\n  {\n    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n    var r = nbi(),\n      r2 = nbi(),\n      g = z.convert(this),\n      i = nbits(e) - 1;\n    g.copyTo(r);\n    while (--i >= 0)\n    {\n      z.sqrTo(r, r2);\n      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n      else\n      {\n        var t = r;\n        r = r2;\n        r2 = t;\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) this^e % m, 0 <= e < 2^32\n  function bnModPowInt(e, m)\n  {\n    var z;\n    if (e < 256 || m.isEven()) z = new Classic(m);\n    else z = new Montgomery(m);\n    return this.exp(e, z);\n  }\n  // protected\n  BigInteger.prototype.copyTo = bnpCopyTo;\n  BigInteger.prototype.fromInt = bnpFromInt;\n  BigInteger.prototype.fromString = bnpFromString;\n  BigInteger.prototype.clamp = bnpClamp;\n  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n  BigInteger.prototype.subTo = bnpSubTo;\n  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n  BigInteger.prototype.squareTo = bnpSquareTo;\n  BigInteger.prototype.divRemTo = bnpDivRemTo;\n  BigInteger.prototype.invDigit = bnpInvDigit;\n  BigInteger.prototype.isEven = bnpIsEven;\n  BigInteger.prototype.exp = bnpExp;\n  // public\n  BigInteger.prototype.toString = bnToString;\n  BigInteger.prototype.negate = bnNegate;\n  BigInteger.prototype.abs = bnAbs;\n  BigInteger.prototype.compareTo = bnCompareTo;\n  BigInteger.prototype.bitLength = bnBitLength;\n  BigInteger.prototype.mod = bnMod;\n  BigInteger.prototype.modPowInt = bnModPowInt;\n  // \"constants\"\n  BigInteger.ZERO = nbv(0);\n  BigInteger.ONE = nbv(1);\n  // Copyright (c) 2005-2009  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Extended JavaScript BN functions, required for RSA private ops.\n  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n  // Version 1.2: square() API, isProbablePrime fix\n  // (public)\n  function bnClone()\n  {\n    var r = nbi();\n    this.copyTo(r);\n    return r;\n  }\n  // (public) return value as integer\n  function bnIntValue()\n  {\n    if (this.s < 0)\n    {\n      if (this.t == 1) return this[0] - this.DV;\n      else if (this.t == 0) return -1;\n    }\n    else if (this.t == 1) return this[0];\n    else if (this.t == 0) return 0;\n    // assumes 16 < DB < 32\n    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n  }\n  // (public) return value as byte\n  function bnByteValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n  }\n  // (public) return value as short (assumes DB>=16)\n  function bnShortValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n  }\n  // (protected) return x s.t. r^x < DV\n  function bnpChunkSize(r)\n  {\n    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n  }\n  // (public) 0 if this == 0, 1 if this > 0\n  function bnSigNum()\n  {\n    if (this.s < 0) return -1;\n    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n    else return 1;\n  }\n  // (protected) convert to radix string\n  function bnpToRadix(b)\n  {\n    if (b == null) b = 10;\n    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n    var cs = this.chunkSize(b);\n    var a = Math.pow(b, cs);\n    var d = nbv(a),\n      y = nbi(),\n      z = nbi(),\n      r = \"\";\n    this.divRemTo(d, y, z);\n    while (y.signum() > 0)\n    {\n      r = (a + z.intValue()).toString(b).substr(1) + r;\n      y.divRemTo(d, y, z);\n    }\n    return z.intValue().toString(b) + r;\n  }\n  // (protected) convert from radix string\n  function bnpFromRadix(s, b)\n  {\n    this.fromInt(0);\n    if (b == null) b = 10;\n    var cs = this.chunkSize(b);\n    var d = Math.pow(b, cs),\n      mi = false,\n      j = 0,\n      w = 0;\n    for (var i = 0; i < s.length; ++i)\n    {\n      var x = intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n        continue;\n      }\n      w = b * w + x;\n      if (++j >= cs)\n      {\n        this.dMultiply(d);\n        this.dAddOffset(w, 0);\n        j = 0;\n        w = 0;\n      }\n    }\n    if (j > 0)\n    {\n      this.dMultiply(Math.pow(b, j));\n      this.dAddOffset(w, 0);\n    }\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) alternate constructor\n  function bnpFromNumber(a, b, c)\n  {\n    if (\"number\" == typeof b)\n    {\n      // new BigInteger(int,int,RNG)\n      if (a < 2) this.fromInt(1);\n      else\n      {\n        this.fromNumber(a, c);\n        if (!this.testBit(a - 1)) // force MSB set\n          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n        while (!this.isProbablePrime(b))\n        {\n          this.dAddOffset(2, 0);\n          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n        }\n      }\n    }\n    else\n    {\n      // new BigInteger(int,RNG)\n      var x = new Array(),\n        t = a & 7;\n      x.length = (a >> 3) + 1;\n      b.nextBytes(x);\n      if (t > 0) x[0] &= ((1 << t) - 1);\n      else x[0] = 0;\n      this.fromString(x, 256);\n    }\n  }\n  // (public) convert to bigendian byte array\n  function bnToByteArray()\n  {\n    var i = this.t,\n      r = new Array();\n    r[0] = this.s;\n    var p = this.DB - (i * this.DB) % 8,\n      d, k = 0;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n        r[k++] = d | (this.s << (this.DB - p));\n      while (i >= 0)\n      {\n        if (p < 8)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n          d |= this[--i] >> (p += this.DB - 8);\n        }\n        else\n        {\n          d = (this[i] >> (p -= 8)) & 0xff;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if ((d & 0x80) != 0) d |= -256;\n        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n        if (k > 0 || d != this.s) r[k++] = d;\n      }\n    }\n    return r;\n  }\n\n  function bnEquals(a)\n  {\n    return (this.compareTo(a) == 0);\n  }\n\n  function bnMin(a)\n  {\n    return (this.compareTo(a) < 0) ? this : a;\n  }\n\n  function bnMax(a)\n  {\n    return (this.compareTo(a) > 0) ? this : a;\n  }\n  // (protected) r = this op a (bitwise)\n  function bnpBitwiseTo(a, op, r)\n  {\n    var i, f, m = Math.min(a.t, this.t);\n    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n    if (a.t < this.t)\n    {\n      f = a.s & this.DM;\n      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n      r.t = this.t;\n    }\n    else\n    {\n      f = this.s & this.DM;\n      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n      r.t = a.t;\n    }\n    r.s = op(this.s, a.s);\n    r.clamp();\n  }\n  // (public) this & a\n  function op_and(x, y)\n  {\n    return x & y;\n  }\n\n  function bnAnd(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_and, r);\n    return r;\n  }\n  // (public) this | a\n  function op_or(x, y)\n  {\n    return x | y;\n  }\n\n  function bnOr(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_or, r);\n    return r;\n  }\n  // (public) this ^ a\n  function op_xor(x, y)\n  {\n    return x ^ y;\n  }\n\n  function bnXor(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_xor, r);\n    return r;\n  }\n  // (public) this & ~a\n  function op_andnot(x, y)\n  {\n    return x & ~y;\n  }\n\n  function bnAndNot(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_andnot, r);\n    return r;\n  }\n  // (public) ~this\n  function bnNot()\n  {\n    var r = nbi();\n    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n    r.t = this.t;\n    r.s = ~this.s;\n    return r;\n  }\n  // (public) this << n\n  function bnShiftLeft(n)\n  {\n    var r = nbi();\n    if (n < 0) this.rShiftTo(-n, r);\n    else this.lShiftTo(n, r);\n    return r;\n  }\n  // (public) this >> n\n  function bnShiftRight(n)\n  {\n    var r = nbi();\n    if (n < 0) this.lShiftTo(-n, r);\n    else this.rShiftTo(n, r);\n    return r;\n  }\n  // return index of lowest 1-bit in x, x < 2^31\n  function lbit(x)\n  {\n    if (x == 0) return -1;\n    var r = 0;\n    if ((x & 0xffff) == 0)\n    {\n      x >>= 16;\n      r += 16;\n    }\n    if ((x & 0xff) == 0)\n    {\n      x >>= 8;\n      r += 8;\n    }\n    if ((x & 0xf) == 0)\n    {\n      x >>= 4;\n      r += 4;\n    }\n    if ((x & 3) == 0)\n    {\n      x >>= 2;\n      r += 2;\n    }\n    if ((x & 1) == 0)++r;\n    return r;\n  }\n  // (public) returns index of lowest 1-bit (or -1 if none)\n  function bnGetLowestSetBit()\n  {\n    for (var i = 0; i < this.t; ++i)\n      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n    if (this.s < 0) return this.t * this.DB;\n    return -1;\n  }\n  // return number of 1 bits in x\n  function cbit(x)\n  {\n    var r = 0;\n    while (x != 0)\n    {\n      x &= x - 1;\n      ++r;\n    }\n    return r;\n  }\n  // (public) return number of set bits\n  function bnBitCount()\n  {\n    var r = 0,\n      x = this.s & this.DM;\n    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n    return r;\n  }\n  // (public) true iff nth bit is set\n  function bnTestBit(n)\n  {\n    var j = Math.floor(n / this.DB);\n    if (j >= this.t) return (this.s != 0);\n    return ((this[j] & (1 << (n % this.DB))) != 0);\n  }\n  // (protected) this op (1<<n)\n  function bnpChangeBit(n, op)\n  {\n    var r = BigInteger.ONE.shiftLeft(n);\n    this.bitwiseTo(r, op, r);\n    return r;\n  }\n  // (public) this | (1<<n)\n  function bnSetBit(n)\n  {\n    return this.changeBit(n, op_or);\n  }\n  // (public) this & ~(1<<n)\n  function bnClearBit(n)\n  {\n    return this.changeBit(n, op_andnot);\n  }\n  // (public) this ^ (1<<n)\n  function bnFlipBit(n)\n  {\n    return this.changeBit(n, op_xor);\n  }\n  // (protected) r = this + a\n  function bnpAddTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] + a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c += a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c += a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c > 0) r[i++] = c;\n    else if (c < -1) r[i++] = this.DV + c;\n    r.t = i;\n    r.clamp();\n  }\n  // (public) this + a\n  function bnAdd(a)\n  {\n    var r = nbi();\n    this.addTo(a, r);\n    return r;\n  }\n  // (public) this - a\n  function bnSubtract(a)\n  {\n    var r = nbi();\n    this.subTo(a, r);\n    return r;\n  }\n  // (public) this * a\n  function bnMultiply(a)\n  {\n    var r = nbi();\n    this.multiplyTo(a, r);\n    return r;\n  }\n  // (public) this^2\n  function bnSquare()\n  {\n    var r = nbi();\n    this.squareTo(r);\n    return r;\n  }\n  // (public) this / a\n  function bnDivide(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, r, null);\n    return r;\n  }\n  // (public) this % a\n  function bnRemainder(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, null, r);\n    return r;\n  }\n  // (public) [this/a,this%a]\n  function bnDivideAndRemainder(a)\n  {\n    var q = nbi(),\n      r = nbi();\n    this.divRemTo(a, q, r);\n    return new Array(q, r);\n  }\n  // (protected) this *= n, this >= 0, 1 < n < DV\n  function bnpDMultiply(n)\n  {\n    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n    ++this.t;\n    this.clamp();\n  }\n  // (protected) this += n << w words, this >= 0\n  function bnpDAddOffset(n, w)\n  {\n    if (n == 0) return;\n    while (this.t <= w) this[this.t++] = 0;\n    this[w] += n;\n    while (this[w] >= this.DV)\n    {\n      this[w] -= this.DV;\n      if (++w >= this.t) this[this.t++] = 0;\n      ++this[w];\n    }\n  }\n  // A \"null\" reducer\n  function NullExp()\n  {}\n\n  function nNop(x)\n  {\n    return x;\n  }\n\n  function nMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n  }\n\n  function nSqrTo(x, r)\n  {\n    x.squareTo(r);\n  }\n  NullExp.prototype.convert = nNop;\n  NullExp.prototype.revert = nNop;\n  NullExp.prototype.mulTo = nMulTo;\n  NullExp.prototype.sqrTo = nSqrTo;\n  // (public) this^e\n  function bnPow(e)\n  {\n    return this.exp(e, new NullExp());\n  }\n  // (protected) r = lower n words of \"this * a\", a.t <= n\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyLowerTo(a, n, r)\n  {\n    var i = Math.min(this.t + a.t, n);\n    r.s = 0; // assumes a,this >= 0\n    r.t = i;\n    while (i > 0) r[--i] = 0;\n    var j;\n    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n    r.clamp();\n  }\n  // (protected) r = \"this * a\" without lower n words, n > 0\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyUpperTo(a, n, r)\n  {\n    --n;\n    var i = r.t = this.t + a.t - n;\n    r.s = 0; // assumes a,this >= 0\n    while (--i >= 0) r[i] = 0;\n    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n    r.clamp();\n    r.drShiftTo(1, r);\n  }\n  // Barrett modular reduction\n  function Barrett(m)\n  {\n    // setup Barrett\n    this.r2 = nbi();\n    this.q3 = nbi();\n    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n    this.mu = this.r2.divide(m);\n    this.m = m;\n  }\n\n  function barrettConvert(x)\n  {\n    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n    else if (x.compareTo(this.m) < 0) return x;\n    else\n    {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n  }\n\n  function barrettRevert(x)\n  {\n    return x;\n  }\n  // x = x mod m (HAC 14.42)\n  function barrettReduce(x)\n  {\n    x.drShiftTo(this.m.t - 1, this.r2);\n    if (x.t > this.m.t + 1)\n    {\n      x.t = this.m.t + 1;\n      x.clamp();\n    }\n    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n    x.subTo(this.r2, x);\n    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = x^2 mod m; x != r\n  function barrettSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = x*y mod m; x,y != r\n  function barrettMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Barrett.prototype.convert = barrettConvert;\n  Barrett.prototype.revert = barrettRevert;\n  Barrett.prototype.reduce = barrettReduce;\n  Barrett.prototype.mulTo = barrettMulTo;\n  Barrett.prototype.sqrTo = barrettSqrTo;\n  // (public) this^e % m (HAC 14.85)\n  function bnModPow(e, m)\n  {\n    var i = e.bitLength(),\n      k, r = nbv(1),\n      z;\n    if (i <= 0) return r;\n    else if (i < 18) k = 1;\n    else if (i < 48) k = 3;\n    else if (i < 144) k = 4;\n    else if (i < 768) k = 5;\n    else k = 6;\n    if (i < 8)\n      z = new Classic(m);\n    else if (m.isEven())\n      z = new Barrett(m);\n    else\n      z = new Montgomery(m);\n    // precomputation\n    var g = new Array(),\n      n = 3,\n      k1 = k - 1,\n      km = (1 << k) - 1;\n    g[1] = z.convert(this);\n    if (k > 1)\n    {\n      var g2 = nbi();\n      z.sqrTo(g[1], g2);\n      while (n <= km)\n      {\n        g[n] = nbi();\n        z.mulTo(g2, g[n - 2], g[n]);\n        n += 2;\n      }\n    }\n    var j = e.t - 1,\n      w, is1 = true,\n      r2 = nbi(),\n      t;\n    i = nbits(e[j]) - 1;\n    while (j >= 0)\n    {\n      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n      else\n      {\n        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n      }\n      n = k;\n      while ((w & 1) == 0)\n      {\n        w >>= 1;\n        --n;\n      }\n      if ((i -= n) < 0)\n      {\n        i += this.DB;\n        --j;\n      }\n      if (is1)\n      { // ret == 1, don't bother squaring or multiplying it\n        g[w].copyTo(r);\n        is1 = false;\n      }\n      else\n      {\n        while (n > 1)\n        {\n          z.sqrTo(r, r2);\n          z.sqrTo(r2, r);\n          n -= 2;\n        }\n        if (n > 0) z.sqrTo(r, r2);\n        else\n        {\n          t = r;\n          r = r2;\n          r2 = t;\n        }\n        z.mulTo(r2, g[w], r);\n      }\n      while (j >= 0 && (e[j] & (1 << i)) == 0)\n      {\n        z.sqrTo(r, r2);\n        t = r;\n        r = r2;\n        r2 = t;\n        if (--i < 0)\n        {\n          i = this.DB - 1;\n          --j;\n        }\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) gcd(this,a) (HAC 14.54)\n  function bnGCD(a)\n  {\n    var x = (this.s < 0) ? this.negate() : this.clone();\n    var y = (a.s < 0) ? a.negate() : a.clone();\n    if (x.compareTo(y) < 0)\n    {\n      var t = x;\n      x = y;\n      y = t;\n    }\n    var i = x.getLowestSetBit(),\n      g = y.getLowestSetBit();\n    if (g < 0) return x;\n    if (i < g) g = i;\n    if (g > 0)\n    {\n      x.rShiftTo(g, x);\n      y.rShiftTo(g, y);\n    }\n    while (x.signum() > 0)\n    {\n      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n      if (x.compareTo(y) >= 0)\n      {\n        x.subTo(y, x);\n        x.rShiftTo(1, x);\n      }\n      else\n      {\n        y.subTo(x, y);\n        y.rShiftTo(1, y);\n      }\n    }\n    if (g > 0) y.lShiftTo(g, y);\n    return y;\n  }\n  // (protected) this % n, n < 2^26\n  function bnpModInt(n)\n  {\n    if (n <= 0) return 0;\n    var d = this.DV % n,\n      r = (this.s < 0) ? n - 1 : 0;\n    if (this.t > 0)\n      if (d == 0) r = this[0] % n;\n      else\n        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n    return r;\n  }\n  // (public) 1/this % m (HAC 14.61)\n  function bnModInverse(m)\n  {\n    var ac = m.isEven();\n    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n    var u = m.clone(),\n      v = this.clone();\n    var a = nbv(1),\n      b = nbv(0),\n      c = nbv(0),\n      d = nbv(1);\n    while (u.signum() != 0)\n    {\n      while (u.isEven())\n      {\n        u.rShiftTo(1, u);\n        if (ac)\n        {\n          if (!a.isEven() || !b.isEven())\n          {\n            a.addTo(this, a);\n            b.subTo(m, b);\n          }\n          a.rShiftTo(1, a);\n        }\n        else if (!b.isEven()) b.subTo(m, b);\n        b.rShiftTo(1, b);\n      }\n      while (v.isEven())\n      {\n        v.rShiftTo(1, v);\n        if (ac)\n        {\n          if (!c.isEven() || !d.isEven())\n          {\n            c.addTo(this, c);\n            d.subTo(m, d);\n          }\n          c.rShiftTo(1, c);\n        }\n        else if (!d.isEven()) d.subTo(m, d);\n        d.rShiftTo(1, d);\n      }\n      if (u.compareTo(v) >= 0)\n      {\n        u.subTo(v, u);\n        if (ac) a.subTo(c, a);\n        b.subTo(d, b);\n      }\n      else\n      {\n        v.subTo(u, v);\n        if (ac) c.subTo(a, c);\n        d.subTo(b, d);\n      }\n    }\n    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n    if (d.compareTo(m) >= 0) return d.subtract(m);\n    if (d.signum() < 0) d.addTo(m, d);\n    else return d;\n    if (d.signum() < 0) return d.add(m);\n    else return d;\n  }\n  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n  // (public) test primality with certainty >= 1-.5^t\n  function bnIsProbablePrime(t)\n  {\n    var i, x = this.abs();\n    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n    {\n      for (i = 0; i < lowprimes.length; ++i)\n        if (x[0] == lowprimes[i]) return true;\n      return false;\n    }\n    if (x.isEven()) return false;\n    i = 1;\n    while (i < lowprimes.length)\n    {\n      var m = lowprimes[i],\n        j = i + 1;\n      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n      m = x.modInt(m);\n      while (i < j)\n        if (m % lowprimes[i++] == 0) return false;\n    }\n    return x.millerRabin(t);\n  }\n  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n  function bnpMillerRabin(t)\n  {\n    var n1 = this.subtract(BigInteger.ONE);\n    var k = n1.getLowestSetBit();\n    if (k <= 0) return false;\n    var r = n1.shiftRight(k);\n    t = (t + 1) >> 1;\n    if (t > lowprimes.length) t = lowprimes.length;\n    var a = nbi();\n    for (var i = 0; i < t; ++i)\n    {\n      //Pick bases at random, instead of starting at 2\n      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n      var y = a.modPow(r, this);\n      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n      {\n        var j = 1;\n        while (j++ < k && y.compareTo(n1) != 0)\n        {\n          y = y.modPowInt(2, this);\n          if (y.compareTo(BigInteger.ONE) == 0) return false;\n        }\n        if (y.compareTo(n1) != 0) return false;\n      }\n    }\n    return true;\n  }\n  // protected\n  BigInteger.prototype.chunkSize = bnpChunkSize;\n  BigInteger.prototype.toRadix = bnpToRadix;\n  BigInteger.prototype.fromRadix = bnpFromRadix;\n  BigInteger.prototype.fromNumber = bnpFromNumber;\n  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n  BigInteger.prototype.changeBit = bnpChangeBit;\n  BigInteger.prototype.addTo = bnpAddTo;\n  BigInteger.prototype.dMultiply = bnpDMultiply;\n  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n  BigInteger.prototype.modInt = bnpModInt;\n  BigInteger.prototype.millerRabin = bnpMillerRabin;\n  // public\n  BigInteger.prototype.clone = bnClone;\n  BigInteger.prototype.intValue = bnIntValue;\n  BigInteger.prototype.byteValue = bnByteValue;\n  BigInteger.prototype.shortValue = bnShortValue;\n  BigInteger.prototype.signum = bnSigNum;\n  BigInteger.prototype.toByteArray = bnToByteArray;\n  BigInteger.prototype.equals = bnEquals;\n  BigInteger.prototype.min = bnMin;\n  BigInteger.prototype.max = bnMax;\n  BigInteger.prototype.and = bnAnd;\n  BigInteger.prototype.or = bnOr;\n  BigInteger.prototype.xor = bnXor;\n  BigInteger.prototype.andNot = bnAndNot;\n  BigInteger.prototype.not = bnNot;\n  BigInteger.prototype.shiftLeft = bnShiftLeft;\n  BigInteger.prototype.shiftRight = bnShiftRight;\n  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n  BigInteger.prototype.bitCount = bnBitCount;\n  BigInteger.prototype.testBit = bnTestBit;\n  BigInteger.prototype.setBit = bnSetBit;\n  BigInteger.prototype.clearBit = bnClearBit;\n  BigInteger.prototype.flipBit = bnFlipBit;\n  BigInteger.prototype.add = bnAdd;\n  BigInteger.prototype.subtract = bnSubtract;\n  BigInteger.prototype.multiply = bnMultiply;\n  BigInteger.prototype.divide = bnDivide;\n  BigInteger.prototype.remainder = bnRemainder;\n  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n  BigInteger.prototype.modPow = bnModPow;\n  BigInteger.prototype.modInverse = bnModInverse;\n  BigInteger.prototype.pow = bnPow;\n  BigInteger.prototype.gcd = bnGCD;\n  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n  // JSBN-specific extension\n  BigInteger.prototype.square = bnSquare;\n  var Int128 = BigInteger;\n  // BigInteger interfaces not implemented in jsbn:\n  // BigInteger(int signum, byte[] magnitude)\n  // double doubleValue()\n  // float floatValue()\n  // int hashCode()\n  // long longValue()\n  // static BigInteger valueOf(long val)\n  // Helper functions to make BigInteger functions callable with two parameters\n  // as in original C# Clipper\n  Int128.prototype.IsNegative = function ()\n  {\n    if (this.compareTo(Int128.ZERO) == -1) return true;\n    else return false;\n  };\n  Int128.op_Equality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) == 0) return true;\n    else return false;\n  };\n  Int128.op_Inequality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) != 0) return true;\n    else return false;\n  };\n  Int128.op_GreaterThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) > 0) return true;\n    else return false;\n  };\n  Int128.op_LessThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) < 0) return true;\n    else return false;\n  };\n  Int128.op_Addition = function (lhs, rhs)\n  {\n    return new Int128(lhs).add(new Int128(rhs));\n  };\n  Int128.op_Subtraction = function (lhs, rhs)\n  {\n    return new Int128(lhs).subtract(new Int128(rhs));\n  };\n  Int128.Int128Mul = function (lhs, rhs)\n  {\n    return new Int128(lhs).multiply(new Int128(rhs));\n  };\n  Int128.op_Division = function (lhs, rhs)\n  {\n    return lhs.divide(rhs);\n  };\n  Int128.prototype.ToDouble = function ()\n  {\n    return parseFloat(this.toString()); // This could be something faster\n  };\n  // end of Int128 section\n  /*\n  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n  else self.Int128 = Int128;\n  */\n\n\n  // ---------------------------------------------\n  // Here starts the actual Clipper library:\n  // Helper function to support Inheritance in Javascript\n\tvar Inherit = function (ce, ce2)\n\t{\n\t\tvar p;\n\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t{\n\t\t\tfor (p in ce2.prototype)\n\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t};\n  ClipperLib.Path = function ()\n  {\n    return [];\n  };\n  ClipperLib.Paths = function ()\n  {\n    return []; // Was previously [[]], but caused problems when pushed\n  };\n  // Preserves the calling way of original C# Clipper\n  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n  ClipperLib.DoublePoint = function ()\n  {\n    var a = arguments;\n    this.X = 0;\n    this.Y = 0;\n    // public DoublePoint(DoublePoint dp)\n    // public DoublePoint(IntPoint ip)\n    if (a.length == 1)\n    {\n      this.X = a[0].X;\n      this.Y = a[0].Y;\n    }\n    else if (a.length == 2)\n    {\n      this.X = a[0];\n      this.Y = a[1];\n    }\n  }; // This is internal faster function when called without arguments\n  ClipperLib.DoublePoint0 = function ()\n  {\n    this.X = 0;\n    this.Y = 0;\n  };\n  // This is internal faster function when called with 1 argument (dp or ip)\n  ClipperLib.DoublePoint1 = function (dp)\n  {\n    this.X = dp.X;\n    this.Y = dp.Y;\n  };\n  // This is internal faster function when called with 2 arguments (x and y)\n  ClipperLib.DoublePoint2 = function (x, y)\n  {\n    this.X = x;\n    this.Y = y;\n  };\n  // PolyTree & PolyNode start\n  // -------------------------------\n  ClipperLib.PolyNode = function ()\n  {\n    this.m_Parent = null;\n    this.m_polygon = new ClipperLib.Path();\n    this.m_Index = 0;\n    this.m_jointype = 0;\n    this.m_endtype = 0;\n    this.m_Childs = [];\n    this.IsOpen = false;\n  };\n  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n  {\n    var result = true;\n    var node = this.m_Parent;\n    while (node !== null)\n    {\n      result = !result;\n      node = node.m_Parent;\n    }\n    return result;\n  };\n  ClipperLib.PolyNode.prototype.ChildCount = function ()\n  {\n    return this.m_Childs.length;\n  };\n  ClipperLib.PolyNode.prototype.Contour = function ()\n  {\n    return this.m_polygon;\n  };\n  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n  {\n    var cnt = this.m_Childs.length;\n    this.m_Childs.push(Child);\n    Child.m_Parent = this;\n    Child.m_Index = cnt;\n  };\n  ClipperLib.PolyNode.prototype.GetNext = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return this.GetNextSiblingUp();\n  };\n  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n  {\n    if (this.m_Parent === null)\n      return null;\n    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n      return this.m_Parent.GetNextSiblingUp();\n    else\n      return this.m_Parent.m_Childs[this.m_Index + 1];\n  };\n  ClipperLib.PolyNode.prototype.Childs = function ()\n  {\n    return this.m_Childs;\n  };\n  ClipperLib.PolyNode.prototype.Parent = function ()\n  {\n    return this.m_Parent;\n  };\n  ClipperLib.PolyNode.prototype.IsHole = function ()\n  {\n    return this.IsHoleNode();\n  };\n  // PolyTree : PolyNode\n  ClipperLib.PolyTree = function ()\n  {\n    this.m_AllPolys = [];\n    ClipperLib.PolyNode.call(this);\n  };\n  ClipperLib.PolyTree.prototype.Clear = function ()\n  {\n    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n      this.m_AllPolys[i] = null;\n    this.m_AllPolys.length = 0;\n    this.m_Childs.length = 0;\n  };\n  ClipperLib.PolyTree.prototype.GetFirst = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return null;\n  };\n  ClipperLib.PolyTree.prototype.Total = function ()\n  {\n\t\tvar result = this.m_AllPolys.length;\n\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\treturn result;\n  };\n  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n  // -------------------------------\n  // PolyTree & PolyNode end\n  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n  {\n    return Math.abs(a);\n  };\n  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n  {\n    return Math.max(a, b);\n  };\n  /*\n  -----------------------------------\n  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n  -----------------------------------\n  */\n  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n  {\n    return a | 0;\n  };\n  else ClipperLib.Cast_Int32 = function (a)\n  { // eg. browser.chrome || browser.chromium || browser.firefox\n    return~~ a;\n  };\n  /*\n  --------------------------\n  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n  Chrome: bitwise_not_floor\n  Firefox17: toInteger (typeof test)\n  IE9: bitwise_or_floor\n  IE7 and IE8: to_parseint\n  Chromium: to_floor_or_ceil\n  Firefox3: to_floor_or_ceil\n  Firefox15: to_floor_or_ceil\n  Opera: to_floor_or_ceil\n  Safari: to_floor_or_ceil\n  --------------------------\n  */\n  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    else return~~ a;\n  };\n  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n  {\n    return Number.toInteger(a);\n  };\n  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n  {\n    return parseInt(a, 10);\n  };\n  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    return a | 0;\n  };\n  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n  else ClipperLib.Cast_Int64 = function (a)\n  {\n    return a < 0 ? Math.ceil(a) : Math.floor(a);\n  };\n  ClipperLib.Clear = function (a)\n  {\n    a.length = 0;\n  };\n  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n  ClipperLib.PI = 3.141592653589793;\n  ClipperLib.PI2 = 2 * 3.141592653589793;\n  ClipperLib.IntPoint = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    this.X = 0;\n    this.Y = 0;\n    if (use_xyz)\n    {\n      this.Z = 0;\n      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = a[2];\n      }\n      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = 0;\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n          this.Z = 0;\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n          this.X = pt.X;\n          this.Y = pt.Y;\n          this.Z = pt.Z;\n        }\n      }\n      else // public IntPoint()\n      {\n        this.X = 0;\n        this.Y = 0;\n        this.Z = 0;\n      }\n    }\n    else // if (!use_xyz)\n    {\n      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          this.X = pt.X;\n          this.Y = pt.Y;\n        }\n      }\n      else // public IntPoint(IntPoint pt)\n      {\n        this.X = 0;\n        this.Y = 0;\n      }\n    }\n  };\n  ClipperLib.IntPoint.op_Equality = function (a, b)\n  {\n    //return a == b;\n    return a.X == b.X && a.Y == b.Y;\n  };\n  ClipperLib.IntPoint.op_Inequality = function (a, b)\n  {\n    //return a != b;\n    return a.X != b.X || a.Y != b.Y;\n  };\n  /*\n  ClipperLib.IntPoint.prototype.Equals = function (obj)\n  {\n    if (obj === null)\n        return false;\n    if (obj instanceof ClipperLib.IntPoint)\n    {\n        var a = Cast(obj, ClipperLib.IntPoint);\n        return (this.X == a.X) && (this.Y == a.Y);\n    }\n    else\n        return false;\n  };\n*/\n  if (use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n      this.Z = pt.Z;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint3 = function (x, y, z)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = z;\n    };\n  }\n  else // if (!use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n    };\n  }\n  ClipperLib.IntRect = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    if (alen == 4) // function (l, t, r, b)\n    {\n      this.left = a[0];\n      this.top = a[1];\n      this.right = a[2];\n      this.bottom = a[3];\n    }\n    else if (alen == 1) // function (ir)\n    {\n      this.left = ir.left;\n      this.top = ir.top;\n      this.right = ir.right;\n      this.bottom = ir.bottom;\n    }\n    else // function ()\n    {\n      this.left = 0;\n      this.top = 0;\n      this.right = 0;\n      this.bottom = 0;\n    }\n  };\n  ClipperLib.IntRect0 = function ()\n  {\n    this.left = 0;\n    this.top = 0;\n    this.right = 0;\n    this.bottom = 0;\n  };\n  ClipperLib.IntRect1 = function (ir)\n  {\n    this.left = ir.left;\n    this.top = ir.top;\n    this.right = ir.right;\n    this.bottom = ir.bottom;\n  };\n  ClipperLib.IntRect4 = function (l, t, r, b)\n  {\n    this.left = l;\n    this.top = t;\n    this.right = r;\n    this.bottom = b;\n  };\n  ClipperLib.ClipType = {\n    ctIntersection: 0,\n    ctUnion: 1,\n    ctDifference: 2,\n    ctXor: 3\n  };\n  ClipperLib.PolyType = {\n    ptSubject: 0,\n    ptClip: 1\n  };\n  ClipperLib.PolyFillType = {\n    pftEvenOdd: 0,\n    pftNonZero: 1,\n    pftPositive: 2,\n    pftNegative: 3\n  };\n  ClipperLib.JoinType = {\n    jtSquare: 0,\n    jtRound: 1,\n    jtMiter: 2\n  };\n  ClipperLib.EndType = {\n    etOpenSquare: 0,\n    etOpenRound: 1,\n    etOpenButt: 2,\n    etClosedLine: 3,\n    etClosedPolygon: 4\n  };\n  ClipperLib.EdgeSide = {\n    esLeft: 0,\n    esRight: 1\n  };\n  ClipperLib.Direction = {\n    dRightToLeft: 0,\n    dLeftToRight: 1\n  };\n  ClipperLib.TEdge = function ()\n  {\n    this.Bot = new ClipperLib.IntPoint();\n    this.Curr = new ClipperLib.IntPoint();\n    this.Top = new ClipperLib.IntPoint();\n    this.Delta = new ClipperLib.IntPoint();\n    this.Dx = 0;\n    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n    this.Side = ClipperLib.EdgeSide.esLeft;\n    this.WindDelta = 0;\n    this.WindCnt = 0;\n    this.WindCnt2 = 0;\n    this.OutIdx = 0;\n    this.Next = null;\n    this.Prev = null;\n    this.NextInLML = null;\n    this.NextInAEL = null;\n    this.PrevInAEL = null;\n    this.NextInSEL = null;\n    this.PrevInSEL = null;\n  };\n  ClipperLib.IntersectNode = function ()\n  {\n    this.Edge1 = null;\n    this.Edge2 = null;\n    this.Pt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.MyIntersectNodeSort = function () {};\n  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n  {\n    var i = node2.Pt.Y - node1.Pt.Y;\n    if (i > 0) return 1;\n    else if (i < 0) return -1;\n    else return 0;\n  };\n\n  ClipperLib.LocalMinima = function ()\n  {\n    this.Y = 0;\n    this.LeftBound = null;\n    this.RightBound = null;\n    this.Next = null;\n  };\n  ClipperLib.Scanbeam = function ()\n  {\n    this.Y = 0;\n    this.Next = null;\n  };\n  ClipperLib.OutRec = function ()\n  {\n    this.Idx = 0;\n    this.IsHole = false;\n    this.IsOpen = false;\n    this.FirstLeft = null;\n    this.Pts = null;\n    this.BottomPt = null;\n    this.PolyNode = null;\n  };\n  ClipperLib.OutPt = function ()\n  {\n    this.Idx = 0;\n    this.Pt = new ClipperLib.IntPoint();\n    this.Next = null;\n    this.Prev = null;\n  };\n  ClipperLib.Join = function ()\n  {\n    this.OutPt1 = null;\n    this.OutPt2 = null;\n    this.OffPt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.ClipperBase = function ()\n  {\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_edges = new Array();\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n    this.PreserveCollinear = false;\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n  // protected const double horizontal = -3.4E+38;\n  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n  // So had to adjust them to more suitable for Javascript.\n  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n  ClipperLib.ClipperBase.Skip = -2;\n  ClipperLib.ClipperBase.Unassigned = -1;\n  ClipperLib.ClipperBase.tolerance = 1E-20;\n  if (use_int32)\n  {\n    ClipperLib.ClipperBase.loRange = 0x7FFF;\n    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n  }\n  else\n  {\n    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n  }\n\n  ClipperLib.ClipperBase.near_zero = function (val)\n  {\n    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n  };\n  ClipperLib.ClipperBase.IsHorizontal = function (e)\n  {\n    return e.Delta.Y === 0;\n  };\n  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n  {\n    var pp2 = pp;\n    do {\n      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n        return true;\n      pp2 = pp2.Next;\n    }\n    while (pp2 != pp)\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n  {\n    if (UseFullRange)\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n    else\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n  };\n  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n  {\n    var pp2 = pp;\n    while (true)\n    {\n      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n        return true;\n      pp2 = pp2.Next;\n      if (pp2 == pp)\n        break;\n    }\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n    if (alen == 3) // function (e1, e2, UseFullRange)\n    {\n      e1 = a[0];\n      e2 = a[1];\n      UseFullRange = a[2];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n      else\n        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n    }\n    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      UseFullRange = a[3];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n    }\n    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      pt4 = a[3];\n      UseFullRange = a[4];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n    }\n  };\n  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n    else\n      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n  };\n  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.prototype.Clear = function ()\n  {\n    this.DisposeLocalMinimaList();\n    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n    {\n      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n        this.m_edges[i][j] = null;\n      ClipperLib.Clear(this.m_edges[i]);\n    }\n    ClipperLib.Clear(this.m_edges);\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n  {\n    while (this.m_MinimaList !== null)\n    {\n      var tmpLm = this.m_MinimaList.Next;\n      this.m_MinimaList = null;\n      this.m_MinimaList = tmpLm;\n    }\n    this.m_CurrentLM = null;\n  };\n  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n  {\n    if (useFullRange.Value)\n    {\n      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n    }\n    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n    {\n      useFullRange.Value = true;\n      this.RangeTest(Pt, useFullRange);\n    }\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n  {\n    e.Next = eNext;\n    e.Prev = ePrev;\n    //e.Curr = pt;\n    e.Curr.X = pt.X;\n    e.Curr.Y = pt.Y;\n    e.OutIdx = -1;\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n  {\n    if (e.Curr.Y >= e.Next.Curr.Y)\n    {\n      //e.Bot = e.Curr;\n      e.Bot.X = e.Curr.X;\n      e.Bot.Y = e.Curr.Y;\n      //e.Top = e.Next.Curr;\n      e.Top.X = e.Next.Curr.X;\n      e.Top.Y = e.Next.Curr.Y;\n    }\n    else\n    {\n      //e.Top = e.Curr;\n      e.Top.X = e.Curr.X;\n      e.Top.Y = e.Curr.Y;\n      //e.Bot = e.Next.Curr;\n      e.Bot.X = e.Next.Curr.X;\n      e.Bot.Y = e.Next.Curr.Y;\n    }\n    this.SetDx(e);\n    e.PolyTyp = polyType;\n  };\n  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n  {\n    var E2;\n    for (;;)\n    {\n      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n        E = E.Next;\n      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n        break;\n      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Prev;\n      E2 = E;\n      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Next;\n      if (E.Top.Y == E.Prev.Bot.Y)\n        continue;\n      //ie just an intermediate horz.\n      if (E2.Prev.Bot.X < E.Bot.X)\n        E = E2;\n      break;\n    }\n    return E;\n  };\n  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n  {\n    var EStart;\n    var Result = E;\n    var Horz;\n\n      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n      {\n        //check if there are edges beyond the skip edge in the bound and if so\n        //create another LocMin and calling ProcessBound once more ...\n        E = Result;\n        if (LeftBoundIsForward)\n        {\n          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n        }\n        else\n        {\n          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n        }\n        if (E == Result)\n        {\n          if (LeftBoundIsForward) Result = E.Next;\n          else Result = E.Prev;\n        }\n        else\n        {\n          //there are more edges in the bound beyond result starting with E\n          if (LeftBoundIsForward)\n            E = Result.Next;\n          else\n            E = Result.Prev;\n          var locMin = new ClipperLib.LocalMinima();\n          locMin.Next = null;\n          locMin.Y = E.Bot.Y;\n          locMin.LeftBound = null;\n          locMin.RightBound = E;\n          E.WindDelta = 0;\n          Result = this.ProcessBound(E, LeftBoundIsForward);\n          this.InsertLocalMinima(locMin);\n        }\n        return Result;\n      }\n\n      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n      {\n        //We need to be careful with open paths because this may not be a\n        //true local minima (ie E may be following a skip edge).\n        //Also, consecutive horz. edges may start heading left before going right.\n        if (LeftBoundIsForward) EStart = E.Prev;\n        else EStart = E.Next;\n        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n          {\n            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n              this.ReverseHorizontal(E);\n          }\n          else if (EStart.Bot.X != E.Bot.X)\n            this.ReverseHorizontal(E);\n        }\n      }\n\n      EStart = E;\n      if (LeftBoundIsForward)\n      {\n        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Next;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          //nb: at the top of a bound, horizontals are added to the bound\n          //only when the preceding edge attaches to the horizontal's left vertex\n          //unless a Skip edge is encountered when that becomes the top divide\n          Horz = Result;\n          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Prev;\n          if (Horz.Prev.Top.X == Result.Next.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Prev;\n          }\n          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n            Result = Horz.Prev;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Next;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Next;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Next;\n        //move to the edge just beyond current bound\n      }\n      else\n      {\n        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Prev;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          Horz = Result;\n          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Next;\n          if (Horz.Next.Top.X == Result.Prev.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Next;\n          }\n          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n            Result = Horz.Next;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Prev;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Prev;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Prev;\n        //move to the edge just beyond current bound\n      }\n\n    return Result;\n  };\n\n  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n  {\n    if (use_lines)\n    {\n      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n    }\n    else\n    {\n      if (!Closed)\n        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n    }\n    var highI = pg.length - 1;\n    if (Closed)\n      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n    --highI;\n    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n    --highI;\n    if ((Closed && highI < 2) || (!Closed && highI < 1))\n      return false;\n    //create a new edge array ...\n    var edges = new Array();\n    for (var i = 0; i <= highI; i++)\n      edges.push(new ClipperLib.TEdge());\n    var IsFlat = true;\n    //1. Basic (first) edge initialization ...\n\n    //edges[1].Curr = pg[1];\n    edges[1].Curr.X = pg[1].X;\n    edges[1].Curr.Y = pg[1].Y;\n\n    var $1 = {Value: this.m_UseFullRange};\n    this.RangeTest(pg[0], $1);\n    this.m_UseFullRange = $1.Value;\n\n    $1.Value = this.m_UseFullRange;\n    this.RangeTest(pg[highI], $1);\n    this.m_UseFullRange = $1.Value;\n\n    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n    for (var i = highI - 1; i >= 1; --i)\n    {\n      $1.Value = this.m_UseFullRange;\n      this.RangeTest(pg[i], $1);\n      this.m_UseFullRange = $1.Value;\n\n      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n    }\n\n    var eStart = edges[0];\n    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n    var E = eStart,\n      eLoopStop = eStart;\n    for (;;)\n    {\n    //console.log(E.Next, eStart);\n    \t//nb: allows matching start and end points when not Closed ...\n      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n      {\n        if (E == E.Next)\n          break;\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        eLoopStop = E;\n        continue;\n      }\n      if (E.Prev == E.Next)\n        break;\n      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n      {\n        //Collinear edges are allowed for open paths but in closed paths\n        //the default is to merge adjacent collinear edges into a single edge.\n        //However, if the PreserveCollinear property is enabled, only overlapping\n        //collinear edges (ie spikes) will be removed from closed paths.\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        E = E.Prev;\n        eLoopStop = E;\n        continue;\n      }\n      E = E.Next;\n      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n    }\n    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n      return false;\n    if (!Closed)\n    {\n      this.m_HasOpenPaths = true;\n      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n    }\n    //3. Do second stage of edge initialization ...\n    E = eStart;\n    do {\n      this.InitEdge2(E, polyType);\n      E = E.Next;\n      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n        IsFlat = false;\n    }\n    while (E != eStart)\n    //4. Finally, add edge bounds to LocalMinima list ...\n    //Totally flat paths must be handled differently when adding them\n    //to LocalMinima list to avoid endless loops etc ...\n    if (IsFlat)\n    {\n      if (Closed)\n        return false;\n      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n      if (E.Prev.Bot.X < E.Prev.Top.X)\n        this.ReverseHorizontal(E.Prev);\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      locMin.RightBound.WindDelta = 0;\n      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n      {\n        E.NextInLML = E.Next;\n        if (E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        E = E.Next;\n      }\n      this.InsertLocalMinima(locMin);\n      this.m_edges.push(edges);\n      return true;\n    }\n    this.m_edges.push(edges);\n    var leftBoundIsForward;\n    var EMin = null;\n\n\t\t//workaround to avoid an endless loop in the while loop below when\n    //open paths have matching start and end points ...\n    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n    \tE = E.Next;\n\n    for (;;)\n    {\n      E = this.FindNextLocMin(E);\n      if (E == EMin)\n        break;\n      else if (EMin == null)\n        EMin = E;\n      //E and E.Prev now share a local minima (left aligned if horizontal).\n      //Compare their slopes to find which starts which bound ...\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      if (E.Dx < E.Prev.Dx)\n      {\n        locMin.LeftBound = E.Prev;\n        locMin.RightBound = E;\n        leftBoundIsForward = false;\n        //Q.nextInLML = Q.prev\n      }\n      else\n      {\n        locMin.LeftBound = E;\n        locMin.RightBound = E.Prev;\n        leftBoundIsForward = true;\n        //Q.nextInLML = Q.next\n      }\n      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      if (!Closed)\n        locMin.LeftBound.WindDelta = 0;\n      else if (locMin.LeftBound.Next == locMin.RightBound)\n        locMin.LeftBound.WindDelta = -1;\n      else\n        locMin.LeftBound.WindDelta = 1;\n      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n      \tE = this.ProcessBound(E, leftBoundIsForward);\n      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.LeftBound = null;\n      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.RightBound = null;\n      this.InsertLocalMinima(locMin);\n      if (!leftBoundIsForward)\n        E = E2;\n    }\n    return true;\n  };\n  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n  {\n    //  console.log(\"-------------------------------------------\");\n    //  console.log(JSON.stringify(ppg));\n    var result = false;\n    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n      if (this.AddPath(ppg[i], polyType, closed))\n        result = true;\n    return result;\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n  {\n    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\n   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n   return false;\n\n    else if (pt1.X != pt3.X)\n      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n    else\n      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n  };\n  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n  {\n    //removes e from double_linked_list (but without removing from memory)\n    e.Prev.Next = e.Next;\n    e.Next.Prev = e.Prev;\n    var result = e.Next;\n    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n    return result;\n  };\n  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n  {\n    e.Delta.X = (e.Top.X - e.Bot.X);\n    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n  };\n  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n  {\n    if (this.m_MinimaList === null)\n    {\n      this.m_MinimaList = newLm;\n    }\n    else if (newLm.Y >= this.m_MinimaList.Y)\n    {\n      newLm.Next = this.m_MinimaList;\n      this.m_MinimaList = newLm;\n    }\n    else\n    {\n      var tmpLm = this.m_MinimaList;\n      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n        tmpLm = tmpLm.Next;\n      newLm.Next = tmpLm.Next;\n      tmpLm.Next = newLm;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n  {\n    if (this.m_CurrentLM === null)\n      return;\n    this.m_CurrentLM = this.m_CurrentLM.Next;\n  };\n  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n  {\n    //swap horizontal edges' top and bottom x's so they follow the natural\n    //progression of the bounds - ie so their xbots will align with the\n    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n    var tmp = e.Top.X;\n    e.Top.X = e.Bot.X;\n    e.Bot.X = tmp;\n    if (use_xyz)\n    {\n      tmp = e.Top.Z;\n      e.Top.Z = e.Bot.Z;\n      e.Bot.Z = tmp;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.Reset = function ()\n  {\n    this.m_CurrentLM = this.m_MinimaList;\n    if (this.m_CurrentLM == null)\n      return;\n    //ie nothing to process\n    //reset all edges ...\n    var lm = this.m_MinimaList;\n    while (lm != null)\n    {\n      var e = lm.LeftBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esLeft;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      e = lm.RightBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esRight;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n  {\n    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n    this.m_PolyOuts = null;\n    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = null;\n    this.m_IntersectNodeComparer = null;\n    this.m_ExecuteLocked = false;\n    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_Joins = null;\n    this.m_GhostJoins = null;\n    this.m_UsingPolyTree = false;\n    this.ReverseSolution = false;\n    this.StrictlySimple = false;\n    ClipperLib.ClipperBase.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = new Array();\n    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n    this.m_ExecuteLocked = false;\n    this.m_UsingPolyTree = false;\n    this.m_PolyOuts = new Array();\n    this.m_Joins = new Array();\n    this.m_GhostJoins = new Array();\n    this.ReverseSolution = (1 & InitOptions) !== 0;\n    this.StrictlySimple = (2 & InitOptions) !== 0;\n    this.PreserveCollinear = (4 & InitOptions) !== 0;\n    if (use_xyz)\n    {\n      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n    }\n  };\n  ClipperLib.Clipper.ioReverseSolution = 1;\n  ClipperLib.Clipper.ioStrictlySimple = 2;\n  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\n  ClipperLib.Clipper.prototype.Clear = function ()\n  {\n    if (this.m_edges.length === 0)\n      return;\n    //avoids problems with ClipperBase destructor\n    this.DisposeAllPolyPts();\n    ClipperLib.ClipperBase.prototype.Clear.call(this);\n  };\n\n  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n  {\n    while (this.m_Scanbeam !== null)\n    {\n      var sb2 = this.m_Scanbeam.Next;\n      this.m_Scanbeam = null;\n      this.m_Scanbeam = sb2;\n    }\n  };\n  ClipperLib.Clipper.prototype.Reset = function ()\n  {\n    ClipperLib.ClipperBase.prototype.Reset.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n\n    var lm = this.m_MinimaList;\n    while (lm !== null)\n    {\n      this.InsertScanbeam(lm.Y);\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n  {\n    if (this.m_Scanbeam === null)\n    {\n      this.m_Scanbeam = new ClipperLib.Scanbeam();\n      this.m_Scanbeam.Next = null;\n      this.m_Scanbeam.Y = Y;\n    }\n    else if (Y > this.m_Scanbeam.Y)\n    {\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = this.m_Scanbeam;\n      this.m_Scanbeam = newSb;\n    }\n    else\n    {\n      var sb2 = this.m_Scanbeam;\n      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n        sb2 = sb2.Next;\n      if (Y == sb2.Y)\n        return;\n      //ie ignores duplicates\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = sb2.Next;\n      sb2.Next = newSb;\n    }\n  };\n  // ************************************\n  ClipperLib.Clipper.prototype.Execute = function ()\n  {\n    var a = arguments,\n      alen = a.length,\n      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        solution = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      if (this.m_HasOpenPaths)\n        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n      this.m_ExecuteLocked = true;\n      ClipperLib.Clear(solution);\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = false;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult(solution);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        polytree = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      this.m_ExecuteLocked = true;\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = true;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult2(polytree);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n    {\n      var clipType = a[0],\n        solution = a[1];\n      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n    {\n      var clipType = a[0],\n        polytree = a[1];\n      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n  {\n    //skip if an outermost polygon or\n    //already already points to the correct FirstLeft ...\n    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n      return;\n    var orfl = outRec.FirstLeft;\n    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n      orfl = orfl.FirstLeft;\n    outRec.FirstLeft = orfl;\n  };\n  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n  {\n    try\n    {\n      this.Reset();\n      if (this.m_CurrentLM === null)\n        return false;\n      var botY = this.PopScanbeam();\n      do {\n        this.InsertLocalMinimaIntoAEL(botY);\n        ClipperLib.Clear(this.m_GhostJoins);\n        this.ProcessHorizontals(false);\n        if (this.m_Scanbeam === null)\n          break;\n        var topY = this.PopScanbeam();\n        if (!this.ProcessIntersections(topY)) return false;\n\n        this.ProcessEdgesAtTopOfScanbeam(topY);\n        botY = topY;\n      }\n      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n      //fix orientations ...\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts === null || outRec.IsOpen)\n          continue;\n        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n          this.ReversePolyPtLinks(outRec.Pts);\n      }\n      this.JoinCommonEdges();\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts !== null && !outRec.IsOpen)\n          this.FixupOutPolygon(outRec);\n      }\n      if (this.StrictlySimple)\n        this.DoSimplePolygons();\n      return true;\n    }\n    finally\n    {\n      ClipperLib.Clear(this.m_Joins);\n      ClipperLib.Clear(this.m_GhostJoins);\n    }\n  };\n  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n  {\n    var Y = this.m_Scanbeam.Y;\n    this.m_Scanbeam = this.m_Scanbeam.Next;\n    return Y;\n  };\n\n  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n      this.DisposeOutRec(i);\n    ClipperLib.Clear(this.m_PolyOuts);\n  };\n  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n  {\n    var outRec = this.m_PolyOuts[index];\n    outRec.Pts = null;\n    outRec = null;\n    this.m_PolyOuts[index] = null;\n  };\n\n  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op1;\n    j.OutPt2 = Op2;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_Joins.push(j);\n  };\n  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_GhostJoins.push(j);\n  };\n  if (use_xyz)\n  {\n    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n    {\n      if (this.ZFillFunction !== null)\n      {\n        if (pt.Z != 0 || this.ZFillFunction === null) return;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n      }\n    };\n\n    //------------------------------------------------------------------------------\n  }\n\n  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n  {\n    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n    {\n      var lb = this.m_CurrentLM.LeftBound;\n      var rb = this.m_CurrentLM.RightBound;\n      this.PopLocalMinima();\n      var Op1 = null;\n      if (lb === null)\n      {\n        this.InsertEdgeIntoAEL(rb, null);\n        this.SetWindingCount(rb);\n        if (this.IsContributing(rb))\n          Op1 = this.AddOutPt(rb, rb.Bot);\n      }\n      else if (rb == null)\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.SetWindingCount(lb);\n        if (this.IsContributing(lb))\n          Op1 = this.AddOutPt(lb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      else\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.InsertEdgeIntoAEL(rb, lb);\n        this.SetWindingCount(lb);\n        rb.WindCnt = lb.WindCnt;\n        rb.WindCnt2 = lb.WindCnt2;\n        if (this.IsContributing(lb))\n          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      if (rb != null)\n      {\n        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n          this.AddEdgeToSEL(rb);\n        else\n          this.InsertScanbeam(rb.Top.Y);\n      }\n      if (lb == null || rb == null) continue;\n      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n      {\n        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n        {\n          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n          //the 'ghost' join to a real join ready for later ...\n          var j = this.m_GhostJoins[i];\n\n\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n        }\n      }\n      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n        lb.PrevInAEL.OutIdx >= 0 &&\n        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n      {\n        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n        this.AddJoin(Op1, Op2, lb.Top);\n      }\n      if (lb.NextInAEL != rb)\n      {\n        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n        {\n          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n          this.AddJoin(Op1, Op2, rb.Top);\n        }\n        var e = lb.NextInAEL;\n        if (e !== null)\n          while (e != rb)\n          {\n            //nb: For calculating winding counts etc, IntersectEdges() assumes\n            //that param1 will be to the right of param2 ABOVE the intersection ...\n            this.IntersectEdges(rb, e, lb.Curr, false);\n            //order important here\n            e = e.NextInAEL;\n          }\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n  {\n    if (this.m_ActiveEdges === null)\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = null;\n      this.m_ActiveEdges = edge;\n    }\n    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = this.m_ActiveEdges;\n      this.m_ActiveEdges.PrevInAEL = edge;\n      this.m_ActiveEdges = edge;\n    }\n    else\n    {\n      if (startEdge === null)\n        startEdge = this.m_ActiveEdges;\n      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n        startEdge = startEdge.NextInAEL;\n      edge.NextInAEL = startEdge.NextInAEL;\n      if (startEdge.NextInAEL !== null)\n        startEdge.NextInAEL.PrevInAEL = edge;\n      edge.PrevInAEL = startEdge;\n      startEdge.NextInAEL = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n  {\n    if (e2.Curr.X == e1.Curr.X)\n    {\n      if (e2.Top.Y > e1.Top.Y)\n        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n      else\n        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n    }\n    else\n      return e2.Curr.X < e1.Curr.X;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n  {\n    var pft, pft2;\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      pft = this.m_SubjFillType;\n      pft2 = this.m_ClipFillType;\n    }\n    else\n    {\n      pft = this.m_ClipFillType;\n      pft2 = this.m_SubjFillType;\n    }\n    switch (pft)\n    {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftNonZero:\n      if (Math.abs(edge.WindCnt) != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftPositive:\n      if (edge.WindCnt != 1)\n        return false;\n      break;\n    default:\n      if (edge.WindCnt != -1)\n        return false;\n      break;\n    }\n    switch (this.m_ClipType)\n    {\n    case ClipperLib.ClipType.ctIntersection:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 !== 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 > 0);\n      default:\n        return (edge.WindCnt2 < 0);\n      }\n    case ClipperLib.ClipType.ctUnion:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 === 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 <= 0);\n      default:\n        return (edge.WindCnt2 >= 0);\n      }\n    case ClipperLib.ClipType.ctDifference:\n      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 !== 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 > 0);\n        default:\n          return (edge.WindCnt2 < 0);\n        }\n    case ClipperLib.ClipType.ctXor:\n      if (edge.WindDelta === 0)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        return true;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n  {\n    var e = edge.PrevInAEL;\n    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n      e = e.PrevInAEL;\n    if (e === null)\n    {\n      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      edge.WindCnt2 = 0;\n      e = this.m_ActiveEdges;\n      //ie get ready to calc WindCnt2\n    }\n    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n    {\n      edge.WindCnt = 1;\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else if (this.IsEvenOddFillType(edge))\n    {\n      //EvenOdd filling ...\n      if (edge.WindDelta === 0)\n      {\n        //are we inside a subj polygon ...\n        var Inside = true;\n        var e2 = e.PrevInAEL;\n        while (e2 !== null)\n        {\n          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n            Inside = !Inside;\n          e2 = e2.PrevInAEL;\n        }\n        edge.WindCnt = (Inside ? 0 : 1);\n      }\n      else\n      {\n        edge.WindCnt = edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      if (e.WindCnt * e.WindDelta < 0)\n      {\n        //prev edge is 'decreasing' WindCount (WC) toward zero\n        //so we're outside the previous polygon ...\n        if (Math.abs(e.WindCnt) > 1)\n        {\n          //outside prev poly but still inside another.\n          //when reversing direction of prev poly use the same WC\n          if (e.WindDelta * edge.WindDelta < 0)\n            edge.WindCnt = e.WindCnt;\n          else\n            edge.WindCnt = e.WindCnt + edge.WindDelta;\n        }\n        else\n          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      }\n      else\n      {\n        //prev edge is 'increasing' WindCount (WC) away from zero\n        //so we're inside the previous polygon ...\n        if (edge.WindDelta === 0)\n          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n        else if (e.WindDelta * edge.WindDelta < 0)\n          edge.WindCnt = e.WindCnt;\n        else\n          edge.WindCnt = e.WindCnt + edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    //update WindCnt2 ...\n    if (this.IsEvenOddAltFillType(edge))\n    {\n      //EvenOdd filling ...\n      while (e != edge)\n      {\n        if (e.WindDelta !== 0)\n          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n        e = e.NextInAEL;\n      }\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      while (e != edge)\n      {\n        edge.WindCnt2 += e.WindDelta;\n        e = e.NextInAEL;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n  {\n    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n    //However, we don't need to worry about order with horizontal edge processing.\n    if (this.m_SortedEdges === null)\n    {\n      this.m_SortedEdges = edge;\n      edge.PrevInSEL = null;\n      edge.NextInSEL = null;\n    }\n    else\n    {\n      edge.NextInSEL = this.m_SortedEdges;\n      edge.PrevInSEL = null;\n      this.m_SortedEdges.PrevInSEL = edge;\n      this.m_SortedEdges = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n  {\n    var e = this.m_ActiveEdges;\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n  {\n    //check that one or other edge hasn't already been removed from AEL ...\n    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n      return;\n    if (edge1.NextInAEL == edge2)\n    {\n      var next = edge2.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge1;\n      var prev = edge1.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      edge2.NextInAEL = edge1;\n      edge1.PrevInAEL = edge2;\n      edge1.NextInAEL = next;\n    }\n    else if (edge2.NextInAEL == edge1)\n    {\n      var next = edge1.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge2;\n      var prev = edge2.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge1;\n      edge1.PrevInAEL = prev;\n      edge1.NextInAEL = edge2;\n      edge2.PrevInAEL = edge1;\n      edge2.NextInAEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInAEL;\n      var prev = edge1.PrevInAEL;\n      edge1.NextInAEL = edge2.NextInAEL;\n      if (edge1.NextInAEL !== null)\n        edge1.NextInAEL.PrevInAEL = edge1;\n      edge1.PrevInAEL = edge2.PrevInAEL;\n      if (edge1.PrevInAEL !== null)\n        edge1.PrevInAEL.NextInAEL = edge1;\n      edge2.NextInAEL = next;\n      if (edge2.NextInAEL !== null)\n        edge2.NextInAEL.PrevInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      if (edge2.PrevInAEL !== null)\n        edge2.PrevInAEL.NextInAEL = edge2;\n    }\n    if (edge1.PrevInAEL === null)\n      this.m_ActiveEdges = edge1;\n    else if (edge2.PrevInAEL === null)\n      this.m_ActiveEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n  {\n    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n      return;\n    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n      return;\n    if (edge1.NextInSEL == edge2)\n    {\n      var next = edge2.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge1;\n      var prev = edge1.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      edge2.NextInSEL = edge1;\n      edge1.PrevInSEL = edge2;\n      edge1.NextInSEL = next;\n    }\n    else if (edge2.NextInSEL == edge1)\n    {\n      var next = edge1.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge2;\n      var prev = edge2.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge1;\n      edge1.PrevInSEL = prev;\n      edge1.NextInSEL = edge2;\n      edge2.PrevInSEL = edge1;\n      edge2.NextInSEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInSEL;\n      var prev = edge1.PrevInSEL;\n      edge1.NextInSEL = edge2.NextInSEL;\n      if (edge1.NextInSEL !== null)\n        edge1.NextInSEL.PrevInSEL = edge1;\n      edge1.PrevInSEL = edge2.PrevInSEL;\n      if (edge1.PrevInSEL !== null)\n        edge1.PrevInSEL.NextInSEL = edge1;\n      edge2.NextInSEL = next;\n      if (edge2.NextInSEL !== null)\n        edge2.NextInSEL.PrevInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      if (edge2.PrevInSEL !== null)\n        edge2.PrevInSEL.NextInSEL = edge2;\n    }\n    if (edge1.PrevInSEL === null)\n      this.m_SortedEdges = edge1;\n    else if (edge2.PrevInSEL === null)\n      this.m_SortedEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n  {\n    this.AddOutPt(e1, pt);\n    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n    if (e1.OutIdx == e2.OutIdx)\n    {\n      e1.OutIdx = -1;\n      e2.OutIdx = -1;\n    }\n    else if (e1.OutIdx < e2.OutIdx)\n      this.AppendPolygon(e1, e2);\n    else\n      this.AppendPolygon(e2, e1);\n  };\n  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n  {\n    var result;\n    var e, prevE;\n    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n    {\n      result = this.AddOutPt(e1, pt);\n      e2.OutIdx = e1.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esLeft;\n      e2.Side = ClipperLib.EdgeSide.esRight;\n      e = e1;\n      if (e.PrevInAEL == e2)\n        prevE = e2.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    else\n    {\n      result = this.AddOutPt(e2, pt);\n      e1.OutIdx = e2.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esRight;\n      e2.Side = ClipperLib.EdgeSide.esLeft;\n      e = e2;\n      if (e.PrevInAEL == e1)\n        prevE = e1.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n    {\n      var outPt = this.AddOutPt(prevE, pt);\n      this.AddJoin(result, outPt, e.Top);\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n  {\n    var result = new ClipperLib.OutRec();\n    result.Idx = -1;\n    result.IsHole = false;\n    result.IsOpen = false;\n    result.FirstLeft = null;\n    result.Pts = null;\n    result.BottomPt = null;\n    result.PolyNode = null;\n    this.m_PolyOuts.push(result);\n    result.Idx = this.m_PolyOuts.length - 1;\n    return result;\n  };\n  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n  {\n    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n    if (e.OutIdx < 0)\n    {\n      var outRec = this.CreateOutRec();\n      outRec.IsOpen = (e.WindDelta === 0);\n      var newOp = new ClipperLib.OutPt();\n      outRec.Pts = newOp;\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = newOp;\n      newOp.Prev = newOp;\n      if (!outRec.IsOpen)\n        this.SetHoleState(e, outRec);\n      e.OutIdx = outRec.Idx;\n      //nb: do this after SetZ !\n      return newOp;\n    }\n    else\n    {\n      var outRec = this.m_PolyOuts[e.OutIdx];\n      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n      var op = outRec.Pts;\n      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n        return op;\n      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n        return op.Prev;\n      var newOp = new ClipperLib.OutPt();\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = op;\n      newOp.Prev = op.Prev;\n      newOp.Prev.Next = newOp;\n      op.Prev = newOp;\n      if (ToFront)\n        outRec.Pts = newOp;\n      return newOp;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n  {\n    var tmp = new ClipperLib.IntPoint(pt1.Value);\n    //pt1.Value = pt2.Value;\n    pt1.Value.X = pt2.Value.X;\n    pt1.Value.Y = pt2.Value.Y;\n    //pt2.Value = tmp;\n    pt2.Value.X = tmp.X;\n    pt2.Value.Y = tmp.Y;\n  };\n  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t{\n\t\tvar tmp;\n\t\tif (seg1a > seg1b)\n\t\t{\n\t\t\ttmp = seg1a;\n\t\t\tseg1a = seg1b;\n\t\t\tseg1b = tmp;\n\t\t}\n\t\tif (seg2a > seg2b)\n\t\t{\n\t\t\ttmp = seg2a;\n\t\t\tseg2a = seg2b;\n\t\t\tseg2b = tmp;\n\t\t}\n\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t}\n\n  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n  {\n    var isHole = false;\n    var e2 = e.PrevInAEL;\n    while (e2 !== null)\n    {\n      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n      {\n        isHole = !isHole;\n        if (outRec.FirstLeft === null)\n          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n      }\n      e2 = e2.PrevInAEL;\n    }\n    if (isHole)\n      outRec.IsHole = true;\n  };\n  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n  {\n    if (pt1.Y == pt2.Y)\n      return ClipperLib.ClipperBase.horizontal;\n    else\n      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n  };\n  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n  {\n    var p = btmPt1.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Prev;\n    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt1.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Next;\n    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt2.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Prev;\n    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    p = btmPt2.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Next;\n    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n  };\n  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n  {\n    var dups = null;\n    var p = pp.Next;\n    while (p != pp)\n    {\n      if (p.Pt.Y > pp.Pt.Y)\n      {\n        pp = p;\n        dups = null;\n      }\n      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n      {\n        if (p.Pt.X < pp.Pt.X)\n        {\n          dups = null;\n          pp = p;\n        }\n        else\n        {\n          if (p.Next != pp && p.Prev != pp)\n            dups = p;\n        }\n      }\n      p = p.Next;\n    }\n    if (dups !== null)\n    {\n      //there appears to be at least 2 vertices at bottomPt so ...\n      while (dups != p)\n      {\n        if (!this.FirstIsBottomPt(p, dups))\n          pp = dups;\n        dups = dups.Next;\n        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n          dups = dups.Next;\n      }\n    }\n    return pp;\n  };\n  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n  {\n    //work out which polygon fragment has the correct hole state ...\n    if (outRec1.BottomPt === null)\n      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n    if (outRec2.BottomPt === null)\n      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n    var bPt1 = outRec1.BottomPt;\n    var bPt2 = outRec2.BottomPt;\n    if (bPt1.Pt.Y > bPt2.Pt.Y)\n      return outRec1;\n    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n      return outRec2;\n    else if (bPt1.Pt.X < bPt2.Pt.X)\n      return outRec1;\n    else if (bPt1.Pt.X > bPt2.Pt.X)\n      return outRec2;\n    else if (bPt1.Next == bPt1)\n      return outRec2;\n    else if (bPt2.Next == bPt2)\n      return outRec1;\n    else if (this.FirstIsBottomPt(bPt1, bPt2))\n      return outRec1;\n    else\n      return outRec2;\n  };\n  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n  {\n    do {\n      outRec1 = outRec1.FirstLeft;\n      if (outRec1 == outRec2)\n        return true;\n    }\n    while (outRec1 !== null)\n    return false;\n  };\n  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n  {\n    var outrec = this.m_PolyOuts[idx];\n    while (outrec != this.m_PolyOuts[outrec.Idx])\n      outrec = this.m_PolyOuts[outrec.Idx];\n    return outrec;\n  };\n  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n  {\n    //get the start and ends of both output polygons ...\n    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n    var holeStateRec;\n    if (this.Param1RightOfParam2(outRec1, outRec2))\n      holeStateRec = outRec2;\n    else if (this.Param1RightOfParam2(outRec2, outRec1))\n      holeStateRec = outRec1;\n    else\n      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n    var p1_lft = outRec1.Pts;\n    var p1_rt = p1_lft.Prev;\n    var p2_lft = outRec2.Pts;\n    var p2_rt = p2_lft.Prev;\n    var side;\n    //join e2 poly onto e1 poly and delete pointers to e2 ...\n    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n      {\n        //z y x a b c\n        this.ReversePolyPtLinks(p2_lft);\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        outRec1.Pts = p2_rt;\n      }\n      else\n      {\n        //x y z a b c\n        p2_rt.Next = p1_lft;\n        p1_lft.Prev = p2_rt;\n        p2_lft.Prev = p1_rt;\n        p1_rt.Next = p2_lft;\n        outRec1.Pts = p2_lft;\n      }\n      side = ClipperLib.EdgeSide.esLeft;\n    }\n    else\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esRight)\n      {\n        //a b c z y x\n        this.ReversePolyPtLinks(p2_lft);\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n      }\n      else\n      {\n        //a b c x y z\n        p1_rt.Next = p2_lft;\n        p2_lft.Prev = p1_rt;\n        p1_lft.Prev = p2_rt;\n        p2_rt.Next = p1_lft;\n      }\n      side = ClipperLib.EdgeSide.esRight;\n    }\n    outRec1.BottomPt = null;\n    if (holeStateRec == outRec2)\n    {\n      if (outRec2.FirstLeft != outRec1)\n        outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec1.IsHole = outRec2.IsHole;\n    }\n    outRec2.Pts = null;\n    outRec2.BottomPt = null;\n    outRec2.FirstLeft = outRec1;\n    var OKIdx = e1.OutIdx;\n    var ObsoleteIdx = e2.OutIdx;\n    e1.OutIdx = -1;\n    //nb: safe because we only get here via AddLocalMaxPoly\n    e2.OutIdx = -1;\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (e.OutIdx == ObsoleteIdx)\n      {\n        e.OutIdx = OKIdx;\n        e.Side = side;\n        break;\n      }\n      e = e.NextInAEL;\n    }\n    outRec2.Idx = outRec1.Idx;\n  };\n  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n  {\n    if (pp === null)\n      return;\n    var pp1;\n    var pp2;\n    pp1 = pp;\n    do {\n      pp2 = pp1.Next;\n      pp1.Next = pp1.Prev;\n      pp1.Prev = pp2;\n      pp1 = pp2;\n    }\n    while (pp1 != pp)\n  };\n  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n  {\n    var side = edge1.Side;\n    edge1.Side = edge2.Side;\n    edge2.Side = side;\n  };\n  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n  {\n    var outIdx = edge1.OutIdx;\n    edge1.OutIdx = edge2.OutIdx;\n    edge2.OutIdx = outIdx;\n  };\n  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n  {\n    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n    //e2 in AEL except when e1 is being inserted at the intersection point ...\n    var e1Contributing = (e1.OutIdx >= 0);\n    var e2Contributing = (e2.OutIdx >= 0);\n\n    if (use_xyz)\n    \tthis.SetZ(pt, e1, e2);\n\n    if (use_lines)\n    {\n      //if either edge is on an OPEN path ...\n      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n      {\n        //ignore subject-subject open path intersections UNLESS they\n        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n        //if intersecting a subj line with a subj poly ...\n        else if (e1.PolyTyp == e2.PolyTyp &&\n          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n        {\n          if (e1.WindDelta === 0)\n          {\n            if (e2Contributing)\n            {\n              this.AddOutPt(e1, pt);\n              if (e1Contributing)\n                e1.OutIdx = -1;\n            }\n          }\n          else\n          {\n            if (e1Contributing)\n            {\n              this.AddOutPt(e2, pt);\n              if (e2Contributing)\n                e2.OutIdx = -1;\n            }\n          }\n        }\n        else if (e1.PolyTyp != e2.PolyTyp)\n        {\n          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n          {\n            this.AddOutPt(e1, pt);\n            if (e1Contributing)\n              e1.OutIdx = -1;\n          }\n          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n          {\n            this.AddOutPt(e2, pt);\n            if (e2Contributing)\n              e2.OutIdx = -1;\n          }\n        }\n        return;\n      }\n    }\n    //update winding counts...\n    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n    if (e1.PolyTyp == e2.PolyTyp)\n    {\n      if (this.IsEvenOddFillType(e1))\n      {\n        var oldE1WindCnt = e1.WindCnt;\n        e1.WindCnt = e2.WindCnt;\n        e2.WindCnt = oldE1WindCnt;\n      }\n      else\n      {\n        if (e1.WindCnt + e2.WindDelta === 0)\n          e1.WindCnt = -e1.WindCnt;\n        else\n          e1.WindCnt += e2.WindDelta;\n        if (e2.WindCnt - e1.WindDelta === 0)\n          e2.WindCnt = -e2.WindCnt;\n        else\n          e2.WindCnt -= e1.WindDelta;\n      }\n    }\n    else\n    {\n      if (!this.IsEvenOddFillType(e2))\n        e1.WindCnt2 += e2.WindDelta;\n      else\n        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n      if (!this.IsEvenOddFillType(e1))\n        e2.WindCnt2 -= e1.WindDelta;\n      else\n        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n    }\n    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e1FillType = this.m_SubjFillType;\n      e1FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e1FillType = this.m_ClipFillType;\n      e1FillType2 = this.m_SubjFillType;\n    }\n    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e2FillType = this.m_SubjFillType;\n      e2FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e2FillType = this.m_ClipFillType;\n      e2FillType2 = this.m_SubjFillType;\n    }\n    var e1Wc, e2Wc;\n    switch (e1FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e1Wc = e1.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e1Wc = -e1.WindCnt;\n      break;\n    default:\n      e1Wc = Math.abs(e1.WindCnt);\n      break;\n    }\n    switch (e2FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e2Wc = e2.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e2Wc = -e2.WindCnt;\n      break;\n    default:\n      e2Wc = Math.abs(e2.WindCnt);\n      break;\n    }\n    if (e1Contributing && e2Contributing)\n    {\n\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t{\n\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t}\n      else\n      {\n        this.AddOutPt(e1, pt);\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e1Contributing)\n    {\n      if (e2Wc === 0 || e2Wc == 1)\n      {\n        this.AddOutPt(e1, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e2Contributing)\n    {\n      if (e1Wc === 0 || e1Wc == 1)\n      {\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n    {\n      //neither edge is currently contributing ...\n      var e1Wc2, e2Wc2;\n      switch (e1FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e1Wc2 = e1.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e1Wc2 = -e1.WindCnt2;\n        break;\n      default:\n        e1Wc2 = Math.abs(e1.WindCnt2);\n        break;\n      }\n      switch (e2FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e2Wc2 = e2.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e2Wc2 = -e2.WindCnt2;\n        break;\n      default:\n        e2Wc2 = Math.abs(e2.WindCnt2);\n        break;\n      }\n      if (e1.PolyTyp != e2.PolyTyp)\n      {\n        this.AddLocalMinPoly(e1, e2, pt);\n      }\n      else if (e1Wc == 1 && e2Wc == 1)\n        switch (this.m_ClipType)\n        {\n        case ClipperLib.ClipType.ctIntersection:\n          if (e1Wc2 > 0 && e2Wc2 > 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctUnion:\n          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctDifference:\n          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctXor:\n          this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        }\n      else\n        ClipperLib.Clipper.SwapSides(e1, e2);\n    }\n  };\n  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n  {\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n      return;\n    //already deleted\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = AelNext;\n    else\n      this.m_ActiveEdges = AelNext;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = AelPrev;\n    e.NextInAEL = null;\n    e.PrevInAEL = null;\n  };\n  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n  {\n    var SelPrev = e.PrevInSEL;\n    var SelNext = e.NextInSEL;\n    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n      return;\n    //already deleted\n    if (SelPrev !== null)\n      SelPrev.NextInSEL = SelNext;\n    else\n      this.m_SortedEdges = SelNext;\n    if (SelNext !== null)\n      SelNext.PrevInSEL = SelPrev;\n    e.NextInSEL = null;\n    e.PrevInSEL = null;\n  };\n  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n  {\n    if (e.NextInLML === null)\n      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    e.NextInLML.OutIdx = e.OutIdx;\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = e.NextInLML;\n    else\n      this.m_ActiveEdges = e.NextInLML;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = e.NextInLML;\n    e.NextInLML.Side = e.Side;\n    e.NextInLML.WindDelta = e.WindDelta;\n    e.NextInLML.WindCnt = e.WindCnt;\n    e.NextInLML.WindCnt2 = e.WindCnt2;\n    e = e.NextInLML;\n    //    e.Curr = e.Bot;\n    e.Curr.X = e.Bot.X;\n    e.Curr.Y = e.Bot.Y;\n    e.PrevInAEL = AelPrev;\n    e.NextInAEL = AelNext;\n    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n      this.InsertScanbeam(e.Top.Y);\n    return e;\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n  {\n    var horzEdge = this.m_SortedEdges;\n    while (horzEdge !== null)\n    {\n      this.DeleteFromSEL(horzEdge);\n      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n      horzEdge = this.m_SortedEdges;\n    }\n  };\n  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n  {\n    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n    {\n        $var.Left = HorzEdge.Bot.X;\n        $var.Right = HorzEdge.Top.X;\n        $var.Dir = ClipperLib.Direction.dLeftToRight;\n    }\n    else\n    {\n        $var.Left = HorzEdge.Top.X;\n        $var.Right = HorzEdge.Bot.X;\n        $var.Dir = ClipperLib.Direction.dRightToLeft;\n    }\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n  {\n    var $var = {Dir: null, Left: null, Right: null};\n    this.GetHorzDirection(horzEdge, $var);\n    var dir = $var.Dir;\n    var horzLeft = $var.Left;\n    var horzRight = $var.Right;\n\n    var eLastHorz = horzEdge,\n      eMaxPair = null;\n    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n      eLastHorz = eLastHorz.NextInLML;\n    if (eLastHorz.NextInLML === null)\n      eMaxPair = this.GetMaximaPair(eLastHorz);\n    for (;;)\n    {\n      var IsLastHorz = (horzEdge == eLastHorz);\n      var e = this.GetNextInAEL(horzEdge, dir);\n      while (e !== null)\n      {\n        //Break if we've got to the end of an intermediate horizontal edge ...\n        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n          break;\n        var eNext = this.GetNextInAEL(e, dir);\n        //saves eNext for later\n        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n        {\n          //so far we're still in range of the horizontal Edge  but make sure\n          //we're at the last of consec. horizontals when matching with eMaxPair\n          if (e == eMaxPair && IsLastHorz)\n          {\n\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n            return;\n          }\n          else if (dir == ClipperLib.Direction.dLeftToRight)\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(horzEdge, e, Pt);\n          }\n          else\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(e, horzEdge, Pt);\n          }\n          this.SwapPositionsInAEL(horzEdge, e);\n        }\n        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n          break;\n        e = eNext;\n      }\n      //end while\n      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n      {\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.OutIdx >= 0)\n          this.AddOutPt(horzEdge, horzEdge.Bot);\n\n          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n          this.GetHorzDirection(horzEdge, $var);\n          dir = $var.Dir;\n          horzLeft = $var.Left;\n          horzRight = $var.Right;\n      }\n      else\n        break;\n    }\n    //end for (;;)\n    if (horzEdge.NextInLML !== null)\n    {\n      if (horzEdge.OutIdx >= 0)\n      {\n        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.WindDelta === 0)\n          return;\n        //nb: HorzEdge is no longer horizontal here\n        var ePrev = horzEdge.PrevInAEL;\n        var eNext = horzEdge.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n        {\n          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n        {\n          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n      }\n      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    }\n  \telse\n    {\n      if (horzEdge.OutIdx >= 0)\n        this.AddOutPt(horzEdge, horzEdge.Top);\n      this.DeleteFromAEL(horzEdge);\n    }\n  };\n  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n  {\n    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n  };\n  ClipperLib.Clipper.prototype.IsMinima = function (e)\n  {\n    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n  };\n  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n  {\n    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n  };\n  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n  {\n    return (e.Top.Y == Y && e.NextInLML !== null);\n  };\n  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n  {\n    var result = null;\n    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n      result = e.Next;\n    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n      result = e.Prev;\n    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n      return null;\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n  {\n    if (this.m_ActiveEdges == null)\n      return true;\n    try\n    {\n      this.BuildIntersectList(topY);\n      if (this.m_IntersectList.length == 0)\n        return true;\n      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n        this.ProcessIntersectList();\n      else\n        return false;\n    }\n    catch ($$e2)\n    {\n      this.m_SortedEdges = null;\n      this.m_IntersectList.length = 0;\n      ClipperLib.Error(\"ProcessIntersections error\");\n    }\n    this.m_SortedEdges = null;\n    return true;\n  };\n  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n  {\n    if (this.m_ActiveEdges === null)\n      return;\n    //prepare for sorting ...\n    var e = this.m_ActiveEdges;\n    //console.log(JSON.stringify(JSON.decycle( e )));\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n      e = e.NextInAEL;\n    }\n    //bubblesort ...\n    var isModified = true;\n    while (isModified && this.m_SortedEdges !== null)\n    {\n      isModified = false;\n      e = this.m_SortedEdges;\n      while (e.NextInSEL !== null)\n      {\n        var eNext = e.NextInSEL;\n        var pt = new ClipperLib.IntPoint();\n        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n        if (e.Curr.X > eNext.Curr.X)\n        {\n\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n          var newNode = new ClipperLib.IntersectNode();\n          newNode.Edge1 = e;\n          newNode.Edge2 = eNext;\n          //newNode.Pt = pt;\n          newNode.Pt.X = pt.X;\n          newNode.Pt.Y = pt.Y;\n          this.m_IntersectList.push(newNode);\n          this.SwapPositionsInSEL(e, eNext);\n          isModified = true;\n        }\n        else\n          e = eNext;\n      }\n      if (e.PrevInSEL !== null)\n        e.PrevInSEL.NextInSEL = null;\n      else\n        break;\n    }\n    this.m_SortedEdges = null;\n  };\n  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n  {\n    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n  };\n  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n  {\n    //the following typecast is safe because the differences in Pt.Y will\n    //be limited to the height of the scanbeam.\n    return (node2.Pt.Y - node1.Pt.Y);\n  };\n  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n  {\n    //pre-condition: intersections are sorted bottom-most first.\n    //Now it's crucial that intersections are made only between adjacent edges,\n    //so to ensure this the order of intersections may need adjusting ...\n    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n    this.CopyAELToSEL();\n    var cnt = this.m_IntersectList.length;\n    for (var i = 0; i < cnt; i++)\n    {\n      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n      {\n        var j = i + 1;\n        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n          j++;\n        if (j == cnt)\n          return false;\n        var tmp = this.m_IntersectList[i];\n        this.m_IntersectList[i] = this.m_IntersectList[j];\n        this.m_IntersectList[j] = tmp;\n      }\n      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n  {\n    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n    {\n      var iNode = this.m_IntersectList[i];\n      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n    }\n    this.m_IntersectList.length = 0;\n  };\n  /*\n  --------------------------------\n  Round speedtest: http://jsperf.com/fastest-round\n  --------------------------------\n  */\n  var R1 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n  };\n  var R2 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n  };\n  var R3 = function (a)\n  {\n    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n  };\n  var R4 = function (a)\n  {\n    if (a < 0)\n    {\n      a -= 0.5;\n      return a < -2147483648 ? Math.ceil(a) : a | 0;\n    }\n    else\n    {\n      a += 0.5;\n      return a > 2147483647 ? Math.floor(a) : a | 0;\n    }\n  };\n  if (browser.msie) ClipperLib.Clipper.Round = R1;\n  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n  ClipperLib.Clipper.TopX = function (edge, currentY)\n  {\n    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n    if (currentY == edge.Top.Y)\n      return edge.Top.X;\n    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n  };\n  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n  {\n    ip.X = 0;\n    ip.Y = 0;\n    var b1, b2;\n    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n    //return false but for the edge.Dx value be equal due to double precision rounding.\n    if (edge1.Dx == edge2.Dx)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\treturn;\n    }\n    if (edge1.Delta.X === 0)\n    {\n      ip.X = edge1.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n      {\n        ip.Y = edge2.Bot.Y;\n      }\n      else\n      {\n        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n      }\n    }\n    else if (edge2.Delta.X === 0)\n    {\n      ip.X = edge2.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n      {\n        ip.Y = edge1.Bot.Y;\n      }\n      else\n      {\n        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n      }\n    }\n    else\n    {\n      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n      ip.Y = ClipperLib.Clipper.Round(q);\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n      else\n        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n    }\n    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n    {\n      if (edge1.Top.Y > edge2.Top.Y)\n      {\n        ip.Y = edge1.Top.Y;\n        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n        return ip.X < edge1.Top.X;\n      }\n      else\n        ip.Y = edge2.Top.Y;\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n      else\n        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n    }\n\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\tif (ip.Y > edge1.Curr.Y)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t}\n  };\n\n  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n  {\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n      var IsMaximaEdge = this.IsMaxima(e, topY);\n      if (IsMaximaEdge)\n      {\n        var eMaxPair = this.GetMaximaPair(e);\n        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n      }\n      if (IsMaximaEdge)\n      {\n        var ePrev = e.PrevInAEL;\n        this.DoMaxima(e);\n        if (ePrev === null)\n          e = this.m_ActiveEdges;\n        else\n          e = ePrev.NextInAEL;\n      }\n      else\n      {\n        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n        {\n          e = this.UpdateEdgeIntoAEL(e);\n          if (e.OutIdx >= 0)\n            this.AddOutPt(e, e.Bot);\n          this.AddEdgeToSEL(e);\n        }\n        else\n        {\n          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n          e.Curr.Y = topY;\n        }\n        if (this.StrictlySimple)\n        {\n          var ePrev = e.PrevInAEL;\n          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n            (ePrev.WindDelta !== 0))\n          {\n           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\n\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t}\n\n            var op = this.AddOutPt(ePrev, ip);\n            var op2 = this.AddOutPt(e, ip);\n            this.AddJoin(op, op2, ip);\n            //StrictlySimple (type-3) join\n          }\n        }\n        e = e.NextInAEL;\n      }\n    }\n    //3. Process horizontals at the Top of the scanbeam ...\n    this.ProcessHorizontals(true);\n    //4. Promote intermediate vertices ...\n    e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (this.IsIntermediate(e, topY))\n      {\n        var op = null;\n        if (e.OutIdx >= 0)\n          op = this.AddOutPt(e, e.Top);\n        e = this.UpdateEdgeIntoAEL(e);\n        //if output polygons share an edge, they'll need joining later ...\n        var ePrev = e.PrevInAEL;\n        var eNext = e.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(ePrev, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n          eNext.Curr.Y == e.Bot.Y && op !== null &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(eNext, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n      }\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n  {\n    var eMaxPair = this.GetMaximaPair(e);\n    if (eMaxPair === null)\n    {\n      if (e.OutIdx >= 0)\n        this.AddOutPt(e, e.Top);\n      this.DeleteFromAEL(e);\n      return;\n    }\n    var eNext = e.NextInAEL;\n    var use_lines = true;\n    while (eNext !== null && eNext != eMaxPair)\n    {\n      this.IntersectEdges(e, eNext, e.Top);\n      this.SwapPositionsInAEL(e, eNext);\n      eNext = e.NextInAEL;\n    }\n    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n    {\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n    {\n    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (use_lines && e.WindDelta === 0)\n    {\n      if (e.OutIdx >= 0)\n      {\n        this.AddOutPt(e, e.Top);\n        e.OutIdx = -1;\n      }\n      this.DeleteFromAEL(e);\n      if (eMaxPair.OutIdx >= 0)\n      {\n        this.AddOutPt(eMaxPair, e.Top);\n        eMaxPair.OutIdx = -1;\n      }\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else\n      ClipperLib.Error(\"DoMaxima error\");\n  };\n  ClipperLib.Clipper.ReversePaths = function (polys)\n  {\n    for (var i = 0, len = polys.length; i < len; i++)\n      polys[i].reverse();\n  };\n  ClipperLib.Clipper.Orientation = function (poly)\n  {\n    return ClipperLib.Clipper.Area(poly) >= 0;\n  };\n  ClipperLib.Clipper.prototype.PointCount = function (pts)\n  {\n    if (pts === null)\n      return 0;\n    var result = 0;\n    var p = pts;\n    do {\n      result++;\n      p = p.Next;\n    }\n    while (p != pts)\n    return result;\n  };\n  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n  {\n    ClipperLib.Clear(polyg);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null)\n        continue;\n      var p = outRec.Pts.Prev;\n      var cnt = this.PointCount(p);\n      if (cnt < 2)\n        continue;\n      var pg = new Array(cnt);\n      for (var j = 0; j < cnt; j++)\n      {\n        pg[j] = p.Pt;\n        p = p.Prev;\n      }\n      polyg.push(pg);\n    }\n  };\n  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n  {\n    polytree.Clear();\n    //add each output polygon/contour to polytree ...\n    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      var cnt = this.PointCount(outRec.Pts);\n      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n        continue;\n      this.FixHoleLinkage(outRec);\n      var pn = new ClipperLib.PolyNode();\n      polytree.m_AllPolys.push(pn);\n      outRec.PolyNode = pn;\n      pn.m_polygon.length = cnt;\n      var op = outRec.Pts.Prev;\n      for (var j = 0; j < cnt; j++)\n      {\n        pn.m_polygon[j] = op.Pt;\n        op = op.Prev;\n      }\n    }\n    //fixup PolyNode links etc ...\n    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.PolyNode === null)\n        continue;\n      else if (outRec.IsOpen)\n      {\n        outRec.PolyNode.IsOpen = true;\n        polytree.AddChild(outRec.PolyNode);\n      }\n      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n      else\n        polytree.AddChild(outRec.PolyNode);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n  {\n    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n    //parallel edges by removing the middle vertex.\n    var lastOK = null;\n    outRec.BottomPt = null;\n    var pp = outRec.Pts;\n    for (;;)\n    {\n      if (pp.Prev == pp || pp.Prev == pp.Next)\n      {\n        outRec.Pts = null;\n        return;\n      }\n      //test for duplicate points and collinear edges ...\n      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n      {\n        lastOK = null;\n        pp.Prev.Next = pp.Next;\n        pp.Next.Prev = pp.Prev;\n        pp = pp.Prev;\n      }\n      else if (pp == lastOK)\n        break;\n      else\n      {\n        if (lastOK === null)\n          lastOK = pp;\n        pp = pp.Next;\n      }\n    }\n    outRec.Pts = pp;\n  };\n  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n  {\n    var result = new ClipperLib.OutPt();\n    //result.Pt = outPt.Pt;\n    result.Pt.X = outPt.Pt.X;\n    result.Pt.Y = outPt.Pt.Y;\n    result.Idx = outPt.Idx;\n    if (InsertAfter)\n    {\n      result.Next = outPt.Next;\n      result.Prev = outPt;\n      outPt.Next.Prev = result;\n      outPt.Next = result;\n    }\n    else\n    {\n      result.Prev = outPt.Prev;\n      result.Next = outPt;\n      outPt.Prev.Next = result;\n      outPt.Prev = result;\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n  {\n    if (a1 < a2)\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a1, b1);\n        $val.Right = Math.min(a2, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a1, b2);\n        $val.Right = Math.min(a2, b1);\n      }\n    }\n    else\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a2, b1);\n        $val.Right = Math.min(a1, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a2, b2);\n        $val.Right = Math.min(a1, b1);\n      }\n    }\n    return $val.Left < $val.Right;\n  };\n  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n  {\n    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    if (Dir1 == Dir2)\n      return false;\n    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n    //So, to facilitate this while inserting Op1b and Op2b ...\n    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op1.Next.Pt.X <= Pt.X &&\n        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op1.Next.Pt.X >= Pt.X &&\n        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, DiscardLeft);\n      }\n    }\n    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op2.Next.Pt.X <= Pt.X &&\n        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op2.Next.Pt.X >= Pt.X &&\n        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, DiscardLeft);\n      }\n    }\n    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n    {\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n    }\n    else\n    {\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n  {\n    var op1 = j.OutPt1,\n      op1b = new ClipperLib.OutPt();\n    var op2 = j.OutPt2,\n      op2b = new ClipperLib.OutPt();\n    //There are 3 kinds of joins for output polygons ...\n    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n    //3. StrictlySimple joins where edges touch but are not collinear and where\n    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n    {\n      //Strictly Simple join ...\n\t\t\tif (outRec1 != outRec2) return false;\n\n      op1b = j.OutPt1.Next;\n      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n        op1b = op1b.Next;\n      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n      op2b = j.OutPt2.Next;\n      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n        op2b = op2b.Next;\n      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n      if (reverse1 == reverse2)\n        return false;\n      if (reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n    else if (isHorizontal)\n    {\n      //treat horizontal joins differently to non-horizontal joins since with\n      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n      //may be anywhere along the horizontal edge.\n      op1b = op1;\n      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n        op1 = op1.Prev;\n      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n        op1b = op1b.Next;\n      if (op1b.Next == op1 || op1b.Next == op2)\n        return false;\n      //a flat 'polygon'\n      op2b = op2;\n      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n        op2 = op2.Prev;\n      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n        op2b = op2b.Next;\n      if (op2b.Next == op2 || op2b.Next == op1)\n        return false;\n      //a flat 'polygon'\n      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n      var $val = {Left: null, Right: null};\n      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n        return false;\n      var Left = $val.Left;\n      var Right = $val.Right;\n\n      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n      //on the discard Side as either may still be needed for other joins ...\n      var Pt = new ClipperLib.IntPoint();\n      var DiscardLeftSide;\n      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n      {\n        //Pt = op1.Pt;\n        Pt.X = op1.Pt.X;\n        Pt.Y = op1.Pt.Y;\n        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n      }\n      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n      {\n        //Pt = op2.Pt;\n        Pt.X = op2.Pt.X;\n        Pt.Y = op2.Pt.Y;\n        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n      }\n      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n      {\n        //Pt = op1b.Pt;\n        Pt.X = op1b.Pt.X;\n        Pt.Y = op1b.Pt.Y;\n        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n      }\n      else\n      {\n        //Pt = op2b.Pt;\n        Pt.X = op2b.Pt.X;\n        Pt.Y = op2b.Pt.Y;\n        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n      }\n      j.OutPt1 = op1;\n      j.OutPt2 = op2;\n      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n    }\n    else\n    {\n      //nb: For non-horizontal joins ...\n      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n      //make sure the polygons are correctly oriented ...\n      op1b = op1.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n        op1b = op1b.Next;\n      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse1)\n      {\n        op1b = op1.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n          op1b = op1b.Prev;\n        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      op2b = op2.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n        op2b = op2b.Next;\n      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse2)\n      {\n        op2b = op2.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n          op2b = op2b.Prev;\n        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n        return false;\n      if (Reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n  };\n  ClipperLib.Clipper.GetBounds = function (paths)\n  {\n    var i = 0,\n      cnt = paths.length;\n    while (i < cnt && paths[i].length == 0) i++;\n    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n    var result = new ClipperLib.IntRect();\n    result.left = paths[i][0].X;\n    result.right = result.left;\n    result.top = paths[i][0].Y;\n    result.bottom = result.top;\n    for (; i < cnt; i++)\n      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n      {\n        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n      }\n    return result;\n  }\n  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n  {\n    var opStart = ops;\n    var result = new ClipperLib.IntRect();\n    result.left = ops.Pt.X;\n    result.right = ops.Pt.X;\n    result.top = ops.Pt.Y;\n    result.bottom = ops.Pt.Y;\n    ops = ops.Next;\n    while (ops != opStart)\n    {\n      if (ops.Pt.X < result.left)\n        result.left = ops.Pt.X;\n      if (ops.Pt.X > result.right)\n        result.right = ops.Pt.X;\n      if (ops.Pt.Y < result.top)\n        result.top = ops.Pt.Y;\n      if (ops.Pt.Y > result.bottom)\n        result.bottom = ops.Pt.Y;\n      ops = ops.Next;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0,\n      cnt = path.length;\n    if (cnt < 3)\n      return 0;\n    var ip = path[0];\n    for (var i = 1; i <= cnt; ++i)\n    {\n      var ipNext = (i == cnt ? path[0] : path[i]);\n      if (ipNext.Y == pt.Y)\n      {\n        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n          return -1;\n      }\n      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n      {\n        if (ip.X >= pt.X)\n        {\n          if (ipNext.X > pt.X)\n            result = 1 - result;\n          else\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (ipNext.X > pt.X)\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n      }\n      ip = ipNext;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0;\n    var startOp = op;\n\t\tvar ptx = pt.X, pty = pt.Y;\n    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n    do\n    {\n\t\t\top = op.Next;\n\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n      if (poly1y == pty)\n      {\n        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n          return -1;\n      }\n      if ((poly0y < pty) != (poly1y < pty))\n      {\n        if (poly0x >= ptx)\n        {\n          if (poly1x > ptx)\n            result = 1 - result;\n          else\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (poly1x > ptx)\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n      }\n      poly0x = poly1x;\n      poly0y = poly1y;\n    } while (startOp != op);\n\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n  {\n    var op = outPt1;\n    do\n    {\n\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n      var res = this.PointInPolygon(op.Pt, outPt2);\n      if (res >= 0)\n        return res > 0;\n      op = op.Next;\n    }\n    while (op != outPt1)\n    return true;\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\tcontinue;\n\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (firstLeft == OldOutRec)\n\t\t\t{\n        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n          outRec.FirstLeft = NewOutRec;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n  {\n    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n      if (outRec.FirstLeft == OldOutRec)\n        outRec.FirstLeft = NewOutRec;\n  };\n  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n  {\n    while (FirstLeft != null && FirstLeft.Pts == null)\n      FirstLeft = FirstLeft.FirstLeft;\n    return FirstLeft;\n  };\n  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n  {\n    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n    {\n      var join = this.m_Joins[i];\n      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n      if (outRec1.Pts == null || outRec2.Pts == null)\n        continue;\n      //get the polygon fragment with the correct hole state (FirstLeft)\n      //before calling JoinPoints() ...\n      var holeStateRec;\n      if (outRec1 == outRec2)\n        holeStateRec = outRec1;\n      else if (this.Param1RightOfParam2(outRec1, outRec2))\n        holeStateRec = outRec2;\n      else if (this.Param1RightOfParam2(outRec2, outRec1))\n        holeStateRec = outRec1;\n      else\n        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n      if (outRec1 == outRec2)\n      {\n        //instead of joining two polygons, we've just created a new one by\n        //splitting one polygon into two.\n        outRec1.Pts = join.OutPt1;\n        outRec1.BottomPt = null;\n        outRec2 = this.CreateOutRec();\n        outRec2.Pts = join.OutPt2;\n        //update all OutRec2.Pts Idx's ...\n        this.UpdateOutPtIdxs(outRec2);\n        //We now need to check every OutRec.FirstLeft pointer. If it points\n        //to OutRec1 it may need to point to OutRec2 instead ...\n        if (this.m_UsingPolyTree)\n          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n          {\n            var oRec = this.m_PolyOuts[j];\n            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n              continue;\n            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n              oRec.FirstLeft = outRec2;\n          }\n        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n        {\n          //outRec2 is contained by outRec1 ...\n          outRec2.IsHole = !outRec1.IsHole;\n          outRec2.FirstLeft = outRec1;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec2, outRec1);\n          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n            this.ReversePolyPtLinks(outRec2.Pts);\n        }\n        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n        {\n          //outRec1 is contained by outRec2 ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec1.IsHole = !outRec2.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          outRec1.FirstLeft = outRec2;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec1, outRec2);\n          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n            this.ReversePolyPtLinks(outRec1.Pts);\n        }\n        else\n        {\n          //the 2 polygons are completely separate ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          //fixup FirstLeft pointers that may need reassigning to OutRec2\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts1(outRec1, outRec2);\n        }\n      }\n      else\n      {\n        //joined 2 polygons together ...\n        outRec2.Pts = null;\n        outRec2.BottomPt = null;\n        outRec2.Idx = outRec1.Idx;\n        outRec1.IsHole = holeStateRec.IsHole;\n        if (holeStateRec == outRec2)\n          outRec1.FirstLeft = outRec2.FirstLeft;\n        outRec2.FirstLeft = outRec1;\n        //fixup FirstLeft pointers that may need reassigning to OutRec1\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec2, outRec1);\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n  {\n    var op = outrec.Pts;\n    do {\n      op.Idx = outrec.Idx;\n      op = op.Prev;\n    }\n    while (op != outrec.Pts)\n  };\n  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n  {\n    var i = 0;\n    while (i < this.m_PolyOuts.length)\n    {\n      var outrec = this.m_PolyOuts[i++];\n      var op = outrec.Pts;\n\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\tcontinue;\n      do //for each Pt in Polygon until duplicate found do ...\n      {\n        var op2 = op.Next;\n        while (op2 != outrec.Pts)\n        {\n          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n          {\n            //split the polygon into two ...\n            var op3 = op.Prev;\n            var op4 = op2.Prev;\n            op.Prev = op4;\n            op4.Next = op;\n            op2.Prev = op3;\n            op3.Next = op2;\n            outrec.Pts = op;\n            var outrec2 = this.CreateOutRec();\n            outrec2.Pts = op2;\n            this.UpdateOutPtIdxs(outrec2);\n            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n            {\n              //OutRec2 is contained by OutRec1 ...\n              outrec2.IsHole = !outrec.IsHole;\n              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\n            }\n            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n            {\n              //OutRec1 is contained by OutRec2 ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec.IsHole = !outrec2.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n              outrec.FirstLeft = outrec2;\n              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n            }\n            else\n            {\n              //the 2 polygons are separate ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n            }\n            op2 = op;\n            //ie get ready for the next iteration\n          }\n          op2 = op2.Next;\n        }\n        op = op.Next;\n      }\n      while (op != outrec.Pts)\n    }\n  };\n  ClipperLib.Clipper.Area = function (poly)\n  {\n    var cnt = poly.length;\n    if (cnt < 3)\n      return 0;\n    var a = 0;\n    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n    {\n      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n      j = i;\n    }\n    return -a * 0.5;\n  };\n  ClipperLib.Clipper.prototype.Area = function (outRec)\n  {\n    var op = outRec.Pts;\n    if (op == null)\n      return 0;\n    var a = 0;\n    do {\n      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n      op = op.Next;\n    }\n    while (op != outRec.Pts)\n    return a * 0.5;\n  };\n  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n  {\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n  {\n    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n  {\n    var dx = (pt1.X - pt2.X);\n    var dy = (pt1.Y - pt2.Y);\n    return (dx * dx + dy * dy);\n  };\n  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n  {\n    //The equation of a line in general form (Ax + By + C = 0)\n    //given 2 points (x,y) & (x,y) is ...\n    //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0\n    //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y\n    //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)\n    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n    var A = ln1.Y - ln2.Y;\n    var B = ln2.X - ln1.X;\n    var C = A * ln1.X + B * ln1.Y;\n    C = A * pt.X + B * pt.Y - C;\n    return (C * C) / (A * A + B * B);\n  };\n\n\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t{\n\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t//between the other 2 points is the one that's tested for distance.\n\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t{\n\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t\telse\n\t\t{\n\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t}\n\n  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n  {\n    var dx = pt1.X - pt2.X;\n    var dy = pt1.Y - pt2.Y;\n    return ((dx * dx) + (dy * dy) <= distSqrd);\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.Clipper.ExcludeOp = function (op)\n  {\n    var result = op.Prev;\n    result.Next = op.Next;\n    op.Next.Prev = result;\n    result.Idx = 0;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n  {\n    if (typeof (distance) == \"undefined\") distance = 1.415;\n    //distance = proximity in units/pixels below which vertices will be stripped.\n    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n    //both x & y coords within 1 unit, then the second vertex will be stripped.\n    var cnt = path.length;\n    if (cnt == 0)\n      return new Array();\n    var outPts = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n      outPts[i] = new ClipperLib.OutPt();\n    for (var i = 0; i < cnt; ++i)\n    {\n      outPts[i].Pt = path[i];\n      outPts[i].Next = outPts[(i + 1) % cnt];\n      outPts[i].Next.Prev = outPts[i];\n      outPts[i].Idx = 0;\n    }\n    var distSqrd = distance * distance;\n    var op = outPts[0];\n    while (op.Idx == 0 && op.Next != op.Prev)\n    {\n      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n      {\n        ClipperLib.Clipper.ExcludeOp(op.Next);\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt -= 2;\n      }\n      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else\n      {\n        op.Idx = 1;\n        op = op.Next;\n      }\n    }\n    if (cnt < 3)\n      cnt = 0;\n    var result = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n    {\n      result[i] = new ClipperLib.IntPoint(op.Pt);\n      op = op.Next;\n    }\n    outPts = null;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n  {\n    var result = new Array(polys.length);\n    for (var i = 0, ilen = polys.length; i < ilen; i++)\n      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n    return result;\n  };\n  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n  {\n    var delta = (IsClosed ? 1 : 0);\n    var polyCnt = pattern.length;\n    var pathCnt = path.length;\n    var result = new Array();\n    if (IsSum)\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n        result.push(p);\n      }\n    else\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n        result.push(p);\n      }\n    var quads = new Array();\n    for (var i = 0; i < pathCnt - 1 + delta; i++)\n      for (var j = 0; j < polyCnt; j++)\n      {\n        var quad = new Array();\n        quad.push(result[i % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n        if (!ClipperLib.Clipper.Orientation(quad))\n          quad.reverse();\n        quads.push(quad);\n      }\n\t\t\treturn quads;\n  };\n\n\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t{\n\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t{\n\t\t\tvar path = path_or_paths;\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\telse\n\t\t{\n \t\t\tvar paths = path_or_paths;\n\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t{\n\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tif (pathIsClosed)\n\t\t\t\t{\n\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn solution;\n\t\t}\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t{\n\t\tvar outPath = new ClipperLib.Path();\n\t\tfor (var i = 0; i < path.length; i++)\n\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\treturn outPath;\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t{\n\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\tvar c = new ClipperLib.Clipper();\n\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\treturn paths;\n\t}\n\n  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n  {\n    var result = new Array();\n    //result.set_Capacity(polytree.get_Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n    return result;\n  };\n  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n  {\n    var match = true;\n    switch (nt)\n    {\n    case ClipperLib.Clipper.NodeType.ntOpen:\n      return;\n    case ClipperLib.Clipper.NodeType.ntClosed:\n      match = !polynode.IsOpen;\n      break;\n    default:\n      break;\n    }\n    if (polynode.m_polygon.length > 0 && match)\n      paths.push(polynode.m_polygon);\n    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n  };\n  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.ChildCount());\n    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n      if (polytree.Childs()[i].IsOpen)\n        result.push(polytree.Childs()[i].m_polygon);\n    return result;\n  };\n  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n    return result;\n  };\n  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n  ClipperLib.Clipper.NodeType = {\n    ntAny: 0,\n    ntOpen: 1,\n    ntClosed: 2\n  };\n  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n  {\n    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n    this.m_destPolys = new ClipperLib.Paths();\n    this.m_srcPoly = new ClipperLib.Path();\n    this.m_destPoly = new ClipperLib.Path();\n    this.m_normals = new Array();\n    this.m_delta = 0;\n    this.m_sinA = 0;\n    this.m_sin = 0;\n    this.m_cos = 0;\n    this.m_miterLim = 0;\n    this.m_StepsPerRad = 0;\n    this.m_lowest = new ClipperLib.IntPoint();\n    this.m_polyNodes = new ClipperLib.PolyNode();\n    this.MiterLimit = miterLimit;\n    this.ArcTolerance = arcTolerance;\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n  ClipperLib.ClipperOffset.prototype.Clear = function ()\n  {\n    ClipperLib.Clear(this.m_polyNodes.Childs());\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n  {\n    var highI = path.length - 1;\n    if (highI < 0)\n      return;\n    var newNode = new ClipperLib.PolyNode();\n    newNode.m_jointype = joinType;\n    newNode.m_endtype = endType;\n    //strip duplicate points from path and also get index to the lowest point ...\n    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n        highI--;\n    //newNode.m_polygon.set_Capacity(highI + 1);\n    newNode.m_polygon.push(path[0]);\n    var j = 0,\n      k = 0;\n    for (var i = 1; i <= highI; i++)\n      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n      {\n        j++;\n        newNode.m_polygon.push(path[i]);\n        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n          k = j;\n      }\n    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\n    this.m_polyNodes.AddChild(newNode);\n    //if this path's lowest pt is lower than all the others then update m_lowest\n    if (endType != ClipperLib.EndType.etClosedPolygon)\n      return;\n    if (this.m_lowest.X < 0)\n      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    else\n    {\n      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n  {\n    for (var i = 0, ilen = paths.length; i < ilen; i++)\n      this.AddPath(paths[i], joinType, endType);\n  };\n  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n  {\n    //fixup orientations of all closed paths if the orientation of the\n    //closed path with the lowermost vertex is wrong ...\n    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n          node.m_polygon.reverse();\n      }\n    }\n    else\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n          node.m_polygon.reverse();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n  {\n    var dx = (pt2.X - pt1.X);\n    var dy = (pt2.Y - pt1.Y);\n    if ((dx == 0) && (dy == 0))\n      return new ClipperLib.DoublePoint(0, 0);\n    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n    dx *= f;\n    dy *= f;\n    return new ClipperLib.DoublePoint(dy, -dx);\n  };\n  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n  {\n    this.m_destPolys = new Array();\n    this.m_delta = delta;\n    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n    if (ClipperLib.ClipperBase.near_zero(delta))\n    {\n      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n          this.m_destPolys.push(node.m_polygon);\n      }\n      return;\n    }\n    //see offset_triginometry3.svg in the documentation folder ...\n    if (this.MiterLimit > 2)\n      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n    else\n      this.m_miterLim = 0.5;\n    var y;\n    if (this.ArcTolerance <= 0)\n      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n    else\n      y = this.ArcTolerance;\n    //see offset_triginometry2.svg in the documentation folder ...\n    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n    if (delta < 0)\n      this.m_sin = -this.m_sin;\n    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      this.m_srcPoly = node.m_polygon;\n      var len = this.m_srcPoly.length;\n      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n        continue;\n      this.m_destPoly = new Array();\n      if (len == 1)\n      {\n        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n        {\n          var X = 1,\n            Y = 0;\n          for (var j = 1; j <= steps; j++)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            var X2 = X;\n            X = X * this.m_cos - this.m_sin * Y;\n            Y = X2 * this.m_sin + Y * this.m_cos;\n          }\n        }\n        else\n        {\n          var X = -1,\n            Y = -1;\n          for (var j = 0; j < 4; ++j)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            if (X < 0)\n              X = 1;\n            else if (Y < 0)\n              Y = 1;\n            else\n              X = -1;\n          }\n        }\n        this.m_destPolys.push(this.m_destPoly);\n        continue;\n      }\n      //build m_normals ...\n      this.m_normals.length = 0;\n      //this.m_normals.set_Capacity(len);\n      for (var j = 0; j < len - 1; j++)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n      else\n        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n        this.m_destPoly = new Array();\n        //re-build m_normals ...\n        var n = this.m_normals[len - 1];\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n        k = 0;\n        for (var j = len - 1; j >= 0; j--)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else\n      {\n        var k = 0;\n        for (var j = 1; j < len - 1; ++j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        var pt1;\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          var j = len - 1;\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          var j = len - 1;\n          k = len - 2;\n          this.m_sinA = 0;\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(j, k);\n          else\n            this.DoRound(j, k);\n        }\n        //re-build m_normals ...\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n        k = len - 1;\n        for (var j = k - 1; j > 0; --j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          k = 1;\n          this.m_sinA = 0;\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(0, 1);\n          else\n            this.DoRound(0, 1);\n        }\n        this.m_destPolys.push(this.m_destPoly);\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.Execute = function ()\n  {\n    var a = arguments,\n      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n    if (!ispolytree) // function (solution, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      ClipperLib.Clear(solution);\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        if (solution.length > 0)\n          solution.splice(0, 1);\n      }\n      //console.log(JSON.stringify(solution));\n    }\n    else // function (polytree, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      solution.Clear();\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        //remove the outer PolyNode rectangle ...\n        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n        {\n          var outerNode = solution.Childs()[0];\n          //solution.Childs.set_Capacity(outerNode.ChildCount);\n          solution.Childs()[0] = outerNode.Childs()[0];\n          solution.Childs()[0].m_Parent = solution;\n          for (var i = 1; i < outerNode.ChildCount(); i++)\n            solution.AddChild(outerNode.Childs()[i]);\n        }\n        else\n          solution.Clear();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n  {\n\t\t//cross product ...\n\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\n\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t{\n\t\t\t//dot product ...\n\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t{\n\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\treturn k;\n\t\t\t}\n\t\t\t//else angle ==> 180 degrees\n\t\t}\n    else if (this.m_sinA > 1)\n      this.m_sinA = 1.0;\n    else if (this.m_sinA < -1)\n      this.m_sinA = -1.0;\n    if (this.m_sinA * this.m_delta < 0)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n    }\n    else\n      switch (jointype)\n      {\n      case ClipperLib.JoinType.jtMiter:\n        {\n          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n          if (r >= this.m_miterLim)\n            this.DoMiter(j, k, r);\n          else\n            this.DoSquare(j, k);\n          break;\n        }\n      case ClipperLib.JoinType.jtSquare:\n        this.DoSquare(j, k);\n        break;\n      case ClipperLib.JoinType.jtRound:\n        this.DoRound(j, k);\n        break;\n      }\n    k = j;\n    return k;\n  };\n  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n  {\n    var dx = Math.tan(Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n  };\n  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n  {\n    var q = this.m_delta / r;\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n  };\n  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n  {\n    var a = Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\n    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\n    var X = this.m_normals[k].X,\n      Y = this.m_normals[k].Y,\n      X2;\n    for (var i = 0; i < steps; ++i)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n      X2 = X;\n      X = X * this.m_cos - this.m_sin * Y;\n      Y = X2 * this.m_sin + Y * this.m_cos;\n    }\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n  };\n  ClipperLib.Error = function (message)\n  {\n    try\n    {\n      throw new Error(message);\n    }\n    catch (err)\n    {\n      alert(err.message);\n    }\n  };\n  // ---------------------------------\n  // JS extension by Timo 2013\n  ClipperLib.JS = {};\n  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n  };\n  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    var area = 0;\n    for (var i = 0; i < poly.length; i++)\n    {\n      area += ClipperLib.Clipper.Area(poly[i]);\n    }\n    return area / (scale * scale);\n  };\n  ClipperLib.JS.BoundsOfPath = function (path, scale)\n  {\n    return ClipperLib.JS.BoundsOfPaths([path], scale);\n  };\n  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n  {\n    if (!scale) scale = 1;\n    var bounds = ClipperLib.Clipper.GetBounds(paths);\n    bounds.left /= scale;\n    bounds.bottom /= scale;\n    bounds.right /= scale;\n    bounds.top /= scale;\n    return bounds;\n  };\n  // Clean() joins vertices that are too near each other\n  // and causes distortion to offsetted polygons without cleaning\n  ClipperLib.JS.Clean = function (polygon, delta)\n  {\n    if (!(polygon instanceof Array)) return [];\n    var isPolygons = polygon[0] instanceof Array;\n    var polygon = ClipperLib.JS.Clone(polygon);\n    if (typeof delta != \"number\" || delta === null)\n    {\n      ClipperLib.Error(\"Delta is not a number in Clean().\");\n      return polygon;\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n    if (!isPolygons) polygon = [polygon];\n    var k_length = polygon.length;\n    var len, poly, result, d, p, j, i;\n    var results = [];\n    for (var k = 0; k < k_length; k++)\n    {\n      poly = polygon[k];\n      len = poly.length;\n      if (len === 0) continue;\n      else if (len < 3)\n      {\n        result = poly;\n        results.push(result);\n        continue;\n      }\n      result = poly;\n      d = delta * delta;\n      //d = Math.floor(c_delta * c_delta);\n      p = poly[0];\n      j = 1;\n      for (i = 1; i < len; i++)\n      {\n        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n          continue;\n        result[j] = poly[i];\n        p = poly[i];\n        j++;\n      }\n      p = poly[j - 1];\n      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n        j--;\n      if (j < len)\n        result.splice(j, len - j);\n      if (result.length) results.push(result);\n    }\n    if (!isPolygons && results.length) results = results[0];\n    else if (!isPolygons && results.length === 0) results = [];\n    else if (isPolygons && results.length === 0) results = [\n      []\n    ];\n    return results;\n  }\n  // Make deep copy of Polygons or Polygon\n  // so that also IntPoint objects are cloned and not only referenced\n  // This should be the fastest way\n  ClipperLib.JS.Clone = function (polygon)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (polygon.length === 0) return [];\n    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n    var isPolygons = polygon[0] instanceof Array;\n    if (!isPolygons) polygon = [polygon];\n    var len = polygon.length,\n      plen, i, j, result;\n    var results = new Array(len);\n    for (i = 0; i < len; i++)\n    {\n      plen = polygon[i].length;\n      result = new Array(plen);\n      for (j = 0; j < plen; j++)\n      {\n        result[j] = {\n          X: polygon[i][j].X,\n          Y: polygon[i][j].Y\n        };\n      }\n      results[i] = result;\n    }\n    if (!isPolygons) results = results[0];\n    return results;\n  };\n  // Removes points that doesn't affect much to the visual appearance.\n  // If middle point is at or under certain distance (tolerance) of the line segment between\n  // start and end point, the middle point is removed.\n  ClipperLib.JS.Lighten = function (polygon, tolerance)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (typeof tolerance != \"number\" || tolerance === null)\n    {\n      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n    {\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n    var bxax, byay, l, ax, ay;\n    var len = polygon.length;\n    var toleranceSq = tolerance * tolerance;\n    var results = [];\n    for (i = 0; i < len; i++)\n    {\n      poly = polygon[i];\n      plen = poly.length;\n      if (plen == 0) continue;\n      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n      {\n        poly2 = [];\n        plen = poly.length;\n        // the first have to added to the end, if first and last are not the same\n        // this way we ensure that also the actual last point can be removed if needed\n        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n        {\n          addlast = 1;\n          poly.push(\n          {\n            X: poly[0].X,\n            Y: poly[0].Y\n          });\n          plen = poly.length;\n        }\n        else addlast = 0;\n        rem = []; // Indexes of removed points\n        for (j = 0; j < plen - 2; j++)\n        {\n          A = poly[j]; // Start point of line segment\n          P = poly[j + 1]; // Middle point. This is the one to be removed.\n          B = poly[j + 2]; // End point of line segment\n          ax = A.X;\n          ay = A.Y;\n          bxax = B.X - ax;\n          byay = B.Y - ay;\n          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n          {\n            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n            if (l > 1)\n            {\n              ax = B.X;\n              ay = B.Y;\n            }\n            else if (l > 0)\n            {\n              ax += bxax * l;\n              ay += byay * l;\n            }\n          }\n          bxax = P.X - ax;\n          byay = P.Y - ay;\n          d = bxax * bxax + byay * byay;\n          if (d <= toleranceSq)\n          {\n            rem[j + 1] = 1;\n            j++; // when removed, transfer the pointer to the next one\n          }\n        }\n        // add all unremoved points to poly2\n        poly2.push(\n        {\n          X: poly[0].X,\n          Y: poly[0].Y\n        });\n        for (j = 1; j < plen - 1; j++)\n          if (!rem[j]) poly2.push(\n          {\n            X: poly[j].X,\n            Y: poly[j].Y\n          });\n        poly2.push(\n        {\n          X: poly[plen - 1].X,\n          Y: poly[plen - 1].Y\n        });\n        // if the first point was added to the end, remove it\n        if (addlast) poly.pop();\n        // break, if there was not anymore removed points\n        if (!rem.length) break;\n        // else continue looping using poly2, to check if there are points to remove\n        else poly = poly2;\n      }\n      plen = poly2.length;\n      // remove duplicate from end, if needed\n      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n      {\n        poly2.pop();\n      }\n      if (poly2.length > 2) // to avoid two-point-polygons\n        results.push(poly2);\n    }\n    if (!(polygon[0] instanceof Array)) results = results[0];\n    if (typeof (results) == \"undefined\") results = [\n      []\n    ];\n    return results;\n  }\n  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n  {\n    if (typeof (path) == \"undefined\") return 0;\n    var sqrt = Math.sqrt;\n    var perimeter = 0.0;\n    var p1, p2, p1x = 0.0,\n      p1y = 0.0,\n      p2x = 0.0,\n      p2y = 0.0;\n    var j = path.length;\n    if (j < 2) return 0;\n    if (closed)\n    {\n      path[j] = path[0];\n      j++;\n    }\n    while (--j)\n    {\n      p1 = path[j];\n      p1x = p1.X;\n      p1y = p1.Y;\n      p2 = path[j - 1];\n      p2x = p2.X;\n      p2y = p2.Y;\n      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n    }\n    if (closed) path.pop();\n    return perimeter / scale;\n  };\n  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n  {\n    if (!scale) scale = 1;\n    var perimeter = 0;\n    for (var i = 0; i < paths.length; i++)\n    {\n      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n    }\n    return perimeter;\n  };\n  ClipperLib.JS.ScaleDownPath = function (path, scale)\n  {\n    var i, p;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = p.X / scale;\n      p.Y = p.Y / scale;\n    }\n  };\n  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n  {\n    var i, j, p;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = p.X / scale;\n        p.Y = p.Y / scale;\n      }\n    }\n  };\n  ClipperLib.JS.ScaleUpPath = function (path, scale)\n  {\n    var i, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = round(p.X * scale);\n      p.Y = round(p.Y * scale);\n    }\n  };\n  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n  {\n    var i, j, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = round(p.X * scale);\n        p.Y = round(p.Y * scale);\n      }\n    }\n  };\n  ClipperLib.ExPolygons = function ()\n  {\n    return [];\n  }\n  ClipperLib.ExPolygon = function ()\n  {\n    this.outer = null;\n    this.holes = null;\n  };\n  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n  {\n    var ep = new ClipperLib.ExPolygon();\n    ep.outer = polynode.Contour();\n    var childs = polynode.Childs();\n    var ilen = childs.length;\n    ep.holes = new Array(ilen);\n    var node, n, i, j, childs2, jlen;\n    for (i = 0; i < ilen; i++)\n    {\n      node = childs[i];\n      ep.holes[i] = node.Contour();\n      //Add outer polygons contained by (nested within) holes ...\n      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n      {\n        n = childs2[j];\n        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n      }\n    }\n    expolygons.push(ep);\n  };\n  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n  {\n    var a, i, alen, ilen;\n    var paths = new ClipperLib.Paths();\n    for (a = 0, alen = expolygons.length; a < alen; a++)\n    {\n      paths.push(expolygons[a].outer);\n      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n      {\n        paths.push(expolygons[a].holes[i]);\n      }\n    }\n    return paths;\n  }\n  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n  {\n    var expolygons = new ClipperLib.ExPolygons();\n    var node, i, childs, ilen;\n    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n    {\n      node = childs[i];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n    }\n    return expolygons;\n  };\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/clipper-lib/clipper.js\n// module id = 3\n// module chunks = 0","import * as glMatrix from \"./common.js\";\r\n\r\n/**\r\n * 3x3 Matrix\r\n * @module mat3\r\n */\r\n\r\n/**\r\n * Creates a new identity mat3\r\n *\r\n * @returns {mat3} a new 3x3 matrix\r\n */\r\nexport function create() {\r\n  var out = new glMatrix.ARRAY_TYPE(9);\r\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n    out[3] = 0;\r\n    out[5] = 0;\r\n    out[6] = 0;\r\n    out[7] = 0;\r\n  }\r\n  out[0] = 1;\r\n  out[4] = 1;\r\n  out[8] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copies the upper-left 3x3 values into the given mat3.\r\n *\r\n * @param {mat3} out the receiving 3x3 matrix\r\n * @param {mat4} a   the source 4x4 matrix\r\n * @returns {mat3} out\r\n */\r\nexport function fromMat4(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[4];\r\n  out[4] = a[5];\r\n  out[5] = a[6];\r\n  out[6] = a[8];\r\n  out[7] = a[9];\r\n  out[8] = a[10];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new mat3 initialized with values from an existing matrix\r\n *\r\n * @param {mat3} a matrix to clone\r\n * @returns {mat3} a new 3x3 matrix\r\n */\r\nexport function clone(a) {\r\n  var out = new glMatrix.ARRAY_TYPE(9);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  out[6] = a[6];\r\n  out[7] = a[7];\r\n  out[8] = a[8];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one mat3 to another\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\r\nexport function copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  out[6] = a[6];\r\n  out[7] = a[7];\r\n  out[8] = a[8];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Create a new mat3 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\r\n * @returns {mat3} A new mat3\r\n */\r\nexport function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\r\n  var out = new glMatrix.ARRAY_TYPE(9);\r\n  out[0] = m00;\r\n  out[1] = m01;\r\n  out[2] = m02;\r\n  out[3] = m10;\r\n  out[4] = m11;\r\n  out[5] = m12;\r\n  out[6] = m20;\r\n  out[7] = m21;\r\n  out[8] = m22;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a mat3 to the given values\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\r\n * @returns {mat3} out\r\n */\r\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\r\n  out[0] = m00;\r\n  out[1] = m01;\r\n  out[2] = m02;\r\n  out[3] = m10;\r\n  out[4] = m11;\r\n  out[5] = m12;\r\n  out[6] = m20;\r\n  out[7] = m21;\r\n  out[8] = m22;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set a mat3 to the identity matrix\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @returns {mat3} out\r\n */\r\nexport function identity(out) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 1;\r\n  out[5] = 0;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transpose the values of a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\r\nexport function transpose(out, a) {\r\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\r\n  if (out === a) {\r\n    var a01 = a[1],\r\n        a02 = a[2],\r\n        a12 = a[5];\r\n    out[1] = a[3];\r\n    out[2] = a[6];\r\n    out[3] = a01;\r\n    out[5] = a[7];\r\n    out[6] = a02;\r\n    out[7] = a12;\r\n  } else {\r\n    out[0] = a[0];\r\n    out[1] = a[3];\r\n    out[2] = a[6];\r\n    out[3] = a[1];\r\n    out[4] = a[4];\r\n    out[5] = a[7];\r\n    out[6] = a[2];\r\n    out[7] = a[5];\r\n    out[8] = a[8];\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Inverts a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\r\nexport function invert(out, a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2];\r\n  var a10 = a[3],\r\n      a11 = a[4],\r\n      a12 = a[5];\r\n  var a20 = a[6],\r\n      a21 = a[7],\r\n      a22 = a[8];\r\n\r\n  var b01 = a22 * a11 - a12 * a21;\r\n  var b11 = -a22 * a10 + a12 * a20;\r\n  var b21 = a21 * a10 - a11 * a20;\r\n\r\n  // Calculate the determinant\r\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\r\n\r\n  if (!det) {\r\n    return null;\r\n  }\r\n  det = 1.0 / det;\r\n\r\n  out[0] = b01 * det;\r\n  out[1] = (-a22 * a01 + a02 * a21) * det;\r\n  out[2] = (a12 * a01 - a02 * a11) * det;\r\n  out[3] = b11 * det;\r\n  out[4] = (a22 * a00 - a02 * a20) * det;\r\n  out[5] = (-a12 * a00 + a02 * a10) * det;\r\n  out[6] = b21 * det;\r\n  out[7] = (-a21 * a00 + a01 * a20) * det;\r\n  out[8] = (a11 * a00 - a01 * a10) * det;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the adjugate of a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\r\nexport function adjoint(out, a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2];\r\n  var a10 = a[3],\r\n      a11 = a[4],\r\n      a12 = a[5];\r\n  var a20 = a[6],\r\n      a21 = a[7],\r\n      a22 = a[8];\r\n\r\n  out[0] = a11 * a22 - a12 * a21;\r\n  out[1] = a02 * a21 - a01 * a22;\r\n  out[2] = a01 * a12 - a02 * a11;\r\n  out[3] = a12 * a20 - a10 * a22;\r\n  out[4] = a00 * a22 - a02 * a20;\r\n  out[5] = a02 * a10 - a00 * a12;\r\n  out[6] = a10 * a21 - a11 * a20;\r\n  out[7] = a01 * a20 - a00 * a21;\r\n  out[8] = a00 * a11 - a01 * a10;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the determinant of a mat3\r\n *\r\n * @param {mat3} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\r\nexport function determinant(a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2];\r\n  var a10 = a[3],\r\n      a11 = a[4],\r\n      a12 = a[5];\r\n  var a20 = a[6],\r\n      a21 = a[7],\r\n      a22 = a[8];\r\n\r\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\r\n}\r\n\r\n/**\r\n * Multiplies two mat3's\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @returns {mat3} out\r\n */\r\nexport function multiply(out, a, b) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2];\r\n  var a10 = a[3],\r\n      a11 = a[4],\r\n      a12 = a[5];\r\n  var a20 = a[6],\r\n      a21 = a[7],\r\n      a22 = a[8];\r\n\r\n  var b00 = b[0],\r\n      b01 = b[1],\r\n      b02 = b[2];\r\n  var b10 = b[3],\r\n      b11 = b[4],\r\n      b12 = b[5];\r\n  var b20 = b[6],\r\n      b21 = b[7],\r\n      b22 = b[8];\r\n\r\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\r\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\r\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\r\n\r\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\r\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\r\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\r\n\r\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\r\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\r\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Translate a mat3 by the given vector\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to translate\r\n * @param {vec2} v vector to translate by\r\n * @returns {mat3} out\r\n */\r\nexport function translate(out, a, v) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a10 = a[3],\r\n      a11 = a[4],\r\n      a12 = a[5],\r\n      a20 = a[6],\r\n      a21 = a[7],\r\n      a22 = a[8],\r\n      x = v[0],\r\n      y = v[1];\r\n\r\n  out[0] = a00;\r\n  out[1] = a01;\r\n  out[2] = a02;\r\n\r\n  out[3] = a10;\r\n  out[4] = a11;\r\n  out[5] = a12;\r\n\r\n  out[6] = x * a00 + y * a10 + a20;\r\n  out[7] = x * a01 + y * a11 + a21;\r\n  out[8] = x * a02 + y * a12 + a22;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a mat3 by the given angle\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat3} out\r\n */\r\nexport function rotate(out, a, rad) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a10 = a[3],\r\n      a11 = a[4],\r\n      a12 = a[5],\r\n      a20 = a[6],\r\n      a21 = a[7],\r\n      a22 = a[8],\r\n      s = Math.sin(rad),\r\n      c = Math.cos(rad);\r\n\r\n  out[0] = c * a00 + s * a10;\r\n  out[1] = c * a01 + s * a11;\r\n  out[2] = c * a02 + s * a12;\r\n\r\n  out[3] = c * a10 - s * a00;\r\n  out[4] = c * a11 - s * a01;\r\n  out[5] = c * a12 - s * a02;\r\n\r\n  out[6] = a20;\r\n  out[7] = a21;\r\n  out[8] = a22;\r\n  return out;\r\n};\r\n\r\n/**\r\n * Scales the mat3 by the dimensions in the given vec2\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to rotate\r\n * @param {vec2} v the vec2 to scale the matrix by\r\n * @returns {mat3} out\r\n **/\r\nexport function scale(out, a, v) {\r\n  var x = v[0],\r\n      y = v[1];\r\n\r\n  out[0] = x * a[0];\r\n  out[1] = x * a[1];\r\n  out[2] = x * a[2];\r\n\r\n  out[3] = y * a[3];\r\n  out[4] = y * a[4];\r\n  out[5] = y * a[5];\r\n\r\n  out[6] = a[6];\r\n  out[7] = a[7];\r\n  out[8] = a[8];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.translate(dest, dest, vec);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {vec2} v Translation vector\r\n * @returns {mat3} out\r\n */\r\nexport function fromTranslation(out, v) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 1;\r\n  out[5] = 0;\r\n  out[6] = v[0];\r\n  out[7] = v[1];\r\n  out[8] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.rotate(dest, dest, rad);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat3} out\r\n */\r\nexport function fromRotation(out, rad) {\r\n  var s = Math.sin(rad),\r\n      c = Math.cos(rad);\r\n\r\n  out[0] = c;\r\n  out[1] = s;\r\n  out[2] = 0;\r\n\r\n  out[3] = -s;\r\n  out[4] = c;\r\n  out[5] = 0;\r\n\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.scale(dest, dest, vec);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {vec2} v Scaling vector\r\n * @returns {mat3} out\r\n */\r\nexport function fromScaling(out, v) {\r\n  out[0] = v[0];\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n\r\n  out[3] = 0;\r\n  out[4] = v[1];\r\n  out[5] = 0;\r\n\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copies the values from a mat2d into a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat2d} a the matrix to copy\r\n * @returns {mat3} out\r\n **/\r\nexport function fromMat2d(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = 0;\r\n\r\n  out[3] = a[2];\r\n  out[4] = a[3];\r\n  out[5] = 0;\r\n\r\n  out[6] = a[4];\r\n  out[7] = a[5];\r\n  out[8] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n* Calculates a 3x3 matrix from the given quaternion\r\n*\r\n* @param {mat3} out mat3 receiving operation result\r\n* @param {quat} q Quaternion to create matrix from\r\n*\r\n* @returns {mat3} out\r\n*/\r\nexport function fromQuat(out, q) {\r\n  var x = q[0],\r\n      y = q[1],\r\n      z = q[2],\r\n      w = q[3];\r\n  var x2 = x + x;\r\n  var y2 = y + y;\r\n  var z2 = z + z;\r\n\r\n  var xx = x * x2;\r\n  var yx = y * x2;\r\n  var yy = y * y2;\r\n  var zx = z * x2;\r\n  var zy = z * y2;\r\n  var zz = z * z2;\r\n  var wx = w * x2;\r\n  var wy = w * y2;\r\n  var wz = w * z2;\r\n\r\n  out[0] = 1 - yy - zz;\r\n  out[3] = yx - wz;\r\n  out[6] = zx + wy;\r\n\r\n  out[1] = yx + wz;\r\n  out[4] = 1 - xx - zz;\r\n  out[7] = zy - wx;\r\n\r\n  out[2] = zx - wy;\r\n  out[5] = zy + wx;\r\n  out[8] = 1 - xx - yy;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\r\n*\r\n* @param {mat3} out mat3 receiving operation result\r\n* @param {mat4} a Mat4 to derive the normal matrix from\r\n*\r\n* @returns {mat3} out\r\n*/\r\nexport function normalFromMat4(out, a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a03 = a[3];\r\n  var a10 = a[4],\r\n      a11 = a[5],\r\n      a12 = a[6],\r\n      a13 = a[7];\r\n  var a20 = a[8],\r\n      a21 = a[9],\r\n      a22 = a[10],\r\n      a23 = a[11];\r\n  var a30 = a[12],\r\n      a31 = a[13],\r\n      a32 = a[14],\r\n      a33 = a[15];\r\n\r\n  var b00 = a00 * a11 - a01 * a10;\r\n  var b01 = a00 * a12 - a02 * a10;\r\n  var b02 = a00 * a13 - a03 * a10;\r\n  var b03 = a01 * a12 - a02 * a11;\r\n  var b04 = a01 * a13 - a03 * a11;\r\n  var b05 = a02 * a13 - a03 * a12;\r\n  var b06 = a20 * a31 - a21 * a30;\r\n  var b07 = a20 * a32 - a22 * a30;\r\n  var b08 = a20 * a33 - a23 * a30;\r\n  var b09 = a21 * a32 - a22 * a31;\r\n  var b10 = a21 * a33 - a23 * a31;\r\n  var b11 = a22 * a33 - a23 * a32;\r\n\r\n  // Calculate the determinant\r\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\r\n  if (!det) {\r\n    return null;\r\n  }\r\n  det = 1.0 / det;\r\n\r\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\r\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\r\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\r\n\r\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\r\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\r\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\r\n\r\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\r\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\r\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a 2D projection matrix with the given bounds\r\n *\r\n * @param {mat3} out mat3 frustum matrix will be written into\r\n * @param {number} width Width of your gl context\r\n * @param {number} height Height of gl context\r\n * @returns {mat3} out\r\n */\r\nexport function projection(out, width, height) {\r\n  out[0] = 2 / width;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = -2 / height;\r\n  out[5] = 0;\r\n  out[6] = -1;\r\n  out[7] = 1;\r\n  out[8] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a string representation of a mat3\r\n *\r\n * @param {mat3} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\r\nexport function str(a) {\r\n  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';\r\n}\r\n\r\n/**\r\n * Returns Frobenius norm of a mat3\r\n *\r\n * @param {mat3} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\r\nexport function frob(a) {\r\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));\r\n}\r\n\r\n/**\r\n * Adds two mat3's\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @returns {mat3} out\r\n */\r\nexport function add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  out[3] = a[3] + b[3];\r\n  out[4] = a[4] + b[4];\r\n  out[5] = a[5] + b[5];\r\n  out[6] = a[6] + b[6];\r\n  out[7] = a[7] + b[7];\r\n  out[8] = a[8] + b[8];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @returns {mat3} out\r\n */\r\nexport function subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  out[2] = a[2] - b[2];\r\n  out[3] = a[3] - b[3];\r\n  out[4] = a[4] - b[4];\r\n  out[5] = a[5] - b[5];\r\n  out[6] = a[6] - b[6];\r\n  out[7] = a[7] - b[7];\r\n  out[8] = a[8] - b[8];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat3} out\r\n */\r\nexport function multiplyScalar(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  out[3] = a[3] * b;\r\n  out[4] = a[4] * b;\r\n  out[5] = a[5] * b;\r\n  out[6] = a[6] * b;\r\n  out[7] = a[7] * b;\r\n  out[8] = a[8] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat3} out the receiving vector\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat3} out\r\n */\r\nexport function multiplyScalarAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  out[2] = a[2] + b[2] * scale;\r\n  out[3] = a[3] + b[3] * scale;\r\n  out[4] = a[4] + b[4] * scale;\r\n  out[5] = a[5] + b[5] * scale;\r\n  out[6] = a[6] + b[6] * scale;\r\n  out[7] = a[7] + b[7] * scale;\r\n  out[8] = a[8] + b[8] * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat3} a The first matrix.\r\n * @param {mat3} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nexport function exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat3} a The first matrix.\r\n * @param {mat3} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nexport function equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3],\r\n      a4 = a[4],\r\n      a5 = a[5],\r\n      a6 = a[6],\r\n      a7 = a[7],\r\n      a8 = a[8];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3],\r\n      b4 = b[4],\r\n      b5 = b[5],\r\n      b6 = b[6],\r\n      b7 = b[7],\r\n      b8 = b[8];\r\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\r\n}\r\n\r\n/**\r\n * Alias for {@link mat3.multiply}\r\n * @function\r\n */\r\nexport var mul = multiply;\r\n\r\n/**\r\n * Alias for {@link mat3.subtract}\r\n * @function\r\n */\r\nexport var sub = subtract;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/gl-matrix/lib/gl-matrix/mat3.js\n// module id = 4\n// module chunks = 0","import * as glMatrix from \"./common.js\";\r\n\r\n/**\r\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\r\n * @module mat4\r\n */\r\n\r\n/**\r\n * Creates a new identity mat4\r\n *\r\n * @returns {mat4} a new 4x4 matrix\r\n */\r\nexport function create() {\r\n  var out = new glMatrix.ARRAY_TYPE(16);\r\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n    out[3] = 0;\r\n    out[4] = 0;\r\n    out[6] = 0;\r\n    out[7] = 0;\r\n    out[8] = 0;\r\n    out[9] = 0;\r\n    out[11] = 0;\r\n    out[12] = 0;\r\n    out[13] = 0;\r\n    out[14] = 0;\r\n  }\r\n  out[0] = 1;\r\n  out[5] = 1;\r\n  out[10] = 1;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new mat4 initialized with values from an existing matrix\r\n *\r\n * @param {mat4} a matrix to clone\r\n * @returns {mat4} a new 4x4 matrix\r\n */\r\nexport function clone(a) {\r\n  var out = new glMatrix.ARRAY_TYPE(16);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  out[6] = a[6];\r\n  out[7] = a[7];\r\n  out[8] = a[8];\r\n  out[9] = a[9];\r\n  out[10] = a[10];\r\n  out[11] = a[11];\r\n  out[12] = a[12];\r\n  out[13] = a[13];\r\n  out[14] = a[14];\r\n  out[15] = a[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one mat4 to another\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\r\nexport function copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  out[6] = a[6];\r\n  out[7] = a[7];\r\n  out[8] = a[8];\r\n  out[9] = a[9];\r\n  out[10] = a[10];\r\n  out[11] = a[11];\r\n  out[12] = a[12];\r\n  out[13] = a[13];\r\n  out[14] = a[14];\r\n  out[15] = a[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Create a new mat4 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} A new mat4\r\n */\r\nexport function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\r\n  var out = new glMatrix.ARRAY_TYPE(16);\r\n  out[0] = m00;\r\n  out[1] = m01;\r\n  out[2] = m02;\r\n  out[3] = m03;\r\n  out[4] = m10;\r\n  out[5] = m11;\r\n  out[6] = m12;\r\n  out[7] = m13;\r\n  out[8] = m20;\r\n  out[9] = m21;\r\n  out[10] = m22;\r\n  out[11] = m23;\r\n  out[12] = m30;\r\n  out[13] = m31;\r\n  out[14] = m32;\r\n  out[15] = m33;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a mat4 to the given values\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} out\r\n */\r\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\r\n  out[0] = m00;\r\n  out[1] = m01;\r\n  out[2] = m02;\r\n  out[3] = m03;\r\n  out[4] = m10;\r\n  out[5] = m11;\r\n  out[6] = m12;\r\n  out[7] = m13;\r\n  out[8] = m20;\r\n  out[9] = m21;\r\n  out[10] = m22;\r\n  out[11] = m23;\r\n  out[12] = m30;\r\n  out[13] = m31;\r\n  out[14] = m32;\r\n  out[15] = m33;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set a mat4 to the identity matrix\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @returns {mat4} out\r\n */\r\nexport function identity(out) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = 1;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = 1;\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transpose the values of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\r\nexport function transpose(out, a) {\r\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\r\n  if (out === a) {\r\n    var a01 = a[1],\r\n        a02 = a[2],\r\n        a03 = a[3];\r\n    var a12 = a[6],\r\n        a13 = a[7];\r\n    var a23 = a[11];\r\n\r\n    out[1] = a[4];\r\n    out[2] = a[8];\r\n    out[3] = a[12];\r\n    out[4] = a01;\r\n    out[6] = a[9];\r\n    out[7] = a[13];\r\n    out[8] = a02;\r\n    out[9] = a12;\r\n    out[11] = a[14];\r\n    out[12] = a03;\r\n    out[13] = a13;\r\n    out[14] = a23;\r\n  } else {\r\n    out[0] = a[0];\r\n    out[1] = a[4];\r\n    out[2] = a[8];\r\n    out[3] = a[12];\r\n    out[4] = a[1];\r\n    out[5] = a[5];\r\n    out[6] = a[9];\r\n    out[7] = a[13];\r\n    out[8] = a[2];\r\n    out[9] = a[6];\r\n    out[10] = a[10];\r\n    out[11] = a[14];\r\n    out[12] = a[3];\r\n    out[13] = a[7];\r\n    out[14] = a[11];\r\n    out[15] = a[15];\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Inverts a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\r\nexport function invert(out, a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a03 = a[3];\r\n  var a10 = a[4],\r\n      a11 = a[5],\r\n      a12 = a[6],\r\n      a13 = a[7];\r\n  var a20 = a[8],\r\n      a21 = a[9],\r\n      a22 = a[10],\r\n      a23 = a[11];\r\n  var a30 = a[12],\r\n      a31 = a[13],\r\n      a32 = a[14],\r\n      a33 = a[15];\r\n\r\n  var b00 = a00 * a11 - a01 * a10;\r\n  var b01 = a00 * a12 - a02 * a10;\r\n  var b02 = a00 * a13 - a03 * a10;\r\n  var b03 = a01 * a12 - a02 * a11;\r\n  var b04 = a01 * a13 - a03 * a11;\r\n  var b05 = a02 * a13 - a03 * a12;\r\n  var b06 = a20 * a31 - a21 * a30;\r\n  var b07 = a20 * a32 - a22 * a30;\r\n  var b08 = a20 * a33 - a23 * a30;\r\n  var b09 = a21 * a32 - a22 * a31;\r\n  var b10 = a21 * a33 - a23 * a31;\r\n  var b11 = a22 * a33 - a23 * a32;\r\n\r\n  // Calculate the determinant\r\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\r\n  if (!det) {\r\n    return null;\r\n  }\r\n  det = 1.0 / det;\r\n\r\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\r\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\r\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\r\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\r\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\r\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\r\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\r\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\r\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\r\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\r\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\r\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\r\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\r\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\r\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\r\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the adjugate of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\r\nexport function adjoint(out, a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a03 = a[3];\r\n  var a10 = a[4],\r\n      a11 = a[5],\r\n      a12 = a[6],\r\n      a13 = a[7];\r\n  var a20 = a[8],\r\n      a21 = a[9],\r\n      a22 = a[10],\r\n      a23 = a[11];\r\n  var a30 = a[12],\r\n      a31 = a[13],\r\n      a32 = a[14],\r\n      a33 = a[15];\r\n\r\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\r\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\r\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\r\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\r\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\r\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\r\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\r\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\r\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\r\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\r\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\r\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\r\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\r\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\r\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\r\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the determinant of a mat4\r\n *\r\n * @param {mat4} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\r\nexport function determinant(a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a03 = a[3];\r\n  var a10 = a[4],\r\n      a11 = a[5],\r\n      a12 = a[6],\r\n      a13 = a[7];\r\n  var a20 = a[8],\r\n      a21 = a[9],\r\n      a22 = a[10],\r\n      a23 = a[11];\r\n  var a30 = a[12],\r\n      a31 = a[13],\r\n      a32 = a[14],\r\n      a33 = a[15];\r\n\r\n  var b00 = a00 * a11 - a01 * a10;\r\n  var b01 = a00 * a12 - a02 * a10;\r\n  var b02 = a00 * a13 - a03 * a10;\r\n  var b03 = a01 * a12 - a02 * a11;\r\n  var b04 = a01 * a13 - a03 * a11;\r\n  var b05 = a02 * a13 - a03 * a12;\r\n  var b06 = a20 * a31 - a21 * a30;\r\n  var b07 = a20 * a32 - a22 * a30;\r\n  var b08 = a20 * a33 - a23 * a30;\r\n  var b09 = a21 * a32 - a22 * a31;\r\n  var b10 = a21 * a33 - a23 * a31;\r\n  var b11 = a22 * a33 - a23 * a32;\r\n\r\n  // Calculate the determinant\r\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n}\r\n\r\n/**\r\n * Multiplies two mat4s\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @returns {mat4} out\r\n */\r\nexport function multiply(out, a, b) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a03 = a[3];\r\n  var a10 = a[4],\r\n      a11 = a[5],\r\n      a12 = a[6],\r\n      a13 = a[7];\r\n  var a20 = a[8],\r\n      a21 = a[9],\r\n      a22 = a[10],\r\n      a23 = a[11];\r\n  var a30 = a[12],\r\n      a31 = a[13],\r\n      a32 = a[14],\r\n      a33 = a[15];\r\n\r\n  // Cache only the current line of the second matrix\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3];\r\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n  b0 = b[4];b1 = b[5];b2 = b[6];b3 = b[7];\r\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n  b0 = b[8];b1 = b[9];b2 = b[10];b3 = b[11];\r\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n  b0 = b[12];b1 = b[13];b2 = b[14];b3 = b[15];\r\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Translate a mat4 by the given vector\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to translate\r\n * @param {vec3} v vector to translate by\r\n * @returns {mat4} out\r\n */\r\nexport function translate(out, a, v) {\r\n  var x = v[0],\r\n      y = v[1],\r\n      z = v[2];\r\n  var a00 = void 0,\r\n      a01 = void 0,\r\n      a02 = void 0,\r\n      a03 = void 0;\r\n  var a10 = void 0,\r\n      a11 = void 0,\r\n      a12 = void 0,\r\n      a13 = void 0;\r\n  var a20 = void 0,\r\n      a21 = void 0,\r\n      a22 = void 0,\r\n      a23 = void 0;\r\n\r\n  if (a === out) {\r\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\r\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\r\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\r\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\r\n  } else {\r\n    a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];\r\n    a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];\r\n    a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];\r\n\r\n    out[0] = a00;out[1] = a01;out[2] = a02;out[3] = a03;\r\n    out[4] = a10;out[5] = a11;out[6] = a12;out[7] = a13;\r\n    out[8] = a20;out[9] = a21;out[10] = a22;out[11] = a23;\r\n\r\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\r\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\r\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\r\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to scale\r\n * @param {vec3} v the vec3 to scale the matrix by\r\n * @returns {mat4} out\r\n **/\r\nexport function scale(out, a, v) {\r\n  var x = v[0],\r\n      y = v[1],\r\n      z = v[2];\r\n\r\n  out[0] = a[0] * x;\r\n  out[1] = a[1] * x;\r\n  out[2] = a[2] * x;\r\n  out[3] = a[3] * x;\r\n  out[4] = a[4] * y;\r\n  out[5] = a[5] * y;\r\n  out[6] = a[6] * y;\r\n  out[7] = a[7] * y;\r\n  out[8] = a[8] * z;\r\n  out[9] = a[9] * z;\r\n  out[10] = a[10] * z;\r\n  out[11] = a[11] * z;\r\n  out[12] = a[12];\r\n  out[13] = a[13];\r\n  out[14] = a[14];\r\n  out[15] = a[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a mat4 by the given angle around the given axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {vec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\r\nexport function rotate(out, a, rad, axis) {\r\n  var x = axis[0],\r\n      y = axis[1],\r\n      z = axis[2];\r\n  var len = Math.sqrt(x * x + y * y + z * z);\r\n  var s = void 0,\r\n      c = void 0,\r\n      t = void 0;\r\n  var a00 = void 0,\r\n      a01 = void 0,\r\n      a02 = void 0,\r\n      a03 = void 0;\r\n  var a10 = void 0,\r\n      a11 = void 0,\r\n      a12 = void 0,\r\n      a13 = void 0;\r\n  var a20 = void 0,\r\n      a21 = void 0,\r\n      a22 = void 0,\r\n      a23 = void 0;\r\n  var b00 = void 0,\r\n      b01 = void 0,\r\n      b02 = void 0;\r\n  var b10 = void 0,\r\n      b11 = void 0,\r\n      b12 = void 0;\r\n  var b20 = void 0,\r\n      b21 = void 0,\r\n      b22 = void 0;\r\n\r\n  if (len < glMatrix.EPSILON) {\r\n    return null;\r\n  }\r\n\r\n  len = 1 / len;\r\n  x *= len;\r\n  y *= len;\r\n  z *= len;\r\n\r\n  s = Math.sin(rad);\r\n  c = Math.cos(rad);\r\n  t = 1 - c;\r\n\r\n  a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];\r\n  a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];\r\n  a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];\r\n\r\n  // Construct the elements of the rotation matrix\r\n  b00 = x * x * t + c;b01 = y * x * t + z * s;b02 = z * x * t - y * s;\r\n  b10 = x * y * t - z * s;b11 = y * y * t + c;b12 = z * y * t + x * s;\r\n  b20 = x * z * t + y * s;b21 = y * z * t - x * s;b22 = z * z * t + c;\r\n\r\n  // Perform rotation-specific matrix multiplication\r\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\r\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\r\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\r\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\r\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\r\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\r\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\r\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\r\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\r\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\r\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\r\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\r\n\r\n  if (a !== out) {\r\n    // If the source and destination differ, copy the unchanged last row\r\n    out[12] = a[12];\r\n    out[13] = a[13];\r\n    out[14] = a[14];\r\n    out[15] = a[15];\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a matrix by the given angle around the X axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nexport function rotateX(out, a, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  var a10 = a[4];\r\n  var a11 = a[5];\r\n  var a12 = a[6];\r\n  var a13 = a[7];\r\n  var a20 = a[8];\r\n  var a21 = a[9];\r\n  var a22 = a[10];\r\n  var a23 = a[11];\r\n\r\n  if (a !== out) {\r\n    // If the source and destination differ, copy the unchanged rows\r\n    out[0] = a[0];\r\n    out[1] = a[1];\r\n    out[2] = a[2];\r\n    out[3] = a[3];\r\n    out[12] = a[12];\r\n    out[13] = a[13];\r\n    out[14] = a[14];\r\n    out[15] = a[15];\r\n  }\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[4] = a10 * c + a20 * s;\r\n  out[5] = a11 * c + a21 * s;\r\n  out[6] = a12 * c + a22 * s;\r\n  out[7] = a13 * c + a23 * s;\r\n  out[8] = a20 * c - a10 * s;\r\n  out[9] = a21 * c - a11 * s;\r\n  out[10] = a22 * c - a12 * s;\r\n  out[11] = a23 * c - a13 * s;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a matrix by the given angle around the Y axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nexport function rotateY(out, a, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  var a00 = a[0];\r\n  var a01 = a[1];\r\n  var a02 = a[2];\r\n  var a03 = a[3];\r\n  var a20 = a[8];\r\n  var a21 = a[9];\r\n  var a22 = a[10];\r\n  var a23 = a[11];\r\n\r\n  if (a !== out) {\r\n    // If the source and destination differ, copy the unchanged rows\r\n    out[4] = a[4];\r\n    out[5] = a[5];\r\n    out[6] = a[6];\r\n    out[7] = a[7];\r\n    out[12] = a[12];\r\n    out[13] = a[13];\r\n    out[14] = a[14];\r\n    out[15] = a[15];\r\n  }\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[0] = a00 * c - a20 * s;\r\n  out[1] = a01 * c - a21 * s;\r\n  out[2] = a02 * c - a22 * s;\r\n  out[3] = a03 * c - a23 * s;\r\n  out[8] = a00 * s + a20 * c;\r\n  out[9] = a01 * s + a21 * c;\r\n  out[10] = a02 * s + a22 * c;\r\n  out[11] = a03 * s + a23 * c;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a matrix by the given angle around the Z axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nexport function rotateZ(out, a, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  var a00 = a[0];\r\n  var a01 = a[1];\r\n  var a02 = a[2];\r\n  var a03 = a[3];\r\n  var a10 = a[4];\r\n  var a11 = a[5];\r\n  var a12 = a[6];\r\n  var a13 = a[7];\r\n\r\n  if (a !== out) {\r\n    // If the source and destination differ, copy the unchanged last row\r\n    out[8] = a[8];\r\n    out[9] = a[9];\r\n    out[10] = a[10];\r\n    out[11] = a[11];\r\n    out[12] = a[12];\r\n    out[13] = a[13];\r\n    out[14] = a[14];\r\n    out[15] = a[15];\r\n  }\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[0] = a00 * c + a10 * s;\r\n  out[1] = a01 * c + a11 * s;\r\n  out[2] = a02 * c + a12 * s;\r\n  out[3] = a03 * c + a13 * s;\r\n  out[4] = a10 * c - a00 * s;\r\n  out[5] = a11 * c - a01 * s;\r\n  out[6] = a12 * c - a02 * s;\r\n  out[7] = a13 * c - a03 * s;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {vec3} v Translation vector\r\n * @returns {mat4} out\r\n */\r\nexport function fromTranslation(out, v) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = 1;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = 1;\r\n  out[11] = 0;\r\n  out[12] = v[0];\r\n  out[13] = v[1];\r\n  out[14] = v[2];\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.scale(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {vec3} v Scaling vector\r\n * @returns {mat4} out\r\n */\r\nexport function fromScaling(out, v) {\r\n  out[0] = v[0];\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = v[1];\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = v[2];\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a given angle around a given axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotate(dest, dest, rad, axis);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {vec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\r\nexport function fromRotation(out, rad, axis) {\r\n  var x = axis[0],\r\n      y = axis[1],\r\n      z = axis[2];\r\n  var len = Math.sqrt(x * x + y * y + z * z);\r\n  var s = void 0,\r\n      c = void 0,\r\n      t = void 0;\r\n\r\n  if (len < glMatrix.EPSILON) {\r\n    return null;\r\n  }\r\n\r\n  len = 1 / len;\r\n  x *= len;\r\n  y *= len;\r\n  z *= len;\r\n\r\n  s = Math.sin(rad);\r\n  c = Math.cos(rad);\r\n  t = 1 - c;\r\n\r\n  // Perform rotation-specific matrix multiplication\r\n  out[0] = x * x * t + c;\r\n  out[1] = y * x * t + z * s;\r\n  out[2] = z * x * t - y * s;\r\n  out[3] = 0;\r\n  out[4] = x * y * t - z * s;\r\n  out[5] = y * y * t + c;\r\n  out[6] = z * y * t + x * s;\r\n  out[7] = 0;\r\n  out[8] = x * z * t + y * s;\r\n  out[9] = y * z * t - x * s;\r\n  out[10] = z * z * t + c;\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from the given angle around the X axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateX(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nexport function fromXRotation(out, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = c;\r\n  out[6] = s;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = -s;\r\n  out[10] = c;\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from the given angle around the Y axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateY(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nexport function fromYRotation(out, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[0] = c;\r\n  out[1] = 0;\r\n  out[2] = -s;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = 1;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = s;\r\n  out[9] = 0;\r\n  out[10] = c;\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from the given angle around the Z axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateZ(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nexport function fromZRotation(out, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[0] = c;\r\n  out[1] = s;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = -s;\r\n  out[5] = c;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = 1;\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a quaternion rotation and vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {vec3} v Translation vector\r\n * @returns {mat4} out\r\n */\r\nexport function fromRotationTranslation(out, q, v) {\r\n  // Quaternion math\r\n  var x = q[0],\r\n      y = q[1],\r\n      z = q[2],\r\n      w = q[3];\r\n  var x2 = x + x;\r\n  var y2 = y + y;\r\n  var z2 = z + z;\r\n\r\n  var xx = x * x2;\r\n  var xy = x * y2;\r\n  var xz = x * z2;\r\n  var yy = y * y2;\r\n  var yz = y * z2;\r\n  var zz = z * z2;\r\n  var wx = w * x2;\r\n  var wy = w * y2;\r\n  var wz = w * z2;\r\n\r\n  out[0] = 1 - (yy + zz);\r\n  out[1] = xy + wz;\r\n  out[2] = xz - wy;\r\n  out[3] = 0;\r\n  out[4] = xy - wz;\r\n  out[5] = 1 - (xx + zz);\r\n  out[6] = yz + wx;\r\n  out[7] = 0;\r\n  out[8] = xz + wy;\r\n  out[9] = yz - wx;\r\n  out[10] = 1 - (xx + yy);\r\n  out[11] = 0;\r\n  out[12] = v[0];\r\n  out[13] = v[1];\r\n  out[14] = v[2];\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new mat4 from a dual quat.\r\n *\r\n * @param {mat4} out Matrix\r\n * @param {quat2} a Dual Quaternion\r\n * @returns {mat4} mat4 receiving operation result\r\n */\r\nexport function fromQuat2(out, a) {\r\n  var translation = new glMatrix.ARRAY_TYPE(3);\r\n  var bx = -a[0],\r\n      by = -a[1],\r\n      bz = -a[2],\r\n      bw = a[3],\r\n      ax = a[4],\r\n      ay = a[5],\r\n      az = a[6],\r\n      aw = a[7];\r\n\r\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw;\r\n  //Only scale if it makes sense\r\n  if (magnitude > 0) {\r\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\r\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\r\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\r\n  } else {\r\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\r\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\r\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\r\n  }\r\n  fromRotationTranslation(out, a, translation);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the translation vector component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslation,\r\n *  the returned vector will be the same as the translation vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive translation component\r\n * @param  {mat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\r\nexport function getTranslation(out, mat) {\r\n  out[0] = mat[12];\r\n  out[1] = mat[13];\r\n  out[2] = mat[14];\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the scaling factor component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslationScale\r\n *  with a normalized Quaternion paramter, the returned vector will be\r\n *  the same as the scaling vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive scaling factor component\r\n * @param  {mat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\r\nexport function getScaling(out, mat) {\r\n  var m11 = mat[0];\r\n  var m12 = mat[1];\r\n  var m13 = mat[2];\r\n  var m21 = mat[4];\r\n  var m22 = mat[5];\r\n  var m23 = mat[6];\r\n  var m31 = mat[8];\r\n  var m32 = mat[9];\r\n  var m33 = mat[10];\r\n\r\n  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);\r\n  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);\r\n  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a quaternion representing the rotational component\r\n *  of a transformation matrix. If a matrix is built with\r\n *  fromRotationTranslation, the returned quaternion will be the\r\n *  same as the quaternion originally supplied.\r\n * @param {quat} out Quaternion to receive the rotation component\r\n * @param {mat4} mat Matrix to be decomposed (input)\r\n * @return {quat} out\r\n */\r\nexport function getRotation(out, mat) {\r\n  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n  var trace = mat[0] + mat[5] + mat[10];\r\n  var S = 0;\r\n\r\n  if (trace > 0) {\r\n    S = Math.sqrt(trace + 1.0) * 2;\r\n    out[3] = 0.25 * S;\r\n    out[0] = (mat[6] - mat[9]) / S;\r\n    out[1] = (mat[8] - mat[2]) / S;\r\n    out[2] = (mat[1] - mat[4]) / S;\r\n  } else if (mat[0] > mat[5] && mat[0] > mat[10]) {\r\n    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;\r\n    out[3] = (mat[6] - mat[9]) / S;\r\n    out[0] = 0.25 * S;\r\n    out[1] = (mat[1] + mat[4]) / S;\r\n    out[2] = (mat[8] + mat[2]) / S;\r\n  } else if (mat[5] > mat[10]) {\r\n    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;\r\n    out[3] = (mat[8] - mat[2]) / S;\r\n    out[0] = (mat[1] + mat[4]) / S;\r\n    out[1] = 0.25 * S;\r\n    out[2] = (mat[6] + mat[9]) / S;\r\n  } else {\r\n    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;\r\n    out[3] = (mat[1] - mat[4]) / S;\r\n    out[0] = (mat[8] + mat[2]) / S;\r\n    out[1] = (mat[6] + mat[9]) / S;\r\n    out[2] = 0.25 * S;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {vec3} v Translation vector\r\n * @param {vec3} s Scaling vector\r\n * @returns {mat4} out\r\n */\r\nexport function fromRotationTranslationScale(out, q, v, s) {\r\n  // Quaternion math\r\n  var x = q[0],\r\n      y = q[1],\r\n      z = q[2],\r\n      w = q[3];\r\n  var x2 = x + x;\r\n  var y2 = y + y;\r\n  var z2 = z + z;\r\n\r\n  var xx = x * x2;\r\n  var xy = x * y2;\r\n  var xz = x * z2;\r\n  var yy = y * y2;\r\n  var yz = y * z2;\r\n  var zz = z * z2;\r\n  var wx = w * x2;\r\n  var wy = w * y2;\r\n  var wz = w * z2;\r\n  var sx = s[0];\r\n  var sy = s[1];\r\n  var sz = s[2];\r\n\r\n  out[0] = (1 - (yy + zz)) * sx;\r\n  out[1] = (xy + wz) * sx;\r\n  out[2] = (xz - wy) * sx;\r\n  out[3] = 0;\r\n  out[4] = (xy - wz) * sy;\r\n  out[5] = (1 - (xx + zz)) * sy;\r\n  out[6] = (yz + wx) * sy;\r\n  out[7] = 0;\r\n  out[8] = (xz + wy) * sz;\r\n  out[9] = (yz - wx) * sz;\r\n  out[10] = (1 - (xx + yy)) * sz;\r\n  out[11] = 0;\r\n  out[12] = v[0];\r\n  out[13] = v[1];\r\n  out[14] = v[2];\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     mat4.translate(dest, origin);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *     mat4.translate(dest, negativeOrigin);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {vec3} v Translation vector\r\n * @param {vec3} s Scaling vector\r\n * @param {vec3} o The origin vector around which to scale and rotate\r\n * @returns {mat4} out\r\n */\r\nexport function fromRotationTranslationScaleOrigin(out, q, v, s, o) {\r\n  // Quaternion math\r\n  var x = q[0],\r\n      y = q[1],\r\n      z = q[2],\r\n      w = q[3];\r\n  var x2 = x + x;\r\n  var y2 = y + y;\r\n  var z2 = z + z;\r\n\r\n  var xx = x * x2;\r\n  var xy = x * y2;\r\n  var xz = x * z2;\r\n  var yy = y * y2;\r\n  var yz = y * z2;\r\n  var zz = z * z2;\r\n  var wx = w * x2;\r\n  var wy = w * y2;\r\n  var wz = w * z2;\r\n\r\n  var sx = s[0];\r\n  var sy = s[1];\r\n  var sz = s[2];\r\n\r\n  var ox = o[0];\r\n  var oy = o[1];\r\n  var oz = o[2];\r\n\r\n  var out0 = (1 - (yy + zz)) * sx;\r\n  var out1 = (xy + wz) * sx;\r\n  var out2 = (xz - wy) * sx;\r\n  var out4 = (xy - wz) * sy;\r\n  var out5 = (1 - (xx + zz)) * sy;\r\n  var out6 = (yz + wx) * sy;\r\n  var out8 = (xz + wy) * sz;\r\n  var out9 = (yz - wx) * sz;\r\n  var out10 = (1 - (xx + yy)) * sz;\r\n\r\n  out[0] = out0;\r\n  out[1] = out1;\r\n  out[2] = out2;\r\n  out[3] = 0;\r\n  out[4] = out4;\r\n  out[5] = out5;\r\n  out[6] = out6;\r\n  out[7] = 0;\r\n  out[8] = out8;\r\n  out[9] = out9;\r\n  out[10] = out10;\r\n  out[11] = 0;\r\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\r\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\r\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates a 4x4 matrix from the given quaternion\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat} q Quaternion to create matrix from\r\n *\r\n * @returns {mat4} out\r\n */\r\nexport function fromQuat(out, q) {\r\n  var x = q[0],\r\n      y = q[1],\r\n      z = q[2],\r\n      w = q[3];\r\n  var x2 = x + x;\r\n  var y2 = y + y;\r\n  var z2 = z + z;\r\n\r\n  var xx = x * x2;\r\n  var yx = y * x2;\r\n  var yy = y * y2;\r\n  var zx = z * x2;\r\n  var zy = z * y2;\r\n  var zz = z * z2;\r\n  var wx = w * x2;\r\n  var wy = w * y2;\r\n  var wz = w * z2;\r\n\r\n  out[0] = 1 - yy - zz;\r\n  out[1] = yx + wz;\r\n  out[2] = zx - wy;\r\n  out[3] = 0;\r\n\r\n  out[4] = yx - wz;\r\n  out[5] = 1 - xx - zz;\r\n  out[6] = zy + wx;\r\n  out[7] = 0;\r\n\r\n  out[8] = zx + wy;\r\n  out[9] = zy - wx;\r\n  out[10] = 1 - xx - yy;\r\n  out[11] = 0;\r\n\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a frustum matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Number} left Left bound of the frustum\r\n * @param {Number} right Right bound of the frustum\r\n * @param {Number} bottom Bottom bound of the frustum\r\n * @param {Number} top Top bound of the frustum\r\n * @param {Number} near Near bound of the frustum\r\n * @param {Number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\r\nexport function frustum(out, left, right, bottom, top, near, far) {\r\n  var rl = 1 / (right - left);\r\n  var tb = 1 / (top - bottom);\r\n  var nf = 1 / (near - far);\r\n  out[0] = near * 2 * rl;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = near * 2 * tb;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = (right + left) * rl;\r\n  out[9] = (top + bottom) * tb;\r\n  out[10] = (far + near) * nf;\r\n  out[11] = -1;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = far * near * 2 * nf;\r\n  out[15] = 0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a perspective projection matrix with the given bounds.\r\n * Passing null/undefined/no value for far will generate infinite projection matrix.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} fovy Vertical field of view in radians\r\n * @param {number} aspect Aspect ratio. typically viewport width/height\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum, can be null or Infinity\r\n * @returns {mat4} out\r\n */\r\nexport function perspective(out, fovy, aspect, near, far) {\r\n  var f = 1.0 / Math.tan(fovy / 2),\r\n      nf = void 0;\r\n  out[0] = f / aspect;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = f;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[11] = -1;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[15] = 0;\r\n  if (far != null && far !== Infinity) {\r\n    nf = 1 / (near - far);\r\n    out[10] = (far + near) * nf;\r\n    out[14] = 2 * far * near * nf;\r\n  } else {\r\n    out[10] = -1;\r\n    out[14] = -2 * near;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a perspective projection matrix with the given field of view.\r\n * This is primarily useful for generating projection matrices to be used\r\n * with the still experiemental WebVR API.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\r\nexport function perspectiveFromFieldOfView(out, fov, near, far) {\r\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\r\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\r\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\r\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\r\n  var xScale = 2.0 / (leftTan + rightTan);\r\n  var yScale = 2.0 / (upTan + downTan);\r\n\r\n  out[0] = xScale;\r\n  out[1] = 0.0;\r\n  out[2] = 0.0;\r\n  out[3] = 0.0;\r\n  out[4] = 0.0;\r\n  out[5] = yScale;\r\n  out[6] = 0.0;\r\n  out[7] = 0.0;\r\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\r\n  out[9] = (upTan - downTan) * yScale * 0.5;\r\n  out[10] = far / (near - far);\r\n  out[11] = -1.0;\r\n  out[12] = 0.0;\r\n  out[13] = 0.0;\r\n  out[14] = far * near / (near - far);\r\n  out[15] = 0.0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a orthogonal projection matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} left Left bound of the frustum\r\n * @param {number} right Right bound of the frustum\r\n * @param {number} bottom Bottom bound of the frustum\r\n * @param {number} top Top bound of the frustum\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\r\nexport function ortho(out, left, right, bottom, top, near, far) {\r\n  var lr = 1 / (left - right);\r\n  var bt = 1 / (bottom - top);\r\n  var nf = 1 / (near - far);\r\n  out[0] = -2 * lr;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = -2 * bt;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = 2 * nf;\r\n  out[11] = 0;\r\n  out[12] = (left + right) * lr;\r\n  out[13] = (top + bottom) * bt;\r\n  out[14] = (far + near) * nf;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\r\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {vec3} eye Position of the viewer\r\n * @param {vec3} center Point the viewer is looking at\r\n * @param {vec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\r\nexport function lookAt(out, eye, center, up) {\r\n  var x0 = void 0,\r\n      x1 = void 0,\r\n      x2 = void 0,\r\n      y0 = void 0,\r\n      y1 = void 0,\r\n      y2 = void 0,\r\n      z0 = void 0,\r\n      z1 = void 0,\r\n      z2 = void 0,\r\n      len = void 0;\r\n  var eyex = eye[0];\r\n  var eyey = eye[1];\r\n  var eyez = eye[2];\r\n  var upx = up[0];\r\n  var upy = up[1];\r\n  var upz = up[2];\r\n  var centerx = center[0];\r\n  var centery = center[1];\r\n  var centerz = center[2];\r\n\r\n  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {\r\n    return identity(out);\r\n  }\r\n\r\n  z0 = eyex - centerx;\r\n  z1 = eyey - centery;\r\n  z2 = eyez - centerz;\r\n\r\n  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\r\n  z0 *= len;\r\n  z1 *= len;\r\n  z2 *= len;\r\n\r\n  x0 = upy * z2 - upz * z1;\r\n  x1 = upz * z0 - upx * z2;\r\n  x2 = upx * z1 - upy * z0;\r\n  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\r\n  if (!len) {\r\n    x0 = 0;\r\n    x1 = 0;\r\n    x2 = 0;\r\n  } else {\r\n    len = 1 / len;\r\n    x0 *= len;\r\n    x1 *= len;\r\n    x2 *= len;\r\n  }\r\n\r\n  y0 = z1 * x2 - z2 * x1;\r\n  y1 = z2 * x0 - z0 * x2;\r\n  y2 = z0 * x1 - z1 * x0;\r\n\r\n  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\r\n  if (!len) {\r\n    y0 = 0;\r\n    y1 = 0;\r\n    y2 = 0;\r\n  } else {\r\n    len = 1 / len;\r\n    y0 *= len;\r\n    y1 *= len;\r\n    y2 *= len;\r\n  }\r\n\r\n  out[0] = x0;\r\n  out[1] = y0;\r\n  out[2] = z0;\r\n  out[3] = 0;\r\n  out[4] = x1;\r\n  out[5] = y1;\r\n  out[6] = z1;\r\n  out[7] = 0;\r\n  out[8] = x2;\r\n  out[9] = y2;\r\n  out[10] = z2;\r\n  out[11] = 0;\r\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\r\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\r\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a matrix that makes something look at something else.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {vec3} eye Position of the viewer\r\n * @param {vec3} center Point the viewer is looking at\r\n * @param {vec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\r\nexport function targetTo(out, eye, target, up) {\r\n  var eyex = eye[0],\r\n      eyey = eye[1],\r\n      eyez = eye[2],\r\n      upx = up[0],\r\n      upy = up[1],\r\n      upz = up[2];\r\n\r\n  var z0 = eyex - target[0],\r\n      z1 = eyey - target[1],\r\n      z2 = eyez - target[2];\r\n\r\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\r\n  if (len > 0) {\r\n    len = 1 / Math.sqrt(len);\r\n    z0 *= len;\r\n    z1 *= len;\r\n    z2 *= len;\r\n  }\r\n\r\n  var x0 = upy * z2 - upz * z1,\r\n      x1 = upz * z0 - upx * z2,\r\n      x2 = upx * z1 - upy * z0;\r\n\r\n  len = x0 * x0 + x1 * x1 + x2 * x2;\r\n  if (len > 0) {\r\n    len = 1 / Math.sqrt(len);\r\n    x0 *= len;\r\n    x1 *= len;\r\n    x2 *= len;\r\n  }\r\n\r\n  out[0] = x0;\r\n  out[1] = x1;\r\n  out[2] = x2;\r\n  out[3] = 0;\r\n  out[4] = z1 * x2 - z2 * x1;\r\n  out[5] = z2 * x0 - z0 * x2;\r\n  out[6] = z0 * x1 - z1 * x0;\r\n  out[7] = 0;\r\n  out[8] = z0;\r\n  out[9] = z1;\r\n  out[10] = z2;\r\n  out[11] = 0;\r\n  out[12] = eyex;\r\n  out[13] = eyey;\r\n  out[14] = eyez;\r\n  out[15] = 1;\r\n  return out;\r\n};\r\n\r\n/**\r\n * Returns a string representation of a mat4\r\n *\r\n * @param {mat4} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\r\nexport function str(a) {\r\n  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';\r\n}\r\n\r\n/**\r\n * Returns Frobenius norm of a mat4\r\n *\r\n * @param {mat4} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\r\nexport function frob(a) {\r\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));\r\n}\r\n\r\n/**\r\n * Adds two mat4's\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @returns {mat4} out\r\n */\r\nexport function add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  out[3] = a[3] + b[3];\r\n  out[4] = a[4] + b[4];\r\n  out[5] = a[5] + b[5];\r\n  out[6] = a[6] + b[6];\r\n  out[7] = a[7] + b[7];\r\n  out[8] = a[8] + b[8];\r\n  out[9] = a[9] + b[9];\r\n  out[10] = a[10] + b[10];\r\n  out[11] = a[11] + b[11];\r\n  out[12] = a[12] + b[12];\r\n  out[13] = a[13] + b[13];\r\n  out[14] = a[14] + b[14];\r\n  out[15] = a[15] + b[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @returns {mat4} out\r\n */\r\nexport function subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  out[2] = a[2] - b[2];\r\n  out[3] = a[3] - b[3];\r\n  out[4] = a[4] - b[4];\r\n  out[5] = a[5] - b[5];\r\n  out[6] = a[6] - b[6];\r\n  out[7] = a[7] - b[7];\r\n  out[8] = a[8] - b[8];\r\n  out[9] = a[9] - b[9];\r\n  out[10] = a[10] - b[10];\r\n  out[11] = a[11] - b[11];\r\n  out[12] = a[12] - b[12];\r\n  out[13] = a[13] - b[13];\r\n  out[14] = a[14] - b[14];\r\n  out[15] = a[15] - b[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat4} out\r\n */\r\nexport function multiplyScalar(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  out[3] = a[3] * b;\r\n  out[4] = a[4] * b;\r\n  out[5] = a[5] * b;\r\n  out[6] = a[6] * b;\r\n  out[7] = a[7] * b;\r\n  out[8] = a[8] * b;\r\n  out[9] = a[9] * b;\r\n  out[10] = a[10] * b;\r\n  out[11] = a[11] * b;\r\n  out[12] = a[12] * b;\r\n  out[13] = a[13] * b;\r\n  out[14] = a[14] * b;\r\n  out[15] = a[15] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat4} out the receiving vector\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat4} out\r\n */\r\nexport function multiplyScalarAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  out[2] = a[2] + b[2] * scale;\r\n  out[3] = a[3] + b[3] * scale;\r\n  out[4] = a[4] + b[4] * scale;\r\n  out[5] = a[5] + b[5] * scale;\r\n  out[6] = a[6] + b[6] * scale;\r\n  out[7] = a[7] + b[7] * scale;\r\n  out[8] = a[8] + b[8] * scale;\r\n  out[9] = a[9] + b[9] * scale;\r\n  out[10] = a[10] + b[10] * scale;\r\n  out[11] = a[11] + b[11] * scale;\r\n  out[12] = a[12] + b[12] * scale;\r\n  out[13] = a[13] + b[13] * scale;\r\n  out[14] = a[14] + b[14] * scale;\r\n  out[15] = a[15] + b[15] * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat4} a The first matrix.\r\n * @param {mat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nexport function exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat4} a The first matrix.\r\n * @param {mat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nexport function equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var a4 = a[4],\r\n      a5 = a[5],\r\n      a6 = a[6],\r\n      a7 = a[7];\r\n  var a8 = a[8],\r\n      a9 = a[9],\r\n      a10 = a[10],\r\n      a11 = a[11];\r\n  var a12 = a[12],\r\n      a13 = a[13],\r\n      a14 = a[14],\r\n      a15 = a[15];\r\n\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3];\r\n  var b4 = b[4],\r\n      b5 = b[5],\r\n      b6 = b[6],\r\n      b7 = b[7];\r\n  var b8 = b[8],\r\n      b9 = b[9],\r\n      b10 = b[10],\r\n      b11 = b[11];\r\n  var b12 = b[12],\r\n      b13 = b[13],\r\n      b14 = b[14],\r\n      b15 = b[15];\r\n\r\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\r\n}\r\n\r\n/**\r\n * Alias for {@link mat4.multiply}\r\n * @function\r\n */\r\nexport var mul = multiply;\r\n\r\n/**\r\n * Alias for {@link mat4.subtract}\r\n * @function\r\n */\r\nexport var sub = subtract;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/gl-matrix/lib/gl-matrix/mat4.js\n// module id = 5\n// module chunks = 0","import * as glMatrix from \"./common.js\";\r\nimport * as mat3 from \"./mat3.js\";\r\nimport * as vec3 from \"./vec3.js\";\r\nimport * as vec4 from \"./vec4.js\";\r\n\r\n/**\r\n * Quaternion\r\n * @module quat\r\n */\r\n\r\n/**\r\n * Creates a new identity quat\r\n *\r\n * @returns {quat} a new quaternion\r\n */\r\nexport function create() {\r\n  var out = new glMatrix.ARRAY_TYPE(4);\r\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\r\n    out[0] = 0;\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n  }\r\n  out[3] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set a quat to the identity quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\r\nexport function identity(out) {\r\n  out[0] = 0;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Sets a quat from the given angle and rotation axis,\r\n * then returns it.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {vec3} axis the axis around which to rotate\r\n * @param {Number} rad the angle in radians\r\n * @returns {quat} out\r\n **/\r\nexport function setAxisAngle(out, axis, rad) {\r\n  rad = rad * 0.5;\r\n  var s = Math.sin(rad);\r\n  out[0] = s * axis[0];\r\n  out[1] = s * axis[1];\r\n  out[2] = s * axis[2];\r\n  out[3] = Math.cos(rad);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Gets the rotation axis and angle for a given\r\n *  quaternion. If a quaternion is created with\r\n *  setAxisAngle, this method will return the same\r\n *  values as providied in the original parameter list\r\n *  OR functionally equivalent values.\r\n * Example: The quaternion formed by axis [0, 0, 1] and\r\n *  angle -90 is the same as the quaternion formed by\r\n *  [0, 0, 1] and 270. This method favors the latter.\r\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\r\n * @param  {quat} q     Quaternion to be decomposed\r\n * @return {Number}     Angle, in radians, of the rotation\r\n */\r\nexport function getAxisAngle(out_axis, q) {\r\n  var rad = Math.acos(q[3]) * 2.0;\r\n  var s = Math.sin(rad / 2.0);\r\n  if (s > glMatrix.EPSILON) {\r\n    out_axis[0] = q[0] / s;\r\n    out_axis[1] = q[1] / s;\r\n    out_axis[2] = q[2] / s;\r\n  } else {\r\n    // If s is zero, return any axis (no rotation - axis does not matter)\r\n    out_axis[0] = 1;\r\n    out_axis[1] = 0;\r\n    out_axis[2] = 0;\r\n  }\r\n  return rad;\r\n}\r\n\r\n/**\r\n * Multiplies two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {quat} out\r\n */\r\nexport function multiply(out, a, b) {\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n  var bx = b[0],\r\n      by = b[1],\r\n      bz = b[2],\r\n      bw = b[3];\r\n\r\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\r\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\r\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\r\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a quaternion by the given angle about the X axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\r\nexport function rotateX(out, a, rad) {\r\n  rad *= 0.5;\r\n\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n  var bx = Math.sin(rad),\r\n      bw = Math.cos(rad);\r\n\r\n  out[0] = ax * bw + aw * bx;\r\n  out[1] = ay * bw + az * bx;\r\n  out[2] = az * bw - ay * bx;\r\n  out[3] = aw * bw - ax * bx;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a quaternion by the given angle about the Y axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\r\nexport function rotateY(out, a, rad) {\r\n  rad *= 0.5;\r\n\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n  var by = Math.sin(rad),\r\n      bw = Math.cos(rad);\r\n\r\n  out[0] = ax * bw - az * by;\r\n  out[1] = ay * bw + aw * by;\r\n  out[2] = az * bw + ax * by;\r\n  out[3] = aw * bw - ay * by;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a quaternion by the given angle about the Z axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\r\nexport function rotateZ(out, a, rad) {\r\n  rad *= 0.5;\r\n\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n  var bz = Math.sin(rad),\r\n      bw = Math.cos(rad);\r\n\r\n  out[0] = ax * bw + ay * bz;\r\n  out[1] = ay * bw - ax * bz;\r\n  out[2] = az * bw + aw * bz;\r\n  out[3] = aw * bw - az * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the W component of a quat from the X, Y, and Z components.\r\n * Assumes that quaternion is 1 unit in length.\r\n * Any existing W component will be ignored.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate W component of\r\n * @returns {quat} out\r\n */\r\nexport function calculateW(out, a) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2];\r\n\r\n  out[0] = x;\r\n  out[1] = y;\r\n  out[2] = z;\r\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\r\n  return out;\r\n}\r\n\r\n/**\r\n * Performs a spherical linear interpolation between two quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\r\nexport function slerp(out, a, b, t) {\r\n  // benchmarks:\r\n  //    http://jsperf.com/quaternion-slerp-implementations\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n  var bx = b[0],\r\n      by = b[1],\r\n      bz = b[2],\r\n      bw = b[3];\r\n\r\n  var omega = void 0,\r\n      cosom = void 0,\r\n      sinom = void 0,\r\n      scale0 = void 0,\r\n      scale1 = void 0;\r\n\r\n  // calc cosine\r\n  cosom = ax * bx + ay * by + az * bz + aw * bw;\r\n  // adjust signs (if necessary)\r\n  if (cosom < 0.0) {\r\n    cosom = -cosom;\r\n    bx = -bx;\r\n    by = -by;\r\n    bz = -bz;\r\n    bw = -bw;\r\n  }\r\n  // calculate coefficients\r\n  if (1.0 - cosom > glMatrix.EPSILON) {\r\n    // standard case (slerp)\r\n    omega = Math.acos(cosom);\r\n    sinom = Math.sin(omega);\r\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\r\n    scale1 = Math.sin(t * omega) / sinom;\r\n  } else {\r\n    // \"from\" and \"to\" quaternions are very close\r\n    //  ... so we can do a linear interpolation\r\n    scale0 = 1.0 - t;\r\n    scale1 = t;\r\n  }\r\n  // calculate final values\r\n  out[0] = scale0 * ax + scale1 * bx;\r\n  out[1] = scale0 * ay + scale1 * by;\r\n  out[2] = scale0 * az + scale1 * bz;\r\n  out[3] = scale0 * aw + scale1 * bw;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a random quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\r\nexport function random(out) {\r\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\r\n  // TODO: Calling random 3 times is probably not the fastest solution\r\n  var u1 = glMatrix.RANDOM();\r\n  var u2 = glMatrix.RANDOM();\r\n  var u3 = glMatrix.RANDOM();\r\n\r\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\r\n  var sqrtU1 = Math.sqrt(u1);\r\n\r\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\r\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\r\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\r\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the inverse of a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate inverse of\r\n * @returns {quat} out\r\n */\r\nexport function invert(out, a) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\r\n  var invDot = dot ? 1.0 / dot : 0;\r\n\r\n  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\r\n\r\n  out[0] = -a0 * invDot;\r\n  out[1] = -a1 * invDot;\r\n  out[2] = -a2 * invDot;\r\n  out[3] = a3 * invDot;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the conjugate of a quat\r\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate conjugate of\r\n * @returns {quat} out\r\n */\r\nexport function conjugate(out, a) {\r\n  out[0] = -a[0];\r\n  out[1] = -a[1];\r\n  out[2] = -a[2];\r\n  out[3] = a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a quaternion from the given 3x3 rotation matrix.\r\n *\r\n * NOTE: The resultant quaternion is not normalized, so you should be sure\r\n * to renormalize the quaternion yourself where necessary.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {mat3} m rotation matrix\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport function fromMat3(out, m) {\r\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\r\n  // article \"Quaternion Calculus and Fast Animation\".\r\n  var fTrace = m[0] + m[4] + m[8];\r\n  var fRoot = void 0;\r\n\r\n  if (fTrace > 0.0) {\r\n    // |w| > 1/2, may as well choose w > 1/2\r\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\r\n    out[3] = 0.5 * fRoot;\r\n    fRoot = 0.5 / fRoot; // 1/(4w)\r\n    out[0] = (m[5] - m[7]) * fRoot;\r\n    out[1] = (m[6] - m[2]) * fRoot;\r\n    out[2] = (m[1] - m[3]) * fRoot;\r\n  } else {\r\n    // |w| <= 1/2\r\n    var i = 0;\r\n    if (m[4] > m[0]) i = 1;\r\n    if (m[8] > m[i * 3 + i]) i = 2;\r\n    var j = (i + 1) % 3;\r\n    var k = (i + 2) % 3;\r\n\r\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\r\n    out[i] = 0.5 * fRoot;\r\n    fRoot = 0.5 / fRoot;\r\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\r\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\r\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a quaternion from the given euler angle x, y, z.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {x} Angle to rotate around X axis in degrees.\r\n * @param {y} Angle to rotate around Y axis in degrees.\r\n * @param {z} Angle to rotate around Z axis in degrees.\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport function fromEuler(out, x, y, z) {\r\n  var halfToRad = 0.5 * Math.PI / 180.0;\r\n  x *= halfToRad;\r\n  y *= halfToRad;\r\n  z *= halfToRad;\r\n\r\n  var sx = Math.sin(x);\r\n  var cx = Math.cos(x);\r\n  var sy = Math.sin(y);\r\n  var cy = Math.cos(y);\r\n  var sz = Math.sin(z);\r\n  var cz = Math.cos(z);\r\n\r\n  out[0] = sx * cy * cz - cx * sy * sz;\r\n  out[1] = cx * sy * cz + sx * cy * sz;\r\n  out[2] = cx * cy * sz - sx * sy * cz;\r\n  out[3] = cx * cy * cz + sx * sy * sz;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a string representation of a quatenion\r\n *\r\n * @param {quat} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\r\nexport function str(a) {\r\n  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\r\n}\r\n\r\n/**\r\n * Creates a new quat initialized with values from an existing quaternion\r\n *\r\n * @param {quat} a quaternion to clone\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\r\nexport var clone = vec4.clone;\r\n\r\n/**\r\n * Creates a new quat initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\r\nexport var fromValues = vec4.fromValues;\r\n\r\n/**\r\n * Copy the values from one quat to another\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the source quaternion\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport var copy = vec4.copy;\r\n\r\n/**\r\n * Set the components of a quat to the given values\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport var set = vec4.set;\r\n\r\n/**\r\n * Adds two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport var add = vec4.add;\r\n\r\n/**\r\n * Alias for {@link quat.multiply}\r\n * @function\r\n */\r\nexport var mul = multiply;\r\n\r\n/**\r\n * Scales a quat by a scalar number\r\n *\r\n * @param {quat} out the receiving vector\r\n * @param {quat} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport var scale = vec4.scale;\r\n\r\n/**\r\n * Calculates the dot product of two quat's\r\n *\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {Number} dot product of a and b\r\n * @function\r\n */\r\nexport var dot = vec4.dot;\r\n\r\n/**\r\n * Performs a linear interpolation between two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport var lerp = vec4.lerp;\r\n\r\n/**\r\n * Calculates the length of a quat\r\n *\r\n * @param {quat} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\r\nexport var length = vec4.length;\r\n\r\n/**\r\n * Alias for {@link quat.length}\r\n * @function\r\n */\r\nexport var len = length;\r\n\r\n/**\r\n * Calculates the squared length of a quat\r\n *\r\n * @param {quat} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n * @function\r\n */\r\nexport var squaredLength = vec4.squaredLength;\r\n\r\n/**\r\n * Alias for {@link quat.squaredLength}\r\n * @function\r\n */\r\nexport var sqrLen = squaredLength;\r\n\r\n/**\r\n * Normalize a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quaternion to normalize\r\n * @returns {quat} out\r\n * @function\r\n */\r\nexport var normalize = vec4.normalize;\r\n\r\n/**\r\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {quat} a The first quaternion.\r\n * @param {quat} b The second quaternion.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nexport var exactEquals = vec4.exactEquals;\r\n\r\n/**\r\n * Returns whether or not the quaternions have approximately the same elements in the same position.\r\n *\r\n * @param {quat} a The first vector.\r\n * @param {quat} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nexport var equals = vec4.equals;\r\n\r\n/**\r\n * Sets a quaternion to represent the shortest rotation from one\r\n * vector to another.\r\n *\r\n * Both vectors are assumed to be unit length.\r\n *\r\n * @param {quat} out the receiving quaternion.\r\n * @param {vec3} a the initial vector\r\n * @param {vec3} b the destination vector\r\n * @returns {quat} out\r\n */\r\nexport var rotationTo = function () {\r\n  var tmpvec3 = vec3.create();\r\n  var xUnitVec3 = vec3.fromValues(1, 0, 0);\r\n  var yUnitVec3 = vec3.fromValues(0, 1, 0);\r\n\r\n  return function (out, a, b) {\r\n    var dot = vec3.dot(a, b);\r\n    if (dot < -0.999999) {\r\n      vec3.cross(tmpvec3, xUnitVec3, a);\r\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\r\n      vec3.normalize(tmpvec3, tmpvec3);\r\n      setAxisAngle(out, tmpvec3, Math.PI);\r\n      return out;\r\n    } else if (dot > 0.999999) {\r\n      out[0] = 0;\r\n      out[1] = 0;\r\n      out[2] = 0;\r\n      out[3] = 1;\r\n      return out;\r\n    } else {\r\n      vec3.cross(tmpvec3, a, b);\r\n      out[0] = tmpvec3[0];\r\n      out[1] = tmpvec3[1];\r\n      out[2] = tmpvec3[2];\r\n      out[3] = 1 + dot;\r\n      return normalize(out, out);\r\n    }\r\n  };\r\n}();\r\n\r\n/**\r\n * Performs a spherical linear interpolation with two control points\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {quat} c the third operand\r\n * @param {quat} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\r\nexport var sqlerp = function () {\r\n  var temp1 = create();\r\n  var temp2 = create();\r\n\r\n  return function (out, a, b, c, d, t) {\r\n    slerp(temp1, a, d, t);\r\n    slerp(temp2, b, c, t);\r\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\r\n\r\n    return out;\r\n  };\r\n}();\r\n\r\n/**\r\n * Sets the specified quaternion with values corresponding to the given\r\n * axes. Each axis is a vec3 and is expected to be unit length and\r\n * perpendicular to all other specified axes.\r\n *\r\n * @param {vec3} view  the vector representing the viewing direction\r\n * @param {vec3} right the vector representing the local \"right\" direction\r\n * @param {vec3} up    the vector representing the local \"up\" direction\r\n * @returns {quat} out\r\n */\r\nexport var setAxes = function () {\r\n  var matr = mat3.create();\r\n\r\n  return function (out, view, right, up) {\r\n    matr[0] = right[0];\r\n    matr[3] = right[1];\r\n    matr[6] = right[2];\r\n\r\n    matr[1] = up[0];\r\n    matr[4] = up[1];\r\n    matr[7] = up[2];\r\n\r\n    matr[2] = -view[0];\r\n    matr[5] = -view[1];\r\n    matr[8] = -view[2];\r\n\r\n    return normalize(out, fromMat3(out, matr));\r\n  };\r\n}();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/gl-matrix/lib/gl-matrix/quat.js\n// module id = 6\n// module chunks = 0","import * as glMatrix from \"./common.js\";\r\n\r\n/**\r\n * 3 Dimensional Vector\r\n * @module vec3\r\n */\r\n\r\n/**\r\n * Creates a new, empty vec3\r\n *\r\n * @returns {vec3} a new 3D vector\r\n */\r\nexport function create() {\r\n  var out = new glMatrix.ARRAY_TYPE(3);\r\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\r\n    out[0] = 0;\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new vec3 initialized with values from an existing vector\r\n *\r\n * @param {vec3} a vector to clone\r\n * @returns {vec3} a new 3D vector\r\n */\r\nexport function clone(a) {\r\n  var out = new glMatrix.ARRAY_TYPE(3);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the length of a vec3\r\n *\r\n * @param {vec3} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\r\nexport function length(a) {\r\n  var x = a[0];\r\n  var y = a[1];\r\n  var z = a[2];\r\n  return Math.sqrt(x * x + y * y + z * z);\r\n}\r\n\r\n/**\r\n * Creates a new vec3 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} a new 3D vector\r\n */\r\nexport function fromValues(x, y, z) {\r\n  var out = new glMatrix.ARRAY_TYPE(3);\r\n  out[0] = x;\r\n  out[1] = y;\r\n  out[2] = z;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one vec3 to another\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the source vector\r\n * @returns {vec3} out\r\n */\r\nexport function copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a vec3 to the given values\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} out\r\n */\r\nexport function set(out, x, y, z) {\r\n  out[0] = x;\r\n  out[1] = y;\r\n  out[2] = z;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\nexport function add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\nexport function subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  out[2] = a[2] - b[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Multiplies two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\nexport function multiply(out, a, b) {\r\n  out[0] = a[0] * b[0];\r\n  out[1] = a[1] * b[1];\r\n  out[2] = a[2] * b[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Divides two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\nexport function divide(out, a, b) {\r\n  out[0] = a[0] / b[0];\r\n  out[1] = a[1] / b[1];\r\n  out[2] = a[2] / b[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.ceil the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to ceil\r\n * @returns {vec3} out\r\n */\r\nexport function ceil(out, a) {\r\n  out[0] = Math.ceil(a[0]);\r\n  out[1] = Math.ceil(a[1]);\r\n  out[2] = Math.ceil(a[2]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.floor the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to floor\r\n * @returns {vec3} out\r\n */\r\nexport function floor(out, a) {\r\n  out[0] = Math.floor(a[0]);\r\n  out[1] = Math.floor(a[1]);\r\n  out[2] = Math.floor(a[2]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the minimum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\nexport function min(out, a, b) {\r\n  out[0] = Math.min(a[0], b[0]);\r\n  out[1] = Math.min(a[1], b[1]);\r\n  out[2] = Math.min(a[2], b[2]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the maximum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\nexport function max(out, a, b) {\r\n  out[0] = Math.max(a[0], b[0]);\r\n  out[1] = Math.max(a[1], b[1]);\r\n  out[2] = Math.max(a[2], b[2]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.round the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to round\r\n * @returns {vec3} out\r\n */\r\nexport function round(out, a) {\r\n  out[0] = Math.round(a[0]);\r\n  out[1] = Math.round(a[1]);\r\n  out[2] = Math.round(a[2]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Scales a vec3 by a scalar number\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec3} out\r\n */\r\nexport function scale(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two vec3's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec3} out\r\n */\r\nexport function scaleAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  out[2] = a[2] + b[2] * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the euclidian distance between two vec3's\r\n *\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\r\nexport function distance(a, b) {\r\n  var x = b[0] - a[0];\r\n  var y = b[1] - a[1];\r\n  var z = b[2] - a[2];\r\n  return Math.sqrt(x * x + y * y + z * z);\r\n}\r\n\r\n/**\r\n * Calculates the squared euclidian distance between two vec3's\r\n *\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\r\nexport function squaredDistance(a, b) {\r\n  var x = b[0] - a[0];\r\n  var y = b[1] - a[1];\r\n  var z = b[2] - a[2];\r\n  return x * x + y * y + z * z;\r\n}\r\n\r\n/**\r\n * Calculates the squared length of a vec3\r\n *\r\n * @param {vec3} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\r\nexport function squaredLength(a) {\r\n  var x = a[0];\r\n  var y = a[1];\r\n  var z = a[2];\r\n  return x * x + y * y + z * z;\r\n}\r\n\r\n/**\r\n * Negates the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to negate\r\n * @returns {vec3} out\r\n */\r\nexport function negate(out, a) {\r\n  out[0] = -a[0];\r\n  out[1] = -a[1];\r\n  out[2] = -a[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the inverse of the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to invert\r\n * @returns {vec3} out\r\n */\r\nexport function inverse(out, a) {\r\n  out[0] = 1.0 / a[0];\r\n  out[1] = 1.0 / a[1];\r\n  out[2] = 1.0 / a[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Normalize a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to normalize\r\n * @returns {vec3} out\r\n */\r\nexport function normalize(out, a) {\r\n  var x = a[0];\r\n  var y = a[1];\r\n  var z = a[2];\r\n  var len = x * x + y * y + z * z;\r\n  if (len > 0) {\r\n    //TODO: evaluate use of glm_invsqrt here?\r\n    len = 1 / Math.sqrt(len);\r\n    out[0] = a[0] * len;\r\n    out[1] = a[1] * len;\r\n    out[2] = a[2] * len;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the dot product of two vec3's\r\n *\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\r\nexport function dot(a, b) {\r\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r\n}\r\n\r\n/**\r\n * Computes the cross product of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\nexport function cross(out, a, b) {\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2];\r\n  var bx = b[0],\r\n      by = b[1],\r\n      bz = b[2];\r\n\r\n  out[0] = ay * bz - az * by;\r\n  out[1] = az * bx - ax * bz;\r\n  out[2] = ax * by - ay * bx;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Performs a linear interpolation between two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\r\nexport function lerp(out, a, b, t) {\r\n  var ax = a[0];\r\n  var ay = a[1];\r\n  var az = a[2];\r\n  out[0] = ax + t * (b[0] - ax);\r\n  out[1] = ay + t * (b[1] - ay);\r\n  out[2] = az + t * (b[2] - az);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Performs a hermite interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {vec3} c the third operand\r\n * @param {vec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\r\nexport function hermite(out, a, b, c, d, t) {\r\n  var factorTimes2 = t * t;\r\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\r\n  var factor2 = factorTimes2 * (t - 2) + t;\r\n  var factor3 = factorTimes2 * (t - 1);\r\n  var factor4 = factorTimes2 * (3 - 2 * t);\r\n\r\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\r\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\r\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Performs a bezier interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {vec3} c the third operand\r\n * @param {vec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\r\nexport function bezier(out, a, b, c, d, t) {\r\n  var inverseFactor = 1 - t;\r\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\r\n  var factorTimes2 = t * t;\r\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\r\n  var factor2 = 3 * t * inverseFactorTimesTwo;\r\n  var factor3 = 3 * factorTimes2 * inverseFactor;\r\n  var factor4 = factorTimes2 * t;\r\n\r\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\r\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\r\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec3} out\r\n */\r\nexport function random(out, scale) {\r\n  scale = scale || 1.0;\r\n\r\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\r\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\r\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\r\n\r\n  out[0] = Math.cos(r) * zScale;\r\n  out[1] = Math.sin(r) * zScale;\r\n  out[2] = z * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec3 with a mat4.\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec3} out\r\n */\r\nexport function transformMat4(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2];\r\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\r\n  w = w || 1.0;\r\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\r\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\r\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec3 with a mat3.\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to transform\r\n * @param {mat3} m the 3x3 matrix to transform with\r\n * @returns {vec3} out\r\n */\r\nexport function transformMat3(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2];\r\n  out[0] = x * m[0] + y * m[3] + z * m[6];\r\n  out[1] = x * m[1] + y * m[4] + z * m[7];\r\n  out[2] = x * m[2] + y * m[5] + z * m[8];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec3 with a quat\r\n * Can also be used for dual quaternions. (Multiply it with the real part)\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to transform\r\n * @param {quat} q quaternion to transform with\r\n * @returns {vec3} out\r\n */\r\nexport function transformQuat(out, a, q) {\r\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\r\n  var qx = q[0],\r\n      qy = q[1],\r\n      qz = q[2],\r\n      qw = q[3];\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2];\r\n  // var qvec = [qx, qy, qz];\r\n  // var uv = vec3.cross([], qvec, a);\r\n  var uvx = qy * z - qz * y,\r\n      uvy = qz * x - qx * z,\r\n      uvz = qx * y - qy * x;\r\n  // var uuv = vec3.cross([], qvec, uv);\r\n  var uuvx = qy * uvz - qz * uvy,\r\n      uuvy = qz * uvx - qx * uvz,\r\n      uuvz = qx * uvy - qy * uvx;\r\n  // vec3.scale(uv, uv, 2 * w);\r\n  var w2 = qw * 2;\r\n  uvx *= w2;\r\n  uvy *= w2;\r\n  uvz *= w2;\r\n  // vec3.scale(uuv, uuv, 2);\r\n  uuvx *= 2;\r\n  uuvy *= 2;\r\n  uuvz *= 2;\r\n  // return vec3.add(out, a, vec3.add(out, uv, uuv));\r\n  out[0] = x + uvx + uuvx;\r\n  out[1] = y + uvy + uuvy;\r\n  out[2] = z + uvz + uuvz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotate a 3D vector around the x-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {vec3} a The vec3 point to rotate\r\n * @param {vec3} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec3} out\r\n */\r\nexport function rotateX(out, a, b, c) {\r\n  var p = [],\r\n      r = [];\r\n  //Translate point to the origin\r\n  p[0] = a[0] - b[0];\r\n  p[1] = a[1] - b[1];\r\n  p[2] = a[2] - b[2];\r\n\r\n  //perform rotation\r\n  r[0] = p[0];\r\n  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\r\n  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);\r\n\r\n  //translate to correct position\r\n  out[0] = r[0] + b[0];\r\n  out[1] = r[1] + b[1];\r\n  out[2] = r[2] + b[2];\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotate a 3D vector around the y-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {vec3} a The vec3 point to rotate\r\n * @param {vec3} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec3} out\r\n */\r\nexport function rotateY(out, a, b, c) {\r\n  var p = [],\r\n      r = [];\r\n  //Translate point to the origin\r\n  p[0] = a[0] - b[0];\r\n  p[1] = a[1] - b[1];\r\n  p[2] = a[2] - b[2];\r\n\r\n  //perform rotation\r\n  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\r\n  r[1] = p[1];\r\n  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);\r\n\r\n  //translate to correct position\r\n  out[0] = r[0] + b[0];\r\n  out[1] = r[1] + b[1];\r\n  out[2] = r[2] + b[2];\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotate a 3D vector around the z-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {vec3} a The vec3 point to rotate\r\n * @param {vec3} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec3} out\r\n */\r\nexport function rotateZ(out, a, b, c) {\r\n  var p = [],\r\n      r = [];\r\n  //Translate point to the origin\r\n  p[0] = a[0] - b[0];\r\n  p[1] = a[1] - b[1];\r\n  p[2] = a[2] - b[2];\r\n\r\n  //perform rotation\r\n  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\r\n  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\r\n  r[2] = p[2];\r\n\r\n  //translate to correct position\r\n  out[0] = r[0] + b[0];\r\n  out[1] = r[1] + b[1];\r\n  out[2] = r[2] + b[2];\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Get the angle between two 3D vectors\r\n * @param {vec3} a The first operand\r\n * @param {vec3} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\r\nexport function angle(a, b) {\r\n  var tempA = fromValues(a[0], a[1], a[2]);\r\n  var tempB = fromValues(b[0], b[1], b[2]);\r\n\r\n  normalize(tempA, tempA);\r\n  normalize(tempB, tempB);\r\n\r\n  var cosine = dot(tempA, tempB);\r\n\r\n  if (cosine > 1.0) {\r\n    return 0;\r\n  } else if (cosine < -1.0) {\r\n    return Math.PI;\r\n  } else {\r\n    return Math.acos(cosine);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {vec3} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\r\nexport function str(a) {\r\n  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';\r\n}\r\n\r\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec3} a The first vector.\r\n * @param {vec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nexport function exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\r\n}\r\n\r\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {vec3} a The first vector.\r\n * @param {vec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nexport function equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2];\r\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\r\n}\r\n\r\n/**\r\n * Alias for {@link vec3.subtract}\r\n * @function\r\n */\r\nexport var sub = subtract;\r\n\r\n/**\r\n * Alias for {@link vec3.multiply}\r\n * @function\r\n */\r\nexport var mul = multiply;\r\n\r\n/**\r\n * Alias for {@link vec3.divide}\r\n * @function\r\n */\r\nexport var div = divide;\r\n\r\n/**\r\n * Alias for {@link vec3.distance}\r\n * @function\r\n */\r\nexport var dist = distance;\r\n\r\n/**\r\n * Alias for {@link vec3.squaredDistance}\r\n * @function\r\n */\r\nexport var sqrDist = squaredDistance;\r\n\r\n/**\r\n * Alias for {@link vec3.length}\r\n * @function\r\n */\r\nexport var len = length;\r\n\r\n/**\r\n * Alias for {@link vec3.squaredLength}\r\n * @function\r\n */\r\nexport var sqrLen = squaredLength;\r\n\r\n/**\r\n * Perform some operation over an array of vec3s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\r\nexport var forEach = function () {\r\n  var vec = create();\r\n\r\n  return function (a, stride, offset, count, fn, arg) {\r\n    var i = void 0,\r\n        l = void 0;\r\n    if (!stride) {\r\n      stride = 3;\r\n    }\r\n\r\n    if (!offset) {\r\n      offset = 0;\r\n    }\r\n\r\n    if (count) {\r\n      l = Math.min(count * stride + offset, a.length);\r\n    } else {\r\n      l = a.length;\r\n    }\r\n\r\n    for (i = offset; i < l; i += stride) {\r\n      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];\r\n      fn(vec, vec, arg);\r\n      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];\r\n    }\r\n\r\n    return a;\r\n  };\r\n}();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/gl-matrix/lib/gl-matrix/vec3.js\n// module id = 7\n// module chunks = 0","import * as glMatrix from \"./common.js\";\r\n\r\n/**\r\n * 4 Dimensional Vector\r\n * @module vec4\r\n */\r\n\r\n/**\r\n * Creates a new, empty vec4\r\n *\r\n * @returns {vec4} a new 4D vector\r\n */\r\nexport function create() {\r\n  var out = new glMatrix.ARRAY_TYPE(4);\r\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\r\n    out[0] = 0;\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n    out[3] = 0;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new vec4 initialized with values from an existing vector\r\n *\r\n * @param {vec4} a vector to clone\r\n * @returns {vec4} a new 4D vector\r\n */\r\nexport function clone(a) {\r\n  var out = new glMatrix.ARRAY_TYPE(4);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new vec4 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} a new 4D vector\r\n */\r\nexport function fromValues(x, y, z, w) {\r\n  var out = new glMatrix.ARRAY_TYPE(4);\r\n  out[0] = x;\r\n  out[1] = y;\r\n  out[2] = z;\r\n  out[3] = w;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one vec4 to another\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the source vector\r\n * @returns {vec4} out\r\n */\r\nexport function copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a vec4 to the given values\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} out\r\n */\r\nexport function set(out, x, y, z, w) {\r\n  out[0] = x;\r\n  out[1] = y;\r\n  out[2] = z;\r\n  out[3] = w;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\r\nexport function add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  out[3] = a[3] + b[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\r\nexport function subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  out[2] = a[2] - b[2];\r\n  out[3] = a[3] - b[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Multiplies two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\r\nexport function multiply(out, a, b) {\r\n  out[0] = a[0] * b[0];\r\n  out[1] = a[1] * b[1];\r\n  out[2] = a[2] * b[2];\r\n  out[3] = a[3] * b[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Divides two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\r\nexport function divide(out, a, b) {\r\n  out[0] = a[0] / b[0];\r\n  out[1] = a[1] / b[1];\r\n  out[2] = a[2] / b[2];\r\n  out[3] = a[3] / b[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.ceil the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to ceil\r\n * @returns {vec4} out\r\n */\r\nexport function ceil(out, a) {\r\n  out[0] = Math.ceil(a[0]);\r\n  out[1] = Math.ceil(a[1]);\r\n  out[2] = Math.ceil(a[2]);\r\n  out[3] = Math.ceil(a[3]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.floor the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to floor\r\n * @returns {vec4} out\r\n */\r\nexport function floor(out, a) {\r\n  out[0] = Math.floor(a[0]);\r\n  out[1] = Math.floor(a[1]);\r\n  out[2] = Math.floor(a[2]);\r\n  out[3] = Math.floor(a[3]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the minimum of two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\r\nexport function min(out, a, b) {\r\n  out[0] = Math.min(a[0], b[0]);\r\n  out[1] = Math.min(a[1], b[1]);\r\n  out[2] = Math.min(a[2], b[2]);\r\n  out[3] = Math.min(a[3], b[3]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the maximum of two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\r\nexport function max(out, a, b) {\r\n  out[0] = Math.max(a[0], b[0]);\r\n  out[1] = Math.max(a[1], b[1]);\r\n  out[2] = Math.max(a[2], b[2]);\r\n  out[3] = Math.max(a[3], b[3]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.round the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to round\r\n * @returns {vec4} out\r\n */\r\nexport function round(out, a) {\r\n  out[0] = Math.round(a[0]);\r\n  out[1] = Math.round(a[1]);\r\n  out[2] = Math.round(a[2]);\r\n  out[3] = Math.round(a[3]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Scales a vec4 by a scalar number\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec4} out\r\n */\r\nexport function scale(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  out[3] = a[3] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two vec4's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec4} out\r\n */\r\nexport function scaleAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  out[2] = a[2] + b[2] * scale;\r\n  out[3] = a[3] + b[3] * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the euclidian distance between two vec4's\r\n *\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\r\nexport function distance(a, b) {\r\n  var x = b[0] - a[0];\r\n  var y = b[1] - a[1];\r\n  var z = b[2] - a[2];\r\n  var w = b[3] - a[3];\r\n  return Math.sqrt(x * x + y * y + z * z + w * w);\r\n}\r\n\r\n/**\r\n * Calculates the squared euclidian distance between two vec4's\r\n *\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\r\nexport function squaredDistance(a, b) {\r\n  var x = b[0] - a[0];\r\n  var y = b[1] - a[1];\r\n  var z = b[2] - a[2];\r\n  var w = b[3] - a[3];\r\n  return x * x + y * y + z * z + w * w;\r\n}\r\n\r\n/**\r\n * Calculates the length of a vec4\r\n *\r\n * @param {vec4} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\r\nexport function length(a) {\r\n  var x = a[0];\r\n  var y = a[1];\r\n  var z = a[2];\r\n  var w = a[3];\r\n  return Math.sqrt(x * x + y * y + z * z + w * w);\r\n}\r\n\r\n/**\r\n * Calculates the squared length of a vec4\r\n *\r\n * @param {vec4} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\r\nexport function squaredLength(a) {\r\n  var x = a[0];\r\n  var y = a[1];\r\n  var z = a[2];\r\n  var w = a[3];\r\n  return x * x + y * y + z * z + w * w;\r\n}\r\n\r\n/**\r\n * Negates the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to negate\r\n * @returns {vec4} out\r\n */\r\nexport function negate(out, a) {\r\n  out[0] = -a[0];\r\n  out[1] = -a[1];\r\n  out[2] = -a[2];\r\n  out[3] = -a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the inverse of the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to invert\r\n * @returns {vec4} out\r\n */\r\nexport function inverse(out, a) {\r\n  out[0] = 1.0 / a[0];\r\n  out[1] = 1.0 / a[1];\r\n  out[2] = 1.0 / a[2];\r\n  out[3] = 1.0 / a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Normalize a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to normalize\r\n * @returns {vec4} out\r\n */\r\nexport function normalize(out, a) {\r\n  var x = a[0];\r\n  var y = a[1];\r\n  var z = a[2];\r\n  var w = a[3];\r\n  var len = x * x + y * y + z * z + w * w;\r\n  if (len > 0) {\r\n    len = 1 / Math.sqrt(len);\r\n    out[0] = x * len;\r\n    out[1] = y * len;\r\n    out[2] = z * len;\r\n    out[3] = w * len;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the dot product of two vec4's\r\n *\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\r\nexport function dot(a, b) {\r\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\r\n}\r\n\r\n/**\r\n * Performs a linear interpolation between two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec4} out\r\n */\r\nexport function lerp(out, a, b, t) {\r\n  var ax = a[0];\r\n  var ay = a[1];\r\n  var az = a[2];\r\n  var aw = a[3];\r\n  out[0] = ax + t * (b[0] - ax);\r\n  out[1] = ay + t * (b[1] - ay);\r\n  out[2] = az + t * (b[2] - az);\r\n  out[3] = aw + t * (b[3] - aw);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec4} out\r\n */\r\nexport function random(out, scale) {\r\n  scale = scale || 1.0;\r\n\r\n  // Marsaglia, George. Choosing a Point from the Surface of a\r\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\r\n  // http://projecteuclid.org/euclid.aoms/1177692644;\r\n  var v1, v2, v3, v4;\r\n  var s1, s2;\r\n  do {\r\n    v1 = glMatrix.RANDOM() * 2 - 1;\r\n    v2 = glMatrix.RANDOM() * 2 - 1;\r\n    s1 = v1 * v1 + v2 * v2;\r\n  } while (s1 >= 1);\r\n  do {\r\n    v3 = glMatrix.RANDOM() * 2 - 1;\r\n    v4 = glMatrix.RANDOM() * 2 - 1;\r\n    s2 = v3 * v3 + v4 * v4;\r\n  } while (s2 >= 1);\r\n\r\n  var d = Math.sqrt((1 - s1) / s2);\r\n  out[0] = scale * v1;\r\n  out[1] = scale * v2;\r\n  out[2] = scale * v3 * d;\r\n  out[3] = scale * v4 * d;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec4 with a mat4.\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec4} out\r\n */\r\nexport function transformMat4(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2],\r\n      w = a[3];\r\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\r\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\r\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\r\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec4 with a quat\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the vector to transform\r\n * @param {quat} q quaternion to transform with\r\n * @returns {vec4} out\r\n */\r\nexport function transformQuat(out, a, q) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2];\r\n  var qx = q[0],\r\n      qy = q[1],\r\n      qz = q[2],\r\n      qw = q[3];\r\n\r\n  // calculate quat * vec\r\n  var ix = qw * x + qy * z - qz * y;\r\n  var iy = qw * y + qz * x - qx * z;\r\n  var iz = qw * z + qx * y - qy * x;\r\n  var iw = -qx * x - qy * y - qz * z;\r\n\r\n  // calculate result * inverse quat\r\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n  out[3] = a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {vec4} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\r\nexport function str(a) {\r\n  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\r\n}\r\n\r\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec4} a The first vector.\r\n * @param {vec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nexport function exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\r\n}\r\n\r\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {vec4} a The first vector.\r\n * @param {vec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nexport function equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3];\r\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\r\n}\r\n\r\n/**\r\n * Alias for {@link vec4.subtract}\r\n * @function\r\n */\r\nexport var sub = subtract;\r\n\r\n/**\r\n * Alias for {@link vec4.multiply}\r\n * @function\r\n */\r\nexport var mul = multiply;\r\n\r\n/**\r\n * Alias for {@link vec4.divide}\r\n * @function\r\n */\r\nexport var div = divide;\r\n\r\n/**\r\n * Alias for {@link vec4.distance}\r\n * @function\r\n */\r\nexport var dist = distance;\r\n\r\n/**\r\n * Alias for {@link vec4.squaredDistance}\r\n * @function\r\n */\r\nexport var sqrDist = squaredDistance;\r\n\r\n/**\r\n * Alias for {@link vec4.length}\r\n * @function\r\n */\r\nexport var len = length;\r\n\r\n/**\r\n * Alias for {@link vec4.squaredLength}\r\n * @function\r\n */\r\nexport var sqrLen = squaredLength;\r\n\r\n/**\r\n * Perform some operation over an array of vec4s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\r\nexport var forEach = function () {\r\n  var vec = create();\r\n\r\n  return function (a, stride, offset, count, fn, arg) {\r\n    var i = void 0,\r\n        l = void 0;\r\n    if (!stride) {\r\n      stride = 4;\r\n    }\r\n\r\n    if (!offset) {\r\n      offset = 0;\r\n    }\r\n\r\n    if (count) {\r\n      l = Math.min(count * stride + offset, a.length);\r\n    } else {\r\n      l = a.length;\r\n    }\r\n\r\n    for (i = offset; i < l; i += stride) {\r\n      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];vec[3] = a[i + 3];\r\n      fn(vec, vec, arg);\r\n      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];a[i + 3] = vec[3];\r\n    }\r\n\r\n    return a;\r\n  };\r\n}();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/gl-matrix/lib/gl-matrix/vec4.js\n// module id = 8\n// module chunks = 0","/*** IMPORTS FROM imports-loader ***/\n(function() {\nvar fix = module.exports=0;\n\n// Snap.svg 0.5.0\n//\n// Copyright (c) 2013  2017 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// build: 2017-02-06\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//  \\\\\n//  Eve 0.5.0 - JavaScript Events Library                       \\\\\n//  \\\\\n//  Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)  \\\\\n//  \\\\\n\n(function (glob) {\n    var version = \"0.5.0\",\n        has = \"hasOwnProperty\",\n        separator = /[\\.\\/]/,\n        comaseparator = /\\s*,\\s*/,\n        wildcard = \"*\",\n        fun = function () {},\n        numsort = function (a, b) {\n            return a - b;\n        },\n        current_event,\n        stop,\n        events = {n: {}},\n        firstDefined = function () {\n            for (var i = 0, ii = this.length; i < ii; i++) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n        lastDefined = function () {\n            var i = this.length;\n            while (--i) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n        objtos = Object.prototype.toString,\n        Str = String,\n        isArray = Array.isArray || function (ar) {\n            return ar instanceof Array || objtos.call(ar) == \"[object Array]\";\n        };\n    /*\\\n     * eve\n     [ method ]\n\n     * Fires event with given `name`, given scope and other parameters.\n\n     > Arguments\n\n     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n     - scope (object) context for the event handlers\n     - varargs (...) the rest of arguments will be sent to event handlers\n\n     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n    \\*/\n        eve = function (name, scope) {\n            var e = events,\n                oldstop = stop,\n                args = Array.prototype.slice.call(arguments, 2),\n                listeners = eve.listeners(name),\n                z = 0,\n                f = false,\n                l,\n                indexed = [],\n                queue = {},\n                out = [],\n                ce = current_event,\n                errors = [];\n            out.firstDefined = firstDefined;\n            out.lastDefined = lastDefined;\n            current_event = name;\n            stop = 0;\n            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n                indexed.push(listeners[i].zIndex);\n                if (listeners[i].zIndex < 0) {\n                    queue[listeners[i].zIndex] = listeners[i];\n                }\n            }\n            indexed.sort(numsort);\n            while (indexed[z] < 0) {\n                l = queue[indexed[z++]];\n                out.push(l.apply(scope, args));\n                if (stop) {\n                    stop = oldstop;\n                    return out;\n                }\n            }\n            for (i = 0; i < ii; i++) {\n                l = listeners[i];\n                if (\"zIndex\" in l) {\n                    if (l.zIndex == indexed[z]) {\n                        out.push(l.apply(scope, args));\n                        if (stop) {\n                            break;\n                        }\n                        do {\n                            z++;\n                            l = queue[indexed[z]];\n                            l && out.push(l.apply(scope, args));\n                            if (stop) {\n                                break;\n                            }\n                        } while (l)\n                    } else {\n                        queue[l.zIndex] = l;\n                    }\n                } else {\n                    out.push(l.apply(scope, args));\n                    if (stop) {\n                        break;\n                    }\n                }\n            }\n            stop = oldstop;\n            current_event = ce;\n            return out;\n        };\n        // Undocumented. Debug only.\n        eve._events = events;\n    /*\\\n     * eve.listeners\n     [ method ]\n\n     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\n     > Arguments\n\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\n     = (array) array of event handlers\n    \\*/\n    eve.listeners = function (name) {\n        var names = isArray(name) ? name : name.split(separator),\n            e = events,\n            item,\n            items,\n            k,\n            i,\n            ii,\n            j,\n            jj,\n            nes,\n            es = [e],\n            out = [];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            nes = [];\n            for (j = 0, jj = es.length; j < jj; j++) {\n                e = es[j].n;\n                items = [e[names[i]], e[wildcard]];\n                k = 2;\n                while (k--) {\n                    item = items[k];\n                    if (item) {\n                        nes.push(item);\n                        out = out.concat(item.f || []);\n                    }\n                }\n            }\n            es = nes;\n        }\n        return out;\n    };\n    /*\\\n     * eve.separator\n     [ method ]\n\n     * If for some reasons you dont like default separators (`.` or `/`) you can specify yours\n     * here. Be aware that if you pass a string longer than one character it will be treated as\n     * a list of characters.\n\n     - separator (string) new separator. Empty string resets to default: `.` or `/`.\n    \\*/\n    eve.separator = function (sep) {\n        if (sep) {\n            sep = Str(sep).replace(/(?=[\\.\\^\\]\\[\\-])/g, \"\\\\\");\n            sep = \"[\" + sep + \"]\";\n            separator = new RegExp(sep);\n        } else {\n            separator = /[\\.\\/]/;\n        }\n    };\n    /*\\\n     * eve.on\n     [ method ]\n     **\n     * Binds given event handler with a given name. You can use wildcards `*` for the names:\n     | eve.on(\"*.under.*\", f);\n     | eve(\"mouse.under.floor\"); // triggers f\n     * Use @eve to trigger the listener.\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     - name (array) if you dont want to use separators, you can use array of strings\n     - f (function) event handler function\n     **\n     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. \n     > Example:\n     | eve.on(\"mouse\", eatIt)(2);\n     | eve.on(\"mouse\", scream);\n     | eve.on(\"mouse\", catchIt)(1);\n     * This will ensure that `catchIt` function will be called before `eatIt`.\n     *\n     * If you want to put your handler before non-indexed handlers, specify a negative value.\n     * Note: I assume most of the time you dont need to worry about z-index, but its nice to have this feature just in case.\n    \\*/\n    eve.on = function (name, f) {\n        if (typeof f != \"function\") {\n            return function () {};\n        }\n        var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);\n        for (var i = 0, ii = names.length; i < ii; i++) {\n            (function (name) {\n                var names = isArray(name) ? name : Str(name).split(separator),\n                    e = events,\n                    exist;\n                for (var i = 0, ii = names.length; i < ii; i++) {\n                    e = e.n;\n                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\n                }\n                e.f = e.f || [];\n                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n                    exist = true;\n                    break;\n                }\n                !exist && e.f.push(f);\n            }(names[i]));\n        }\n        return function (zIndex) {\n            if (+zIndex == +zIndex) {\n                f.zIndex = +zIndex;\n            }\n        };\n    };\n    /*\\\n     * eve.f\n     [ method ]\n     **\n     * Returns function that will fire given event with optional arguments.\n     * Arguments that will be passed to the result function will be also\n     * concated to the list of final arguments.\n     | el.onclick = eve.f(\"click\", 1, 2);\n     | eve.on(\"click\", function (a, b, c) {\n     |     console.log(a, b, c); // 1, 2, [event object]\n     | });\n     > Arguments\n     - event (string) event name\n     - varargs () and any other arguments\n     = (function) possible event handler function\n    \\*/\n    eve.f = function (event) {\n        var attrs = [].slice.call(arguments, 1);\n        return function () {\n            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n        };\n    };\n    /*\\\n     * eve.stop\n     [ method ]\n     **\n     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n    \\*/\n    eve.stop = function () {\n        stop = 1;\n    };\n    /*\\\n     * eve.nt\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     > Arguments\n     **\n     - subname (string) #optional subname of the event\n     **\n     = (string) name of the event, if `subname` is not specified\n     * or\n     = (boolean) `true`, if current events name contains `subname`\n    \\*/\n    eve.nt = function (subname) {\n        var cur = isArray(current_event) ? current_event.join(\".\") : current_event;\n        if (subname) {\n            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(cur);\n        }\n        return cur;\n    };\n    /*\\\n     * eve.nts\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     **\n     = (array) names of the event\n    \\*/\n    eve.nts = function () {\n        return isArray(current_event) ? current_event : current_event.split(separator);\n    };\n    /*\\\n     * eve.off\n     [ method ]\n     **\n     * Removes given function from the list of event listeners assigned to given name.\n     * If no arguments specified all the events will be cleared.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n    \\*/\n    /*\\\n     * eve.unbind\n     [ method ]\n     **\n     * See @eve.off\n    \\*/\n    eve.off = eve.unbind = function (name, f) {\n        if (!name) {\n            eve._events = events = {n: {}};\n            return;\n        }\n        var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);\n        if (names.length > 1) {\n            for (var i = 0, ii = names.length; i < ii; i++) {\n                eve.off(names[i], f);\n            }\n            return;\n        }\n        names = isArray(name) ? name : Str(name).split(separator);\n        var e,\n            key,\n            splice,\n            i, ii, j, jj,\n            cur = [events],\n            inodes = [];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            for (j = 0; j < cur.length; j += splice.length - 2) {\n                splice = [j, 1];\n                e = cur[j].n;\n                if (names[i] != wildcard) {\n                    if (e[names[i]]) {\n                        splice.push(e[names[i]]);\n                        inodes.unshift({\n                            n: e,\n                            name: names[i]\n                        });\n                    }\n                } else {\n                    for (key in e) if (e[has](key)) {\n                        splice.push(e[key]);\n                        inodes.unshift({\n                            n: e,\n                            name: key\n                        });\n                    }\n                }\n                cur.splice.apply(cur, splice);\n            }\n        }\n        for (i = 0, ii = cur.length; i < ii; i++) {\n            e = cur[i];\n            while (e.n) {\n                if (f) {\n                    if (e.f) {\n                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n                            e.f.splice(j, 1);\n                            break;\n                        }\n                        !e.f.length && delete e.f;\n                    }\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        var funcs = e.n[key].f;\n                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n                            funcs.splice(j, 1);\n                            break;\n                        }\n                        !funcs.length && delete e.n[key].f;\n                    }\n                } else {\n                    delete e.f;\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        delete e.n[key].f;\n                    }\n                }\n                e = e.n;\n            }\n        }\n        // prune inner nodes in path\n        prune: for (i = 0, ii = inodes.length; i < ii; i++) {\n            e = inodes[i];\n            for (key in e.n[e.name].f) {\n                // not empty (has listeners)\n                continue prune;\n            }\n            for (key in e.n[e.name].n) {\n                // not empty (has children)\n                continue prune;\n            }\n            // is empty\n            delete e.n[e.name];\n        }\n    };\n    /*\\\n     * eve.once\n     [ method ]\n     **\n     * Binds given event handler with a given name to only run once then unbind itself.\n     | eve.once(\"login\", f);\n     | eve(\"login\"); // triggers f\n     | eve(\"login\"); // no listeners\n     * Use @eve to trigger the listener.\n     **\n     > Arguments\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) same return function as @eve.on\n    \\*/\n    eve.once = function (name, f) {\n        var f2 = function () {\n            eve.off(name, f2);\n            return f.apply(this, arguments);\n        };\n        return eve.on(name, f2);\n    };\n    /*\\\n     * eve.version\n     [ property (string) ]\n     **\n     * Current version of the library.\n    \\*/\n    eve.version = version;\n    eve.toString = function () {\n        return \"You are running Eve \" + version;\n    };\n    (typeof module != \"undefined\" && module.exports) ? (module.exports = eve) : (typeof define === \"function\" && define.amd ? (define(\"eve\", [], function() { return eve; })) : (glob.eve = eve));\n})(this);\n\n(function (glob, factory) {\n    // AMD support\n    if (typeof define == \"function\" && define.amd) {\n        // Define as an anonymous module\n        define([\"eve\"], function (eve) {\n            return factory(glob, eve);\n        });\n    } else if (typeof exports != \"undefined\") {\n        // Next for Node.js or CommonJS\n        var eve = require(\"eve\");\n        module.exports = factory(glob, eve);\n    } else {\n        // Browser globals (glob is window)\n        // Snap adds itself to window\n        factory(glob, glob.eve);\n    }\n}(window || this, function (window, eve) {\n\n// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar mina = (function (eve) {\n    var animations = {},\n    requestAnimFrame = window.requestAnimationFrame       ||\n                       window.webkitRequestAnimationFrame ||\n                       window.mozRequestAnimationFrame    ||\n                       window.oRequestAnimationFrame      ||\n                       window.msRequestAnimationFrame     ||\n                       function (callback) {\n                           setTimeout(callback, 16, new Date().getTime());\n                           return true;\n                       },\n    requestID,\n    isArray = Array.isArray || function (a) {\n        return a instanceof Array ||\n            Object.prototype.toString.call(a) == \"[object Array]\";\n    },\n    idgen = 0,\n    idprefix = \"M\" + (+new Date).toString(36),\n    ID = function () {\n        return idprefix + (idgen++).toString(36);\n    },\n    diff = function (a, b, A, B) {\n        if (isArray(a)) {\n            res = [];\n            for (var i = 0, ii = a.length; i < ii; i++) {\n                res[i] = diff(a[i], b, A[i], B);\n            }\n            return res;\n        }\n        var dif = (A - a) / (B - b);\n        return function (bb) {\n            return a + dif * (bb - b);\n        };\n    },\n    timer = Date.now || function () {\n        return +new Date;\n    },\n    sta = function (val) {\n        var a = this;\n        if (val == null) {\n            return a.s;\n        }\n        var ds = a.s - val;\n        a.b += a.dur * ds;\n        a.B += a.dur * ds;\n        a.s = val;\n    },\n    speed = function (val) {\n        var a = this;\n        if (val == null) {\n            return a.spd;\n        }\n        a.spd = val;\n    },\n    duration = function (val) {\n        var a = this;\n        if (val == null) {\n            return a.dur;\n        }\n        a.s = a.s * val / a.dur;\n        a.dur = val;\n    },\n    stopit = function () {\n        var a = this;\n        delete animations[a.id];\n        a.update();\n        eve(\"mina.stop.\" + a.id, a);\n    },\n    pause = function () {\n        var a = this;\n        if (a.pdif) {\n            return;\n        }\n        delete animations[a.id];\n        a.update();\n        a.pdif = a.get() - a.b;\n    },\n    resume = function () {\n        var a = this;\n        if (!a.pdif) {\n            return;\n        }\n        a.b = a.get() - a.pdif;\n        delete a.pdif;\n        animations[a.id] = a;\n        frame();\n    },\n    update = function () {\n        var a = this,\n            res;\n        if (isArray(a.start)) {\n            res = [];\n            for (var j = 0, jj = a.start.length; j < jj; j++) {\n                res[j] = +a.start[j] +\n                    (a.end[j] - a.start[j]) * a.easing(a.s);\n            }\n        } else {\n            res = +a.start + (a.end - a.start) * a.easing(a.s);\n        }\n        a.set(res);\n    },\n    frame = function (timeStamp) {\n        // Manual invokation?\n        if (!timeStamp) {\n            // Frame loop stopped?\n            if (!requestID) {\n                // Start frame loop...\n                requestID = requestAnimFrame(frame);\n            }\n            return;\n        }\n        var len = 0;\n        for (var i in animations) if (animations.hasOwnProperty(i)) {\n            var a = animations[i],\n                b = a.get(),\n                res;\n            len++;\n            a.s = (b - a.b) / (a.dur / a.spd);\n            if (a.s >= 1) {\n                delete animations[i];\n                a.s = 1;\n                len--;\n                (function (a) {\n                    setTimeout(function () {\n                        eve(\"mina.finish.\" + a.id, a);\n                    });\n                }(a));\n            }\n            a.update();\n        }\n        requestID = len ? requestAnimFrame(frame) : false;\n    },\n    /*\\\n     * mina\n     [ method ]\n     **\n     * Generic animation of numbers\n     **\n     - a (number) start _slave_ number\n     - A (number) end _slave_ number\n     - b (number) start _master_ number (start time in general case)\n     - B (number) end _master_ number (end time in general case)\n     - get (function) getter of _master_ number (see @mina.time)\n     - set (function) setter of _slave_ number\n     - easing (function) #optional easing function, default is @mina.linear\n     = (object) animation descriptor\n     o {\n     o         id (string) animation id,\n     o         start (number) start _slave_ number,\n     o         end (number) end _slave_ number,\n     o         b (number) start _master_ number,\n     o         s (number) animation status (0..1),\n     o         dur (number) animation duration,\n     o         spd (number) animation speed,\n     o         get (function) getter of _master_ number (see @mina.time),\n     o         set (function) setter of _slave_ number,\n     o         easing (function) easing function, default is @mina.linear,\n     o         status (function) status getter/setter,\n     o         speed (function) speed getter/setter,\n     o         duration (function) duration getter/setter,\n     o         stop (function) animation stopper\n     o         pause (function) pauses the animation\n     o         resume (function) resumes the animation\n     o         update (function) calles setter with the right value of the animation\n     o }\n    \\*/\n    mina = function (a, A, b, B, get, set, easing) {\n        var anim = {\n            id: ID(),\n            start: a,\n            end: A,\n            b: b,\n            s: 0,\n            dur: B - b,\n            spd: 1,\n            get: get,\n            set: set,\n            easing: easing || mina.linear,\n            status: sta,\n            speed: speed,\n            duration: duration,\n            stop: stopit,\n            pause: pause,\n            resume: resume,\n            update: update\n        };\n        animations[anim.id] = anim;\n        var len = 0, i;\n        for (i in animations) if (animations.hasOwnProperty(i)) {\n            len++;\n            if (len == 2) {\n                break;\n            }\n        }\n        len == 1 && frame();\n        return anim;\n    };\n    /*\\\n     * mina.time\n     [ method ]\n     **\n     * Returns the current time. Equivalent to:\n     | function () {\n     |     return (new Date).getTime();\n     | }\n    \\*/\n    mina.time = timer;\n    /*\\\n     * mina.getById\n     [ method ]\n     **\n     * Returns an animation by its id\n     - id (string) animation's id\n     = (object) See @mina\n    \\*/\n    mina.getById = function (id) {\n        return animations[id] || null;\n    };\n\n    /*\\\n     * mina.linear\n     [ method ]\n     **\n     * Default linear easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.linear = function (n) {\n        return n;\n    };\n    /*\\\n     * mina.easeout\n     [ method ]\n     **\n     * Easeout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.easeout = function (n) {\n        return Math.pow(n, 1.7);\n    };\n    /*\\\n     * mina.easein\n     [ method ]\n     **\n     * Easein easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.easein = function (n) {\n        return Math.pow(n, .48);\n    };\n    /*\\\n     * mina.easeinout\n     [ method ]\n     **\n     * Easeinout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.easeinout = function (n) {\n        if (n == 1) {\n            return 1;\n        }\n        if (n == 0) {\n            return 0;\n        }\n        var q = .48 - n / 1.04,\n            Q = Math.sqrt(.1734 + q * q),\n            x = Q - q,\n            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),\n            y = -Q - q,\n            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),\n            t = X + Y + .5;\n        return (1 - t) * 3 * t * t + t * t * t;\n    };\n    /*\\\n     * mina.backin\n     [ method ]\n     **\n     * Backin easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.backin = function (n) {\n        if (n == 1) {\n            return 1;\n        }\n        var s = 1.70158;\n        return n * n * ((s + 1) * n - s);\n    };\n    /*\\\n     * mina.backout\n     [ method ]\n     **\n     * Backout easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.backout = function (n) {\n        if (n == 0) {\n            return 0;\n        }\n        n = n - 1;\n        var s = 1.70158;\n        return n * n * ((s + 1) * n + s) + 1;\n    };\n    /*\\\n     * mina.elastic\n     [ method ]\n     **\n     * Elastic easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.elastic = function (n) {\n        if (n == !!n) {\n            return n;\n        }\n        return Math.pow(2, -10 * n) * Math.sin((n - .075) *\n            (2 * Math.PI) / .3) + 1;\n    };\n    /*\\\n     * mina.bounce\n     [ method ]\n     **\n     * Bounce easing\n     - n (number) input 0..1\n     = (number) output 0..1\n    \\*/\n    mina.bounce = function (n) {\n        var s = 7.5625,\n            p = 2.75,\n            l;\n        if (n < 1 / p) {\n            l = s * n * n;\n        } else {\n            if (n < 2 / p) {\n                n -= 1.5 / p;\n                l = s * n * n + .75;\n            } else {\n                if (n < 2.5 / p) {\n                    n -= 2.25 / p;\n                    l = s * n * n + .9375;\n                } else {\n                    n -= 2.625 / p;\n                    l = s * n * n + .984375;\n                }\n            }\n        }\n        return l;\n    };\n    window.mina = mina;\n    return mina;\n})(typeof eve == \"undefined\" ? function () {} : eve);\n\n// Copyright (c) 2013 - 2017 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar Snap = (function(root) {\nSnap.version = \"0.5.1\";\n/*\\\n * Snap\n [ method ]\n **\n * Creates a drawing surface or wraps existing SVG element.\n **\n - width (number|string) width of surface\n - height (number|string) height of surface\n * or\n - DOM (SVGElement) element to be wrapped into Snap structure\n * or\n - array (array) array of elements (will return set of elements)\n * or\n - query (string) CSS query selector\n = (object) @Element\n\\*/\nfunction Snap(w, h) {\n    if (w) {\n        if (w.nodeType) {\n            return wrap(w);\n        }\n        if (is(w, \"array\") && Snap.set) {\n            return Snap.set.apply(Snap, w);\n        }\n        if (w instanceof Element) {\n            return w;\n        }\n        if (h == null) {\n            // try {\n                w = glob.doc.querySelector(String(w));\n                return wrap(w);\n            // } catch (e) {\n                // return null;\n            // }\n        }\n    }\n    w = w == null ? \"100%\" : w;\n    h = h == null ? \"100%\" : h;\n    return new Paper(w, h);\n}\nSnap.toString = function () {\n    return \"Snap v\" + this.version;\n};\nSnap._ = {};\nvar glob = {\n    win: root.window,\n    doc: root.window.document\n};\nSnap._.glob = glob;\nvar has = \"hasOwnProperty\",\n    Str = String,\n    toFloat = parseFloat,\n    toInt = parseInt,\n    math = Math,\n    mmax = math.max,\n    mmin = math.min,\n    abs = math.abs,\n    pow = math.pow,\n    PI = math.PI,\n    round = math.round,\n    E = \"\",\n    S = \" \",\n    objectToString = Object.prototype.toString,\n    ISURL = /^url\\(['\"]?([^\\)]+?)['\"]?\\)$/i,\n    colourRegExp = /^\\s*((#[a-f\\d]{6})|(#[a-f\\d]{3})|rgba?\\(\\s*([\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+%?(?:\\s*,\\s*[\\d\\.]+%?)?)\\s*\\)|hsba?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\)|hsla?\\(\\s*([\\d\\.]+(?:deg|\\xb0|%)?\\s*,\\s*[\\d\\.]+%?\\s*,\\s*[\\d\\.]+(?:%?\\s*,\\s*[\\d\\.]+)?%?)\\s*\\))\\s*$/i,\n    bezierrg = /^(?:cubic-)?bezier\\(([^,]+),([^,]+),([^,]+),([^\\)]+)\\)/,\n    separator = Snap._.separator = /[,\\s]+/,\n    whitespace = /[\\s]/g,\n    commaSpaces = /[\\s]*,[\\s]*/,\n    hsrg = {hs: 1, rg: 1},\n    pathCommand = /([a-z])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig,\n    tCommand = /([rstm])[\\s,]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[\\s]*,?[\\s]*)+)/ig,\n    pathValues = /(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[\\s]*,?[\\s]*/ig,\n    idgen = 0,\n    idprefix = \"S\" + (+new Date).toString(36),\n    ID = function (el) {\n        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);\n    },\n    xlink = \"http://www.w3.org/1999/xlink\",\n    xmlns = \"http://www.w3.org/2000/svg\",\n    hub = {},\n    /*\\\n     * Snap.url\n     [ method ]\n     **\n     * Wraps path into `\"url('<path>')\"`.\n     - value (string) path\n     = (string) wrapped path\n    \\*/\n    URL = Snap.url = function (url) {\n        return \"url('#\" + url + \"')\";\n    };\n\nfunction $(el, attr) {\n    if (attr) {\n        if (el == \"#text\") {\n            el = glob.doc.createTextNode(attr.text || attr[\"#text\"] || \"\");\n        }\n        if (el == \"#comment\") {\n            el = glob.doc.createComment(attr.text || attr[\"#text\"] || \"\");\n        }\n        if (typeof el == \"string\") {\n            el = $(el);\n        }\n        if (typeof attr == \"string\") {\n            if (el.nodeType == 1) {\n                if (attr.substring(0, 6) == \"xlink:\") {\n                    return el.getAttributeNS(xlink, attr.substring(6));\n                }\n                if (attr.substring(0, 4) == \"xml:\") {\n                    return el.getAttributeNS(xmlns, attr.substring(4));\n                }\n                return el.getAttribute(attr);\n            } else if (attr == \"text\") {\n                return el.nodeValue;\n            } else {\n                return null;\n            }\n        }\n        if (el.nodeType == 1) {\n            for (var key in attr) if (attr[has](key)) {\n                var val = Str(attr[key]);\n                if (val) {\n                    if (key.substring(0, 6) == \"xlink:\") {\n                        el.setAttributeNS(xlink, key.substring(6), val);\n                    } else if (key.substring(0, 4) == \"xml:\") {\n                        el.setAttributeNS(xmlns, key.substring(4), val);\n                    } else {\n                        el.setAttribute(key, val);\n                    }\n                } else {\n                    el.removeAttribute(key);\n                }\n            }\n        } else if (\"text\" in attr) {\n            el.nodeValue = attr.text;\n        }\n    } else {\n        el = glob.doc.createElementNS(xmlns, el);\n    }\n    return el;\n}\nSnap._.$ = $;\nSnap._.id = ID;\nfunction getAttrs(el) {\n    var attrs = el.attributes,\n        name,\n        out = {};\n    for (var i = 0; i < attrs.length; i++) {\n        if (attrs[i].namespaceURI == xlink) {\n            name = \"xlink:\";\n        } else {\n            name = \"\";\n        }\n        name += attrs[i].name;\n        out[name] = attrs[i].textContent;\n    }\n    return out;\n}\nfunction is(o, type) {\n    type = Str.prototype.toLowerCase.call(type);\n    if (type == \"finite\") {\n        return isFinite(o);\n    }\n    if (type == \"array\" &&\n        (o instanceof Array || Array.isArray && Array.isArray(o))) {\n        return true;\n    }\n    return  type == \"null\" && o === null ||\n            type == typeof o && o !== null ||\n            type == \"object\" && o === Object(o) ||\n            objectToString.call(o).slice(8, -1).toLowerCase() == type;\n}\n/*\\\n * Snap.format\n [ method ]\n **\n * Replaces construction of type `{<name>}` to the corresponding argument\n **\n - token (string) string to format\n - json (object) object which properties are used as a replacement\n = (string) formatted string\n > Usage\n | // this draws a rectangular shape equivalent to \"M10,20h40v50h-40z\"\n | paper.path(Snap.format(\"M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z\", {\n |     x: 10,\n |     y: 20,\n |     dim: {\n |         width: 40,\n |         height: 50,\n |         \"negative width\": -40\n |     }\n | }));\n\\*/\nSnap.format = (function () {\n    var tokenRegex = /\\{([^\\}]+)\\}/g,\n        objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g, // matches .xxxxx or [\"xxxxx\"] to run over object properties\n        replacer = function (all, key, obj) {\n            var res = obj;\n            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {\n                name = name || quotedName;\n                if (res) {\n                    if (name in res) {\n                        res = res[name];\n                    }\n                    typeof res == \"function\" && isFunc && (res = res());\n                }\n            });\n            res = (res == null || res == obj ? all : res) + \"\";\n            return res;\n        };\n    return function (str, obj) {\n        return Str(str).replace(tokenRegex, function (all, key) {\n            return replacer(all, key, obj);\n        });\n    };\n})();\nfunction clone(obj) {\n    if (typeof obj == \"function\" || Object(obj) !== obj) {\n        return obj;\n    }\n    var res = new obj.constructor;\n    for (var key in obj) if (obj[has](key)) {\n        res[key] = clone(obj[key]);\n    }\n    return res;\n}\nSnap._.clone = clone;\nfunction repush(array, item) {\n    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {\n        return array.push(array.splice(i, 1)[0]);\n    }\n}\nfunction cacher(f, scope, postprocessor) {\n    function newf() {\n        var arg = Array.prototype.slice.call(arguments, 0),\n            args = arg.join(\"\\u2400\"),\n            cache = newf.cache = newf.cache || {},\n            count = newf.count = newf.count || [];\n        if (cache[has](args)) {\n            repush(count, args);\n            return postprocessor ? postprocessor(cache[args]) : cache[args];\n        }\n        count.length >= 1e3 && delete cache[count.shift()];\n        count.push(args);\n        cache[args] = f.apply(scope, arg);\n        return postprocessor ? postprocessor(cache[args]) : cache[args];\n    }\n    return newf;\n}\nSnap._.cacher = cacher;\nfunction angle(x1, y1, x2, y2, x3, y3) {\n    if (x3 == null) {\n        var x = x1 - x2,\n            y = y1 - y2;\n        if (!x && !y) {\n            return 0;\n        }\n        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;\n    } else {\n        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);\n    }\n}\nfunction rad(deg) {\n    return deg % 360 * PI / 180;\n}\nfunction deg(rad) {\n    return rad * 180 / PI % 360;\n}\nfunction x_y() {\n    return this.x + S + this.y;\n}\nfunction x_y_w_h() {\n    return this.x + S + this.y + S + this.width + \" \\xd7 \" + this.height;\n}\n\n/*\\\n * Snap.rad\n [ method ]\n **\n * Transform angle to radians\n - deg (number) angle in degrees\n = (number) angle in radians\n\\*/\nSnap.rad = rad;\n/*\\\n * Snap.deg\n [ method ]\n **\n * Transform angle to degrees\n - rad (number) angle in radians\n = (number) angle in degrees\n\\*/\nSnap.deg = deg;\n/*\\\n * Snap.sin\n [ method ]\n **\n * Equivalent to `Math.sin()` only works with degrees, not radians.\n - angle (number) angle in degrees\n = (number) sin\n\\*/\nSnap.sin = function (angle) {\n    return math.sin(Snap.rad(angle));\n};\n/*\\\n * Snap.tan\n [ method ]\n **\n * Equivalent to `Math.tan()` only works with degrees, not radians.\n - angle (number) angle in degrees\n = (number) tan\n\\*/\nSnap.tan = function (angle) {\n    return math.tan(Snap.rad(angle));\n};\n/*\\\n * Snap.cos\n [ method ]\n **\n * Equivalent to `Math.cos()` only works with degrees, not radians.\n - angle (number) angle in degrees\n = (number) cos\n\\*/\nSnap.cos = function (angle) {\n    return math.cos(Snap.rad(angle));\n};\n/*\\\n * Snap.asin\n [ method ]\n **\n * Equivalent to `Math.asin()` only works with degrees, not radians.\n - num (number) value\n = (number) asin in degrees\n\\*/\nSnap.asin = function (num) {\n    return Snap.deg(math.asin(num));\n};\n/*\\\n * Snap.acos\n [ method ]\n **\n * Equivalent to `Math.acos()` only works with degrees, not radians.\n - num (number) value\n = (number) acos in degrees\n\\*/\nSnap.acos = function (num) {\n    return Snap.deg(math.acos(num));\n};\n/*\\\n * Snap.atan\n [ method ]\n **\n * Equivalent to `Math.atan()` only works with degrees, not radians.\n - num (number) value\n = (number) atan in degrees\n\\*/\nSnap.atan = function (num) {\n    return Snap.deg(math.atan(num));\n};\n/*\\\n * Snap.atan2\n [ method ]\n **\n * Equivalent to `Math.atan2()` only works with degrees, not radians.\n - num (number) value\n = (number) atan2 in degrees\n\\*/\nSnap.atan2 = function (num) {\n    return Snap.deg(math.atan2(num));\n};\n/*\\\n * Snap.angle\n [ method ]\n **\n * Returns an angle between two or three points\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n - x3 (number) #optional x coord of third point\n - y3 (number) #optional y coord of third point\n = (number) angle in degrees\n\\*/\nSnap.angle = angle;\n/*\\\n * Snap.len\n [ method ]\n **\n * Returns distance between two points\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n = (number) distance\n\\*/\nSnap.len = function (x1, y1, x2, y2) {\n    return Math.sqrt(Snap.len2(x1, y1, x2, y2));\n};\n/*\\\n * Snap.len2\n [ method ]\n **\n * Returns squared distance between two points\n - x1 (number) x coord of first point\n - y1 (number) y coord of first point\n - x2 (number) x coord of second point\n - y2 (number) y coord of second point\n = (number) distance\n\\*/\nSnap.len2 = function (x1, y1, x2, y2) {\n    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n};\n/*\\\n * Snap.closestPoint\n [ method ]\n **\n * Returns closest point to a given one on a given path.\n - path (Element) path element\n - x (number) x coord of a point\n - y (number) y coord of a point\n = (object) in format\n {\n    x (number) x coord of the point on the path\n    y (number) y coord of the point on the path\n    length (number) length of the path to the point\n    distance (number) distance from the given point to the path\n }\n\\*/\n// Copied from http://bl.ocks.org/mbostock/8027637\nSnap.closestPoint = function (path, x, y) {\n    function distance2(p) {\n        var dx = p.x - x,\n            dy = p.y - y;\n        return dx * dx + dy * dy;\n    }\n    var pathNode = path.node,\n        pathLength = pathNode.getTotalLength(),\n        precision = pathLength / pathNode.pathSegList.numberOfItems * .125,\n        best,\n        bestLength,\n        bestDistance = Infinity;\n\n    // linear scan for coarse approximation\n    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {\n        if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {\n            best = scan;\n            bestLength = scanLength;\n            bestDistance = scanDistance;\n        }\n    }\n\n    // binary search for precise estimate\n    precision *= .5;\n    while (precision > .5) {\n        var before,\n            after,\n            beforeLength,\n            afterLength,\n            beforeDistance,\n            afterDistance;\n        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {\n            best = before;\n            bestLength = beforeLength;\n            bestDistance = beforeDistance;\n        } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {\n            best = after;\n            bestLength = afterLength;\n            bestDistance = afterDistance;\n        } else {\n            precision *= .5;\n        }\n    }\n\n    best = {\n        x: best.x,\n        y: best.y,\n        length: bestLength,\n        distance: Math.sqrt(bestDistance)\n    };\n    return best;\n}\n/*\\\n * Snap.is\n [ method ]\n **\n * Handy replacement for the `typeof` operator\n - o () any object or primitive\n - type (string) name of the type, e.g., `string`, `function`, `number`, etc.\n = (boolean) `true` if given value is of given type\n\\*/\nSnap.is = is;\n/*\\\n * Snap.snapTo\n [ method ]\n **\n * Snaps given value to given grid\n - values (array|number) given array of values or step of the grid\n - value (number) value to adjust\n - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.\n = (number) adjusted value\n\\*/\nSnap.snapTo = function (values, value, tolerance) {\n    tolerance = is(tolerance, \"finite\") ? tolerance : 10;\n    if (is(values, \"array\")) {\n        var i = values.length;\n        while (i--) if (abs(values[i] - value) <= tolerance) {\n            return values[i];\n        }\n    } else {\n        values = +values;\n        var rem = value % values;\n        if (rem < tolerance) {\n            return value - rem;\n        }\n        if (rem > values - tolerance) {\n            return value - rem + values;\n        }\n    }\n    return value;\n};\n// Colour\n/*\\\n * Snap.getRGB\n [ method ]\n **\n * Parses color string as RGB object\n - color (string) color string in one of the following formats:\n # <ul>\n #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>\n #     <li>#  shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>\n #     <li>#  full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>\n #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>\n #     <li>rgba(, , , )  also with opacity</li>\n #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>\n #     <li>rgba(%, %, %, %)  also with opacity</li>\n #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>\n #     <li>hsba(, , , )  also with opacity</li>\n #     <li>hsb(%, %, %)  same as above, but in %</li>\n #     <li>hsba(%, %, %, %)  also with opacity</li>\n #     <li>hsl(, , )  hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>\n #     <li>hsla(, , , )  also with opacity</li>\n #     <li>hsl(%, %, %)  same as above, but in %</li>\n #     <li>hsla(%, %, %, %)  also with opacity</li>\n # </ul>\n * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #,\n o     error (boolean) true if string can't be parsed\n o }\n\\*/\nSnap.getRGB = cacher(function (colour) {\n    if (!colour || !!((colour = Str(colour)).indexOf(\"-\") + 1)) {\n        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n    }\n    if (colour == \"none\") {\n        return {r: -1, g: -1, b: -1, hex: \"none\", toString: rgbtoString};\n    }\n    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == \"#\") && (colour = toHex(colour));\n    if (!colour) {\n        return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n    }\n    var res,\n        red,\n        green,\n        blue,\n        opacity,\n        t,\n        values,\n        rgb = colour.match(colourRegExp);\n    if (rgb) {\n        if (rgb[2]) {\n            blue = toInt(rgb[2].substring(5), 16);\n            green = toInt(rgb[2].substring(3, 5), 16);\n            red = toInt(rgb[2].substring(1, 3), 16);\n        }\n        if (rgb[3]) {\n            blue = toInt((t = rgb[3].charAt(3)) + t, 16);\n            green = toInt((t = rgb[3].charAt(2)) + t, 16);\n            red = toInt((t = rgb[3].charAt(1)) + t, 16);\n        }\n        if (rgb[4]) {\n            values = rgb[4].split(commaSpaces);\n            red = toFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red *= 2.55);\n            green = toFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green *= 2.55);\n            blue = toFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue *= 2.55);\n            rgb[1].toLowerCase().slice(0, 4) == \"rgba\" && (opacity = toFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n        }\n        if (rgb[5]) {\n            values = rgb[5].split(commaSpaces);\n            red = toFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red /= 100);\n            green = toFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green /= 100);\n            blue = toFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue /= 100);\n            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n            rgb[1].toLowerCase().slice(0, 4) == \"hsba\" && (opacity = toFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n            return Snap.hsb2rgb(red, green, blue, opacity);\n        }\n        if (rgb[6]) {\n            values = rgb[6].split(commaSpaces);\n            red = toFloat(values[0]);\n            values[0].slice(-1) == \"%\" && (red /= 100);\n            green = toFloat(values[1]);\n            values[1].slice(-1) == \"%\" && (green /= 100);\n            blue = toFloat(values[2]);\n            values[2].slice(-1) == \"%\" && (blue /= 100);\n            (values[0].slice(-3) == \"deg\" || values[0].slice(-1) == \"\\xb0\") && (red /= 360);\n            rgb[1].toLowerCase().slice(0, 4) == \"hsla\" && (opacity = toFloat(values[3]));\n            values[3] && values[3].slice(-1) == \"%\" && (opacity /= 100);\n            return Snap.hsl2rgb(red, green, blue, opacity);\n        }\n        red = mmin(math.round(red), 255);\n        green = mmin(math.round(green), 255);\n        blue = mmin(math.round(blue), 255);\n        opacity = mmin(mmax(opacity, 0), 1);\n        rgb = {r: red, g: green, b: blue, toString: rgbtoString};\n        rgb.hex = \"#\" + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1);\n        rgb.opacity = is(opacity, \"finite\") ? opacity : 1;\n        return rgb;\n    }\n    return {r: -1, g: -1, b: -1, hex: \"none\", error: 1, toString: rgbtoString};\n}, Snap);\n/*\\\n * Snap.hsb\n [ method ]\n **\n * Converts HSB values to a hex representation of the color\n - h (number) hue\n - s (number) saturation\n - b (number) value or brightness\n = (string) hex representation of the color\n\\*/\nSnap.hsb = cacher(function (h, s, b) {\n    return Snap.hsb2rgb(h, s, b).hex;\n});\n/*\\\n * Snap.hsl\n [ method ]\n **\n * Converts HSL values to a hex representation of the color\n - h (number) hue\n - s (number) saturation\n - l (number) luminosity\n = (string) hex representation of the color\n\\*/\nSnap.hsl = cacher(function (h, s, l) {\n    return Snap.hsl2rgb(h, s, l).hex;\n});\n/*\\\n * Snap.rgb\n [ method ]\n **\n * Converts RGB values to a hex representation of the color\n - r (number) red\n - g (number) green\n - b (number) blue\n = (string) hex representation of the color\n\\*/\nSnap.rgb = cacher(function (r, g, b, o) {\n    if (is(o, \"finite\")) {\n        var round = math.round;\n        return \"rgba(\" + [round(r), round(g), round(b), +o.toFixed(2)] + \")\";\n    }\n    return \"#\" + (16777216 | b | g << 8 | r << 16).toString(16).slice(1);\n});\nvar toHex = function (color) {\n    var i = glob.doc.getElementsByTagName(\"head\")[0] || glob.doc.getElementsByTagName(\"svg\")[0],\n        red = \"rgb(255, 0, 0)\";\n    toHex = cacher(function (color) {\n        if (color.toLowerCase() == \"red\") {\n            return red;\n        }\n        i.style.color = red;\n        i.style.color = color;\n        var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue(\"color\");\n        return out == red ? null : out;\n    });\n    return toHex(color);\n},\nhsbtoString = function () {\n    return \"hsb(\" + [this.h, this.s, this.b] + \")\";\n},\nhsltoString = function () {\n    return \"hsl(\" + [this.h, this.s, this.l] + \")\";\n},\nrgbtoString = function () {\n    return this.opacity == 1 || this.opacity == null ?\n            this.hex :\n            \"rgba(\" + [this.r, this.g, this.b, this.opacity] + \")\";\n},\nprepareRGB = function (r, g, b) {\n    if (g == null && is(r, \"object\") && \"r\" in r && \"g\" in r && \"b\" in r) {\n        b = r.b;\n        g = r.g;\n        r = r.r;\n    }\n    if (g == null && is(r, string)) {\n        var clr = Snap.getRGB(r);\n        r = clr.r;\n        g = clr.g;\n        b = clr.b;\n    }\n    if (r > 1 || g > 1 || b > 1) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n    }\n\n    return [r, g, b];\n},\npackageRGB = function (r, g, b, o) {\n    r = math.round(r * 255);\n    g = math.round(g * 255);\n    b = math.round(b * 255);\n    var rgb = {\n        r: r,\n        g: g,\n        b: b,\n        opacity: is(o, \"finite\") ? o : 1,\n        hex: Snap.rgb(r, g, b),\n        toString: rgbtoString\n    };\n    is(o, \"finite\") && (rgb.opacity = o);\n    return rgb;\n};\n/*\\\n * Snap.color\n [ method ]\n **\n * Parses the color string and returns an object featuring the color's component values\n - clr (string) color string in one of the supported formats (see @Snap.getRGB)\n = (object) Combined RGB/HSB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #,\n o     error (boolean) `true` if string can't be parsed,\n o     h (number) hue,\n o     s (number) saturation,\n o     v (number) value (brightness),\n o     l (number) lightness\n o }\n\\*/\nSnap.color = function (clr) {\n    var rgb;\n    if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"b\" in clr) {\n        rgb = Snap.hsb2rgb(clr);\n        clr.r = rgb.r;\n        clr.g = rgb.g;\n        clr.b = rgb.b;\n        clr.opacity = 1;\n        clr.hex = rgb.hex;\n    } else if (is(clr, \"object\") && \"h\" in clr && \"s\" in clr && \"l\" in clr) {\n        rgb = Snap.hsl2rgb(clr);\n        clr.r = rgb.r;\n        clr.g = rgb.g;\n        clr.b = rgb.b;\n        clr.opacity = 1;\n        clr.hex = rgb.hex;\n    } else {\n        if (is(clr, \"string\")) {\n            clr = Snap.getRGB(clr);\n        }\n        if (is(clr, \"object\") && \"r\" in clr && \"g\" in clr && \"b\" in clr && !(\"error\" in clr)) {\n            rgb = Snap.rgb2hsl(clr);\n            clr.h = rgb.h;\n            clr.s = rgb.s;\n            clr.l = rgb.l;\n            rgb = Snap.rgb2hsb(clr);\n            clr.v = rgb.b;\n        } else {\n            clr = {hex: \"none\"};\n            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;\n            clr.error = 1;\n        }\n    }\n    clr.toString = rgbtoString;\n    return clr;\n};\n/*\\\n * Snap.hsb2rgb\n [ method ]\n **\n * Converts HSB values to an RGB object\n - h (number) hue\n - s (number) saturation\n - v (number) value or brightness\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #\n o }\n\\*/\nSnap.hsb2rgb = function (h, s, v, o) {\n    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"b\" in h) {\n        v = h.b;\n        s = h.s;\n        o = h.o;\n        h = h.h;\n    }\n    h *= 360;\n    var R, G, B, X, C;\n    h = h % 360 / 60;\n    C = v * s;\n    X = C * (1 - abs(h % 2 - 1));\n    R = G = B = v - C;\n\n    h = ~~h;\n    R += [C, X, 0, 0, X, C][h];\n    G += [X, C, C, X, 0, 0][h];\n    B += [0, 0, X, C, C, X][h];\n    return packageRGB(R, G, B, o);\n};\n/*\\\n * Snap.hsl2rgb\n [ method ]\n **\n * Converts HSL values to an RGB object\n - h (number) hue\n - s (number) saturation\n - l (number) luminosity\n = (object) RGB object in the following format:\n o {\n o     r (number) red,\n o     g (number) green,\n o     b (number) blue,\n o     hex (string) color in HTML/CSS format: #\n o }\n\\*/\nSnap.hsl2rgb = function (h, s, l, o) {\n    if (is(h, \"object\") && \"h\" in h && \"s\" in h && \"l\" in h) {\n        l = h.l;\n        s = h.s;\n        h = h.h;\n    }\n    if (h > 1 || s > 1 || l > 1) {\n        h /= 360;\n        s /= 100;\n        l /= 100;\n    }\n    h *= 360;\n    var R, G, B, X, C;\n    h = h % 360 / 60;\n    C = 2 * s * (l < .5 ? l : 1 - l);\n    X = C * (1 - abs(h % 2 - 1));\n    R = G = B = l - C / 2;\n\n    h = ~~h;\n    R += [C, X, 0, 0, X, C][h];\n    G += [X, C, C, X, 0, 0][h];\n    B += [0, 0, X, C, C, X][h];\n    return packageRGB(R, G, B, o);\n};\n/*\\\n * Snap.rgb2hsb\n [ method ]\n **\n * Converts RGB values to an HSB object\n - r (number) red\n - g (number) green\n - b (number) blue\n = (object) HSB object in the following format:\n o {\n o     h (number) hue,\n o     s (number) saturation,\n o     b (number) brightness\n o }\n\\*/\nSnap.rgb2hsb = function (r, g, b) {\n    b = prepareRGB(r, g, b);\n    r = b[0];\n    g = b[1];\n    b = b[2];\n\n    var H, S, V, C;\n    V = mmax(r, g, b);\n    C = V - mmin(r, g, b);\n    H = C == 0 ? null :\n        V == r ? (g - b) / C :\n        V == g ? (b - r) / C + 2 :\n                 (r - g) / C + 4;\n    H = (H + 360) % 6 * 60 / 360;\n    S = C == 0 ? 0 : C / V;\n    return {h: H, s: S, b: V, toString: hsbtoString};\n};\n/*\\\n * Snap.rgb2hsl\n [ method ]\n **\n * Converts RGB values to an HSL object\n - r (number) red\n - g (number) green\n - b (number) blue\n = (object) HSL object in the following format:\n o {\n o     h (number) hue,\n o     s (number) saturation,\n o     l (number) luminosity\n o }\n\\*/\nSnap.rgb2hsl = function (r, g, b) {\n    b = prepareRGB(r, g, b);\n    r = b[0];\n    g = b[1];\n    b = b[2];\n\n    var H, S, L, M, m, C;\n    M = mmax(r, g, b);\n    m = mmin(r, g, b);\n    C = M - m;\n    H = C == 0 ? null :\n        M == r ? (g - b) / C :\n        M == g ? (b - r) / C + 2 :\n                 (r - g) / C + 4;\n    H = (H + 360) % 6 * 60 / 360;\n    L = (M + m) / 2;\n    S = C == 0 ? 0 :\n         L < .5 ? C / (2 * L) :\n                  C / (2 - 2 * L);\n    return {h: H, s: S, l: L, toString: hsltoString};\n};\n\n// Transformations\n/*\\\n * Snap.parsePathString\n [ method ]\n **\n * Utility method\n **\n * Parses given path string into an array of arrays of path segments\n - pathString (string|array) path string or array of segments (in the last case it is returned straight away)\n = (array) array of segments\n\\*/\nSnap.parsePathString = function (pathString) {\n    if (!pathString) {\n        return null;\n    }\n    var pth = Snap.path(pathString);\n    if (pth.arr) {\n        return Snap.path.clone(pth.arr);\n    }\n\n    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},\n        data = [];\n    if (is(pathString, \"array\") && is(pathString[0], \"array\")) { // rough assumption\n        data = Snap.path.clone(pathString);\n    }\n    if (!data.length) {\n        Str(pathString).replace(pathCommand, function (a, b, c) {\n            var params = [],\n                name = b.toLowerCase();\n            c.replace(pathValues, function (a, b) {\n                b && params.push(+b);\n            });\n            if (name == \"m\" && params.length > 2) {\n                data.push([b].concat(params.splice(0, 2)));\n                name = \"l\";\n                b = b == \"m\" ? \"l\" : \"L\";\n            }\n            if (name == \"o\" && params.length == 1) {\n                data.push([b, params[0]]);\n            }\n            if (name == \"r\") {\n                data.push([b].concat(params));\n            } else while (params.length >= paramCounts[name]) {\n                data.push([b].concat(params.splice(0, paramCounts[name])));\n                if (!paramCounts[name]) {\n                    break;\n                }\n            }\n        });\n    }\n    data.toString = Snap.path.toString;\n    pth.arr = Snap.path.clone(data);\n    return data;\n};\n/*\\\n * Snap.parseTransformString\n [ method ]\n **\n * Utility method\n **\n * Parses given transform string into an array of transformations\n - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)\n = (array) array of transformations\n\\*/\nvar parseTransformString = Snap.parseTransformString = function (TString) {\n    if (!TString) {\n        return null;\n    }\n    var paramCounts = {r: 3, s: 4, t: 2, m: 6},\n        data = [];\n    if (is(TString, \"array\") && is(TString[0], \"array\")) { // rough assumption\n        data = Snap.path.clone(TString);\n    }\n    if (!data.length) {\n        Str(TString).replace(tCommand, function (a, b, c) {\n            var params = [],\n                name = b.toLowerCase();\n            c.replace(pathValues, function (a, b) {\n                b && params.push(+b);\n            });\n            data.push([b].concat(params));\n        });\n    }\n    data.toString = Snap.path.toString;\n    return data;\n};\nfunction svgTransform2string(tstr) {\n    var res = [];\n    tstr = tstr.replace(/(?:^|\\s)(\\w+)\\(([^)]+)\\)/g, function (all, name, params) {\n        params = params.split(/\\s*,\\s*|\\s+/);\n        if (name == \"rotate\" && params.length == 1) {\n            params.push(0, 0);\n        }\n        if (name == \"scale\") {\n            if (params.length > 2) {\n                params = params.slice(0, 2);\n            } else if (params.length == 2) {\n                params.push(0, 0);\n            }\n            if (params.length == 1) {\n                params.push(params[0], 0, 0);\n            }\n        }\n        if (name == \"skewX\") {\n            res.push([\"m\", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);\n        } else if (name == \"skewY\") {\n            res.push([\"m\", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);\n        } else {\n            res.push([name.charAt(0)].concat(params));\n        }\n        return all;\n    });\n    return res;\n}\nSnap._.svgTransform2string = svgTransform2string;\nSnap._.rgTransform = /^[a-z][\\s]*-?\\.?\\d/i;\nfunction transform2matrix(tstr, bbox) {\n    var tdata = parseTransformString(tstr),\n        m = new Snap.Matrix;\n    if (tdata) {\n        for (var i = 0, ii = tdata.length; i < ii; i++) {\n            var t = tdata[i],\n                tlen = t.length,\n                command = Str(t[0]).toLowerCase(),\n                absolute = t[0] != command,\n                inver = absolute ? m.invert() : 0,\n                x1,\n                y1,\n                x2,\n                y2,\n                bb;\n            if (command == \"t\" && tlen == 2){\n                m.translate(t[1], 0);\n            } else if (command == \"t\" && tlen == 3) {\n                if (absolute) {\n                    x1 = inver.x(0, 0);\n                    y1 = inver.y(0, 0);\n                    x2 = inver.x(t[1], t[2]);\n                    y2 = inver.y(t[1], t[2]);\n                    m.translate(x2 - x1, y2 - y1);\n                } else {\n                    m.translate(t[1], t[2]);\n                }\n            } else if (command == \"r\") {\n                if (tlen == 2) {\n                    bb = bb || bbox;\n                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                } else if (tlen == 4) {\n                    if (absolute) {\n                        x2 = inver.x(t[2], t[3]);\n                        y2 = inver.y(t[2], t[3]);\n                        m.rotate(t[1], x2, y2);\n                    } else {\n                        m.rotate(t[1], t[2], t[3]);\n                    }\n                }\n            } else if (command == \"s\") {\n                if (tlen == 2 || tlen == 3) {\n                    bb = bb || bbox;\n                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);\n                } else if (tlen == 4) {\n                    if (absolute) {\n                        x2 = inver.x(t[2], t[3]);\n                        y2 = inver.y(t[2], t[3]);\n                        m.scale(t[1], t[1], x2, y2);\n                    } else {\n                        m.scale(t[1], t[1], t[2], t[3]);\n                    }\n                } else if (tlen == 5) {\n                    if (absolute) {\n                        x2 = inver.x(t[3], t[4]);\n                        y2 = inver.y(t[3], t[4]);\n                        m.scale(t[1], t[2], x2, y2);\n                    } else {\n                        m.scale(t[1], t[2], t[3], t[4]);\n                    }\n                }\n            } else if (command == \"m\" && tlen == 7) {\n                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);\n            }\n        }\n    }\n    return m;\n}\nSnap._.transform2matrix = transform2matrix;\nSnap._unit2px = unit2px;\nvar contains = glob.doc.contains || glob.doc.compareDocumentPosition ?\n    function (a, b) {\n        var adown = a.nodeType == 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n            return a == bup || !!(bup && bup.nodeType == 1 && (\n                adown.contains ?\n                    adown.contains(bup) :\n                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16\n            ));\n    } :\n    function (a, b) {\n        if (b) {\n            while (b) {\n                b = b.parentNode;\n                if (b == a) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\nfunction getSomeDefs(el) {\n    var p = el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) ||\n            el.node.parentNode && wrap(el.node.parentNode) ||\n            Snap.select(\"svg\") ||\n            Snap(0, 0),\n        pdefs = p.select(\"defs\"),\n        defs  = pdefs == null ? false : pdefs.node;\n    if (!defs) {\n        defs = make(\"defs\", p.node).node;\n    }\n    return defs;\n}\nfunction getSomeSVG(el) {\n    return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select(\"svg\");\n}\nSnap._.getSomeDefs = getSomeDefs;\nSnap._.getSomeSVG = getSomeSVG;\nfunction unit2px(el, name, value) {\n    var svg = getSomeSVG(el).node,\n        out = {},\n        mgr = svg.querySelector(\".svg---mgr\");\n    if (!mgr) {\n        mgr = $(\"rect\");\n        $(mgr, {x: -9e9, y: -9e9, width: 10, height: 10, \"class\": \"svg---mgr\", fill: \"none\"});\n        svg.appendChild(mgr);\n    }\n    function getW(val) {\n        if (val == null) {\n            return E;\n        }\n        if (val == +val) {\n            return val;\n        }\n        $(mgr, {width: val});\n        try {\n            return mgr.getBBox().width;\n        } catch (e) {\n            return 0;\n        }\n    }\n    function getH(val) {\n        if (val == null) {\n            return E;\n        }\n        if (val == +val) {\n            return val;\n        }\n        $(mgr, {height: val});\n        try {\n            return mgr.getBBox().height;\n        } catch (e) {\n            return 0;\n        }\n    }\n    function set(nam, f) {\n        if (name == null) {\n            out[nam] = f(el.attr(nam) || 0);\n        } else if (nam == name) {\n            out = f(value == null ? el.attr(nam) || 0 : value);\n        }\n    }\n    switch (el.type) {\n        case \"rect\":\n            set(\"rx\", getW);\n            set(\"ry\", getH);\n        case \"image\":\n            set(\"width\", getW);\n            set(\"height\", getH);\n        case \"text\":\n            set(\"x\", getW);\n            set(\"y\", getH);\n        break;\n        case \"circle\":\n            set(\"cx\", getW);\n            set(\"cy\", getH);\n            set(\"r\", getW);\n        break;\n        case \"ellipse\":\n            set(\"cx\", getW);\n            set(\"cy\", getH);\n            set(\"rx\", getW);\n            set(\"ry\", getH);\n        break;\n        case \"line\":\n            set(\"x1\", getW);\n            set(\"x2\", getW);\n            set(\"y1\", getH);\n            set(\"y2\", getH);\n        break;\n        case \"marker\":\n            set(\"refX\", getW);\n            set(\"markerWidth\", getW);\n            set(\"refY\", getH);\n            set(\"markerHeight\", getH);\n        break;\n        case \"radialGradient\":\n            set(\"fx\", getW);\n            set(\"fy\", getH);\n        break;\n        case \"tspan\":\n            set(\"dx\", getW);\n            set(\"dy\", getH);\n        break;\n        default:\n            set(name, getW);\n    }\n    svg.removeChild(mgr);\n    return out;\n}\n/*\\\n * Snap.select\n [ method ]\n **\n * Wraps a DOM element specified by CSS selector as @Element\n - query (string) CSS selector of the element\n = (Element) the current element\n\\*/\nSnap.select = function (query) {\n    query = Str(query).replace(/([^\\\\]):/g, \"$1\\\\:\");\n    return wrap(glob.doc.querySelector(query));\n};\n/*\\\n * Snap.selectAll\n [ method ]\n **\n * Wraps DOM elements specified by CSS selector as set or array of @Element\n - query (string) CSS selector of the element\n = (Element) the current element\n\\*/\nSnap.selectAll = function (query) {\n    var nodelist = glob.doc.querySelectorAll(query),\n        set = (Snap.set || Array)();\n    for (var i = 0; i < nodelist.length; i++) {\n        set.push(wrap(nodelist[i]));\n    }\n    return set;\n};\n\nfunction add2group(list) {\n    if (!is(list, \"array\")) {\n        list = Array.prototype.slice.call(arguments, 0);\n    }\n    var i = 0,\n        j = 0,\n        node = this.node;\n    while (this[i]) delete this[i++];\n    for (i = 0; i < list.length; i++) {\n        if (list[i].type == \"set\") {\n            list[i].forEach(function (el) {\n                node.appendChild(el.node);\n            });\n        } else {\n            node.appendChild(list[i].node);\n        }\n    }\n    var children = node.childNodes;\n    for (i = 0; i < children.length; i++) {\n        this[j++] = wrap(children[i]);\n    }\n    return this;\n}\n// Hub garbage collector every 10s\nsetInterval(function () {\n    for (var key in hub) if (hub[has](key)) {\n        var el = hub[key],\n            node = el.node;\n        if (el.type != \"svg\" && !node.ownerSVGElement || el.type == \"svg\" && (!node.parentNode || \"ownerSVGElement\" in node.parentNode && !node.ownerSVGElement)) {\n            delete hub[key];\n        }\n    }\n}, 1e4);\nfunction Element(el) {\n    if (el.snap in hub) {\n        return hub[el.snap];\n    }\n    var svg;\n    try {\n        svg = el.ownerSVGElement;\n    } catch(e) {}\n    /*\\\n     * Element.node\n     [ property (object) ]\n     **\n     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.\n     > Usage\n     | // draw a circle at coordinate 10,10 with radius of 10\n     | var c = paper.circle(10, 10, 10);\n     | c.node.onclick = function () {\n     |     c.attr(\"fill\", \"red\");\n     | };\n    \\*/\n    this.node = el;\n    if (svg) {\n        this.paper = new Paper(svg);\n    }\n    /*\\\n     * Element.type\n     [ property (string) ]\n     **\n     * SVG tag name of the given element.\n    \\*/\n    this.type = el.tagName || el.nodeName;\n    var id = this.id = ID(this);\n    this.anims = {};\n    this._ = {\n        transform: []\n    };\n    el.snap = id;\n    hub[id] = this;\n    if (this.type == \"g\") {\n        this.add = add2group;\n    }\n    if (this.type in {g: 1, mask: 1, pattern: 1, symbol: 1}) {\n        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {\n            this[method] = Paper.prototype[method];\n        }\n    }\n}\n   /*\\\n     * Element.attr\n     [ method ]\n     **\n     * Gets or sets given attributes of the element.\n     **\n     - params (object) contains key-value pairs of attributes you want to set\n     * or\n     - param (string) name of the attribute\n     = (Element) the current element\n     * or\n     = (string) value of attribute\n     > Usage\n     | el.attr({\n     |     fill: \"#fc0\",\n     |     stroke: \"#000\",\n     |     strokeWidth: 2, // CamelCase...\n     |     \"fill-opacity\": 0.5, // or dash-separated names\n     |     width: \"*=2\" // prefixed values\n     | });\n     | console.log(el.attr(\"fill\")); // #fc0\n     * Prefixed values in format `\"+=10\"` supported. All four operations\n     * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`\n     * and `-`: `\"+=2em\"`.\n    \\*/\n    Element.prototype.attr = function (params, value) {\n        var el = this,\n            node = el.node;\n        if (!params) {\n            if (node.nodeType != 1) {\n                return {\n                    text: node.nodeValue\n                };\n            }\n            var attr = node.attributes,\n                out = {};\n            for (var i = 0, ii = attr.length; i < ii; i++) {\n                out[attr[i].nodeName] = attr[i].nodeValue;\n            }\n            return out;\n        }\n        if (is(params, \"string\")) {\n            if (arguments.length > 1) {\n                var json = {};\n                json[params] = value;\n                params = json;\n            } else {\n                return eve(\"snap.util.getattr.\" + params, el).firstDefined();\n            }\n        }\n        for (var att in params) {\n            if (params[has](att)) {\n                eve(\"snap.util.attr.\" + att, el, params[att]);\n            }\n        }\n        return el;\n    };\n/*\\\n * Snap.parse\n [ method ]\n **\n * Parses SVG fragment and converts it into a @Fragment\n **\n - svg (string) SVG string\n = (Fragment) the @Fragment\n\\*/\nSnap.parse = function (svg) {\n    var f = glob.doc.createDocumentFragment(),\n        full = true,\n        div = glob.doc.createElement(\"div\");\n    svg = Str(svg);\n    if (!svg.match(/^\\s*<\\s*svg(?:\\s|>)/)) {\n        svg = \"<svg>\" + svg + \"</svg>\";\n        full = false;\n    }\n    div.innerHTML = svg;\n    svg = div.getElementsByTagName(\"svg\")[0];\n    if (svg) {\n        if (full) {\n            f = svg;\n        } else {\n            while (svg.firstChild) {\n                f.appendChild(svg.firstChild);\n            }\n        }\n    }\n    return new Fragment(f);\n};\nfunction Fragment(frag) {\n    this.node = frag;\n}\n/*\\\n * Snap.fragment\n [ method ]\n **\n * Creates a DOM fragment from a given list of elements or strings\n **\n - varargs () SVG string\n = (Fragment) the @Fragment\n\\*/\nSnap.fragment = function () {\n    var args = Array.prototype.slice.call(arguments, 0),\n        f = glob.doc.createDocumentFragment();\n    for (var i = 0, ii = args.length; i < ii; i++) {\n        var item = args[i];\n        if (item.node && item.node.nodeType) {\n            f.appendChild(item.node);\n        }\n        if (item.nodeType) {\n            f.appendChild(item);\n        }\n        if (typeof item == \"string\") {\n            f.appendChild(Snap.parse(item).node);\n        }\n    }\n    return new Fragment(f);\n};\n\nfunction make(name, parent) {\n    var res = $(name);\n    parent.appendChild(res);\n    var el = wrap(res);\n    return el;\n}\nfunction Paper(w, h) {\n    var res,\n        desc,\n        defs,\n        proto = Paper.prototype;\n    if (w && w.tagName && w.tagName.toLowerCase() == \"svg\") {\n        if (w.snap in hub) {\n            return hub[w.snap];\n        }\n        var doc = w.ownerDocument;\n        res = new Element(w);\n        desc = w.getElementsByTagName(\"desc\")[0];\n        defs = w.getElementsByTagName(\"defs\")[0];\n        if (!desc) {\n            desc = $(\"desc\");\n            desc.appendChild(doc.createTextNode(\"Created with Snap\"));\n            res.node.appendChild(desc);\n        }\n        if (!defs) {\n            defs = $(\"defs\");\n            res.node.appendChild(defs);\n        }\n        res.defs = defs;\n        for (var key in proto) if (proto[has](key)) {\n            res[key] = proto[key];\n        }\n        res.paper = res.root = res;\n    } else {\n        res = make(\"svg\", glob.doc.body);\n        $(res.node, {\n            height: h,\n            version: 1.1,\n            width: w,\n            xmlns: xmlns\n        });\n    }\n    return res;\n}\nfunction wrap(dom) {\n    if (!dom) {\n        return dom;\n    }\n    if (dom instanceof Element || dom instanceof Fragment) {\n        return dom;\n    }\n    if (dom.tagName && dom.tagName.toLowerCase() == \"svg\") {\n        return new Paper(dom);\n    }\n    if (dom.tagName && dom.tagName.toLowerCase() == \"object\" && dom.type == \"image/svg+xml\") {\n        return new Paper(dom.contentDocument.getElementsByTagName(\"svg\")[0]);\n    }\n    return new Element(dom);\n}\n\nSnap._.make = make;\nSnap._.wrap = wrap;\n/*\\\n * Paper.el\n [ method ]\n **\n * Creates an element on paper with a given name and no attributes\n **\n - name (string) tag name\n - attr (object) attributes\n = (Element) the current element\n > Usage\n | var c = paper.circle(10, 10, 10); // is the same as...\n | var c = paper.el(\"circle\").attr({\n |     cx: 10,\n |     cy: 10,\n |     r: 10\n | });\n | // and the same as\n | var c = paper.el(\"circle\", {\n |     cx: 10,\n |     cy: 10,\n |     r: 10\n | });\n\\*/\nPaper.prototype.el = function (name, attr) {\n    var el = make(name, this.node);\n    attr && el.attr(attr);\n    return el;\n};\n/*\\\n * Element.children\n [ method ]\n **\n * Returns array of all the children of the element.\n = (array) array of Elements\n\\*/\nElement.prototype.children = function () {\n    var out = [],\n        ch = this.node.childNodes;\n    for (var i = 0, ii = ch.length; i < ii; i++) {\n        out[i] = Snap(ch[i]);\n    }\n    return out;\n};\nfunction jsonFiller(root, o) {\n    for (var i = 0, ii = root.length; i < ii; i++) {\n        var item = {\n                type: root[i].type,\n                attr: root[i].attr()\n            },\n            children = root[i].children();\n        o.push(item);\n        if (children.length) {\n            jsonFiller(children, item.childNodes = []);\n        }\n    }\n}\n/*\\\n * Element.toJSON\n [ method ]\n **\n * Returns object representation of the given element and all its children.\n = (object) in format\n o {\n o     type (string) this.type,\n o     attr (object) attributes map,\n o     childNodes (array) optional array of children in the same format\n o }\n\\*/\nElement.prototype.toJSON = function () {\n    var out = [];\n    jsonFiller([this], out);\n    return out[0];\n};\n// default\neve.on(\"snap.util.getattr\", function () {\n    var att = eve.nt();\n    att = att.substring(att.lastIndexOf(\".\") + 1);\n    var css = att.replace(/[A-Z]/g, function (letter) {\n        return \"-\" + letter.toLowerCase();\n    });\n    if (cssAttr[has](css)) {\n        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);\n    } else {\n        return $(this.node, att);\n    }\n});\nvar cssAttr = {\n    \"alignment-baseline\": 0,\n    \"baseline-shift\": 0,\n    \"clip\": 0,\n    \"clip-path\": 0,\n    \"clip-rule\": 0,\n    \"color\": 0,\n    \"color-interpolation\": 0,\n    \"color-interpolation-filters\": 0,\n    \"color-profile\": 0,\n    \"color-rendering\": 0,\n    \"cursor\": 0,\n    \"direction\": 0,\n    \"display\": 0,\n    \"dominant-baseline\": 0,\n    \"enable-background\": 0,\n    \"fill\": 0,\n    \"fill-opacity\": 0,\n    \"fill-rule\": 0,\n    \"filter\": 0,\n    \"flood-color\": 0,\n    \"flood-opacity\": 0,\n    \"font\": 0,\n    \"font-family\": 0,\n    \"font-size\": 0,\n    \"font-size-adjust\": 0,\n    \"font-stretch\": 0,\n    \"font-style\": 0,\n    \"font-variant\": 0,\n    \"font-weight\": 0,\n    \"glyph-orientation-horizontal\": 0,\n    \"glyph-orientation-vertical\": 0,\n    \"image-rendering\": 0,\n    \"kerning\": 0,\n    \"letter-spacing\": 0,\n    \"lighting-color\": 0,\n    \"marker\": 0,\n    \"marker-end\": 0,\n    \"marker-mid\": 0,\n    \"marker-start\": 0,\n    \"mask\": 0,\n    \"opacity\": 0,\n    \"overflow\": 0,\n    \"pointer-events\": 0,\n    \"shape-rendering\": 0,\n    \"stop-color\": 0,\n    \"stop-opacity\": 0,\n    \"stroke\": 0,\n    \"stroke-dasharray\": 0,\n    \"stroke-dashoffset\": 0,\n    \"stroke-linecap\": 0,\n    \"stroke-linejoin\": 0,\n    \"stroke-miterlimit\": 0,\n    \"stroke-opacity\": 0,\n    \"stroke-width\": 0,\n    \"text-anchor\": 0,\n    \"text-decoration\": 0,\n    \"text-rendering\": 0,\n    \"unicode-bidi\": 0,\n    \"visibility\": 0,\n    \"word-spacing\": 0,\n    \"writing-mode\": 0\n};\n\neve.on(\"snap.util.attr\", function (value) {\n    var att = eve.nt(),\n        attr = {};\n    att = att.substring(att.lastIndexOf(\".\") + 1);\n    attr[att] = value;\n    var style = att.replace(/-(\\w)/gi, function (all, letter) {\n            return letter.toUpperCase();\n        }),\n        css = att.replace(/[A-Z]/g, function (letter) {\n            return \"-\" + letter.toLowerCase();\n        });\n    if (cssAttr[has](css)) {\n        this.node.style[style] = value == null ? E : value;\n    } else {\n        $(this.node, attr);\n    }\n});\n(function (proto) {}(Paper.prototype));\n\n// simple ajax\n/*\\\n * Snap.ajax\n [ method ]\n **\n * Simple implementation of Ajax\n **\n - url (string) URL\n - postData (object|string) data for post request\n - callback (function) callback\n - scope (object) #optional scope of callback\n * or\n - url (string) URL\n - callback (function) callback\n - scope (object) #optional scope of callback\n = (XMLHttpRequest) the XMLHttpRequest object, just in case\n\\*/\nSnap.ajax = function (url, postData, callback, scope){\n    var req = new XMLHttpRequest,\n        id = ID();\n    if (req) {\n        if (is(postData, \"function\")) {\n            scope = callback;\n            callback = postData;\n            postData = null;\n        } else if (is(postData, \"object\")) {\n            var pd = [];\n            for (var key in postData) if (postData.hasOwnProperty(key)) {\n                pd.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(postData[key]));\n            }\n            postData = pd.join(\"&\");\n        }\n        req.open(postData ? \"POST\" : \"GET\", url, true);\n        if (postData) {\n            req.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n            req.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n        }\n        if (callback) {\n            eve.once(\"snap.ajax.\" + id + \".0\", callback);\n            eve.once(\"snap.ajax.\" + id + \".200\", callback);\n            eve.once(\"snap.ajax.\" + id + \".304\", callback);\n        }\n        req.onreadystatechange = function() {\n            if (req.readyState != 4) return;\n            eve(\"snap.ajax.\" + id + \".\" + req.status, scope, req);\n        };\n        if (req.readyState == 4) {\n            return req;\n        }\n        req.send(postData);\n        return req;\n    }\n};\n/*\\\n * Snap.load\n [ method ]\n **\n * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)\n **\n - url (string) URL\n - callback (function) callback\n - scope (object) #optional scope of callback\n\\*/\nSnap.load = function (url, callback, scope) {\n    Snap.ajax(url, function (req) {\n        var f = Snap.parse(req.responseText);\n        scope ? callback.call(scope, f) : callback(f);\n    });\n};\nvar getOffset = function (elem) {\n    var box = elem.getBoundingClientRect(),\n        doc = elem.ownerDocument,\n        body = doc.body,\n        docElem = doc.documentElement,\n        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,\n        top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,\n        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;\n    return {\n        y: top,\n        x: left\n    };\n};\n/*\\\n * Snap.getElementByPoint\n [ method ]\n **\n * Returns you topmost element under given point.\n **\n = (object) Snap element object\n - x (number) x coordinate from the top left corner of the window\n - y (number) y coordinate from the top left corner of the window\n > Usage\n | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: \"#f00\"});\n\\*/\nSnap.getElementByPoint = function (x, y) {\n    var paper = this,\n        svg = paper.canvas,\n        target = glob.doc.elementFromPoint(x, y);\n    if (glob.win.opera && target.tagName == \"svg\") {\n        var so = getOffset(target),\n            sr = target.createSVGRect();\n        sr.x = x - so.x;\n        sr.y = y - so.y;\n        sr.width = sr.height = 1;\n        var hits = target.getIntersectionList(sr, null);\n        if (hits.length) {\n            target = hits[hits.length - 1];\n        }\n    }\n    if (!target) {\n        return null;\n    }\n    return wrap(target);\n};\n/*\\\n * Snap.plugin\n [ method ]\n **\n * Let you write plugins. You pass in a function with five arguments, like this:\n | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {\n |     Snap.newmethod = function () {};\n |     Element.prototype.newmethod = function () {};\n |     Paper.prototype.newmethod = function () {};\n | });\n * Inside the function you have access to all main objects (and their\n * prototypes). This allow you to extend anything you want.\n **\n - f (function) your plugin body\n\\*/\nSnap.plugin = function (f) {\n    f(Snap, Element, Paper, glob, Fragment);\n};\nglob.win.Snap = Snap;\nreturn Snap;\n}(window || this));\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var elproto = Element.prototype,\n        is = Snap.is,\n        Str = String,\n        unit2px = Snap._unit2px,\n        $ = Snap._.$,\n        make = Snap._.make,\n        getSomeDefs = Snap._.getSomeDefs,\n        has = \"hasOwnProperty\",\n        wrap = Snap._.wrap;\n    /*\\\n     * Element.getBBox\n     [ method ]\n     **\n     * Returns the bounding box descriptor for the given element\n     **\n     = (object) bounding box descriptor:\n     o {\n     o     cx: (number) x of the center,\n     o     cy: (number) x of the center,\n     o     h: (number) height,\n     o     height: (number) height,\n     o     path: (string) path command for the box,\n     o     r0: (number) radius of a circle that fully encloses the box,\n     o     r1: (number) radius of the smallest circle that can be enclosed,\n     o     r2: (number) radius of the largest circle that can be enclosed,\n     o     vb: (string) box as a viewbox command,\n     o     w: (number) width,\n     o     width: (number) width,\n     o     x2: (number) x of the right side,\n     o     x: (number) x of the left side,\n     o     y2: (number) y of the bottom edge,\n     o     y: (number) y of the top edge\n     o }\n    \\*/\n    elproto.getBBox = function (isWithoutTransform) {\n        if (this.type == \"tspan\") {\n            return Snap._.box(this.node.getClientRects().item(0));\n        }\n        if (!Snap.Matrix || !Snap.path) {\n            return this.node.getBBox();\n        }\n        var el = this,\n            m = new Snap.Matrix;\n        if (el.removed) {\n            return Snap._.box();\n        }\n        while (el.type == \"use\") {\n            if (!isWithoutTransform) {\n                m = m.add(el.transform().localMatrix.translate(el.attr(\"x\") || 0, el.attr(\"y\") || 0));\n            }\n            if (el.original) {\n                el = el.original;\n            } else {\n                var href = el.attr(\"xlink:href\");\n                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf(\"#\") + 1));\n            }\n        }\n        var _ = el._,\n            pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;\n        try {\n            if (isWithoutTransform) {\n                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());\n                return Snap._.box(_.bboxwt);\n            } else {\n                el.realPath = pathfinder(el);\n                el.matrix = el.transform().localMatrix;\n                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));\n                return Snap._.box(_.bbox);\n            }\n        } catch (e) {\n            // Firefox doesnt give you bbox of hidden element\n            return Snap._.box();\n        }\n    };\n    var propString = function () {\n        return this.string;\n    };\n    function extractTransform(el, tstr) {\n        if (tstr == null) {\n            var doReturn = true;\n            if (el.type == \"linearGradient\" || el.type == \"radialGradient\") {\n                tstr = el.node.getAttribute(\"gradientTransform\");\n            } else if (el.type == \"pattern\") {\n                tstr = el.node.getAttribute(\"patternTransform\");\n            } else {\n                tstr = el.node.getAttribute(\"transform\");\n            }\n            if (!tstr) {\n                return new Snap.Matrix;\n            }\n            tstr = Snap._.svgTransform2string(tstr);\n        } else {\n            if (!Snap._.rgTransform.test(tstr)) {\n                tstr = Snap._.svgTransform2string(tstr);\n            } else {\n                tstr = Str(tstr).replace(/\\.{3}|\\u2026/g, el._.transform || \"\");\n            }\n            if (is(tstr, \"array\")) {\n                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);\n            }\n            el._.transform = tstr;\n        }\n        var m = Snap._.transform2matrix(tstr, el.getBBox(1));\n        if (doReturn) {\n            return m;\n        } else {\n            el.matrix = m;\n        }\n    }\n    /*\\\n     * Element.transform\n     [ method ]\n     **\n     * Gets or sets transformation of the element\n     **\n     - tstr (string) transform string in Snap or SVG format\n     = (Element) the current element\n     * or\n     = (object) transformation descriptor:\n     o {\n     o     string (string) transform string,\n     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,\n     o     localMatrix (Matrix) matrix of transformations applied only to the element,\n     o     diffMatrix (Matrix) matrix of difference between global and local transformations,\n     o     global (string) global transformation as string,\n     o     local (string) local transformation as string,\n     o     toString (function) returns `string` property\n     o }\n    \\*/\n    elproto.transform = function (tstr) {\n        var _ = this._;\n        if (tstr == null) {\n            var papa = this,\n                global = new Snap.Matrix(this.node.getCTM()),\n                local = extractTransform(this),\n                ms = [local],\n                m = new Snap.Matrix,\n                i,\n                localString = local.toTransformString(),\n                string = Str(local) == Str(this.matrix) ?\n                            Str(_.transform) : localString;\n            while (papa.type != \"svg\" && (papa = papa.parent())) {\n                ms.push(extractTransform(papa));\n            }\n            i = ms.length;\n            while (i--) {\n                m.add(ms[i]);\n            }\n            return {\n                string: string,\n                globalMatrix: global,\n                totalMatrix: m,\n                localMatrix: local,\n                diffMatrix: global.clone().add(local.invert()),\n                global: global.toTransformString(),\n                total: m.toTransformString(),\n                local: localString,\n                toString: propString\n            };\n        }\n        if (tstr instanceof Snap.Matrix) {\n            this.matrix = tstr;\n            this._.transform = tstr.toTransformString();\n        } else {\n            extractTransform(this, tstr);\n        }\n\n        if (this.node) {\n            if (this.type == \"linearGradient\" || this.type == \"radialGradient\") {\n                $(this.node, {gradientTransform: this.matrix});\n            } else if (this.type == \"pattern\") {\n                $(this.node, {patternTransform: this.matrix});\n            } else {\n                $(this.node, {transform: this.matrix});\n            }\n        }\n\n        return this;\n    };\n    /*\\\n     * Element.parent\n     [ method ]\n     **\n     * Returns the element's parent\n     **\n     = (Element) the parent element\n    \\*/\n    elproto.parent = function () {\n        return wrap(this.node.parentNode);\n    };\n    /*\\\n     * Element.append\n     [ method ]\n     **\n     * Appends the given element to current one\n     **\n     - el (Element|Set) element to append\n     = (Element) the parent element\n    \\*/\n    /*\\\n     * Element.add\n     [ method ]\n     **\n     * See @Element.append\n    \\*/\n    elproto.append = elproto.add = function (el) {\n        if (el) {\n            if (el.type == \"set\") {\n                var it = this;\n                el.forEach(function (el) {\n                    it.add(el);\n                });\n                return this;\n            }\n            el = wrap(el);\n            this.node.appendChild(el.node);\n            el.paper = this.paper;\n        }\n        return this;\n    };\n    /*\\\n     * Element.appendTo\n     [ method ]\n     **\n     * Appends the current element to the given one\n     **\n     - el (Element) parent element to append to\n     = (Element) the child element\n    \\*/\n    elproto.appendTo = function (el) {\n        if (el) {\n            el = wrap(el);\n            el.append(this);\n        }\n        return this;\n    };\n    /*\\\n     * Element.prepend\n     [ method ]\n     **\n     * Prepends the given element to the current one\n     **\n     - el (Element) element to prepend\n     = (Element) the parent element\n    \\*/\n    elproto.prepend = function (el) {\n        if (el) {\n            if (el.type == \"set\") {\n                var it = this,\n                    first;\n                el.forEach(function (el) {\n                    if (first) {\n                        first.after(el);\n                    } else {\n                        it.prepend(el);\n                    }\n                    first = el;\n                });\n                return this;\n            }\n            el = wrap(el);\n            var parent = el.parent();\n            this.node.insertBefore(el.node, this.node.firstChild);\n            this.add && this.add();\n            el.paper = this.paper;\n            this.parent() && this.parent().add();\n            parent && parent.add();\n        }\n        return this;\n    };\n    /*\\\n     * Element.prependTo\n     [ method ]\n     **\n     * Prepends the current element to the given one\n     **\n     - el (Element) parent element to prepend to\n     = (Element) the child element\n    \\*/\n    elproto.prependTo = function (el) {\n        el = wrap(el);\n        el.prepend(this);\n        return this;\n    };\n    /*\\\n     * Element.before\n     [ method ]\n     **\n     * Inserts given element before the current one\n     **\n     - el (Element) element to insert\n     = (Element) the parent element\n    \\*/\n    elproto.before = function (el) {\n        if (el.type == \"set\") {\n            var it = this;\n            el.forEach(function (el) {\n                var parent = el.parent();\n                it.node.parentNode.insertBefore(el.node, it.node);\n                parent && parent.add();\n            });\n            this.parent().add();\n            return this;\n        }\n        el = wrap(el);\n        var parent = el.parent();\n        this.node.parentNode.insertBefore(el.node, this.node);\n        this.parent() && this.parent().add();\n        parent && parent.add();\n        el.paper = this.paper;\n        return this;\n    };\n    /*\\\n     * Element.after\n     [ method ]\n     **\n     * Inserts given element after the current one\n     **\n     - el (Element) element to insert\n     = (Element) the parent element\n    \\*/\n    elproto.after = function (el) {\n        el = wrap(el);\n        var parent = el.parent();\n        if (this.node.nextSibling) {\n            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);\n        } else {\n            this.node.parentNode.appendChild(el.node);\n        }\n        this.parent() && this.parent().add();\n        parent && parent.add();\n        el.paper = this.paper;\n        return this;\n    };\n    /*\\\n     * Element.insertBefore\n     [ method ]\n     **\n     * Inserts the element after the given one\n     **\n     - el (Element) element next to whom insert to\n     = (Element) the parent element\n    \\*/\n    elproto.insertBefore = function (el) {\n        el = wrap(el);\n        var parent = this.parent();\n        el.node.parentNode.insertBefore(this.node, el.node);\n        this.paper = el.paper;\n        parent && parent.add();\n        el.parent() && el.parent().add();\n        return this;\n    };\n    /*\\\n     * Element.insertAfter\n     [ method ]\n     **\n     * Inserts the element after the given one\n     **\n     - el (Element) element next to whom insert to\n     = (Element) the parent element\n    \\*/\n    elproto.insertAfter = function (el) {\n        el = wrap(el);\n        var parent = this.parent();\n        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);\n        this.paper = el.paper;\n        parent && parent.add();\n        el.parent() && el.parent().add();\n        return this;\n    };\n    /*\\\n     * Element.remove\n     [ method ]\n     **\n     * Removes element from the DOM\n     = (Element) the detached element\n    \\*/\n    elproto.remove = function () {\n        var parent = this.parent();\n        this.node.parentNode && this.node.parentNode.removeChild(this.node);\n        delete this.paper;\n        this.removed = true;\n        parent && parent.add();\n        return this;\n    };\n    /*\\\n     * Element.select\n     [ method ]\n     **\n     * Gathers the nested @Element matching the given set of CSS selectors\n     **\n     - query (string) CSS selector\n     = (Element) result of query selection\n    \\*/\n    elproto.select = function (query) {\n        return wrap(this.node.querySelector(query));\n    };\n    /*\\\n     * Element.selectAll\n     [ method ]\n     **\n     * Gathers nested @Element objects matching the given set of CSS selectors\n     **\n     - query (string) CSS selector\n     = (Set|array) result of query selection\n    \\*/\n    elproto.selectAll = function (query) {\n        var nodelist = this.node.querySelectorAll(query),\n            set = (Snap.set || Array)();\n        for (var i = 0; i < nodelist.length; i++) {\n            set.push(wrap(nodelist[i]));\n        }\n        return set;\n    };\n    /*\\\n     * Element.asPX\n     [ method ]\n     **\n     * Returns given attribute of the element as a `px` value (not %, em, etc.)\n     **\n     - attr (string) attribute name\n     - value (string) #optional attribute value\n     = (Element) result of query selection\n    \\*/\n    elproto.asPX = function (attr, value) {\n        if (value == null) {\n            value = this.attr(attr);\n        }\n        return +unit2px(this, attr, value);\n    };\n    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.\n    /*\\\n     * Element.use\n     [ method ]\n     **\n     * Creates a `<use>` element linked to the current element\n     **\n     = (Element) the `<use>` element\n    \\*/\n    elproto.use = function () {\n        var use,\n            id = this.node.id;\n        if (!id) {\n            id = this.id;\n            $(this.node, {\n                id: id\n            });\n        }\n        if (this.type == \"linearGradient\" || this.type == \"radialGradient\" ||\n            this.type == \"pattern\") {\n            use = make(this.type, this.node.parentNode);\n        } else {\n            use = make(\"use\", this.node.parentNode);\n        }\n        $(use.node, {\n            \"xlink:href\": \"#\" + id\n        });\n        use.original = this;\n        return use;\n    };\n    function fixids(el) {\n        var els = el.selectAll(\"*\"),\n            it,\n            url = /^\\s*url\\((\"|'|)(.*)\\1\\)\\s*$/,\n            ids = [],\n            uses = {};\n        function urltest(it, name) {\n            var val = $(it.node, name);\n            val = val && val.match(url);\n            val = val && val[2];\n            if (val && val.charAt() == \"#\") {\n                val = val.substring(1);\n            } else {\n                return;\n            }\n            if (val) {\n                uses[val] = (uses[val] || []).concat(function (id) {\n                    var attr = {};\n                    attr[name] = Snap.url(id);\n                    $(it.node, attr);\n                });\n            }\n        }\n        function linktest(it) {\n            var val = $(it.node, \"xlink:href\");\n            if (val && val.charAt() == \"#\") {\n                val = val.substring(1);\n            } else {\n                return;\n            }\n            if (val) {\n                uses[val] = (uses[val] || []).concat(function (id) {\n                    it.attr(\"xlink:href\", \"#\" + id);\n                });\n            }\n        }\n        for (var i = 0, ii = els.length; i < ii; i++) {\n            it = els[i];\n            urltest(it, \"fill\");\n            urltest(it, \"stroke\");\n            urltest(it, \"filter\");\n            urltest(it, \"mask\");\n            urltest(it, \"clip-path\");\n            linktest(it);\n            var oldid = $(it.node, \"id\");\n            if (oldid) {\n                $(it.node, {id: it.id});\n                ids.push({\n                    old: oldid,\n                    id: it.id\n                });\n            }\n        }\n        for (i = 0, ii = ids.length; i < ii; i++) {\n            var fs = uses[ids[i].old];\n            if (fs) {\n                for (var j = 0, jj = fs.length; j < jj; j++) {\n                    fs[j](ids[i].id);\n                }\n            }\n        }\n    }\n    /*\\\n     * Element.clone\n     [ method ]\n     **\n     * Creates a clone of the element and inserts it after the element\n     **\n     = (Element) the clone\n    \\*/\n    elproto.clone = function () {\n        var clone = wrap(this.node.cloneNode(true));\n        if ($(clone.node, \"id\")) {\n            $(clone.node, {id: clone.id});\n        }\n        fixids(clone);\n        clone.insertAfter(this);\n        return clone;\n    };\n    /*\\\n     * Element.toDefs\n     [ method ]\n     **\n     * Moves element to the shared `<defs>` area\n     **\n     = (Element) the element\n    \\*/\n    elproto.toDefs = function () {\n        var defs = getSomeDefs(this);\n        defs.appendChild(this.node);\n        return this;\n    };\n    /*\\\n     * Element.toPattern\n     [ method ]\n     **\n     * Creates a `<pattern>` element from the current element\n     **\n     * To create a pattern you have to specify the pattern rect:\n     - x (string|number)\n     - y (string|number)\n     - width (string|number)\n     - height (string|number)\n     = (Element) the `<pattern>` element\n     * You can use pattern later on as an argument for `fill` attribute:\n     | var p = paper.path(\"M10-5-10,15M15,0,0,15M0-5-20,15\").attr({\n     |         fill: \"none\",\n     |         stroke: \"#bada55\",\n     |         strokeWidth: 5\n     |     }).pattern(0, 0, 10, 10),\n     |     c = paper.circle(200, 200, 100);\n     | c.attr({\n     |     fill: p\n     | });\n    \\*/\n    elproto.pattern = elproto.toPattern = function (x, y, width, height) {\n        var p = make(\"pattern\", getSomeDefs(this));\n        if (x == null) {\n            x = this.getBBox();\n        }\n        if (is(x, \"object\") && \"x\" in x) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            x = x.x;\n        }\n        $(p.node, {\n            x: x,\n            y: y,\n            width: width,\n            height: height,\n            patternUnits: \"userSpaceOnUse\",\n            id: p.id,\n            viewBox: [x, y, width, height].join(\" \")\n        });\n        p.node.appendChild(this.node);\n        return p;\n    };\n// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.\n// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?\n    /*\\\n     * Element.marker\n     [ method ]\n     **\n     * Creates a `<marker>` element from the current element\n     **\n     * To create a marker you have to specify the bounding rect and reference point:\n     - x (number)\n     - y (number)\n     - width (number)\n     - height (number)\n     - refX (number)\n     - refY (number)\n     = (Element) the `<marker>` element\n     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.\n    \\*/\n    // TODO add usage for markers\n    elproto.marker = function (x, y, width, height, refX, refY) {\n        var p = make(\"marker\", getSomeDefs(this));\n        if (x == null) {\n            x = this.getBBox();\n        }\n        if (is(x, \"object\") && \"x\" in x) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            refX = x.refX || x.cx;\n            refY = x.refY || x.cy;\n            x = x.x;\n        }\n        $(p.node, {\n            viewBox: [x, y, width, height].join(\" \"),\n            markerWidth: width,\n            markerHeight: height,\n            orient: \"auto\",\n            refX: refX || 0,\n            refY: refY || 0,\n            id: p.id\n        });\n        p.node.appendChild(this.node);\n        return p;\n    };\n    var eldata = {};\n    /*\\\n     * Element.data\n     [ method ]\n     **\n     * Adds or retrieves given value associated with given key. (Dont confuse\n     * with `data-` attributes)\n     *\n     * See also @Element.removeData\n     - key (string) key to store data\n     - value (any) #optional value to store\n     = (object) @Element\n     * or, if value is not specified:\n     = (any) value\n     > Usage\n     | for (var i = 0, i < 5, i++) {\n     |     paper.circle(10 + 15 * i, 10, 10)\n     |          .attr({fill: \"#000\"})\n     |          .data(\"i\", i)\n     |          .click(function () {\n     |             alert(this.data(\"i\"));\n     |          });\n     | }\n    \\*/\n    elproto.data = function (key, value) {\n        var data = eldata[this.id] = eldata[this.id] || {};\n        if (arguments.length == 0){\n            eve(\"snap.data.get.\" + this.id, this, data, null);\n            return data;\n        }\n        if (arguments.length == 1) {\n            if (Snap.is(key, \"object\")) {\n                for (var i in key) if (key[has](i)) {\n                    this.data(i, key[i]);\n                }\n                return this;\n            }\n            eve(\"snap.data.get.\" + this.id, this, data[key], key);\n            return data[key];\n        }\n        data[key] = value;\n        eve(\"snap.data.set.\" + this.id, this, value, key);\n        return this;\n    };\n    /*\\\n     * Element.removeData\n     [ method ]\n     **\n     * Removes value associated with an element by given key.\n     * If key is not provided, removes all the data of the element.\n     - key (string) #optional key\n     = (object) @Element\n    \\*/\n    elproto.removeData = function (key) {\n        if (key == null) {\n            eldata[this.id] = {};\n        } else {\n            eldata[this.id] && delete eldata[this.id][key];\n        }\n        return this;\n    };\n    /*\\\n     * Element.outerSVG\n     [ method ]\n     **\n     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.\n     *\n     * See also @Element.innerSVG\n     = (string) SVG code for the element\n    \\*/\n    /*\\\n     * Element.toString\n     [ method ]\n     **\n     * See @Element.outerSVG\n    \\*/\n    elproto.outerSVG = elproto.toString = toString(1);\n    /*\\\n     * Element.innerSVG\n     [ method ]\n     **\n     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`\n     = (string) SVG code for the element\n    \\*/\n    elproto.innerSVG = toString();\n    function toString(type) {\n        return function () {\n            var res = type ? \"<\" + this.type : \"\",\n                attr = this.node.attributes,\n                chld = this.node.childNodes;\n            if (type) {\n                for (var i = 0, ii = attr.length; i < ii; i++) {\n                    res += \" \" + attr[i].name + '=\"' +\n                            attr[i].value.replace(/\"/g, '\\\\\"') + '\"';\n                }\n            }\n            if (chld.length) {\n                type && (res += \">\");\n                for (i = 0, ii = chld.length; i < ii; i++) {\n                    if (chld[i].nodeType == 3) {\n                        res += chld[i].nodeValue;\n                    } else if (chld[i].nodeType == 1) {\n                        res += wrap(chld[i]).toString();\n                    }\n                }\n                type && (res += \"</\" + this.type + \">\");\n            } else {\n                type && (res += \"/>\");\n            }\n            return res;\n        };\n    }\n    elproto.toDataURL = function () {\n        if (window && window.btoa) {\n            var bb = this.getBBox(),\n                svg = Snap.format('<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"{width}\" height=\"{height}\" viewBox=\"{x} {y} {width} {height}\">{contents}</svg>', {\n                x: +bb.x.toFixed(3),\n                y: +bb.y.toFixed(3),\n                width: +bb.width.toFixed(3),\n                height: +bb.height.toFixed(3),\n                contents: this.outerSVG()\n            });\n            return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(svg)));\n        }\n    };\n    /*\\\n     * Fragment.select\n     [ method ]\n     **\n     * See @Element.select\n    \\*/\n    Fragment.prototype.select = elproto.select;\n    /*\\\n     * Fragment.selectAll\n     [ method ]\n     **\n     * See @Element.selectAll\n    \\*/\n    Fragment.prototype.selectAll = elproto.selectAll;\n});\n\n// Copyright (c) 2016 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var elproto = Element.prototype,\n        is = Snap.is,\n        Str = String,\n        has = \"hasOwnProperty\";\n    function slice(from, to, f) {\n        return function (arr) {\n            var res = arr.slice(from, to);\n            if (res.length == 1) {\n                res = res[0];\n            }\n            return f ? f(res) : res;\n        };\n    }\n    var Animation = function (attr, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        this.attr = attr;\n        this.dur = ms;\n        easing && (this.easing = easing);\n        callback && (this.callback = callback);\n    };\n    Snap._.Animation = Animation;\n    /*\\\n     * Snap.animation\n     [ method ]\n     **\n     * Creates an animation object\n     **\n     - attr (object) attributes of final destination\n     - duration (number) duration of the animation, in milliseconds\n     - easing (function) #optional one of easing functions of @mina or custom one\n     - callback (function) #optional callback function that fires when animation ends\n     = (object) animation object\n    \\*/\n    Snap.animation = function (attr, ms, easing, callback) {\n        return new Animation(attr, ms, easing, callback);\n    };\n    /*\\\n     * Element.inAnim\n     [ method ]\n     **\n     * Returns a set of animations that may be able to manipulate the current element\n     **\n     = (object) in format:\n     o {\n     o     anim (object) animation object,\n     o     mina (object) @mina object,\n     o     curStatus (number) 0..1  status of the animation: 0  just started, 1  just finished,\n     o     status (function) gets or sets the status of the animation,\n     o     stop (function) stops the animation\n     o }\n    \\*/\n    elproto.inAnim = function () {\n        var el = this,\n            res = [];\n        for (var id in el.anims) if (el.anims[has](id)) {\n            (function (a) {\n                res.push({\n                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),\n                    mina: a,\n                    curStatus: a.status(),\n                    status: function (val) {\n                        return a.status(val);\n                    },\n                    stop: function () {\n                        a.stop();\n                    }\n                });\n            }(el.anims[id]));\n        }\n        return res;\n    };\n    /*\\\n     * Snap.animate\n     [ method ]\n     **\n     * Runs generic animation of one number into another with a caring function\n     **\n     - from (number|array) number or array of numbers\n     - to (number|array) number or array of numbers\n     - setter (function) caring function that accepts one number argument\n     - duration (number) duration, in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function to execute when animation ends\n     = (object) animation object in @mina format\n     o {\n     o     id (string) animation id, consider it read-only,\n     o     duration (function) gets or sets the duration of the animation,\n     o     easing (function) easing,\n     o     speed (function) gets or sets the speed of the animation,\n     o     status (function) gets or sets the status of the animation,\n     o     stop (function) stops the animation\n     o }\n     | var rect = Snap().rect(0, 0, 10, 10);\n     | Snap.animate(0, 10, function (val) {\n     |     rect.attr({\n     |         x: val\n     |     });\n     | }, 1000);\n     | // in given context is equivalent to\n     | rect.animate({x: 10}, 1000);\n    \\*/\n    Snap.animate = function (from, to, setter, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        var now = mina.time(),\n            anim = mina(from, to, now, now + ms, mina.time, setter, easing);\n        callback && eve.once(\"mina.finish.\" + anim.id, callback);\n        return anim;\n    };\n    /*\\\n     * Element.stop\n     [ method ]\n     **\n     * Stops all the animations for the current element\n     **\n     = (Element) the current element\n    \\*/\n    elproto.stop = function () {\n        var anims = this.inAnim();\n        for (var i = 0, ii = anims.length; i < ii; i++) {\n            anims[i].stop();\n        }\n        return this;\n    };\n    /*\\\n     * Element.animate\n     [ method ]\n     **\n     * Animates the given attributes of the element\n     **\n     - attrs (object) key-value pairs of destination attributes\n     - duration (number) duration of the animation in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function that executes when the animation ends\n     = (Element) the current element\n    \\*/\n    elproto.animate = function (attrs, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        if (attrs instanceof Animation) {\n            callback = attrs.callback;\n            easing = attrs.easing;\n            ms = attrs.dur;\n            attrs = attrs.attr;\n        }\n        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,\n            el = this;\n        for (var key in attrs) if (attrs[has](key)) {\n            if (el.equal) {\n                eq = el.equal(key, Str(attrs[key]));\n                from = eq.from;\n                to = eq.to;\n                f = eq.f;\n            } else {\n                from = +el.attr(key);\n                to = +attrs[key];\n            }\n            var len = is(from, \"array\") ? from.length : 1;\n            keys[key] = slice(fkeys.length, fkeys.length + len, f);\n            fkeys = fkeys.concat(from);\n            tkeys = tkeys.concat(to);\n        }\n        var now = mina.time(),\n            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {\n                var attr = {};\n                for (var key in keys) if (keys[has](key)) {\n                    attr[key] = keys[key](val);\n                }\n                el.attr(attr);\n            }, easing);\n        el.anims[anim.id] = anim;\n        anim._attrs = attrs;\n        anim._callback = callback;\n        eve(\"snap.animcreated.\" + el.id, anim);\n        eve.once(\"mina.finish.\" + anim.id, function () {\n            eve.off(\"mina.*.\" + anim.id);\n            delete el.anims[anim.id];\n            callback && callback.call(el);\n        });\n        eve.once(\"mina.stop.\" + anim.id, function () {\n            eve.off(\"mina.*.\" + anim.id);\n            delete el.anims[anim.id];\n        });\n        return el;\n    };\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var objectToString = Object.prototype.toString,\n        Str = String,\n        math = Math,\n        E = \"\";\n    function Matrix(a, b, c, d, e, f) {\n        if (b == null && objectToString.call(a) == \"[object SVGMatrix]\") {\n            this.a = a.a;\n            this.b = a.b;\n            this.c = a.c;\n            this.d = a.d;\n            this.e = a.e;\n            this.f = a.f;\n            return;\n        }\n        if (a != null) {\n            this.a = +a;\n            this.b = +b;\n            this.c = +c;\n            this.d = +d;\n            this.e = +e;\n            this.f = +f;\n        } else {\n            this.a = 1;\n            this.b = 0;\n            this.c = 0;\n            this.d = 1;\n            this.e = 0;\n            this.f = 0;\n        }\n    }\n    (function (matrixproto) {\n        /*\\\n         * Matrix.add\n         [ method ]\n         **\n         * Adds the given matrix to existing one\n         - a (number)\n         - b (number)\n         - c (number)\n         - d (number)\n         - e (number)\n         - f (number)\n         * or\n         - matrix (object) @Matrix\n        \\*/\n        matrixproto.add = function (a, b, c, d, e, f) {\n            if (a && a instanceof Matrix) {\n                return this.add(a.a, a.b, a.c, a.d, a.e, a.f);\n            }\n            var aNew = a * this.a + b * this.c,\n                bNew = a * this.b + b * this.d;\n            this.e += e * this.a + f * this.c;\n            this.f += e * this.b + f * this.d;\n            this.c = c * this.a + d * this.c;\n            this.d = c * this.b + d * this.d;\n\n            this.a = aNew;\n            this.b = bNew;\n            return this;\n        };\n        /*\\\n         * Matrix.multLeft\n         [ method ]\n         **\n         * Multiplies a passed affine transform to the left: M * this.\n         - a (number)\n         - b (number)\n         - c (number)\n         - d (number)\n         - e (number)\n         - f (number)\n         * or\n         - matrix (object) @Matrix\n        \\*/\n        Matrix.prototype.multLeft = function (a, b, c, d, e, f) {\n            if (a && a instanceof Matrix) {\n                return this.multLeft(a.a, a.b, a.c, a.d, a.e, a.f);\n            }\n            var aNew = a * this.a + c * this.b,\n                cNew = a * this.c + c * this.d,\n                eNew = a * this.e + c * this.f + e;\n            this.b = b * this.a + d * this.b;\n            this.d = b * this.c + d * this.d;\n            this.f = b * this.e + d * this.f + f;\n\n            this.a = aNew;\n            this.c = cNew;\n            this.e = eNew;\n            return this;\n        };\n        /*\\\n         * Matrix.invert\n         [ method ]\n         **\n         * Returns an inverted version of the matrix\n         = (object) @Matrix\n        \\*/\n        matrixproto.invert = function () {\n            var me = this,\n                x = me.a * me.d - me.b * me.c;\n            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);\n        };\n        /*\\\n         * Matrix.clone\n         [ method ]\n         **\n         * Returns a copy of the matrix\n         = (object) @Matrix\n        \\*/\n        matrixproto.clone = function () {\n            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\n        };\n        /*\\\n         * Matrix.translate\n         [ method ]\n         **\n         * Translate the matrix\n         - x (number) horizontal offset distance\n         - y (number) vertical offset distance\n        \\*/\n        matrixproto.translate = function (x, y) {\n            this.e += x * this.a + y * this.c;\n            this.f += x * this.b + y * this.d;\n            return this;\n        };\n        /*\\\n         * Matrix.scale\n         [ method ]\n         **\n         * Scales the matrix\n         - x (number) amount to be scaled, with `1` resulting in no change\n         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)\n         - cx (number) #optional horizontal origin point from which to scale\n         - cy (number) #optional vertical origin point from which to scale\n         * Default cx, cy is the middle point of the element.\n        \\*/\n        matrixproto.scale = function (x, y, cx, cy) {\n            y == null && (y = x);\n            (cx || cy) && this.translate(cx, cy);\n            this.a *= x;\n            this.b *= x;\n            this.c *= y;\n            this.d *= y;\n            (cx || cy) && this.translate(-cx, -cy);\n            return this;\n        };\n        /*\\\n         * Matrix.rotate\n         [ method ]\n         **\n         * Rotates the matrix\n         - a (number) angle of rotation, in degrees\n         - x (number) horizontal origin point from which to rotate\n         - y (number) vertical origin point from which to rotate\n        \\*/\n        matrixproto.rotate = function (a, x, y) {\n            a = Snap.rad(a);\n            x = x || 0;\n            y = y || 0;\n            var cos = +math.cos(a).toFixed(9),\n                sin = +math.sin(a).toFixed(9);\n            this.add(cos, sin, -sin, cos, x, y);\n            return this.add(1, 0, 0, 1, -x, -y);\n        };\n        /*\\\n         * Matrix.skewX\n         [ method ]\n         **\n         * Skews the matrix along the x-axis\n         - x (number) Angle to skew along the x-axis (in degrees).\n        \\*/\n        matrixproto.skewX = function (x) {\n            return this.skew(x, 0);\n        };\n        /*\\\n         * Matrix.skewY\n         [ method ]\n         **\n         * Skews the matrix along the y-axis\n         - y (number) Angle to skew along the y-axis (in degrees).\n        \\*/\n        matrixproto.skewY = function (y) {\n            return this.skew(0, y);\n        };\n        /*\\\n         * Matrix.skew\n         [ method ]\n         **\n         * Skews the matrix\n         - y (number) Angle to skew along the y-axis (in degrees).\n         - x (number) Angle to skew along the x-axis (in degrees).\n        \\*/\n        matrixproto.skew = function (x, y) {\n            x = x || 0;\n            y = y || 0;\n            x = Snap.rad(x);\n            y = Snap.rad(y);\n            var c = math.tan(x).toFixed(9);\n            var b = math.tan(y).toFixed(9);\n            return this.add(1, b, c, 1, 0, 0);\n        };\n        /*\\\n         * Matrix.x\n         [ method ]\n         **\n         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y\n         - x (number)\n         - y (number)\n         = (number) x\n        \\*/\n        matrixproto.x = function (x, y) {\n            return x * this.a + y * this.c + this.e;\n        };\n        /*\\\n         * Matrix.y\n         [ method ]\n         **\n         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x\n         - x (number)\n         - y (number)\n         = (number) y\n        \\*/\n        matrixproto.y = function (x, y) {\n            return x * this.b + y * this.d + this.f;\n        };\n        matrixproto.get = function (i) {\n            return +this[Str.fromCharCode(97 + i)].toFixed(4);\n        };\n        matrixproto.toString = function () {\n            return \"matrix(\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + \")\";\n        };\n        matrixproto.offset = function () {\n            return [this.e.toFixed(4), this.f.toFixed(4)];\n        };\n        function norm(a) {\n            return a[0] * a[0] + a[1] * a[1];\n        }\n        function normalize(a) {\n            var mag = math.sqrt(norm(a));\n            a[0] && (a[0] /= mag);\n            a[1] && (a[1] /= mag);\n        }\n        /*\\\n         * Matrix.determinant\n         [ method ]\n         **\n         * Finds determinant of the given matrix.\n         = (number) determinant\n        \\*/\n        matrixproto.determinant = function () {\n            return this.a * this.d - this.b * this.c;\n        };\n        /*\\\n         * Matrix.split\n         [ method ]\n         **\n         * Splits matrix into primitive transformations\n         = (object) in format:\n         o dx (number) translation by x\n         o dy (number) translation by y\n         o scalex (number) scale by x\n         o scaley (number) scale by y\n         o shear (number) shear\n         o rotate (number) rotation in deg\n         o isSimple (boolean) could it be represented via simple transformations\n        \\*/\n        matrixproto.split = function () {\n            var out = {};\n            // translation\n            out.dx = this.e;\n            out.dy = this.f;\n\n            // scale and shear\n            var row = [[this.a, this.b], [this.c, this.d]];\n            out.scalex = math.sqrt(norm(row[0]));\n            normalize(row[0]);\n\n            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];\n            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];\n\n            out.scaley = math.sqrt(norm(row[1]));\n            normalize(row[1]);\n            out.shear /= out.scaley;\n\n            if (this.determinant() < 0) {\n                out.scalex = -out.scalex;\n            }\n\n            // rotation\n            var sin = row[0][1],\n                cos = row[1][1];\n            if (cos < 0) {\n                out.rotate = Snap.deg(math.acos(cos));\n                if (sin < 0) {\n                    out.rotate = 360 - out.rotate;\n                }\n            } else {\n                out.rotate = Snap.deg(math.asin(sin));\n            }\n\n            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);\n            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;\n            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;\n            return out;\n        };\n        /*\\\n         * Matrix.toTransformString\n         [ method ]\n         **\n         * Returns transform string that represents given matrix\n         = (string) transform string\n        \\*/\n        matrixproto.toTransformString = function (shorter) {\n            var s = shorter || this.split();\n            if (!+s.shear.toFixed(9)) {\n                s.scalex = +s.scalex.toFixed(4);\n                s.scaley = +s.scaley.toFixed(4);\n                s.rotate = +s.rotate.toFixed(4);\n                return  (s.dx || s.dy ? \"t\" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) +\n                        (s.rotate ? \"r\" + [+s.rotate.toFixed(4), 0, 0] : E) +\n                        (s.scalex != 1 || s.scaley != 1 ? \"s\" + [s.scalex, s.scaley, 0, 0] : E);\n            } else {\n                return \"m\" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];\n            }\n        };\n    })(Matrix.prototype);\n    /*\\\n     * Snap.Matrix\n     [ method ]\n     **\n     * Matrix constructor, extend on your own risk.\n     * To create matrices use @Snap.matrix.\n    \\*/\n    Snap.Matrix = Matrix;\n    /*\\\n     * Snap.matrix\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns a matrix based on the given parameters\n     - a (number)\n     - b (number)\n     - c (number)\n     - d (number)\n     - e (number)\n     - f (number)\n     * or\n     - svgMatrix (SVGMatrix)\n     = (object) @Matrix\n    \\*/\n    Snap.matrix = function (a, b, c, d, e, f) {\n        return new Matrix(a, b, c, d, e, f);\n    };\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var has = \"hasOwnProperty\",\n        make = Snap._.make,\n        wrap = Snap._.wrap,\n        is = Snap.is,\n        getSomeDefs = Snap._.getSomeDefs,\n        reURLValue = /^url\\((['\"]?)([^)]+)\\1\\)$/,\n        $ = Snap._.$,\n        URL = Snap.url,\n        Str = String,\n        separator = Snap._.separator,\n        E = \"\";\n    /*\\\n     * Snap.deurl\n     [ method ]\n     **\n     * Unwraps path from `\"url(<path>)\"`.\n     - value (string) url path\n     = (string) unwrapped path\n    \\*/\n    Snap.deurl = function (value) {\n        var res = String(value).match(reURLValue);\n        return res ? res[2] : value;\n    }\n    // Attributes event handlers\n    eve.on(\"snap.util.attr.mask\", function (value) {\n        if (value instanceof Element || value instanceof Fragment) {\n            eve.stop();\n            if (value instanceof Fragment && value.node.childNodes.length == 1) {\n                value = value.node.firstChild;\n                getSomeDefs(this).appendChild(value);\n                value = wrap(value);\n            }\n            if (value.type == \"mask\") {\n                var mask = value;\n            } else {\n                mask = make(\"mask\", getSomeDefs(this));\n                mask.node.appendChild(value.node);\n            }\n            !mask.node.id && $(mask.node, {\n                id: mask.id\n            });\n            $(this.node, {\n                mask: URL(mask.id)\n            });\n        }\n    });\n    (function (clipIt) {\n        eve.on(\"snap.util.attr.clip\", clipIt);\n        eve.on(\"snap.util.attr.clip-path\", clipIt);\n        eve.on(\"snap.util.attr.clipPath\", clipIt);\n    }(function (value) {\n        if (value instanceof Element || value instanceof Fragment) {\n            eve.stop();\n            var clip,\n                node = value.node;\n            while (node) {\n                if (node.nodeName === \"clipPath\") {\n                    clip = new Element(node);\n                    break;\n                }\n                if (node.nodeName === \"svg\") {\n                    clip = undefined;\n                    break;\n                }\n                node = node.parentNode;\n            }\n            if (!clip) {\n                clip = make(\"clipPath\", getSomeDefs(this));\n                clip.node.appendChild(value.node);\n                !clip.node.id && $(clip.node, {\n                    id: clip.id\n                });\n            }\n            $(this.node, {\n                \"clip-path\": URL(clip.node.id || clip.id)\n            });\n        }\n    }));\n    function fillStroke(name) {\n        return function (value) {\n            eve.stop();\n            if (value instanceof Fragment && value.node.childNodes.length == 1 &&\n                (value.node.firstChild.tagName == \"radialGradient\" ||\n                value.node.firstChild.tagName == \"linearGradient\" ||\n                value.node.firstChild.tagName == \"pattern\")) {\n                value = value.node.firstChild;\n                getSomeDefs(this).appendChild(value);\n                value = wrap(value);\n            }\n            if (value instanceof Element) {\n                if (value.type == \"radialGradient\" || value.type == \"linearGradient\"\n                   || value.type == \"pattern\") {\n                    if (!value.node.id) {\n                        $(value.node, {\n                            id: value.id\n                        });\n                    }\n                    var fill = URL(value.node.id);\n                } else {\n                    fill = value.attr(name);\n                }\n            } else {\n                fill = Snap.color(value);\n                if (fill.error) {\n                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);\n                    if (grad) {\n                        if (!grad.node.id) {\n                            $(grad.node, {\n                                id: grad.id\n                            });\n                        }\n                        fill = URL(grad.node.id);\n                    } else {\n                        fill = value;\n                    }\n                } else {\n                    fill = Str(fill);\n                }\n            }\n            var attrs = {};\n            attrs[name] = fill;\n            $(this.node, attrs);\n            this.node.style[name] = E;\n        };\n    }\n    eve.on(\"snap.util.attr.fill\", fillStroke(\"fill\"));\n    eve.on(\"snap.util.attr.stroke\", fillStroke(\"stroke\"));\n    var gradrg = /^([lr])(?:\\(([^)]*)\\))?(.*)$/i;\n    eve.on(\"snap.util.grad.parse\", function parseGrad(string) {\n        string = Str(string);\n        var tokens = string.match(gradrg);\n        if (!tokens) {\n            return null;\n        }\n        var type = tokens[1],\n            params = tokens[2],\n            stops = tokens[3];\n        params = params.split(/\\s*,\\s*/).map(function (el) {\n            return +el == el ? +el : el;\n        });\n        if (params.length == 1 && params[0] == 0) {\n            params = [];\n        }\n        stops = stops.split(\"-\");\n        stops = stops.map(function (el) {\n            el = el.split(\":\");\n            var out = {\n                color: el[0]\n            };\n            if (el[1]) {\n                out.offset = parseFloat(el[1]);\n            }\n            return out;\n        });\n        var len = stops.length,\n            start = 0,\n            j = 0;\n        function seed(i, end) {\n            var step = (end - start) / (i - j);\n            for (var k = j; k < i; k++) {\n                stops[k].offset = +(+start + step * (k - j)).toFixed(2);\n            }\n            j = i;\n            start = end;\n        }\n        len--;\n        for (var i = 0; i < len; i++) if (\"offset\" in stops[i]) {\n            seed(i, stops[i].offset);\n        }\n        stops[len].offset = stops[len].offset || 100;\n        seed(len, stops[len].offset);\n        return {\n            type: type,\n            params: params,\n            stops: stops\n        };\n    });\n\n    eve.on(\"snap.util.attr.d\", function (value) {\n        eve.stop();\n        if (is(value, \"array\") && is(value[0], \"array\")) {\n            value = Snap.path.toString.call(value);\n        }\n        value = Str(value);\n        if (value.match(/[ruo]/i)) {\n            value = Snap.path.toAbsolute(value);\n        }\n        $(this.node, {d: value});\n    })(-1);\n    eve.on(\"snap.util.attr.#text\", function (value) {\n        eve.stop();\n        value = Str(value);\n        var txt = glob.doc.createTextNode(value);\n        while (this.node.firstChild) {\n            this.node.removeChild(this.node.firstChild);\n        }\n        this.node.appendChild(txt);\n    })(-1);\n    eve.on(\"snap.util.attr.path\", function (value) {\n        eve.stop();\n        this.attr({d: value});\n    })(-1);\n    eve.on(\"snap.util.attr.class\", function (value) {\n        eve.stop();\n        this.node.className.baseVal = value;\n    })(-1);\n    eve.on(\"snap.util.attr.viewBox\", function (value) {\n        var vb;\n        if (is(value, \"object\") && \"x\" in value) {\n            vb = [value.x, value.y, value.width, value.height].join(\" \");\n        } else if (is(value, \"array\")) {\n            vb = value.join(\" \");\n        } else {\n            vb = value;\n        }\n        $(this.node, {\n            viewBox: vb\n        });\n        eve.stop();\n    })(-1);\n    eve.on(\"snap.util.attr.transform\", function (value) {\n        this.transform(value);\n        eve.stop();\n    })(-1);\n    eve.on(\"snap.util.attr.r\", function (value) {\n        if (this.type == \"rect\") {\n            eve.stop();\n            $(this.node, {\n                rx: value,\n                ry: value\n            });\n        }\n    })(-1);\n    eve.on(\"snap.util.attr.textpath\", function (value) {\n        eve.stop();\n        if (this.type == \"text\") {\n            var id, tp, node;\n            if (!value && this.textPath) {\n                tp = this.textPath;\n                while (tp.node.firstChild) {\n                    this.node.appendChild(tp.node.firstChild);\n                }\n                tp.remove();\n                delete this.textPath;\n                return;\n            }\n            if (is(value, \"string\")) {\n                var defs = getSomeDefs(this),\n                    path = wrap(defs.parentNode).path(value);\n                defs.appendChild(path.node);\n                id = path.id;\n                path.attr({id: id});\n            } else {\n                value = wrap(value);\n                if (value instanceof Element) {\n                    id = value.attr(\"id\");\n                    if (!id) {\n                        id = value.id;\n                        value.attr({id: id});\n                    }\n                }\n            }\n            if (id) {\n                tp = this.textPath;\n                node = this.node;\n                if (tp) {\n                    tp.attr({\"xlink:href\": \"#\" + id});\n                } else {\n                    tp = $(\"textPath\", {\n                        \"xlink:href\": \"#\" + id\n                    });\n                    while (node.firstChild) {\n                        tp.appendChild(node.firstChild);\n                    }\n                    node.appendChild(tp);\n                    this.textPath = wrap(tp);\n                }\n            }\n        }\n    })(-1);\n    eve.on(\"snap.util.attr.text\", function (value) {\n        if (this.type == \"text\") {\n            var i = 0,\n                node = this.node,\n                tuner = function (chunk) {\n                    var out = $(\"tspan\");\n                    if (is(chunk, \"array\")) {\n                        for (var i = 0; i < chunk.length; i++) {\n                            out.appendChild(tuner(chunk[i]));\n                        }\n                    } else {\n                        out.appendChild(glob.doc.createTextNode(chunk));\n                    }\n                    out.normalize && out.normalize();\n                    return out;\n                };\n            while (node.firstChild) {\n                node.removeChild(node.firstChild);\n            }\n            var tuned = tuner(value);\n            while (tuned.firstChild) {\n                node.appendChild(tuned.firstChild);\n            }\n        }\n        eve.stop();\n    })(-1);\n    function setFontSize(value) {\n        eve.stop();\n        if (value == +value) {\n            value += \"px\";\n        }\n        this.node.style.fontSize = value;\n    }\n    eve.on(\"snap.util.attr.fontSize\", setFontSize)(-1);\n    eve.on(\"snap.util.attr.font-size\", setFontSize)(-1);\n\n\n    eve.on(\"snap.util.getattr.transform\", function () {\n        eve.stop();\n        return this.transform();\n    })(-1);\n    eve.on(\"snap.util.getattr.textpath\", function () {\n        eve.stop();\n        return this.textPath;\n    })(-1);\n    // Markers\n    (function () {\n        function getter(end) {\n            return function () {\n                eve.stop();\n                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue(\"marker-\" + end);\n                if (style == \"none\") {\n                    return style;\n                } else {\n                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));\n                }\n            };\n        }\n        function setter(end) {\n            return function (value) {\n                eve.stop();\n                var name = \"marker\" + end.charAt(0).toUpperCase() + end.substring(1);\n                if (value == \"\" || !value) {\n                    this.node.style[name] = \"none\";\n                    return;\n                }\n                if (value.type == \"marker\") {\n                    var id = value.node.id;\n                    if (!id) {\n                        $(value.node, {id: value.id});\n                    }\n                    this.node.style[name] = URL(id);\n                    return;\n                }\n            };\n        }\n        eve.on(\"snap.util.getattr.marker-end\", getter(\"end\"))(-1);\n        eve.on(\"snap.util.getattr.markerEnd\", getter(\"end\"))(-1);\n        eve.on(\"snap.util.getattr.marker-start\", getter(\"start\"))(-1);\n        eve.on(\"snap.util.getattr.markerStart\", getter(\"start\"))(-1);\n        eve.on(\"snap.util.getattr.marker-mid\", getter(\"mid\"))(-1);\n        eve.on(\"snap.util.getattr.markerMid\", getter(\"mid\"))(-1);\n        eve.on(\"snap.util.attr.marker-end\", setter(\"end\"))(-1);\n        eve.on(\"snap.util.attr.markerEnd\", setter(\"end\"))(-1);\n        eve.on(\"snap.util.attr.marker-start\", setter(\"start\"))(-1);\n        eve.on(\"snap.util.attr.markerStart\", setter(\"start\"))(-1);\n        eve.on(\"snap.util.attr.marker-mid\", setter(\"mid\"))(-1);\n        eve.on(\"snap.util.attr.markerMid\", setter(\"mid\"))(-1);\n    }());\n    eve.on(\"snap.util.getattr.r\", function () {\n        if (this.type == \"rect\" && $(this.node, \"rx\") == $(this.node, \"ry\")) {\n            eve.stop();\n            return $(this.node, \"rx\");\n        }\n    })(-1);\n    function textExtract(node) {\n        var out = [];\n        var children = node.childNodes;\n        for (var i = 0, ii = children.length; i < ii; i++) {\n            var chi = children[i];\n            if (chi.nodeType == 3) {\n                out.push(chi.nodeValue);\n            }\n            if (chi.tagName == \"tspan\") {\n                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {\n                    out.push(chi.firstChild.nodeValue);\n                } else {\n                    out.push(textExtract(chi));\n                }\n            }\n        }\n        return out;\n    }\n    eve.on(\"snap.util.getattr.text\", function () {\n        if (this.type == \"text\" || this.type == \"tspan\") {\n            eve.stop();\n            var out = textExtract(this.node);\n            return out.length == 1 ? out[0] : out;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.#text\", function () {\n        return this.node.textContent;\n    })(-1);\n    eve.on(\"snap.util.getattr.fill\", function (internal) {\n        if (internal) {\n            return;\n        }\n        eve.stop();\n        var value = eve(\"snap.util.getattr.fill\", this, true).firstDefined();\n        return Snap(Snap.deurl(value)) || value;\n    })(-1);\n    eve.on(\"snap.util.getattr.stroke\", function (internal) {\n        if (internal) {\n            return;\n        }\n        eve.stop();\n        var value = eve(\"snap.util.getattr.stroke\", this, true).firstDefined();\n        return Snap(Snap.deurl(value)) || value;\n    })(-1);\n    eve.on(\"snap.util.getattr.viewBox\", function () {\n        eve.stop();\n        var vb = $(this.node, \"viewBox\");\n        if (vb) {\n            vb = vb.split(separator);\n            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);\n        } else {\n            return;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.points\", function () {\n        var p = $(this.node, \"points\");\n        eve.stop();\n        if (p) {\n            return p.split(separator);\n        } else {\n            return;\n        }\n    })(-1);\n    eve.on(\"snap.util.getattr.path\", function () {\n        var p = $(this.node, \"d\");\n        eve.stop();\n        return p;\n    })(-1);\n    eve.on(\"snap.util.getattr.class\", function () {\n        return this.node.className.baseVal;\n    })(-1);\n    function getFontSize() {\n        eve.stop();\n        return this.node.style.fontSize;\n    }\n    eve.on(\"snap.util.getattr.fontSize\", getFontSize)(-1);\n    eve.on(\"snap.util.getattr.font-size\", getFontSize)(-1);\n});\n\n// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var rgNotSpace = /\\S+/g,\n        rgBadSpace = /[\\t\\r\\n\\f]/g,\n        rgTrim = /(^\\s+|\\s+$)/g,\n        Str = String,\n        elproto = Element.prototype;\n    /*\\\n     * Element.addClass\n     [ method ]\n     **\n     * Adds given class name or list of class names to the element.\n     - value (string) class name or space separated list of class names\n     **\n     = (Element) original element.\n    \\*/\n    elproto.addClass = function (value) {\n        var classes = Str(value || \"\").match(rgNotSpace) || [],\n            elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [],\n            j,\n            pos,\n            clazz,\n            finalValue;\n\n        if (classes.length) {\n            j = 0;\n            while (clazz = classes[j++]) {\n                pos = curClasses.indexOf(clazz);\n                if (!~pos) {\n                    curClasses.push(clazz);\n                }\n            }\n\n            finalValue = curClasses.join(\" \");\n            if (className != finalValue) {\n                elem.className.baseVal = finalValue;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Element.removeClass\n     [ method ]\n     **\n     * Removes given class name or list of class names from the element.\n     - value (string) class name or space separated list of class names\n     **\n     = (Element) original element.\n    \\*/\n    elproto.removeClass = function (value) {\n        var classes = Str(value || \"\").match(rgNotSpace) || [],\n            elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [],\n            j,\n            pos,\n            clazz,\n            finalValue;\n        if (curClasses.length) {\n            j = 0;\n            while (clazz = classes[j++]) {\n                pos = curClasses.indexOf(clazz);\n                if (~pos) {\n                    curClasses.splice(pos, 1);\n                }\n            }\n\n            finalValue = curClasses.join(\" \");\n            if (className != finalValue) {\n                elem.className.baseVal = finalValue;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Element.hasClass\n     [ method ]\n     **\n     * Checks if the element has a given class name in the list of class names applied to it.\n     - value (string) class name\n     **\n     = (boolean) `true` if the element has given class\n    \\*/\n    elproto.hasClass = function (value) {\n        var elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [];\n        return !!~curClasses.indexOf(value);\n    };\n    /*\\\n     * Element.toggleClass\n     [ method ]\n     **\n     * Add or remove one or more classes from the element, depending on either\n     * the classs presence or the value of the `flag` argument.\n     - value (string) class name or space separated list of class names\n     - flag (boolean) value to determine whether the class should be added or removed\n     **\n     = (Element) original element.\n    \\*/\n    elproto.toggleClass = function (value, flag) {\n        if (flag != null) {\n            if (flag) {\n                return this.addClass(value);\n            } else {\n                return this.removeClass(value);\n            }\n        }\n        var classes = (value || \"\").match(rgNotSpace) || [],\n            elem = this.node,\n            className = elem.className.baseVal,\n            curClasses = className.match(rgNotSpace) || [],\n            j,\n            pos,\n            clazz,\n            finalValue;\n        j = 0;\n        while (clazz = classes[j++]) {\n            pos = curClasses.indexOf(clazz);\n            if (~pos) {\n                curClasses.splice(pos, 1);\n            } else {\n                curClasses.push(clazz);\n            }\n        }\n\n        finalValue = curClasses.join(\" \");\n        if (className != finalValue) {\n            elem.className.baseVal = finalValue;\n        }\n        return this;\n    };\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var operators = {\n            \"+\": function (x, y) {\n                    return x + y;\n                },\n            \"-\": function (x, y) {\n                    return x - y;\n                },\n            \"/\": function (x, y) {\n                    return x / y;\n                },\n            \"*\": function (x, y) {\n                    return x * y;\n                }\n        },\n        Str = String,\n        reUnit = /[a-z]+$/i,\n        reAddon = /^\\s*([+\\-\\/*])\\s*=\\s*([\\d.eE+\\-]+)\\s*([^\\d\\s]+)?\\s*$/;\n    function getNumber(val) {\n        return val;\n    }\n    function getUnit(unit) {\n        return function (val) {\n            return +val.toFixed(3) + unit;\n        };\n    }\n    eve.on(\"snap.util.attr\", function (val) {\n        var plus = Str(val).match(reAddon);\n        if (plus) {\n            var evnt = eve.nt(),\n                name = evnt.substring(evnt.lastIndexOf(\".\") + 1),\n                a = this.attr(name),\n                atr = {};\n            eve.stop();\n            var unit = plus[3] || \"\",\n                aUnit = a.match(reUnit),\n                op = operators[plus[1]];\n            if (aUnit && aUnit == unit) {\n                val = op(parseFloat(a), +plus[2]);\n            } else {\n                a = this.asPX(name);\n                val = op(this.asPX(name), this.asPX(name, plus[2] + unit));\n            }\n            if (isNaN(a) || isNaN(val)) {\n                return;\n            }\n            atr[name] = val;\n            this.attr(atr);\n        }\n    })(-10);\n    eve.on(\"snap.util.equal\", function (name, b) {\n        var A, B, a = Str(this.attr(name) || \"\"),\n            el = this,\n            bplus = Str(b).match(reAddon);\n        if (bplus) {\n            eve.stop();\n            var unit = bplus[3] || \"\",\n                aUnit = a.match(reUnit),\n                op = operators[bplus[1]];\n            if (aUnit && aUnit == unit) {\n                return {\n                    from: parseFloat(a),\n                    to: op(parseFloat(a), +bplus[2]),\n                    f: getUnit(aUnit)\n                };\n            } else {\n                a = this.asPX(name);\n                return {\n                    from: a,\n                    to: op(a, this.asPX(name, bplus[2] + unit)),\n                    f: getNumber\n                };\n            }\n        }\n    })(-10);\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var proto = Paper.prototype,\n        is = Snap.is;\n    /*\\\n     * Paper.rect\n     [ method ]\n     *\n     * Draws a rectangle\n     **\n     - x (number) x coordinate of the top left corner\n     - y (number) y coordinate of the top left corner\n     - width (number) width\n     - height (number) height\n     - rx (number) #optional horizontal radius for rounded corners, default is 0\n     - ry (number) #optional vertical radius for rounded corners, default is rx or 0\n     = (object) the `rect` element\n     **\n     > Usage\n     | // regular rectangle\n     | var c = paper.rect(10, 10, 50, 50);\n     | // rectangle with rounded corners\n     | var c = paper.rect(40, 40, 50, 50, 10);\n    \\*/\n    proto.rect = function (x, y, w, h, rx, ry) {\n        var attr;\n        if (ry == null) {\n            ry = rx;\n        }\n        if (is(x, \"object\") && x == \"[object Object]\") {\n            attr = x;\n        } else if (x != null) {\n            attr = {\n                x: x,\n                y: y,\n                width: w,\n                height: h\n            };\n            if (rx != null) {\n                attr.rx = rx;\n                attr.ry = ry;\n            }\n        }\n        return this.el(\"rect\", attr);\n    };\n    /*\\\n     * Paper.circle\n     [ method ]\n     **\n     * Draws a circle\n     **\n     - x (number) x coordinate of the centre\n     - y (number) y coordinate of the centre\n     - r (number) radius\n     = (object) the `circle` element\n     **\n     > Usage\n     | var c = paper.circle(50, 50, 40);\n    \\*/\n    proto.circle = function (cx, cy, r) {\n        var attr;\n        if (is(cx, \"object\") && cx == \"[object Object]\") {\n            attr = cx;\n        } else if (cx != null) {\n            attr = {\n                cx: cx,\n                cy: cy,\n                r: r\n            };\n        }\n        return this.el(\"circle\", attr);\n    };\n\n    var preload = (function () {\n        function onerror() {\n            this.parentNode.removeChild(this);\n        }\n        return function (src, f) {\n            var img = glob.doc.createElement(\"img\"),\n                body = glob.doc.body;\n            img.style.cssText = \"position:absolute;left:-9999em;top:-9999em\";\n            img.onload = function () {\n                f.call(img);\n                img.onload = img.onerror = null;\n                body.removeChild(img);\n            };\n            img.onerror = onerror;\n            body.appendChild(img);\n            img.src = src;\n        };\n    }());\n\n    /*\\\n     * Paper.image\n     [ method ]\n     **\n     * Places an image on the surface\n     **\n     - src (string) URI of the source image\n     - x (number) x offset position\n     - y (number) y offset position\n     - width (number) width of the image\n     - height (number) height of the image\n     = (object) the `image` element\n     * or\n     = (object) Snap element object with type `image`\n     **\n     > Usage\n     | var c = paper.image(\"apple.png\", 10, 10, 80, 80);\n    \\*/\n    proto.image = function (src, x, y, width, height) {\n        var el = this.el(\"image\");\n        if (is(src, \"object\") && \"src\" in src) {\n            el.attr(src);\n        } else if (src != null) {\n            var set = {\n                \"xlink:href\": src,\n                preserveAspectRatio: \"none\"\n            };\n            if (x != null && y != null) {\n                set.x = x;\n                set.y = y;\n            }\n            if (width != null && height != null) {\n                set.width = width;\n                set.height = height;\n            } else {\n                preload(src, function () {\n                    Snap._.$(el.node, {\n                        width: this.offsetWidth,\n                        height: this.offsetHeight\n                    });\n                });\n            }\n            Snap._.$(el.node, set);\n        }\n        return el;\n    };\n    /*\\\n     * Paper.ellipse\n     [ method ]\n     **\n     * Draws an ellipse\n     **\n     - x (number) x coordinate of the centre\n     - y (number) y coordinate of the centre\n     - rx (number) horizontal radius\n     - ry (number) vertical radius\n     = (object) the `ellipse` element\n     **\n     > Usage\n     | var c = paper.ellipse(50, 50, 40, 20);\n    \\*/\n    proto.ellipse = function (cx, cy, rx, ry) {\n        var attr;\n        if (is(cx, \"object\") && cx == \"[object Object]\") {\n            attr = cx;\n        } else if (cx != null) {\n            attr ={\n                cx: cx,\n                cy: cy,\n                rx: rx,\n                ry: ry\n            };\n        }\n        return this.el(\"ellipse\", attr);\n    };\n    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.\n    /*\\\n     * Paper.path\n     [ method ]\n     **\n     * Creates a `<path>` element using the given string as the path's definition\n     - pathString (string) #optional path string in SVG format\n     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:\n     | \"M10,20L30,40\"\n     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.\n     *\n     # <p>Here is short list of commands available, for more details see <a href=\"http://www.w3.org/TR/SVG/paths.html#PathData\" title=\"Details of a path's data attribute's format are described in the SVG specification.\">SVG path string format</a> or <a href=\"https://developer.mozilla.org/en/SVG/Tutorial/Paths\">article about path strings at MDN</a>.</p>\n     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>\n     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>\n     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>\n     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>\n     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>\n     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>\n     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>\n     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>\n     # <tr><td>Q</td><td>quadratic Bzier curveto</td><td>(x1 y1 x y)+</td></tr>\n     # <tr><td>T</td><td>smooth quadratic Bzier curveto</td><td>(x y)+</td></tr>\n     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>\n     # <tr><td>R</td><td><a href=\"http://en.wikipedia.org/wiki/CatmullRom_spline#Catmull.E2.80.93Rom_spline\">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>\n     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.\n     * Note: there is a special case when a path consists of only three commands: `M10,10Rz`. In this case the path connects back to its starting point.\n     > Usage\n     | var c = paper.path(\"M10 10L90 90\");\n     | // draw a diagonal line:\n     | // move to 10,10, line to 90,90\n    \\*/\n    proto.path = function (d) {\n        var attr;\n        if (is(d, \"object\") && !is(d, \"array\")) {\n            attr = d;\n        } else if (d) {\n            attr = {d: d};\n        }\n        return this.el(\"path\", attr);\n    };\n    /*\\\n     * Paper.g\n     [ method ]\n     **\n     * Creates a group element\n     **\n     - varargs () #optional elements to nest within the group\n     = (object) the `g` element\n     **\n     > Usage\n     | var c1 = paper.circle(),\n     |     c2 = paper.rect(),\n     |     g = paper.g(c2, c1); // note that the order of elements is different\n     * or\n     | var c1 = paper.circle(),\n     |     c2 = paper.rect(),\n     |     g = paper.g();\n     | g.add(c2, c1);\n    \\*/\n    /*\\\n     * Paper.group\n     [ method ]\n     **\n     * See @Paper.g\n    \\*/\n    proto.group = proto.g = function (first) {\n        var attr,\n            el = this.el(\"g\");\n        if (arguments.length == 1 && first && !first.type) {\n            el.attr(first);\n        } else if (arguments.length) {\n            el.add(Array.prototype.slice.call(arguments, 0));\n        }\n        return el;\n    };\n    /*\\\n     * Paper.svg\n     [ method ]\n     **\n     * Creates a nested SVG element.\n     - x (number) @optional X of the element\n     - y (number) @optional Y of the element\n     - width (number) @optional width of the element\n     - height (number) @optional height of the element\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     **\n     = (object) the `svg` element\n     **\n    \\*/\n    proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {\n        var attrs = {};\n        if (is(x, \"object\") && y == null) {\n            attrs = x;\n        } else {\n            if (x != null) {\n                attrs.x = x;\n            }\n            if (y != null) {\n                attrs.y = y;\n            }\n            if (width != null) {\n                attrs.width = width;\n            }\n            if (height != null) {\n                attrs.height = height;\n            }\n            if (vbx != null && vby != null && vbw != null && vbh != null) {\n                attrs.viewBox = [vbx, vby, vbw, vbh];\n            }\n        }\n        return this.el(\"svg\", attrs);\n    };\n    /*\\\n     * Paper.mask\n     [ method ]\n     **\n     * Equivalent in behaviour to @Paper.g, except its a mask.\n     **\n     = (object) the `mask` element\n     **\n    \\*/\n    proto.mask = function (first) {\n        var attr,\n            el = this.el(\"mask\");\n        if (arguments.length == 1 && first && !first.type) {\n            el.attr(first);\n        } else if (arguments.length) {\n            el.add(Array.prototype.slice.call(arguments, 0));\n        }\n        return el;\n    };\n    /*\\\n     * Paper.ptrn\n     [ method ]\n     **\n     * Equivalent in behaviour to @Paper.g, except its a pattern.\n     - x (number) @optional X of the element\n     - y (number) @optional Y of the element\n     - width (number) @optional width of the element\n     - height (number) @optional height of the element\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     **\n     = (object) the `pattern` element\n     **\n    \\*/\n    proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {\n        if (is(x, \"object\")) {\n            var attr = x;\n        } else {\n            attr = {patternUnits: \"userSpaceOnUse\"};\n            if (x) {\n                attr.x = x;\n            }\n            if (y) {\n                attr.y = y;\n            }\n            if (width != null) {\n                attr.width = width;\n            }\n            if (height != null) {\n                attr.height = height;\n            }\n            if (vx != null && vy != null && vw != null && vh != null) {\n                attr.viewBox = [vx, vy, vw, vh];\n            } else {\n                attr.viewBox = [x || 0, y || 0, width || 0, height || 0];\n            }\n        }\n        return this.el(\"pattern\", attr);\n    };\n    /*\\\n     * Paper.use\n     [ method ]\n     **\n     * Creates a <use> element.\n     - id (string) @optional id of element to link\n     * or\n     - id (Element) @optional element to link\n     **\n     = (object) the `use` element\n     **\n    \\*/\n    proto.use = function (id) {\n        if (id != null) {\n            if (id instanceof Element) {\n                if (!id.attr(\"id\")) {\n                    id.attr({id: Snap._.id(id)});\n                }\n                id = id.attr(\"id\");\n            }\n            if (String(id).charAt() == \"#\") {\n                id = id.substring(1);\n            }\n            return this.el(\"use\", {\"xlink:href\": \"#\" + id});\n        } else {\n            return Element.prototype.use.call(this);\n        }\n    };\n    /*\\\n     * Paper.symbol\n     [ method ]\n     **\n     * Creates a <symbol> element.\n     - vbx (number) @optional viewbox X\n     - vby (number) @optional viewbox Y\n     - vbw (number) @optional viewbox width\n     - vbh (number) @optional viewbox height\n     = (object) the `symbol` element\n     **\n    \\*/\n    proto.symbol = function (vx, vy, vw, vh) {\n        var attr = {};\n        if (vx != null && vy != null && vw != null && vh != null) {\n            attr.viewBox = [vx, vy, vw, vh];\n        }\n\n        return this.el(\"symbol\", attr);\n    };\n    /*\\\n     * Paper.text\n     [ method ]\n     **\n     * Draws a text string\n     **\n     - x (number) x coordinate position\n     - y (number) y coordinate position\n     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements\n     = (object) the `text` element\n     **\n     > Usage\n     | var t1 = paper.text(50, 50, \"Snap\");\n     | var t2 = paper.text(50, 50, [\"S\",\"n\",\"a\",\"p\"]);\n     | // Text path usage\n     | t1.attr({textpath: \"M10,10L100,100\"});\n     | // or\n     | var pth = paper.path(\"M10,10L100,100\");\n     | t1.attr({textpath: pth});\n    \\*/\n    proto.text = function (x, y, text) {\n        var attr = {};\n        if (is(x, \"object\")) {\n            attr = x;\n        } else if (x != null) {\n            attr = {\n                x: x,\n                y: y,\n                text: text || \"\"\n            };\n        }\n        return this.el(\"text\", attr);\n    };\n    /*\\\n     * Paper.line\n     [ method ]\n     **\n     * Draws a line\n     **\n     - x1 (number) x coordinate position of the start\n     - y1 (number) y coordinate position of the start\n     - x2 (number) x coordinate position of the end\n     - y2 (number) y coordinate position of the end\n     = (object) the `line` element\n     **\n     > Usage\n     | var t1 = paper.line(50, 50, 100, 100);\n    \\*/\n    proto.line = function (x1, y1, x2, y2) {\n        var attr = {};\n        if (is(x1, \"object\")) {\n            attr = x1;\n        } else if (x1 != null) {\n            attr = {\n                x1: x1,\n                x2: x2,\n                y1: y1,\n                y2: y2\n            };\n        }\n        return this.el(\"line\", attr);\n    };\n    /*\\\n     * Paper.polyline\n     [ method ]\n     **\n     * Draws a polyline\n     **\n     - points (array) array of points\n     * or\n     - varargs () points\n     = (object) the `polyline` element\n     **\n     > Usage\n     | var p1 = paper.polyline([10, 10, 100, 100]);\n     | var p2 = paper.polyline(10, 10, 100, 100);\n    \\*/\n    proto.polyline = function (points) {\n        if (arguments.length > 1) {\n            points = Array.prototype.slice.call(arguments, 0);\n        }\n        var attr = {};\n        if (is(points, \"object\") && !is(points, \"array\")) {\n            attr = points;\n        } else if (points != null) {\n            attr = {points: points};\n        }\n        return this.el(\"polyline\", attr);\n    };\n    /*\\\n     * Paper.polygon\n     [ method ]\n     **\n     * Draws a polygon. See @Paper.polyline\n    \\*/\n    proto.polygon = function (points) {\n        if (arguments.length > 1) {\n            points = Array.prototype.slice.call(arguments, 0);\n        }\n        var attr = {};\n        if (is(points, \"object\") && !is(points, \"array\")) {\n            attr = points;\n        } else if (points != null) {\n            attr = {points: points};\n        }\n        return this.el(\"polygon\", attr);\n    };\n    // gradients\n    (function () {\n        var $ = Snap._.$;\n        // gradients' helpers\n        /*\\\n         * Element.stops\n         [ method ]\n         **\n         * Only for gradients!\n         * Returns array of gradient stops elements.\n         = (array) the stops array.\n        \\*/\n        function Gstops() {\n            return this.selectAll(\"stop\");\n        }\n        /*\\\n         * Element.addStop\n         [ method ]\n         **\n         * Only for gradients!\n         * Adds another stop to the gradient.\n         - color (string) stops color\n         - offset (number) stops offset 0..100\n         = (object) gradient element\n        \\*/\n        function GaddStop(color, offset) {\n            var stop = $(\"stop\"),\n                attr = {\n                    offset: +offset + \"%\"\n                };\n            color = Snap.color(color);\n            attr[\"stop-color\"] = color.hex;\n            if (color.opacity < 1) {\n                attr[\"stop-opacity\"] = color.opacity;\n            }\n            $(stop, attr);\n            var stops = this.stops(),\n                inserted;\n            for (var i = 0; i < stops.length; i++) {\n                var stopOffset = parseFloat(stops[i].attr(\"offset\"));\n                if (stopOffset > offset) {\n                    this.node.insertBefore(stop, stops[i].node);\n                    inserted = true;\n                    break;\n                }\n            }\n            if (!inserted) {\n                this.node.appendChild(stop);\n            }\n            return this;\n        }\n        function GgetBBox() {\n            if (this.type == \"linearGradient\") {\n                var x1 = $(this.node, \"x1\") || 0,\n                    x2 = $(this.node, \"x2\") || 1,\n                    y1 = $(this.node, \"y1\") || 0,\n                    y2 = $(this.node, \"y2\") || 0;\n                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));\n            } else {\n                var cx = this.node.cx || .5,\n                    cy = this.node.cy || .5,\n                    r = this.node.r || 0;\n                return Snap._.box(cx - r, cy - r, r * 2, r * 2);\n            }\n        }\n        /*\\\n         * Element.setStops\n         [ method ]\n         **\n         * Only for gradients!\n         * Updates stops of the gradient based on passed gradient descriptor. See @Ppaer.gradient\n         - str (string) gradient descriptor part after `()`.\n         = (object) gradient element\n         | var g = paper.gradient(\"l(0, 0, 1, 1)#000-#f00-#fff\");\n         | g.setStops(\"#fff-#000-#f00-#fc0\");\n        \\*/\n        function GsetStops(str) {\n            var grad = str,\n                stops = this.stops();\n            if (typeof str == \"string\") {\n                grad = eve(\"snap.util.grad.parse\", null, \"l(0,0,0,1)\" + str).firstDefined().stops;\n            }\n            if (!Snap.is(grad, \"array\")) {\n                return;\n            }\n            for (var i = 0; i < stops.length; i++) {\n                if (grad[i]) {\n                    var color = Snap.color(grad[i].color),\n                        attr = {\"offset\": grad[i].offset + \"%\"};\n                    attr[\"stop-color\"] = color.hex;\n                    if (color.opacity < 1) {\n                        attr[\"stop-opacity\"] = color.opacity;\n                    }\n                    stops[i].attr(attr);\n                } else {\n                    stops[i].remove();\n                }\n            }\n            for (i = stops.length; i < grad.length; i++) {\n                this.addStop(grad[i].color, grad[i].offset);\n            }\n            return this;\n        }\n        function gradient(defs, str) {\n            var grad = eve(\"snap.util.grad.parse\", null, str).firstDefined(),\n                el;\n            if (!grad) {\n                return null;\n            }\n            grad.params.unshift(defs);\n            if (grad.type.toLowerCase() == \"l\") {\n                el = gradientLinear.apply(0, grad.params);\n            } else {\n                el = gradientRadial.apply(0, grad.params);\n            }\n            if (grad.type != grad.type.toLowerCase()) {\n                $(el.node, {\n                    gradientUnits: \"userSpaceOnUse\"\n                });\n            }\n            var stops = grad.stops,\n                len = stops.length;\n            for (var i = 0; i < len; i++) {\n                var stop = stops[i];\n                el.addStop(stop.color, stop.offset);\n            }\n            return el;\n        }\n        function gradientLinear(defs, x1, y1, x2, y2) {\n            var el = Snap._.make(\"linearGradient\", defs);\n            el.stops = Gstops;\n            el.addStop = GaddStop;\n            el.getBBox = GgetBBox;\n            el.setStops = GsetStops;\n            if (x1 != null) {\n                $(el.node, {\n                    x1: x1,\n                    y1: y1,\n                    x2: x2,\n                    y2: y2\n                });\n            }\n            return el;\n        }\n        function gradientRadial(defs, cx, cy, r, fx, fy) {\n            var el = Snap._.make(\"radialGradient\", defs);\n            el.stops = Gstops;\n            el.addStop = GaddStop;\n            el.getBBox = GgetBBox;\n            if (cx != null) {\n                $(el.node, {\n                    cx: cx,\n                    cy: cy,\n                    r: r\n                });\n            }\n            if (fx != null && fy != null) {\n                $(el.node, {\n                    fx: fx,\n                    fy: fy\n                });\n            }\n            return el;\n        }\n        /*\\\n         * Paper.gradient\n         [ method ]\n         **\n         * Creates a gradient element\n         **\n         - gradient (string) gradient descriptor\n         > Gradient Descriptor\n         * The gradient descriptor is an expression formatted as\n         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be\n         * either linear or radial.  The uppercase `L` or `R` letters\n         * indicate absolute coordinates offset from the SVG surface.\n         * Lowercase `l` or `r` letters indicate coordinates\n         * calculated relative to the element to which the gradient is\n         * applied.  Coordinates specify a linear gradient vector as\n         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,\n         * `r` and optional `fx`, `fy` specifying a focal point away\n         * from the center of the circle. Specify `<colors>` as a list\n         * of dash-separated CSS color values.  Each color may be\n         * followed by a custom offset value, separated with a colon\n         * character.\n         > Examples\n         * Linear gradient, relative from top-left corner to bottom-right\n         * corner, from black through red to white:\n         | var g = paper.gradient(\"l(0, 0, 1, 1)#000-#f00-#fff\");\n         * Linear gradient, absolute from (0, 0) to (100, 100), from black\n         * through red at 25% to white:\n         | var g = paper.gradient(\"L(0, 0, 100, 100)#000-#f00:25-#fff\");\n         * Radial gradient, relative from the center of the element with radius\n         * half the width, from black to white:\n         | var g = paper.gradient(\"r(0.5, 0.5, 0.5)#000-#fff\");\n         * To apply the gradient:\n         | paper.circle(50, 50, 40).attr({\n         |     fill: g\n         | });\n         = (object) the `gradient` element\n        \\*/\n        proto.gradient = function (str) {\n            return gradient(this.defs, str);\n        };\n        proto.gradientLinear = function (x1, y1, x2, y2) {\n            return gradientLinear(this.defs, x1, y1, x2, y2);\n        };\n        proto.gradientRadial = function (cx, cy, r, fx, fy) {\n            return gradientRadial(this.defs, cx, cy, r, fx, fy);\n        };\n        /*\\\n         * Paper.toString\n         [ method ]\n         **\n         * Returns SVG code for the @Paper\n         = (string) SVG code for the @Paper\n        \\*/\n        proto.toString = function () {\n            var doc = this.node.ownerDocument,\n                f = doc.createDocumentFragment(),\n                d = doc.createElement(\"div\"),\n                svg = this.node.cloneNode(true),\n                res;\n            f.appendChild(d);\n            d.appendChild(svg);\n            Snap._.$(svg, {xmlns: \"http://www.w3.org/2000/svg\"});\n            res = d.innerHTML;\n            f.removeChild(f.firstChild);\n            return res;\n        };\n        /*\\\n         * Paper.toDataURL\n         [ method ]\n         **\n         * Returns SVG code for the @Paper as Data URI string.\n         = (string) Data URI string\n        \\*/\n        proto.toDataURL = function () {\n            if (window && window.btoa) {\n                return \"data:image/svg+xml;base64,\" + btoa(unescape(encodeURIComponent(this)));\n            }\n        };\n        /*\\\n         * Paper.clear\n         [ method ]\n         **\n         * Removes all child nodes of the paper, except <defs>.\n        \\*/\n        proto.clear = function () {\n            var node = this.node.firstChild,\n                next;\n            while (node) {\n                next = node.nextSibling;\n                if (node.tagName != \"defs\") {\n                    node.parentNode.removeChild(node);\n                } else {\n                    proto.clear.call({node: node});\n                }\n                node = next;\n            }\n        };\n    }());\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var elproto = Element.prototype,\n        is = Snap.is,\n        clone = Snap._.clone,\n        has = \"hasOwnProperty\",\n        p2s = /,?([a-z]),?/gi,\n        toFloat = parseFloat,\n        math = Math,\n        PI = math.PI,\n        mmin = math.min,\n        mmax = math.max,\n        pow = math.pow,\n        abs = math.abs;\n    function paths(ps) {\n        var p = paths.ps = paths.ps || {};\n        if (p[ps]) {\n            p[ps].sleep = 100;\n        } else {\n            p[ps] = {\n                sleep: 100\n            };\n        }\n        setTimeout(function () {\n            for (var key in p) if (p[has](key) && key != ps) {\n                p[key].sleep--;\n                !p[key].sleep && delete p[key];\n            }\n        });\n        return p[ps];\n    }\n    function box(x, y, width, height) {\n        if (x == null) {\n            x = y = width = height = 0;\n        }\n        if (y == null) {\n            y = x.y;\n            width = x.width;\n            height = x.height;\n            x = x.x;\n        }\n        return {\n            x: x,\n            y: y,\n            width: width,\n            w: width,\n            height: height,\n            h: height,\n            x2: x + width,\n            y2: y + height,\n            cx: x + width / 2,\n            cy: y + height / 2,\n            r1: math.min(width, height) / 2,\n            r2: math.max(width, height) / 2,\n            r0: math.sqrt(width * width + height * height) / 2,\n            path: rectPath(x, y, width, height),\n            vb: [x, y, width, height].join(\" \")\n        };\n    }\n    function toString() {\n        return this.join(\",\").replace(p2s, \"$1\");\n    }\n    function pathClone(pathArray) {\n        var res = clone(pathArray);\n        res.toString = toString;\n        return res;\n    }\n    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {\n        if (length == null) {\n            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\n        } else {\n            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,\n                getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));\n        }\n    }\n    function getLengthFactory(istotal, subpath) {\n        function O(val) {\n            return +(+val).toFixed(3);\n        }\n        return Snap._.cacher(function (path, length, onlystart) {\n            if (path instanceof Element) {\n                path = path.attr(\"d\");\n            }\n            path = path2curve(path);\n            var x, y, p, l, sp = \"\", subpaths = {}, point,\n                len = 0;\n            for (var i = 0, ii = path.length; i < ii; i++) {\n                p = path[i];\n                if (p[0] == \"M\") {\n                    x = +p[1];\n                    y = +p[2];\n                } else {\n                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                    if (len + l > length) {\n                        if (subpath && !subpaths.start) {\n                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                            sp += [\n                                \"C\" + O(point.start.x),\n                                O(point.start.y),\n                                O(point.m.x),\n                                O(point.m.y),\n                                O(point.x),\n                                O(point.y)\n                            ];\n                            if (onlystart) {return sp;}\n                            subpaths.start = sp;\n                            sp = [\n                                \"M\" + O(point.x),\n                                O(point.y) + \"C\" + O(point.n.x),\n                                O(point.n.y),\n                                O(point.end.x),\n                                O(point.end.y),\n                                O(p[5]),\n                                O(p[6])\n                            ].join();\n                            len += l;\n                            x = +p[5];\n                            y = +p[6];\n                            continue;\n                        }\n                        if (!istotal && !subpath) {\n                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);\n                            return point;\n                        }\n                    }\n                    len += l;\n                    x = +p[5];\n                    y = +p[6];\n                }\n                sp += p.shift() + p;\n            }\n            subpaths.end = sp;\n            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);\n            return point;\n        }, null, Snap._.clone);\n    }\n    var getTotalLength = getLengthFactory(1),\n        getPointAtLength = getLengthFactory(),\n        getSubpathsAtLength = getLengthFactory(0, 1);\n    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n        var t1 = 1 - t,\n            t13 = pow(t1, 3),\n            t12 = pow(t1, 2),\n            t2 = t * t,\n            t3 = t2 * t,\n            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,\n            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,\n            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),\n            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),\n            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),\n            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),\n            ax = t1 * p1x + t * c1x,\n            ay = t1 * p1y + t * c1y,\n            cx = t1 * c2x + t * p2x,\n            cy = t1 * c2y + t * p2y,\n            alpha = 90 - math.atan2(mx - nx, my - ny) * 180 / PI;\n        // (mx > nx || my < ny) && (alpha += 180);\n        return {\n            x: x,\n            y: y,\n            m: {x: mx, y: my},\n            n: {x: nx, y: ny},\n            start: {x: ax, y: ay},\n            end: {x: cx, y: cy},\n            alpha: alpha\n        };\n    }\n    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {\n        if (!Snap.is(p1x, \"array\")) {\n            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n        }\n        var bbox = curveDim.apply(null, p1x);\n        return box(\n            bbox.min.x,\n            bbox.min.y,\n            bbox.max.x - bbox.min.x,\n            bbox.max.y - bbox.min.y\n        );\n    }\n    function isPointInsideBBox(bbox, x, y) {\n        return  x >= bbox.x &&\n                x <= bbox.x + bbox.width &&\n                y >= bbox.y &&\n                y <= bbox.y + bbox.height;\n    }\n    function isBBoxIntersect(bbox1, bbox2) {\n        bbox1 = box(bbox1);\n        bbox2 = box(bbox2);\n        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)\n            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)\n            || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)\n            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)\n            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)\n            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)\n            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)\n            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)\n            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x\n                || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)\n            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y\n                || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);\n    }\n    function base3(t, p1, p2, p3, p4) {\n        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,\n            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;\n        return t * t2 - 3 * p1 + 3 * p2;\n    }\n    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {\n        if (z == null) {\n            z = 1;\n        }\n        z = z > 1 ? 1 : z < 0 ? 0 : z;\n        var z2 = z / 2,\n            n = 12,\n            Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],\n            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],\n            sum = 0;\n        for (var i = 0; i < n; i++) {\n            var ct = z2 * Tvalues[i] + z2,\n                xbase = base3(ct, x1, x2, x3, x4),\n                ybase = base3(ct, y1, y2, y3, y4),\n                comb = xbase * xbase + ybase * ybase;\n            sum += Cvalues[i] * math.sqrt(comb);\n        }\n        return z2 * sum;\n    }\n    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {\n        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {\n            return;\n        }\n        var t = 1,\n            step = t / 2,\n            t2 = t - step,\n            l,\n            e = .01;\n        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n        while (abs(l - ll) > e) {\n            step /= 2;\n            t2 += (l < ll ? 1 : -1) * step;\n            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);\n        }\n        return t2;\n    }\n    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n        if (\n            mmax(x1, x2) < mmin(x3, x4) ||\n            mmin(x1, x2) > mmax(x3, x4) ||\n            mmax(y1, y2) < mmin(y3, y4) ||\n            mmin(y1, y2) > mmax(y3, y4)\n        ) {\n            return;\n        }\n        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n        if (!denominator) {\n            return;\n        }\n        var px = nx / denominator,\n            py = ny / denominator,\n            px2 = +px.toFixed(2),\n            py2 = +py.toFixed(2);\n        if (\n            px2 < +mmin(x1, x2).toFixed(2) ||\n            px2 > +mmax(x1, x2).toFixed(2) ||\n            px2 < +mmin(x3, x4).toFixed(2) ||\n            px2 > +mmax(x3, x4).toFixed(2) ||\n            py2 < +mmin(y1, y2).toFixed(2) ||\n            py2 > +mmax(y1, y2).toFixed(2) ||\n            py2 < +mmin(y3, y4).toFixed(2) ||\n            py2 > +mmax(y3, y4).toFixed(2)\n        ) {\n            return;\n        }\n        return {x: px, y: py};\n    }\n    function inter(bez1, bez2) {\n        return interHelper(bez1, bez2);\n    }\n    function interCount(bez1, bez2) {\n        return interHelper(bez1, bez2, 1);\n    }\n    function interHelper(bez1, bez2, justCount) {\n        var bbox1 = bezierBBox(bez1),\n            bbox2 = bezierBBox(bez2);\n        if (!isBBoxIntersect(bbox1, bbox2)) {\n            return justCount ? 0 : [];\n        }\n        var l1 = bezlen.apply(0, bez1),\n            l2 = bezlen.apply(0, bez2),\n            n1 = ~~(l1 / 8),\n            n2 = ~~(l2 / 8),\n            dots1 = [],\n            dots2 = [],\n            xy = {},\n            res = justCount ? 0 : [];\n        for (var i = 0; i < n1 + 1; i++) {\n            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));\n            dots1.push({x: p.x, y: p.y, t: i / n1});\n        }\n        for (i = 0; i < n2 + 1; i++) {\n            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));\n            dots2.push({x: p.x, y: p.y, t: i / n2});\n        }\n        for (i = 0; i < n1; i++) {\n            for (var j = 0; j < n2; j++) {\n                var di = dots1[i],\n                    di1 = dots1[i + 1],\n                    dj = dots2[j],\n                    dj1 = dots2[j + 1],\n                    ci = abs(di1.x - di.x) < .001 ? \"y\" : \"x\",\n                    cj = abs(dj1.x - dj.x) < .001 ? \"y\" : \"x\",\n                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);\n                if (is) {\n                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {\n                        continue;\n                    }\n                    xy[is.x.toFixed(4)] = is.y.toFixed(4);\n                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),\n                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);\n                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {\n                        if (justCount) {\n                            res++;\n                        } else {\n                            res.push({\n                                x: is.x,\n                                y: is.y,\n                                t1: t1,\n                                t2: t2\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    function pathIntersection(path1, path2) {\n        return interPathHelper(path1, path2);\n    }\n    function pathIntersectionNumber(path1, path2) {\n        return interPathHelper(path1, path2, 1);\n    }\n    function interPathHelper(path1, path2, justCount) {\n        path1 = path2curve(path1);\n        path2 = path2curve(path2);\n        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,\n            res = justCount ? 0 : [];\n        for (var i = 0, ii = path1.length; i < ii; i++) {\n            var pi = path1[i];\n            if (pi[0] == \"M\") {\n                x1 = x1m = pi[1];\n                y1 = y1m = pi[2];\n            } else {\n                if (pi[0] == \"C\") {\n                    bez1 = [x1, y1].concat(pi.slice(1));\n                    x1 = bez1[6];\n                    y1 = bez1[7];\n                } else {\n                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];\n                    x1 = x1m;\n                    y1 = y1m;\n                }\n                for (var j = 0, jj = path2.length; j < jj; j++) {\n                    var pj = path2[j];\n                    if (pj[0] == \"M\") {\n                        x2 = x2m = pj[1];\n                        y2 = y2m = pj[2];\n                    } else {\n                        if (pj[0] == \"C\") {\n                            bez2 = [x2, y2].concat(pj.slice(1));\n                            x2 = bez2[6];\n                            y2 = bez2[7];\n                        } else {\n                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];\n                            x2 = x2m;\n                            y2 = y2m;\n                        }\n                        var intr = interHelper(bez1, bez2, justCount);\n                        if (justCount) {\n                            res += intr;\n                        } else {\n                            for (var k = 0, kk = intr.length; k < kk; k++) {\n                                intr[k].segment1 = i;\n                                intr[k].segment2 = j;\n                                intr[k].bez1 = bez1;\n                                intr[k].bez2 = bez2;\n                            }\n                            res = res.concat(intr);\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    function isPointInsidePath(path, x, y) {\n        var bbox = pathBBox(path);\n        return isPointInsideBBox(bbox, x, y) &&\n               interPathHelper(path, [[\"M\", x, y], [\"H\", bbox.x2 + 10]], 1) % 2 == 1;\n    }\n    function pathBBox(path) {\n        var pth = paths(path);\n        if (pth.bbox) {\n            return clone(pth.bbox);\n        }\n        if (!path) {\n            return box();\n        }\n        path = path2curve(path);\n        var x = 0,\n            y = 0,\n            X = [],\n            Y = [],\n            p;\n        for (var i = 0, ii = path.length; i < ii; i++) {\n            p = path[i];\n            if (p[0] == \"M\") {\n                x = p[1];\n                y = p[2];\n                X.push(x);\n                Y.push(y);\n            } else {\n                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);\n                X = X.concat(dim.min.x, dim.max.x);\n                Y = Y.concat(dim.min.y, dim.max.y);\n                x = p[5];\n                y = p[6];\n            }\n        }\n        var xmin = mmin.apply(0, X),\n            ymin = mmin.apply(0, Y),\n            xmax = mmax.apply(0, X),\n            ymax = mmax.apply(0, Y),\n            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);\n        pth.bbox = clone(bb);\n        return bb;\n    }\n    function rectPath(x, y, w, h, r) {\n        if (r) {\n            return [\n                [\"M\", +x + +r, y],\n                [\"l\", w - r * 2, 0],\n                [\"a\", r, r, 0, 0, 1, r, r],\n                [\"l\", 0, h - r * 2],\n                [\"a\", r, r, 0, 0, 1, -r, r],\n                [\"l\", r * 2 - w, 0],\n                [\"a\", r, r, 0, 0, 1, -r, -r],\n                [\"l\", 0, r * 2 - h],\n                [\"a\", r, r, 0, 0, 1, r, -r],\n                [\"z\"]\n            ];\n        }\n        var res = [[\"M\", x, y], [\"l\", w, 0], [\"l\", 0, h], [\"l\", -w, 0], [\"z\"]];\n        res.toString = toString;\n        return res;\n    }\n    function ellipsePath(x, y, rx, ry, a) {\n        if (a == null && ry == null) {\n            ry = rx;\n        }\n        x = +x;\n        y = +y;\n        rx = +rx;\n        ry = +ry;\n        if (a != null) {\n            var rad = Math.PI / 180,\n                x1 = x + rx * Math.cos(-ry * rad),\n                x2 = x + rx * Math.cos(-a * rad),\n                y1 = y + rx * Math.sin(-ry * rad),\n                y2 = y + rx * Math.sin(-a * rad),\n                res = [[\"M\", x1, y1], [\"A\", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];\n        } else {\n            res = [\n                [\"M\", x, y],\n                [\"m\", 0, -ry],\n                [\"a\", rx, ry, 0, 1, 1, 0, 2 * ry],\n                [\"a\", rx, ry, 0, 1, 1, 0, -2 * ry],\n                [\"z\"]\n            ];\n        }\n        res.toString = toString;\n        return res;\n    }\n    var unit2px = Snap._unit2px,\n        getPath = {\n        path: function (el) {\n            return el.attr(\"path\");\n        },\n        circle: function (el) {\n            var attr = unit2px(el);\n            return ellipsePath(attr.cx, attr.cy, attr.r);\n        },\n        ellipse: function (el) {\n            var attr = unit2px(el);\n            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);\n        },\n        rect: function (el) {\n            var attr = unit2px(el);\n            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);\n        },\n        image: function (el) {\n            var attr = unit2px(el);\n            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);\n        },\n        line: function (el) {\n            return \"M\" + [el.attr(\"x1\") || 0, el.attr(\"y1\") || 0, el.attr(\"x2\"), el.attr(\"y2\")];\n        },\n        polyline: function (el) {\n            return \"M\" + el.attr(\"points\");\n        },\n        polygon: function (el) {\n            return \"M\" + el.attr(\"points\") + \"z\";\n        },\n        deflt: function (el) {\n            var bbox = el.node.getBBox();\n            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);\n        }\n    };\n    function pathToRelative(pathArray) {\n        var pth = paths(pathArray),\n            lowerCase = String.prototype.toLowerCase;\n        if (pth.rel) {\n            return pathClone(pth.rel);\n        }\n        if (!Snap.is(pathArray, \"array\") || !Snap.is(pathArray && pathArray[0], \"array\")) {\n            pathArray = Snap.parsePathString(pathArray);\n        }\n        var res = [],\n            x = 0,\n            y = 0,\n            mx = 0,\n            my = 0,\n            start = 0;\n        if (pathArray[0][0] == \"M\") {\n            x = pathArray[0][1];\n            y = pathArray[0][2];\n            mx = x;\n            my = y;\n            start++;\n            res.push([\"M\", x, y]);\n        }\n        for (var i = start, ii = pathArray.length; i < ii; i++) {\n            var r = res[i] = [],\n                pa = pathArray[i];\n            if (pa[0] != lowerCase.call(pa[0])) {\n                r[0] = lowerCase.call(pa[0]);\n                switch (r[0]) {\n                    case \"a\":\n                        r[1] = pa[1];\n                        r[2] = pa[2];\n                        r[3] = pa[3];\n                        r[4] = pa[4];\n                        r[5] = pa[5];\n                        r[6] = +(pa[6] - x).toFixed(3);\n                        r[7] = +(pa[7] - y).toFixed(3);\n                        break;\n                    case \"v\":\n                        r[1] = +(pa[1] - y).toFixed(3);\n                        break;\n                    case \"m\":\n                        mx = pa[1];\n                        my = pa[2];\n                    default:\n                        for (var j = 1, jj = pa.length; j < jj; j++) {\n                            r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);\n                        }\n                }\n            } else {\n                r = res[i] = [];\n                if (pa[0] == \"m\") {\n                    mx = pa[1] + x;\n                    my = pa[2] + y;\n                }\n                for (var k = 0, kk = pa.length; k < kk; k++) {\n                    res[i][k] = pa[k];\n                }\n            }\n            var len = res[i].length;\n            switch (res[i][0]) {\n                case \"z\":\n                    x = mx;\n                    y = my;\n                    break;\n                case \"h\":\n                    x += +res[i][len - 1];\n                    break;\n                case \"v\":\n                    y += +res[i][len - 1];\n                    break;\n                default:\n                    x += +res[i][len - 2];\n                    y += +res[i][len - 1];\n            }\n        }\n        res.toString = toString;\n        pth.rel = pathClone(res);\n        return res;\n    }\n    function pathToAbsolute(pathArray) {\n        var pth = paths(pathArray);\n        if (pth.abs) {\n            return pathClone(pth.abs);\n        }\n        if (!is(pathArray, \"array\") || !is(pathArray && pathArray[0], \"array\")) { // rough assumption\n            pathArray = Snap.parsePathString(pathArray);\n        }\n        if (!pathArray || !pathArray.length) {\n            return [[\"M\", 0, 0]];\n        }\n        var res = [],\n            x = 0,\n            y = 0,\n            mx = 0,\n            my = 0,\n            start = 0,\n            pa0;\n        if (pathArray[0][0] == \"M\") {\n            x = +pathArray[0][1];\n            y = +pathArray[0][2];\n            mx = x;\n            my = y;\n            start++;\n            res[0] = [\"M\", x, y];\n        }\n        var crz = pathArray.length == 3 &&\n            pathArray[0][0] == \"M\" &&\n            pathArray[1][0].toUpperCase() == \"R\" &&\n            pathArray[2][0].toUpperCase() == \"Z\";\n        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {\n            res.push(r = []);\n            pa = pathArray[i];\n            pa0 = pa[0];\n            if (pa0 != pa0.toUpperCase()) {\n                r[0] = pa0.toUpperCase();\n                switch (r[0]) {\n                    case \"A\":\n                        r[1] = pa[1];\n                        r[2] = pa[2];\n                        r[3] = pa[3];\n                        r[4] = pa[4];\n                        r[5] = pa[5];\n                        r[6] = +pa[6] + x;\n                        r[7] = +pa[7] + y;\n                        break;\n                    case \"V\":\n                        r[1] = +pa[1] + y;\n                        break;\n                    case \"H\":\n                        r[1] = +pa[1] + x;\n                        break;\n                    case \"R\":\n                        var dots = [x, y].concat(pa.slice(1));\n                        for (var j = 2, jj = dots.length; j < jj; j++) {\n                            dots[j] = +dots[j] + x;\n                            dots[++j] = +dots[j] + y;\n                        }\n                        res.pop();\n                        res = res.concat(catmullRom2bezier(dots, crz));\n                        break;\n                    case \"O\":\n                        res.pop();\n                        dots = ellipsePath(x, y, pa[1], pa[2]);\n                        dots.push(dots[0]);\n                        res = res.concat(dots);\n                        break;\n                    case \"U\":\n                        res.pop();\n                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n                        r = [\"U\"].concat(res[res.length - 1].slice(-2));\n                        break;\n                    case \"M\":\n                        mx = +pa[1] + x;\n                        my = +pa[2] + y;\n                    default:\n                        for (j = 1, jj = pa.length; j < jj; j++) {\n                            r[j] = +pa[j] + (j % 2 ? x : y);\n                        }\n                }\n            } else if (pa0 == \"R\") {\n                dots = [x, y].concat(pa.slice(1));\n                res.pop();\n                res = res.concat(catmullRom2bezier(dots, crz));\n                r = [\"R\"].concat(pa.slice(-2));\n            } else if (pa0 == \"O\") {\n                res.pop();\n                dots = ellipsePath(x, y, pa[1], pa[2]);\n                dots.push(dots[0]);\n                res = res.concat(dots);\n            } else if (pa0 == \"U\") {\n                res.pop();\n                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));\n                r = [\"U\"].concat(res[res.length - 1].slice(-2));\n            } else {\n                for (var k = 0, kk = pa.length; k < kk; k++) {\n                    r[k] = pa[k];\n                }\n            }\n            pa0 = pa0.toUpperCase();\n            if (pa0 != \"O\") {\n                switch (r[0]) {\n                    case \"Z\":\n                        x = +mx;\n                        y = +my;\n                        break;\n                    case \"H\":\n                        x = r[1];\n                        break;\n                    case \"V\":\n                        y = r[1];\n                        break;\n                    case \"M\":\n                        mx = r[r.length - 2];\n                        my = r[r.length - 1];\n                    default:\n                        x = r[r.length - 2];\n                        y = r[r.length - 1];\n                }\n            }\n        }\n        res.toString = toString;\n        pth.abs = pathClone(res);\n        return res;\n    }\n    function l2c(x1, y1, x2, y2) {\n        return [x1, y1, x2, y2, x2, y2];\n    }\n    function q2c(x1, y1, ax, ay, x2, y2) {\n        var _13 = 1 / 3,\n            _23 = 2 / 3;\n        return [\n                _13 * x1 + _23 * ax,\n                _13 * y1 + _23 * ay,\n                _13 * x2 + _23 * ax,\n                _13 * y2 + _23 * ay,\n                x2,\n                y2\n            ];\n    }\n    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n        // for more information of where this math came from visit:\n        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n        var _120 = PI * 120 / 180,\n            rad = PI / 180 * (+angle || 0),\n            res = [],\n            xy,\n            rotate = Snap._.cacher(function (x, y, rad) {\n                var X = x * math.cos(rad) - y * math.sin(rad),\n                    Y = x * math.sin(rad) + y * math.cos(rad);\n                return {x: X, y: Y};\n            });\n        if (!rx || !ry) {\n            return [x1, y1, x2, y2, x2, y2];\n        }\n        if (!recursive) {\n            xy = rotate(x1, y1, -rad);\n            x1 = xy.x;\n            y1 = xy.y;\n            xy = rotate(x2, y2, -rad);\n            x2 = xy.x;\n            y2 = xy.y;\n            var cos = math.cos(PI / 180 * angle),\n                sin = math.sin(PI / 180 * angle),\n                x = (x1 - x2) / 2,\n                y = (y1 - y2) / 2;\n            var h = x * x / (rx * rx) + y * y / (ry * ry);\n            if (h > 1) {\n                h = math.sqrt(h);\n                rx = h * rx;\n                ry = h * ry;\n            }\n            var rx2 = rx * rx,\n                ry2 = ry * ry,\n                k = (large_arc_flag == sweep_flag ? -1 : 1) *\n                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n                cx = k * rx * y / ry + (x1 + x2) / 2,\n                cy = k * -ry * x / rx + (y1 + y2) / 2,\n                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),\n                f2 = math.asin(((y2 - cy) / ry).toFixed(9));\n\n            f1 = x1 < cx ? PI - f1 : f1;\n            f2 = x2 < cx ? PI - f2 : f2;\n            f1 < 0 && (f1 = PI * 2 + f1);\n            f2 < 0 && (f2 = PI * 2 + f2);\n            if (sweep_flag && f1 > f2) {\n                f1 = f1 - PI * 2;\n            }\n            if (!sweep_flag && f2 > f1) {\n                f2 = f2 - PI * 2;\n            }\n        } else {\n            f1 = recursive[0];\n            f2 = recursive[1];\n            cx = recursive[2];\n            cy = recursive[3];\n        }\n        var df = f2 - f1;\n        if (abs(df) > _120) {\n            var f2old = f2,\n                x2old = x2,\n                y2old = y2;\n            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n            x2 = cx + rx * math.cos(f2);\n            y2 = cy + ry * math.sin(f2);\n            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n        }\n        df = f2 - f1;\n        var c1 = math.cos(f1),\n            s1 = math.sin(f1),\n            c2 = math.cos(f2),\n            s2 = math.sin(f2),\n            t = math.tan(df / 4),\n            hx = 4 / 3 * rx * t,\n            hy = 4 / 3 * ry * t,\n            m1 = [x1, y1],\n            m2 = [x1 + hx * s1, y1 - hy * c1],\n            m3 = [x2 + hx * s2, y2 - hy * c2],\n            m4 = [x2, y2];\n        m2[0] = 2 * m1[0] - m2[0];\n        m2[1] = 2 * m1[1] - m2[1];\n        if (recursive) {\n            return [m2, m3, m4].concat(res);\n        } else {\n            res = [m2, m3, m4].concat(res).join().split(\",\");\n            var newres = [];\n            for (var i = 0, ii = res.length; i < ii; i++) {\n                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;\n            }\n            return newres;\n        }\n    }\n    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {\n        var t1 = 1 - t;\n        return {\n            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,\n            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y\n        };\n    }\n\n    // Returns bounding box of cubic bezier curve.\n    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n    // Original version: NISHIO Hirokazu\n    // Modifications: https://github.com/timo22345\n    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {\n        var tvalues = [],\n            bounds = [[], []],\n            a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n        for (var i = 0; i < 2; ++i) {\n            if (i == 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n            } else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n            if (abs(a) < 1e-12) {\n                if (abs(b) < 1e-12) {\n                    continue;\n                }\n                t = -c / b;\n                if (0 < t && t < 1) {\n                    tvalues.push(t);\n                }\n                continue;\n            }\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = math.sqrt(b2ac);\n            if (b2ac < 0) {\n                continue;\n            }\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if (0 < t1 && t1 < 1) {\n                tvalues.push(t1);\n            }\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if (0 < t2 && t2 < 1) {\n                tvalues.push(t2);\n            }\n        }\n\n        var x, y, j = tvalues.length,\n            jlen = j,\n            mt;\n        while (j--) {\n            t = tvalues[j];\n            mt = 1 - t;\n            bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n            bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n        }\n\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n        bounds[0].length = bounds[1].length = jlen + 2;\n\n\n        return {\n          min: {x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1])},\n          max: {x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1])}\n        };\n    }\n\n    function path2curve(path, path2) {\n        var pth = !path2 && paths(path);\n        if (!path2 && pth.curve) {\n            return pathClone(pth.curve);\n        }\n        var p = pathToAbsolute(path),\n            p2 = path2 && pathToAbsolute(path2),\n            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},\n            processPath = function (path, d, pcom) {\n                var nx, ny;\n                if (!path) {\n                    return [\"C\", d.x, d.y, d.x, d.y, d.x, d.y];\n                }\n                !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);\n                switch (path[0]) {\n                    case \"M\":\n                        d.X = path[1];\n                        d.Y = path[2];\n                        break;\n                    case \"A\":\n                        path = [\"C\"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));\n                        break;\n                    case \"S\":\n                        if (pcom == \"C\" || pcom == \"S\") { // In \"S\" case we have to take into account, if the previous command is C/S.\n                            nx = d.x * 2 - d.bx;          // And reflect the previous\n                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.\n                        }\n                        else {                            // or some else or nothing\n                            nx = d.x;\n                            ny = d.y;\n                        }\n                        path = [\"C\", nx, ny].concat(path.slice(1));\n                        break;\n                    case \"T\":\n                        if (pcom == \"Q\" || pcom == \"T\") { // In \"T\" case we have to take into account, if the previous command is Q/T.\n                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar\n                            d.qy = d.y * 2 - d.qy;        // to case \"S\".\n                        }\n                        else {                            // or something else or nothing\n                            d.qx = d.x;\n                            d.qy = d.y;\n                        }\n                        path = [\"C\"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));\n                        break;\n                    case \"Q\":\n                        d.qx = path[1];\n                        d.qy = path[2];\n                        path = [\"C\"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));\n                        break;\n                    case \"L\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], path[2]));\n                        break;\n                    case \"H\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, path[1], d.y));\n                        break;\n                    case \"V\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, d.x, path[1]));\n                        break;\n                    case \"Z\":\n                        path = [\"C\"].concat(l2c(d.x, d.y, d.X, d.Y));\n                        break;\n                }\n                return path;\n            },\n            fixArc = function (pp, i) {\n                if (pp[i].length > 7) {\n                    pp[i].shift();\n                    var pi = pp[i];\n                    while (pi.length) {\n                        pcoms1[i] = \"A\"; // if created multiple C:s, their original seg is saved\n                        p2 && (pcoms2[i] = \"A\"); // the same as above\n                        pp.splice(i++, 0, [\"C\"].concat(pi.splice(0, 6)));\n                    }\n                    pp.splice(i, 1);\n                    ii = mmax(p.length, p2 && p2.length || 0);\n                }\n            },\n            fixM = function (path1, path2, a1, a2, i) {\n                if (path1 && path2 && path1[i][0] == \"M\" && path2[i][0] != \"M\") {\n                    path2.splice(i, 0, [\"M\", a2.x, a2.y]);\n                    a1.bx = 0;\n                    a1.by = 0;\n                    a1.x = path1[i][1];\n                    a1.y = path1[i][2];\n                    ii = mmax(p.length, p2 && p2.length || 0);\n                }\n            },\n            pcoms1 = [], // path commands of original path p\n            pcoms2 = [], // path commands of original path p2\n            pfirst = \"\", // temporary holder for original path command\n            pcom = \"\"; // holder for previous path command of original path\n        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {\n            p[i] && (pfirst = p[i][0]); // save current path command\n\n            if (pfirst != \"C\") // C is not saved yet, because it may be result of conversion\n            {\n                pcoms1[i] = pfirst; // Save current path command\n                i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom\n            }\n            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath\n\n            if (pcoms1[i] != \"A\" && pfirst == \"C\") pcoms1[i] = \"C\"; // A is the only command\n            // which may produce multiple C:s\n            // so we have to make sure that C is also C in original path\n\n            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1\n\n            if (p2) { // the same procedures is done to p2\n                p2[i] && (pfirst = p2[i][0]);\n                if (pfirst != \"C\") {\n                    pcoms2[i] = pfirst;\n                    i && (pcom = pcoms2[i - 1]);\n                }\n                p2[i] = processPath(p2[i], attrs2, pcom);\n\n                if (pcoms2[i] != \"A\" && pfirst == \"C\") {\n                    pcoms2[i] = \"C\";\n                }\n\n                fixArc(p2, i);\n            }\n            fixM(p, p2, attrs, attrs2, i);\n            fixM(p2, p, attrs2, attrs, i);\n            var seg = p[i],\n                seg2 = p2 && p2[i],\n                seglen = seg.length,\n                seg2len = p2 && seg2.length;\n            attrs.x = seg[seglen - 2];\n            attrs.y = seg[seglen - 1];\n            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;\n            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;\n            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);\n            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);\n            attrs2.x = p2 && seg2[seg2len - 2];\n            attrs2.y = p2 && seg2[seg2len - 1];\n        }\n        if (!p2) {\n            pth.curve = pathClone(p);\n        }\n        return p2 ? [p, p2] : p;\n    }\n    function mapPath(path, matrix) {\n        if (!matrix) {\n            return path;\n        }\n        var x, y, i, j, ii, jj, pathi;\n        path = path2curve(path);\n        for (i = 0, ii = path.length; i < ii; i++) {\n            pathi = path[i];\n            for (j = 1, jj = pathi.length; j < jj; j += 2) {\n                x = matrix.x(pathi[j], pathi[j + 1]);\n                y = matrix.y(pathi[j], pathi[j + 1]);\n                pathi[j] = x;\n                pathi[j + 1] = y;\n            }\n        }\n        return path;\n    }\n\n    // http://schepers.cc/getting-to-the-point\n    function catmullRom2bezier(crp, z) {\n        var d = [];\n        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {\n            var p = [\n                        {x: +crp[i - 2], y: +crp[i - 1]},\n                        {x: +crp[i],     y: +crp[i + 1]},\n                        {x: +crp[i + 2], y: +crp[i + 3]},\n                        {x: +crp[i + 4], y: +crp[i + 5]}\n                    ];\n            if (z) {\n                if (!i) {\n                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};\n                } else if (iLen - 4 == i) {\n                    p[3] = {x: +crp[0], y: +crp[1]};\n                } else if (iLen - 2 == i) {\n                    p[2] = {x: +crp[0], y: +crp[1]};\n                    p[3] = {x: +crp[2], y: +crp[3]};\n                }\n            } else {\n                if (iLen - 4 == i) {\n                    p[3] = p[2];\n                } else if (!i) {\n                    p[0] = {x: +crp[i], y: +crp[i + 1]};\n                }\n            }\n            d.push([\"C\",\n                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,\n                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,\n                  (p[1].x + 6 * p[2].x - p[3].x) / 6,\n                  (p[1].y + 6*p[2].y - p[3].y) / 6,\n                  p[2].x,\n                  p[2].y\n            ]);\n        }\n\n        return d;\n    }\n\n    // export\n    Snap.path = paths;\n\n    /*\\\n     * Snap.path.getTotalLength\n     [ method ]\n     **\n     * Returns the length of the given path in pixels\n     **\n     - path (string) SVG path string\n     **\n     = (number) length\n    \\*/\n    Snap.path.getTotalLength = getTotalLength;\n    /*\\\n     * Snap.path.getPointAtLength\n     [ method ]\n     **\n     * Returns the coordinates of the point located at the given length along the given path\n     **\n     - path (string) SVG path string\n     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n     **\n     = (object) representation of the point:\n     o {\n     o     x: (number) x coordinate,\n     o     y: (number) y coordinate,\n     o     alpha: (number) angle of derivative\n     o }\n    \\*/\n    Snap.path.getPointAtLength = getPointAtLength;\n    /*\\\n     * Snap.path.getSubpath\n     [ method ]\n     **\n     * Returns the subpath of a given path between given start and end lengths\n     **\n     - path (string) SVG path string\n     - from (number) length, in pixels, from the start of the path to the start of the segment\n     - to (number) length, in pixels, from the start of the path to the end of the segment\n     **\n     = (string) path string definition for the segment\n    \\*/\n    Snap.path.getSubpath = function (path, from, to) {\n        if (this.getTotalLength(path) - to < 1e-6) {\n            return getSubpathsAtLength(path, from).end;\n        }\n        var a = getSubpathsAtLength(path, to, 1);\n        return from ? getSubpathsAtLength(a, from).end : a;\n    };\n    /*\\\n     * Element.getTotalLength\n     [ method ]\n     **\n     * Returns the length of the path in pixels (only works for `path` elements)\n     = (number) length\n    \\*/\n    elproto.getTotalLength = function () {\n        if (this.node.getTotalLength) {\n            return this.node.getTotalLength();\n        }\n    };\n    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?\n    /*\\\n     * Element.getPointAtLength\n     [ method ]\n     **\n     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)\n     **\n     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps\n     **\n     = (object) representation of the point:\n     o {\n     o     x: (number) x coordinate,\n     o     y: (number) y coordinate,\n     o     alpha: (number) angle of derivative\n     o }\n    \\*/\n    elproto.getPointAtLength = function (length) {\n        return getPointAtLength(this.attr(\"d\"), length);\n    };\n    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.\n    /*\\\n     * Element.getSubpath\n     [ method ]\n     **\n     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)\n     **\n     - from (number) length, in pixels, from the start of the path to the start of the segment\n     - to (number) length, in pixels, from the start of the path to the end of the segment\n     **\n     = (string) path string definition for the segment\n    \\*/\n    elproto.getSubpath = function (from, to) {\n        return Snap.path.getSubpath(this.attr(\"d\"), from, to);\n    };\n    Snap._.box = box;\n    /*\\\n     * Snap.path.findDotsAtSegment\n     [ method ]\n     **\n     * Utility method\n     **\n     * Finds dot coordinates on the given cubic bezir curve at the given t\n     - p1x (number) x of the first point of the curve\n     - p1y (number) y of the first point of the curve\n     - c1x (number) x of the first anchor of the curve\n     - c1y (number) y of the first anchor of the curve\n     - c2x (number) x of the second anchor of the curve\n     - c2y (number) y of the second anchor of the curve\n     - p2x (number) x of the second point of the curve\n     - p2y (number) y of the second point of the curve\n     - t (number) position on the curve (0..1)\n     = (object) point information in format:\n     o {\n     o     x: (number) x coordinate of the point,\n     o     y: (number) y coordinate of the point,\n     o     m: {\n     o         x: (number) x coordinate of the left anchor,\n     o         y: (number) y coordinate of the left anchor\n     o     },\n     o     n: {\n     o         x: (number) x coordinate of the right anchor,\n     o         y: (number) y coordinate of the right anchor\n     o     },\n     o     start: {\n     o         x: (number) x coordinate of the start of the curve,\n     o         y: (number) y coordinate of the start of the curve\n     o     },\n     o     end: {\n     o         x: (number) x coordinate of the end of the curve,\n     o         y: (number) y coordinate of the end of the curve\n     o     },\n     o     alpha: (number) angle of the curve derivative at the point\n     o }\n    \\*/\n    Snap.path.findDotsAtSegment = findDotsAtSegment;\n    /*\\\n     * Snap.path.bezierBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns the bounding box of a given cubic bezir curve\n     - p1x (number) x of the first point of the curve\n     - p1y (number) y of the first point of the curve\n     - c1x (number) x of the first anchor of the curve\n     - c1y (number) y of the first anchor of the curve\n     - c2x (number) x of the second anchor of the curve\n     - c2y (number) y of the second anchor of the curve\n     - p2x (number) x of the second point of the curve\n     - p2y (number) y of the second point of the curve\n     * or\n     - bez (array) array of six points for bezir curve\n     = (object) bounding box\n     o {\n     o     x: (number) x coordinate of the left top point of the box,\n     o     y: (number) y coordinate of the left top point of the box,\n     o     x2: (number) x coordinate of the right bottom point of the box,\n     o     y2: (number) y coordinate of the right bottom point of the box,\n     o     width: (number) width of the box,\n     o     height: (number) height of the box\n     o }\n    \\*/\n    Snap.path.bezierBBox = bezierBBox;\n    /*\\\n     * Snap.path.isPointInsideBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if given point is inside bounding box\n     - bbox (string) bounding box\n     - x (string) x coordinate of the point\n     - y (string) y coordinate of the point\n     = (boolean) `true` if point is inside\n    \\*/\n    Snap.path.isPointInsideBBox = isPointInsideBBox;\n    Snap.closest = function (x, y, X, Y) {\n        var r = 100,\n            b = box(x - r / 2, y - r / 2, r, r),\n            inside = [],\n            getter = X[0].hasOwnProperty(\"x\") ? function (i) {\n                return {\n                    x: X[i].x,\n                    y: X[i].y\n                };\n            } : function (i) {\n                return {\n                    x: X[i],\n                    y: Y[i]\n                };\n            },\n            found = 0;\n        while (r <= 1e6 && !found) {\n            for (var i = 0, ii = X.length; i < ii; i++) {\n                var xy = getter(i);\n                if (isPointInsideBBox(b, xy.x, xy.y)) {\n                    found++;\n                    inside.push(xy);\n                    break;\n                }\n            }\n            if (!found) {\n                r *= 2;\n                b = box(x - r / 2, y - r / 2, r, r)\n            }\n        }\n        if (r == 1e6) {\n            return;\n        }\n        var len = Infinity,\n            res;\n        for (i = 0, ii = inside.length; i < ii; i++) {\n            var l = Snap.len(x, y, inside[i].x, inside[i].y);\n            if (len > l) {\n                len = l;\n                inside[i].len = l;\n                res = inside[i];\n            }\n        }\n        return res;\n    };\n    /*\\\n     * Snap.path.isBBoxIntersect\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if two bounding boxes intersect\n     - bbox1 (string) first bounding box\n     - bbox2 (string) second bounding box\n     = (boolean) `true` if bounding boxes intersect\n    \\*/\n    Snap.path.isBBoxIntersect = isBBoxIntersect;\n    /*\\\n     * Snap.path.intersection\n     [ method ]\n     **\n     * Utility method\n     **\n     * Finds intersections of two paths\n     - path1 (string) path string\n     - path2 (string) path string\n     = (array) dots of intersection\n     o [\n     o     {\n     o         x: (number) x coordinate of the point,\n     o         y: (number) y coordinate of the point,\n     o         t1: (number) t value for segment of path1,\n     o         t2: (number) t value for segment of path2,\n     o         segment1: (number) order number for segment of path1,\n     o         segment2: (number) order number for segment of path2,\n     o         bez1: (array) eight coordinates representing bezir curve for the segment of path1,\n     o         bez2: (array) eight coordinates representing bezir curve for the segment of path2\n     o     }\n     o ]\n    \\*/\n    Snap.path.intersection = pathIntersection;\n    Snap.path.intersectionNumber = pathIntersectionNumber;\n    /*\\\n     * Snap.path.isPointInside\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns `true` if given point is inside a given closed path.\n     *\n     * Note: fill mode doesnt affect the result of this method.\n     - path (string) path string\n     - x (number) x of the point\n     - y (number) y of the point\n     = (boolean) `true` if point is inside the path\n    \\*/\n    Snap.path.isPointInside = isPointInsidePath;\n    /*\\\n     * Snap.path.getBBox\n     [ method ]\n     **\n     * Utility method\n     **\n     * Returns the bounding box of a given path\n     - path (string) path string\n     = (object) bounding box\n     o {\n     o     x: (number) x coordinate of the left top point of the box,\n     o     y: (number) y coordinate of the left top point of the box,\n     o     x2: (number) x coordinate of the right bottom point of the box,\n     o     y2: (number) y coordinate of the right bottom point of the box,\n     o     width: (number) width of the box,\n     o     height: (number) height of the box\n     o }\n    \\*/\n    Snap.path.getBBox = pathBBox;\n    Snap.path.get = getPath;\n    /*\\\n     * Snap.path.toRelative\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path coordinates into relative values\n     - path (string) path string\n     = (array) path string\n    \\*/\n    Snap.path.toRelative = pathToRelative;\n    /*\\\n     * Snap.path.toAbsolute\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path coordinates into absolute values\n     - path (string) path string\n     = (array) path string\n    \\*/\n    Snap.path.toAbsolute = pathToAbsolute;\n    /*\\\n     * Snap.path.toCubic\n     [ method ]\n     **\n     * Utility method\n     **\n     * Converts path to a new path where all segments are cubic bezir curves\n     - pathString (string|array) path string or array of segments\n     = (array) array of segments\n    \\*/\n    Snap.path.toCubic = path2curve;\n    /*\\\n     * Snap.path.map\n     [ method ]\n     **\n     * Transform the path string with the given matrix\n     - path (string) path string\n     - matrix (object) see @Matrix\n     = (string) transformed path string\n    \\*/\n    Snap.path.map = mapPath;\n    Snap.path.toString = toString;\n    Snap.path.clone = pathClone;\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var mmax = Math.max,\n        mmin = Math.min;\n\n    // Set\n    var Set = function (items) {\n        this.items = [];\n\tthis.bindings = {};\n        this.length = 0;\n        this.type = \"set\";\n        if (items) {\n            for (var i = 0, ii = items.length; i < ii; i++) {\n                if (items[i]) {\n                    this[this.items.length] = this.items[this.items.length] = items[i];\n                    this.length++;\n                }\n            }\n        }\n    },\n    setproto = Set.prototype;\n    /*\\\n     * Set.push\n     [ method ]\n     **\n     * Adds each argument to the current set\n     = (object) original element\n    \\*/\n    setproto.push = function () {\n        var item,\n            len;\n        for (var i = 0, ii = arguments.length; i < ii; i++) {\n            item = arguments[i];\n            if (item) {\n                len = this.items.length;\n                this[len] = this.items[len] = item;\n                this.length++;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Set.pop\n     [ method ]\n     **\n     * Removes last element and returns it\n     = (object) element\n    \\*/\n    setproto.pop = function () {\n        this.length && delete this[this.length--];\n        return this.items.pop();\n    };\n    /*\\\n     * Set.forEach\n     [ method ]\n     **\n     * Executes given function for each element in the set\n     *\n     * If the function returns `false`, the loop stops running.\n     **\n     - callback (function) function to run\n     - thisArg (object) context object for the callback\n     = (object) Set object\n    \\*/\n    setproto.forEach = function (callback, thisArg) {\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\n            if (callback.call(thisArg, this.items[i], i) === false) {\n                return this;\n            }\n        }\n        return this;\n    };\n    /*\\\n     * Set.animate\n     [ method ]\n     **\n     * Animates each element in set in sync.\n     *\n     **\n     - attrs (object) key-value pairs of destination attributes\n     - duration (number) duration of the animation in milliseconds\n     - easing (function) #optional easing function from @mina or custom\n     - callback (function) #optional callback function that executes when the animation ends\n     * or\n     - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`\n     > Usage\n     | // animate all elements in set to radius 10\n     | set.animate({r: 10}, 500, mina.easein);\n     | // or\n     | // animate first element to radius 10, but second to radius 20 and in different time\n     | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);\n     = (Element) the current element\n    \\*/\n    setproto.animate = function (attrs, ms, easing, callback) {\n        if (typeof easing == \"function\" && !easing.length) {\n            callback = easing;\n            easing = mina.linear;\n        }\n        if (attrs instanceof Snap._.Animation) {\n            callback = attrs.callback;\n            easing = attrs.easing;\n            ms = easing.dur;\n            attrs = attrs.attr;\n        }\n        var args = arguments;\n        if (Snap.is(attrs, \"array\") && Snap.is(args[args.length - 1], \"array\")) {\n            var each = true;\n        }\n        var begin,\n            handler = function () {\n                if (begin) {\n                    this.b = begin;\n                } else {\n                    begin = this.b;\n                }\n            },\n            cb = 0,\n            set = this,\n            callbacker = callback && function () {\n                if (++cb == set.length) {\n                    callback.call(this);\n                }\n            };\n        return this.forEach(function (el, i) {\n            eve.once(\"snap.animcreated.\" + el.id, handler);\n            if (each) {\n                args[i] && el.animate.apply(el, args[i]);\n            } else {\n                el.animate(attrs, ms, easing, callbacker);\n            }\n        });\n    };\n    /*\\\n     * Set.remove\n     [ method ]\n     **\n     * Removes all children of the set.\n     *\n     = (object) Set object\n    \\*/\n    setproto.remove = function () {\n        while (this.length) {\n            this.pop().remove();\n        }\n        return this;\n    };\n    /*\\\n     * Set.bind\n     [ method ]\n     **\n     * Specifies how to handle a specific attribute when applied\n     * to a set.\n     *\n     **\n     - attr (string) attribute name\n     - callback (function) function to run\n     * or\n     - attr (string) attribute name\n     - element (Element) specific element in the set to apply the attribute to\n     * or\n     - attr (string) attribute name\n     - element (Element) specific element in the set to apply the attribute to\n     - eattr (string) attribute on the element to bind the attribute to\n     = (object) Set object\n    \\*/\n    setproto.bind = function (attr, a, b) {\n        var data = {};\n        if (typeof a == \"function\") {\n            this.bindings[attr] = a;\n        } else {\n            var aname = b || attr;\n            this.bindings[attr] = function (v) {\n                data[aname] = v;\n                a.attr(data);\n            };\n        }\n        return this;\n    };\n    /*\\\n     * Set.attr\n     [ method ]\n     **\n     * Equivalent of @Element.attr.\n     = (object) Set object\n    \\*/\n    setproto.attr = function (value) {\n        var unbound = {};\n        for (var k in value) {\n            if (this.bindings[k]) {\n                this.bindings[k](value[k]);\n            } else {\n                unbound[k] = value[k];\n            }\n        }\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\n            this.items[i].attr(unbound);\n        }\n        return this;\n    };\n    /*\\\n     * Set.clear\n     [ method ]\n     **\n     * Removes all elements from the set\n    \\*/\n    setproto.clear = function () {\n        while (this.length) {\n            this.pop();\n        }\n    };\n    /*\\\n     * Set.splice\n     [ method ]\n     **\n     * Removes range of elements from the set\n     **\n     - index (number) position of the deletion\n     - count (number) number of element to remove\n     - insertion (object) #optional elements to insert\n     = (object) set elements that were deleted\n    \\*/\n    setproto.splice = function (index, count, insertion) {\n        index = index < 0 ? mmax(this.length + index, 0) : index;\n        count = mmax(0, mmin(this.length - index, count));\n        var tail = [],\n            todel = [],\n            args = [],\n            i;\n        for (i = 2; i < arguments.length; i++) {\n            args.push(arguments[i]);\n        }\n        for (i = 0; i < count; i++) {\n            todel.push(this[index + i]);\n        }\n        for (; i < this.length - index; i++) {\n            tail.push(this[index + i]);\n        }\n        var arglen = args.length;\n        for (i = 0; i < arglen + tail.length; i++) {\n            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];\n        }\n        i = this.items.length = this.length -= count - arglen;\n        while (this[i]) {\n            delete this[i++];\n        }\n        return new Set(todel);\n    };\n    /*\\\n     * Set.exclude\n     [ method ]\n     **\n     * Removes given element from the set\n     **\n     - element (object) element to remove\n     = (boolean) `true` if object was found and removed from the set\n    \\*/\n    setproto.exclude = function (el) {\n        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {\n            this.splice(i, 1);\n            return true;\n        }\n        return false;\n    };\n    /*\\\n     * Set.insertAfter\n     [ method ]\n     **\n     * Inserts set elements after given element.\n     **\n     - element (object) set will be inserted after this element\n     = (object) Set object\n    \\*/\n    setproto.insertAfter = function (el) {\n        var i = this.items.length;\n        while (i--) {\n            this.items[i].insertAfter(el);\n        }\n        return this;\n    };\n    /*\\\n     * Set.getBBox\n     [ method ]\n     **\n     * Union of all bboxes of the set. See @Element.getBBox.\n     = (object) bounding box descriptor. See @Element.getBBox.\n    \\*/\n    setproto.getBBox = function () {\n        var x = [],\n            y = [],\n            x2 = [],\n            y2 = [];\n        for (var i = this.items.length; i--;) if (!this.items[i].removed) {\n            var box = this.items[i].getBBox();\n            x.push(box.x);\n            y.push(box.y);\n            x2.push(box.x + box.width);\n            y2.push(box.y + box.height);\n        }\n        x = mmin.apply(0, x);\n        y = mmin.apply(0, y);\n        x2 = mmax.apply(0, x2);\n        y2 = mmax.apply(0, y2);\n        return {\n            x: x,\n            y: y,\n            x2: x2,\n            y2: y2,\n            width: x2 - x,\n            height: y2 - y,\n            cx: x + (x2 - x) / 2,\n            cy: y + (y2 - y) / 2\n        };\n    };\n    /*\\\n     * Set.insertAfter\n     [ method ]\n     **\n     * Creates a clone of the set.\n     **\n     = (object) New Set object\n    \\*/\n    setproto.clone = function (s) {\n        s = new Set;\n        for (var i = 0, ii = this.items.length; i < ii; i++) {\n            s.push(this.items[i].clone());\n        }\n        return s;\n    };\n    setproto.toString = function () {\n        return \"Snap\\u2018s set\";\n    };\n    setproto.type = \"set\";\n    // export\n    /*\\\n     * Snap.Set\n     [ property ]\n     **\n     * Set constructor.\n    \\*/\n    Snap.Set = Set;\n    /*\\\n     * Snap.set\n     [ method ]\n     **\n     * Creates a set and fills it with list of arguments.\n     **\n     = (object) New Set object\n     | var r = paper.rect(0, 0, 10, 10),\n     |     s1 = Snap.set(), // empty set\n     |     s2 = Snap.set(r, paper.circle(100, 100, 20)); // prefilled set\n    \\*/\n    Snap.set = function () {\n        var set = new Set;\n        if (arguments.length) {\n            set.push.apply(set, Array.prototype.slice.call(arguments, 0));\n        }\n        return set;\n    };\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var names = {},\n        reUnit = /[%a-z]+$/i,\n        Str = String;\n    names.stroke = names.fill = \"colour\";\n    function getEmpty(item) {\n        var l = item[0];\n        switch (l.toLowerCase()) {\n            case \"t\": return [l, 0, 0];\n            case \"m\": return [l, 1, 0, 0, 1, 0, 0];\n            case \"r\": if (item.length == 4) {\n                return [l, 0, item[2], item[3]];\n            } else {\n                return [l, 0];\n            }\n            case \"s\": if (item.length == 5) {\n                return [l, 1, 1, item[3], item[4]];\n            } else if (item.length == 3) {\n                return [l, 1, 1];\n            } else {\n                return [l, 1];\n            }\n        }\n    }\n    function equaliseTransform(t1, t2, getBBox) {\n        t1 = t1 || new Snap.Matrix;\n        t2 = t2 || new Snap.Matrix;\n        t1 = Snap.parseTransformString(t1.toTransformString()) || [];\n        t2 = Snap.parseTransformString(t2.toTransformString()) || [];\n        var maxlength = Math.max(t1.length, t2.length),\n            from = [],\n            to = [],\n            i = 0, j, jj,\n            tt1, tt2;\n        for (; i < maxlength; i++) {\n            tt1 = t1[i] || getEmpty(t2[i]);\n            tt2 = t2[i] || getEmpty(tt1);\n            if (tt1[0] != tt2[0] ||\n                tt1[0].toLowerCase() == \"r\" && (tt1[2] != tt2[2] || tt1[3] != tt2[3]) ||\n                tt1[0].toLowerCase() == \"s\" && (tt1[3] != tt2[3] || tt1[4] != tt2[4])\n                ) {\n                    t1 = Snap._.transform2matrix(t1, getBBox());\n                    t2 = Snap._.transform2matrix(t2, getBBox());\n                    from = [[\"m\", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];\n                    to = [[\"m\", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];\n                    break;\n            }\n            from[i] = [];\n            to[i] = [];\n            for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {\n                j in tt1 && (from[i][j] = tt1[j]);\n                j in tt2 && (to[i][j] = tt2[j]);\n            }\n        }\n        return {\n            from: path2array(from),\n            to: path2array(to),\n            f: getPath(from)\n        };\n    }\n    function getNumber(val) {\n        return val;\n    }\n    function getUnit(unit) {\n        return function (val) {\n            return +val.toFixed(3) + unit;\n        };\n    }\n    function getViewBox(val) {\n        return val.join(\" \");\n    }\n    function getColour(clr) {\n        return Snap.rgb(clr[0], clr[1], clr[2], clr[3]);\n    }\n    function getPath(path) {\n        var k = 0, i, ii, j, jj, out, a, b = [];\n        for (i = 0, ii = path.length; i < ii; i++) {\n            out = \"[\";\n            a = ['\"' + path[i][0] + '\"'];\n            for (j = 1, jj = path[i].length; j < jj; j++) {\n                a[j] = \"val[\" + k++ + \"]\";\n            }\n            out += a + \"]\";\n            b[i] = out;\n        }\n        return Function(\"val\", \"return Snap.path.toString.call([\" + b + \"])\");\n    }\n    function path2array(path) {\n        var out = [];\n        for (var i = 0, ii = path.length; i < ii; i++) {\n            for (var j = 1, jj = path[i].length; j < jj; j++) {\n                out.push(path[i][j]);\n            }\n        }\n        return out;\n    }\n    function isNumeric(obj) {\n        return isFinite(obj);\n    }\n    function arrayEqual(arr1, arr2) {\n        if (!Snap.is(arr1, \"array\") || !Snap.is(arr2, \"array\")) {\n            return false;\n        }\n        return arr1.toString() == arr2.toString();\n    }\n    Element.prototype.equal = function (name, b) {\n        return eve(\"snap.util.equal\", this, name, b).firstDefined();\n    };\n    eve.on(\"snap.util.equal\", function (name, b) {\n        var A, B, a = Str(this.attr(name) || \"\"),\n            el = this;\n        if (names[name] == \"colour\") {\n            A = Snap.color(a);\n            B = Snap.color(b);\n            return {\n                from: [A.r, A.g, A.b, A.opacity],\n                to: [B.r, B.g, B.b, B.opacity],\n                f: getColour\n            };\n        }\n        if (name == \"viewBox\") {\n            A = this.attr(name).vb.split(\" \").map(Number);\n            B = b.split(\" \").map(Number);\n            return {\n                from: A,\n                to: B,\n                f: getViewBox\n            };\n        }\n        if (name == \"transform\" || name == \"gradientTransform\" || name == \"patternTransform\") {\n            if (typeof b == \"string\") {\n                b = Str(b).replace(/\\.{3}|\\u2026/g, a);\n            }\n            a = this.matrix;\n            if (!Snap._.rgTransform.test(b)) {\n                b = Snap._.transform2matrix(Snap._.svgTransform2string(b), this.getBBox());\n            } else {\n                b = Snap._.transform2matrix(b, this.getBBox());\n            }\n            return equaliseTransform(a, b, function () {\n                return el.getBBox(1);\n            });\n        }\n        if (name == \"d\" || name == \"path\") {\n            A = Snap.path.toCubic(a, b);\n            return {\n                from: path2array(A[0]),\n                to: path2array(A[1]),\n                f: getPath(A[0])\n            };\n        }\n        if (name == \"points\") {\n            A = Str(a).split(Snap._.separator);\n            B = Str(b).split(Snap._.separator);\n            return {\n                from: A,\n                to: B,\n                f: function (val) { return val; }\n            };\n        }\n        if (isNumeric(a) && isNumeric(b)) {\n            return {\n                from: parseFloat(a),\n                to: parseFloat(b),\n                f: getNumber\n            };\n        }\n        var aUnit = a.match(reUnit),\n            bUnit = Str(b).match(reUnit);\n        if (aUnit && arrayEqual(aUnit, bUnit)) {\n            return {\n                from: parseFloat(a),\n                to: parseFloat(b),\n                f: getUnit(aUnit)\n            };\n        } else {\n            return {\n                from: this.asPX(name),\n                to: this.asPX(name, b),\n                f: getNumber\n            };\n        }\n    });\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var elproto = Element.prototype,\n    has = \"hasOwnProperty\",\n    supportsTouch = \"createTouch\" in glob.doc,\n    events = [\n        \"click\", \"dblclick\", \"mousedown\", \"mousemove\", \"mouseout\",\n        \"mouseover\", \"mouseup\", \"touchstart\", \"touchmove\", \"touchend\",\n        \"touchcancel\"\n    ],\n    touchMap = {\n        mousedown: \"touchstart\",\n        mousemove: \"touchmove\",\n        mouseup: \"touchend\"\n    },\n    getScroll = function (xy, el) {\n        var name = xy == \"y\" ? \"scrollTop\" : \"scrollLeft\",\n            doc = el && el.node ? el.node.ownerDocument : glob.doc;\n        return doc[name in doc.documentElement ? \"documentElement\" : \"body\"][name];\n    },\n    preventDefault = function () {\n        this.returnValue = false;\n    },\n    preventTouch = function () {\n        return this.originalEvent.preventDefault();\n    },\n    stopPropagation = function () {\n        this.cancelBubble = true;\n    },\n    stopTouch = function () {\n        return this.originalEvent.stopPropagation();\n    },\n    addEvent = function (obj, type, fn, element) {\n        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,\n            f = function (e) {\n                var scrollY = getScroll(\"y\", element),\n                    scrollX = getScroll(\"x\", element);\n                if (supportsTouch && touchMap[has](type)) {\n                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {\n                        if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {\n                            var olde = e;\n                            e = e.targetTouches[i];\n                            e.originalEvent = olde;\n                            e.preventDefault = preventTouch;\n                            e.stopPropagation = stopTouch;\n                            break;\n                        }\n                    }\n                }\n                var x = e.clientX + scrollX,\n                    y = e.clientY + scrollY;\n                return fn.call(element, e, x, y);\n            };\n\n        if (type !== realName) {\n            obj.addEventListener(type, f, false);\n        }\n\n        obj.addEventListener(realName, f, false);\n\n        return function () {\n            if (type !== realName) {\n                obj.removeEventListener(type, f, false);\n            }\n\n            obj.removeEventListener(realName, f, false);\n            return true;\n        };\n    },\n    drag = [],\n    dragMove = function (e) {\n        var x = e.clientX,\n            y = e.clientY,\n            scrollY = getScroll(\"y\"),\n            scrollX = getScroll(\"x\"),\n            dragi,\n            j = drag.length;\n        while (j--) {\n            dragi = drag[j];\n            if (supportsTouch) {\n                var i = e.touches && e.touches.length,\n                    touch;\n                while (i--) {\n                    touch = e.touches[i];\n                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {\n                        x = touch.clientX;\n                        y = touch.clientY;\n                        (e.originalEvent ? e.originalEvent : e).preventDefault();\n                        break;\n                    }\n                }\n            } else {\n                e.preventDefault();\n            }\n            var node = dragi.el.node,\n                o,\n                next = node.nextSibling,\n                parent = node.parentNode,\n                display = node.style.display;\n            // glob.win.opera && parent.removeChild(node);\n            // node.style.display = \"none\";\n            // o = dragi.el.paper.getElementByPoint(x, y);\n            // node.style.display = display;\n            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));\n            // o && eve(\"snap.drag.over.\" + dragi.el.id, dragi.el, o);\n            x += scrollX;\n            y += scrollY;\n            eve(\"snap.drag.move.\" + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);\n        }\n    },\n    dragUp = function (e) {\n        Snap.unmousemove(dragMove).unmouseup(dragUp);\n        var i = drag.length,\n            dragi;\n        while (i--) {\n            dragi = drag[i];\n            dragi.el._drag = {};\n            eve(\"snap.drag.end.\" + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);\n            eve.off(\"snap.drag.*.\" + dragi.el.id);\n        }\n        drag = [];\n    };\n    /*\\\n     * Element.click\n     [ method ]\n     **\n     * Adds a click event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unclick\n     [ method ]\n     **\n     * Removes a click event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.dblclick\n     [ method ]\n     **\n     * Adds a double click event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.undblclick\n     [ method ]\n     **\n     * Removes a double click event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.mousedown\n     [ method ]\n     **\n     * Adds a mousedown event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmousedown\n     [ method ]\n     **\n     * Removes a mousedown event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.mousemove\n     [ method ]\n     **\n     * Adds a mousemove event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmousemove\n     [ method ]\n     **\n     * Removes a mousemove event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.mouseout\n     [ method ]\n     **\n     * Adds a mouseout event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmouseout\n     [ method ]\n     **\n     * Removes a mouseout event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.mouseover\n     [ method ]\n     **\n     * Adds a mouseover event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmouseover\n     [ method ]\n     **\n     * Removes a mouseover event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.mouseup\n     [ method ]\n     **\n     * Adds a mouseup event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.unmouseup\n     [ method ]\n     **\n     * Removes a mouseup event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.touchstart\n     [ method ]\n     **\n     * Adds a touchstart event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchstart\n     [ method ]\n     **\n     * Removes a touchstart event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.touchmove\n     [ method ]\n     **\n     * Adds a touchmove event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchmove\n     [ method ]\n     **\n     * Removes a touchmove event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.touchend\n     [ method ]\n     **\n     * Adds a touchend event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchend\n     [ method ]\n     **\n     * Removes a touchend event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    \n    /*\\\n     * Element.touchcancel\n     [ method ]\n     **\n     * Adds a touchcancel event handler to the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    /*\\\n     * Element.untouchcancel\n     [ method ]\n     **\n     * Removes a touchcancel event handler from the element\n     - handler (function) handler for the event\n     = (object) @Element\n    \\*/\n    for (var i = events.length; i--;) {\n        (function (eventName) {\n            Snap[eventName] = elproto[eventName] = function (fn, scope) {\n                if (Snap.is(fn, \"function\")) {\n                    this.events = this.events || [];\n                    this.events.push({\n                        name: eventName,\n                        f: fn,\n                        unbind: addEvent(this.node || document, eventName, fn, scope || this)\n                    });\n                } else {\n                    for (var i = 0, ii = this.events.length; i < ii; i++) if (this.events[i].name == eventName) {\n                        try {\n                            this.events[i].f.call(this);\n                        } catch (e) {}\n                    }\n                }\n                return this;\n            };\n            Snap[\"un\" + eventName] =\n            elproto[\"un\" + eventName] = function (fn) {\n                var events = this.events || [],\n                    l = events.length;\n                while (l--) if (events[l].name == eventName &&\n                               (events[l].f == fn || !fn)) {\n                    events[l].unbind();\n                    events.splice(l, 1);\n                    !events.length && delete this.events;\n                    return this;\n                }\n                return this;\n            };\n        })(events[i]);\n    }\n    /*\\\n     * Element.hover\n     [ method ]\n     **\n     * Adds hover event handlers to the element\n     - f_in (function) handler for hover in\n     - f_out (function) handler for hover out\n     - icontext (object) #optional context for hover in handler\n     - ocontext (object) #optional context for hover out handler\n     = (object) @Element\n    \\*/\n    elproto.hover = function (f_in, f_out, scope_in, scope_out) {\n        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);\n    };\n    /*\\\n     * Element.unhover\n     [ method ]\n     **\n     * Removes hover event handlers from the element\n     - f_in (function) handler for hover in\n     - f_out (function) handler for hover out\n     = (object) @Element\n    \\*/\n    elproto.unhover = function (f_in, f_out) {\n        return this.unmouseover(f_in).unmouseout(f_out);\n    };\n    var draggable = [];\n    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.\n    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?\n    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.\n    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?\n    /*\\\n     * Element.drag\n     [ method ]\n     **\n     * Adds event handlers for an element's drag gesture\n     **\n     - onmove (function) handler for moving\n     - onstart (function) handler for drag start\n     - onend (function) handler for drag end\n     - mcontext (object) #optional context for moving handler\n     - scontext (object) #optional context for drag start handler\n     - econtext (object) #optional context for drag end handler\n     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start, \n     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element \n     * `drag.over.<id>` fires as well.\n     *\n     * Start event and start handler are called in specified context or in context of the element with following parameters:\n     o x (number) x position of the mouse\n     o y (number) y position of the mouse\n     o event (object) DOM event object\n     * Move event and move handler are called in specified context or in context of the element with following parameters:\n     o dx (number) shift by x from the start point\n     o dy (number) shift by y from the start point\n     o x (number) x position of the mouse\n     o y (number) y position of the mouse\n     o event (object) DOM event object\n     * End event and end handler are called in specified context or in context of the element with following parameters:\n     o event (object) DOM event object\n     = (object) @Element\n    \\*/\n    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {\n        var el = this;\n        if (!arguments.length) {\n            var origTransform;\n            return el.drag(function (dx, dy) {\n                this.attr({\n                    transform: origTransform + (origTransform ? \"T\" : \"t\") + [dx, dy]\n                });\n            }, function () {\n                origTransform = this.transform().local;\n            });\n        }\n        function start(e, x, y) {\n            (e.originalEvent || e).preventDefault();\n            el._drag.x = x;\n            el._drag.y = y;\n            el._drag.id = e.identifier;\n            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);\n            drag.push({el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});\n            onstart && eve.on(\"snap.drag.start.\" + el.id, onstart);\n            onmove && eve.on(\"snap.drag.move.\" + el.id, onmove);\n            onend && eve.on(\"snap.drag.end.\" + el.id, onend);\n            eve(\"snap.drag.start.\" + el.id, start_scope || move_scope || el, x, y, e);\n        }\n        function init(e, x, y) {\n            eve(\"snap.draginit.\" + el.id, el, e, x, y);\n        }\n        eve.on(\"snap.draginit.\" + el.id, start);\n        el._drag = {};\n        draggable.push({el: el, start: start, init: init});\n        el.mousedown(init);\n        return el;\n    };\n    /*\n     * Element.onDragOver\n     [ method ]\n     **\n     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)\n     - f (function) handler for event, first argument would be the element you are dragging over\n    \\*/\n    // elproto.onDragOver = function (f) {\n    //     f ? eve.on(\"snap.drag.over.\" + this.id, f) : eve.unbind(\"snap.drag.over.\" + this.id);\n    // };\n    /*\\\n     * Element.undrag\n     [ method ]\n     **\n     * Removes all drag event handlers from the given element\n    \\*/\n    elproto.undrag = function () {\n        var i = draggable.length;\n        while (i--) if (draggable[i].el == this) {\n            this.unmousedown(draggable[i].init);\n            draggable.splice(i, 1);\n            eve.unbind(\"snap.drag.*.\" + this.id);\n            eve.unbind(\"snap.draginit.\" + this.id);\n        }\n        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);\n        return this;\n    };\n});\n\n// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    var elproto = Element.prototype,\n        pproto = Paper.prototype,\n        rgurl = /^\\s*url\\((.+)\\)/,\n        Str = String,\n        $ = Snap._.$;\n    Snap.filter = {};\n    /*\\\n     * Paper.filter\n     [ method ]\n     **\n     * Creates a `<filter>` element\n     **\n     - filstr (string) SVG fragment of filter provided as a string\n     = (object) @Element\n     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.\n     > Usage\n     | var f = paper.filter('<feGaussianBlur stdDeviation=\"2\"/>'),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    \\*/\n    pproto.filter = function (filstr) {\n        var paper = this;\n        if (paper.type != \"svg\") {\n            paper = paper.paper;\n        }\n        var f = Snap.parse(Str(filstr)),\n            id = Snap._.id(),\n            width = paper.node.offsetWidth,\n            height = paper.node.offsetHeight,\n            filter = $(\"filter\");\n        $(filter, {\n            id: id,\n            filterUnits: \"userSpaceOnUse\"\n        });\n        filter.appendChild(f.node);\n        paper.defs.appendChild(filter);\n        return new Element(filter);\n    };\n\n    eve.on(\"snap.util.getattr.filter\", function () {\n        eve.stop();\n        var p = $(this.node, \"filter\");\n        if (p) {\n            var match = Str(p).match(rgurl);\n            return match && Snap.select(match[1]);\n        }\n    });\n    eve.on(\"snap.util.attr.filter\", function (value) {\n        if (value instanceof Element && value.type == \"filter\") {\n            eve.stop();\n            var id = value.node.id;\n            if (!id) {\n                $(value.node, {id: value.id});\n                id = value.id;\n            }\n            $(this.node, {\n                filter: Snap.url(id)\n            });\n        }\n        if (!value || value == \"none\") {\n            eve.stop();\n            this.node.removeAttribute(\"filter\");\n        }\n    });\n    /*\\\n     * Snap.filter.blur\n     [ method ]\n     **\n     * Returns an SVG markup string for the blur filter\n     **\n     - x (number) amount of horizontal blur, in pixels\n     - y (number) #optional amount of vertical blur, in pixels\n     = (string) filter representation\n     > Usage\n     | var f = paper.filter(Snap.filter.blur(5, 10)),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    \\*/\n    Snap.filter.blur = function (x, y) {\n        if (x == null) {\n            x = 2;\n        }\n        var def = y == null ? x : [x, y];\n        return Snap.format('\\<feGaussianBlur stdDeviation=\"{def}\"/>', {\n            def: def\n        });\n    };\n    Snap.filter.blur.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.shadow\n     [ method ]\n     **\n     * Returns an SVG markup string for the shadow filter\n     **\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - blur (number) #optional amount of blur\n     - color (string) #optional color of the shadow\n     - opacity (number) #optional `0..1` opacity of the shadow\n     * or\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - color (string) #optional color of the shadow\n     - opacity (number) #optional `0..1` opacity of the shadow\n     * which makes blur default to `4`. Or\n     - dx (number) #optional horizontal shift of the shadow, in pixels\n     - dy (number) #optional vertical shift of the shadow, in pixels\n     - opacity (number) #optional `0..1` opacity of the shadow\n     = (string) filter representation\n     > Usage\n     | var f = paper.filter(Snap.filter.shadow(0, 2, .3)),\n     |     c = paper.circle(10, 10, 10).attr({\n     |         filter: f\n     |     });\n    \\*/\n    Snap.filter.shadow = function (dx, dy, blur, color, opacity) {\n        if (opacity == null) {\n            if (color == null) {\n                opacity = blur;\n                blur = 4;\n                color = \"#000\";\n            } else {\n                opacity = color;\n                color = blur;\n                blur = 4;\n            }\n        }\n        if (blur == null) {\n            blur = 4;\n        }\n        if (opacity == null) {\n            opacity = 1;\n        }\n        if (dx == null) {\n            dx = 0;\n            dy = 2;\n        }\n        if (dy == null) {\n            dy = dx;\n        }\n        color = Snap.color(color);\n        return Snap.format('<feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"{blur}\"/><feOffset dx=\"{dx}\" dy=\"{dy}\" result=\"offsetblur\"/><feFlood flood-color=\"{color}\"/><feComposite in2=\"offsetblur\" operator=\"in\"/><feComponentTransfer><feFuncA type=\"linear\" slope=\"{opacity}\"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in=\"SourceGraphic\"/></feMerge>', {\n            color: color,\n            dx: dx,\n            dy: dy,\n            blur: blur,\n            opacity: opacity\n        });\n    };\n    Snap.filter.shadow.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.grayscale\n     [ method ]\n     **\n     * Returns an SVG markup string for the grayscale filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.grayscale = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0\"/>', {\n            a: 0.2126 + 0.7874 * (1 - amount),\n            b: 0.7152 - 0.7152 * (1 - amount),\n            c: 0.0722 - 0.0722 * (1 - amount),\n            d: 0.2126 - 0.2126 * (1 - amount),\n            e: 0.7152 + 0.2848 * (1 - amount),\n            f: 0.0722 - 0.0722 * (1 - amount),\n            g: 0.2126 - 0.2126 * (1 - amount),\n            h: 0.0722 + 0.9278 * (1 - amount)\n        });\n    };\n    Snap.filter.grayscale.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.sepia\n     [ method ]\n     **\n     * Returns an SVG markup string for the sepia filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.sepia = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"matrix\" values=\"{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0\"/>', {\n            a: 0.393 + 0.607 * (1 - amount),\n            b: 0.769 - 0.769 * (1 - amount),\n            c: 0.189 - 0.189 * (1 - amount),\n            d: 0.349 - 0.349 * (1 - amount),\n            e: 0.686 + 0.314 * (1 - amount),\n            f: 0.168 - 0.168 * (1 - amount),\n            g: 0.272 - 0.272 * (1 - amount),\n            h: 0.534 - 0.534 * (1 - amount),\n            i: 0.131 + 0.869 * (1 - amount)\n        });\n    };\n    Snap.filter.sepia.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.saturate\n     [ method ]\n     **\n     * Returns an SVG markup string for the saturate filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.saturate = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feColorMatrix type=\"saturate\" values=\"{amount}\"/>', {\n            amount: 1 - amount\n        });\n    };\n    Snap.filter.saturate.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.hueRotate\n     [ method ]\n     **\n     * Returns an SVG markup string for the hue-rotate filter\n     **\n     - angle (number) angle of rotation\n     = (string) filter representation\n    \\*/\n    Snap.filter.hueRotate = function (angle) {\n        angle = angle || 0;\n        return Snap.format('<feColorMatrix type=\"hueRotate\" values=\"{angle}\"/>', {\n            angle: angle\n        });\n    };\n    Snap.filter.hueRotate.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.invert\n     [ method ]\n     **\n     * Returns an SVG markup string for the invert filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.invert = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n//        <feColorMatrix type=\"matrix\" values=\"-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0\" color-interpolation-filters=\"sRGB\"/>\n        return Snap.format('<feComponentTransfer><feFuncR type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncG type=\"table\" tableValues=\"{amount} {amount2}\"/><feFuncB type=\"table\" tableValues=\"{amount} {amount2}\"/></feComponentTransfer>', {\n            amount: amount,\n            amount2: 1 - amount\n        });\n    };\n    Snap.filter.invert.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.brightness\n     [ method ]\n     **\n     * Returns an SVG markup string for the brightness filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.brightness = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\"/><feFuncG type=\"linear\" slope=\"{amount}\"/><feFuncB type=\"linear\" slope=\"{amount}\"/></feComponentTransfer>', {\n            amount: amount\n        });\n    };\n    Snap.filter.brightness.toString = function () {\n        return this();\n    };\n    /*\\\n     * Snap.filter.contrast\n     [ method ]\n     **\n     * Returns an SVG markup string for the contrast filter\n     **\n     - amount (number) amount of filter (`0..1`)\n     = (string) filter representation\n    \\*/\n    Snap.filter.contrast = function (amount) {\n        if (amount == null) {\n            amount = 1;\n        }\n        return Snap.format('<feComponentTransfer><feFuncR type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncG type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/><feFuncB type=\"linear\" slope=\"{amount}\" intercept=\"{amount2}\"/></feComponentTransfer>', {\n            amount: amount,\n            amount2: .5 - amount / 2\n        });\n    };\n    Snap.filter.contrast.toString = function () {\n        return this();\n    };\n});\n\n// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob, Fragment) {\n    var box = Snap._.box,\n        is = Snap.is,\n        firstLetter = /^[^a-z]*([tbmlrc])/i,\n        toString = function () {\n            return \"T\" + this.dx + \",\" + this.dy;\n        };\n    /*\\\n     * Element.getAlign\n     [ method ]\n     **\n     * Returns shift needed to align the element relatively to given element.\n     * If no elements specified, parent `<svg>` container will be used.\n     - el (object) @optional alignment element\n     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n     = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string\n     > Usage\n     | el.transform(el.getAlign(el2, \"top\"));\n     * or\n     | var dy = el.getAlign(el2, \"top\").dy;\n    \\*/\n    Element.prototype.getAlign = function (el, way) {\n        if (way == null && is(el, \"string\")) {\n            way = el;\n            el = null;\n        }\n        el = el || this.paper;\n        var bx = el.getBBox ? el.getBBox() : box(el),\n            bb = this.getBBox(),\n            out = {};\n        way = way && way.match(firstLetter);\n        way = way ? way[1].toLowerCase() : \"c\";\n        switch (way) {\n            case \"t\":\n                out.dx = 0;\n                out.dy = bx.y - bb.y;\n            break;\n            case \"b\":\n                out.dx = 0;\n                out.dy = bx.y2 - bb.y2;\n            break;\n            case \"m\":\n                out.dx = 0;\n                out.dy = bx.cy - bb.cy;\n            break;\n            case \"l\":\n                out.dx = bx.x - bb.x;\n                out.dy = 0;\n            break;\n            case \"r\":\n                out.dx = bx.x2 - bb.x2;\n                out.dy = 0;\n            break;\n            default:\n                out.dx = bx.cx - bb.cx;\n                out.dy = 0;\n            break;\n        }\n        out.toString = toString;\n        return out;\n    };\n    /*\\\n     * Element.align\n     [ method ]\n     **\n     * Aligns the element relatively to given one via transformation.\n     * If no elements specified, parent `<svg>` container will be used.\n     - el (object) @optional alignment element\n     - way (string) one of six values: `\"top\"`, `\"middle\"`, `\"bottom\"`, `\"left\"`, `\"center\"`, `\"right\"`\n     = (object) this element\n     > Usage\n     | el.align(el2, \"top\");\n     * or\n     | el.align(\"middle\");\n    \\*/\n    Element.prototype.align = function (el, way) {\n        return this.transform(\"...\" + this.getAlign(el, way));\n    };\n});\n\n// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nSnap.plugin(function (Snap, Element, Paper, glob) {\n    // Colours are from https://www.materialui.co\n    var red         = \"#ffebee#ffcdd2#ef9a9a#e57373#ef5350#f44336#e53935#d32f2f#c62828#b71c1c#ff8a80#ff5252#ff1744#d50000\",\n        pink        = \"#FCE4EC#F8BBD0#F48FB1#F06292#EC407A#E91E63#D81B60#C2185B#AD1457#880E4F#FF80AB#FF4081#F50057#C51162\",\n        purple      = \"#F3E5F5#E1BEE7#CE93D8#BA68C8#AB47BC#9C27B0#8E24AA#7B1FA2#6A1B9A#4A148C#EA80FC#E040FB#D500F9#AA00FF\",\n        deeppurple  = \"#EDE7F6#D1C4E9#B39DDB#9575CD#7E57C2#673AB7#5E35B1#512DA8#4527A0#311B92#B388FF#7C4DFF#651FFF#6200EA\",\n        indigo      = \"#E8EAF6#C5CAE9#9FA8DA#7986CB#5C6BC0#3F51B5#3949AB#303F9F#283593#1A237E#8C9EFF#536DFE#3D5AFE#304FFE\",\n        blue        = \"#E3F2FD#BBDEFB#90CAF9#64B5F6#64B5F6#2196F3#1E88E5#1976D2#1565C0#0D47A1#82B1FF#448AFF#2979FF#2962FF\",\n        lightblue   = \"#E1F5FE#B3E5FC#81D4FA#4FC3F7#29B6F6#03A9F4#039BE5#0288D1#0277BD#01579B#80D8FF#40C4FF#00B0FF#0091EA\",\n        cyan        = \"#E0F7FA#B2EBF2#80DEEA#4DD0E1#26C6DA#00BCD4#00ACC1#0097A7#00838F#006064#84FFFF#18FFFF#00E5FF#00B8D4\",\n        teal        = \"#E0F2F1#B2DFDB#80CBC4#4DB6AC#26A69A#009688#00897B#00796B#00695C#004D40#A7FFEB#64FFDA#1DE9B6#00BFA5\",\n        green       = \"#E8F5E9#C8E6C9#A5D6A7#81C784#66BB6A#4CAF50#43A047#388E3C#2E7D32#1B5E20#B9F6CA#69F0AE#00E676#00C853\",\n        lightgreen  = \"#F1F8E9#DCEDC8#C5E1A5#AED581#9CCC65#8BC34A#7CB342#689F38#558B2F#33691E#CCFF90#B2FF59#76FF03#64DD17\",\n        lime        = \"#F9FBE7#F0F4C3#E6EE9C#DCE775#D4E157#CDDC39#C0CA33#AFB42B#9E9D24#827717#F4FF81#EEFF41#C6FF00#AEEA00\",\n        yellow      = \"#FFFDE7#FFF9C4#FFF59D#FFF176#FFEE58#FFEB3B#FDD835#FBC02D#F9A825#F57F17#FFFF8D#FFFF00#FFEA00#FFD600\",\n        amber       = \"#FFF8E1#FFECB3#FFE082#FFD54F#FFCA28#FFC107#FFB300#FFA000#FF8F00#FF6F00#FFE57F#FFD740#FFC400#FFAB00\",\n        orange      = \"#FFF3E0#FFE0B2#FFCC80#FFB74D#FFA726#FF9800#FB8C00#F57C00#EF6C00#E65100#FFD180#FFAB40#FF9100#FF6D00\",\n        deeporange  = \"#FBE9E7#FFCCBC#FFAB91#FF8A65#FF7043#FF5722#F4511E#E64A19#D84315#BF360C#FF9E80#FF6E40#FF3D00#DD2C00\",\n        brown       = \"#EFEBE9#D7CCC8#BCAAA4#A1887F#8D6E63#795548#6D4C41#5D4037#4E342E#3E2723\",\n        grey        = \"#FAFAFA#F5F5F5#EEEEEE#E0E0E0#BDBDBD#9E9E9E#757575#616161#424242#212121\",\n        bluegrey    = \"#ECEFF1#CFD8DC#B0BEC5#90A4AE#78909C#607D8B#546E7A#455A64#37474F#263238\";\n    /*\\\n     * Snap.mui\n     [ property ]\n     **\n     * Contain Material UI colours.\n     | Snap().rect(0, 0, 10, 10).attr({fill: Snap.mui.deeppurple, stroke: Snap.mui.amber[600]});\n     # For colour reference: <a href=\"https://www.materialui.co\">https://www.materialui.co</a>.\n    \\*/\n    Snap.mui = {};\n    /*\\\n     * Snap.flat\n     [ property ]\n     **\n     * Contain Flat UI colours.\n     | Snap().rect(0, 0, 10, 10).attr({fill: Snap.flat.carrot, stroke: Snap.flat.wetasphalt});\n     # For colour reference: <a href=\"https://www.materialui.co\">https://www.materialui.co</a>.\n    \\*/\n    Snap.flat = {};\n    function saveColor(colors) {\n        colors = colors.split(/(?=#)/);\n        var color = new String(colors[5]);\n        color[50] = colors[0];\n        color[100] = colors[1];\n        color[200] = colors[2];\n        color[300] = colors[3];\n        color[400] = colors[4];\n        color[500] = colors[5];\n        color[600] = colors[6];\n        color[700] = colors[7];\n        color[800] = colors[8];\n        color[900] = colors[9];\n        if (colors[10]) {\n            color.A100 = colors[10];\n            color.A200 = colors[11];\n            color.A400 = colors[12];\n            color.A700 = colors[13];\n        }\n        return color;\n    }\n    Snap.mui.red = saveColor(red);\n    Snap.mui.pink = saveColor(pink);\n    Snap.mui.purple = saveColor(purple);\n    Snap.mui.deeppurple = saveColor(deeppurple);\n    Snap.mui.indigo = saveColor(indigo);\n    Snap.mui.blue = saveColor(blue);\n    Snap.mui.lightblue = saveColor(lightblue);\n    Snap.mui.cyan = saveColor(cyan);\n    Snap.mui.teal = saveColor(teal);\n    Snap.mui.green = saveColor(green);\n    Snap.mui.lightgreen = saveColor(lightgreen);\n    Snap.mui.lime = saveColor(lime);\n    Snap.mui.yellow = saveColor(yellow);\n    Snap.mui.amber = saveColor(amber);\n    Snap.mui.orange = saveColor(orange);\n    Snap.mui.deeporange = saveColor(deeporange);\n    Snap.mui.brown = saveColor(brown);\n    Snap.mui.grey = saveColor(grey);\n    Snap.mui.bluegrey = saveColor(bluegrey);\n    Snap.flat.turquoise = \"#1abc9c\";\n    Snap.flat.greensea = \"#16a085\";\n    Snap.flat.sunflower = \"#f1c40f\";\n    Snap.flat.orange = \"#f39c12\";\n    Snap.flat.emerland = \"#2ecc71\";\n    Snap.flat.nephritis = \"#27ae60\";\n    Snap.flat.carrot = \"#e67e22\";\n    Snap.flat.pumpkin = \"#d35400\";\n    Snap.flat.peterriver = \"#3498db\";\n    Snap.flat.belizehole = \"#2980b9\";\n    Snap.flat.alizarin = \"#e74c3c\";\n    Snap.flat.pomegranate = \"#c0392b\";\n    Snap.flat.amethyst = \"#9b59b6\";\n    Snap.flat.wisteria = \"#8e44ad\";\n    Snap.flat.clouds = \"#ecf0f1\";\n    Snap.flat.silver = \"#bdc3c7\";\n    Snap.flat.wetasphalt = \"#34495e\";\n    Snap.flat.midnightblue = \"#2c3e50\";\n    Snap.flat.concrete = \"#95a5a6\";\n    Snap.flat.asbestos = \"#7f8c8d\";\n    /*\\\n     * Snap.importMUIColors\n     [ method ]\n     **\n     * Imports Material UI colours into global object.\n     | Snap.importMUIColors();\n     | Snap().rect(0, 0, 10, 10).attr({fill: deeppurple, stroke: amber[600]});\n     # For colour reference: <a href=\"https://www.materialui.co\">https://www.materialui.co</a>.\n    \\*/\n    Snap.importMUIColors = function () {\n        for (var color in Snap.mui) {\n            if (Snap.mui.hasOwnProperty(color)) {\n                window[color] = Snap.mui[color];\n            }\n        }\n    };\n});\n\nreturn Snap;\n}));\n}.call(window));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/snapsvg/dist/snap.svg.js\n// module id = 9\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint maxcomplexity:11 */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\n\n// -------------------------------------------------------------------------Node\n\n/**\n * Advancing front node\n * @constructor\n * @private\n * @struct\n * @param {!XY} p - Point\n * @param {Triangle=} t triangle (optional)\n */\nvar Node = function(p, t) {\n    /** @type {XY} */\n    this.point = p;\n\n    /** @type {Triangle|null} */\n    this.triangle = t || null;\n\n    /** @type {Node|null} */\n    this.next = null;\n    /** @type {Node|null} */\n    this.prev = null;\n\n    /** @type {number} */\n    this.value = p.x;\n};\n\n// ---------------------------------------------------------------AdvancingFront\n/**\n * @constructor\n * @private\n * @struct\n * @param {Node} head\n * @param {Node} tail\n */\nvar AdvancingFront = function(head, tail) {\n    /** @type {Node} */\n    this.head_ = head;\n    /** @type {Node} */\n    this.tail_ = tail;\n    /** @type {Node} */\n    this.search_node_ = head;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.head = function() {\n    return this.head_;\n};\n\n/** @param {Node} node */\nAdvancingFront.prototype.setHead = function(node) {\n    this.head_ = node;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.tail = function() {\n    return this.tail_;\n};\n\n/** @param {Node} node */\nAdvancingFront.prototype.setTail = function(node) {\n    this.tail_ = node;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.search = function() {\n    return this.search_node_;\n};\n\n/** @param {Node} node */\nAdvancingFront.prototype.setSearch = function(node) {\n    this.search_node_ = node;\n};\n\n/** @return {Node} */\nAdvancingFront.prototype.findSearchNode = function(/*x*/) {\n    // TODO: implement BST index\n    return this.search_node_;\n};\n\n/**\n * @param {number} x value\n * @return {Node}\n */\nAdvancingFront.prototype.locateNode = function(x) {\n    var node = this.search_node_;\n\n    /* jshint boss:true */\n    if (x < node.value) {\n        while (node = node.prev) {\n            if (x >= node.value) {\n                this.search_node_ = node;\n                return node;\n            }\n        }\n    } else {\n        while (node = node.next) {\n            if (x < node.value) {\n                this.search_node_ = node.prev;\n                return node.prev;\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * @param {!XY} point - Point\n * @return {Node}\n */\nAdvancingFront.prototype.locatePoint = function(point) {\n    var px = point.x;\n    var node = this.findSearchNode(px);\n    var nx = node.point.x;\n\n    if (px === nx) {\n        // Here we are comparing point references, not values\n        if (point !== node.point) {\n            // We might have two nodes with same x value for a short time\n            if (point === node.prev.point) {\n                node = node.prev;\n            } else if (point === node.next.point) {\n                node = node.next;\n            } else {\n                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');\n            }\n        }\n    } else if (px < nx) {\n        /* jshint boss:true */\n        while (node = node.prev) {\n            if (point === node.point) {\n                break;\n            }\n        }\n    } else {\n        while (node = node.next) {\n            if (point === node.point) {\n                break;\n            }\n        }\n    }\n\n    if (node) {\n        this.search_node_ = node;\n    }\n    return node;\n};\n\n\n// ----------------------------------------------------------------------Exports\n\nmodule.exports = AdvancingFront;\nmodule.exports.Node = Node;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/advancingfront.js\n// module id = 10\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/*\n * Class added in the JavaScript version (was not present in the c++ version)\n */\n\nvar xy = require('./xy');\n\n/**\n * Custom exception class to indicate invalid Point values\n * @constructor\n * @public\n * @extends Error\n * @struct\n * @param {string=} message - error message\n * @param {Array.<XY>=} points - invalid points\n */\nvar PointError = function(message, points) {\n    this.name = \"PointError\";\n    /**\n     * Invalid points\n     * @public\n     * @type {Array.<XY>}\n     */\n    this.points = points = points || [];\n    /**\n     * Error message\n     * @public\n     * @type {string}\n     */\n    this.message = message || \"Invalid Points!\";\n    for (var i = 0; i < points.length; i++) {\n        this.message += \" \" + xy.toString(points[i]);\n    }\n};\nPointError.prototype = new Error();\nPointError.prototype.constructor = PointError;\n\n\nmodule.exports = PointError;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/pointerror.js\n// module id = 11\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n *\n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint maxcomplexity:10 */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar xy = require(\"./xy\");\n\n\n// ---------------------------------------------------------------------Triangle\n/**\n * Triangle class.<br>\n * Triangle-based data structures are known to have better performance than\n * quad-edge structures.\n * See: J. Shewchuk, \"Triangle: Engineering a 2D Quality Mesh Generator and\n * Delaunay Triangulator\", \"Triangulations in CGAL\"\n *\n * @constructor\n * @struct\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n */\nvar Triangle = function(a, b, c) {\n    /**\n     * Triangle points\n     * @private\n     * @type {Array.<XY>}\n     */\n    this.points_ = [a, b, c];\n\n    /**\n     * Neighbor list\n     * @private\n     * @type {Array.<Triangle>}\n     */\n    this.neighbors_ = [null, null, null];\n\n    /**\n     * Has this triangle been marked as an interior triangle?\n     * @private\n     * @type {boolean}\n     */\n    this.interior_ = false;\n\n    /**\n     * Flags to determine if an edge is a Constrained edge\n     * @private\n     * @type {Array.<boolean>}\n     */\n    this.constrained_edge = [false, false, false];\n\n    /**\n     * Flags to determine if an edge is a Delauney edge\n     * @private\n     * @type {Array.<boolean>}\n     */\n    this.delaunay_edge = [false, false, false];\n};\n\nvar p2s = xy.toString;\n/**\n * For pretty printing ex. <code>\"[(5;42)(10;20)(21;30)]\"</code>.\n * @public\n * @return {string}\n */\nTriangle.prototype.toString = function() {\n    return (\"[\" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + \"]\");\n};\n\n/**\n * Get one vertice of the triangle.\n * The output triangles of a triangulation have vertices which are references\n * to the initial input points (not copies): any custom fields in the\n * initial points can be retrieved in the output triangles.\n * @example\n *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n *      typeof triangles[0].getPoint(0).id\n *      //  \"number\"\n * @param {number} index - vertice index: 0, 1 or 2\n * @public\n * @returns {XY}\n */\nTriangle.prototype.getPoint = function(index) {\n    return this.points_[index];\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode Triangle#getPoint} instead\n */\nTriangle.prototype.GetPoint = Triangle.prototype.getPoint;\n\n/**\n * Get all 3 vertices of the triangle as an array\n * @public\n * @return {Array.<XY>}\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nTriangle.prototype.getPoints = function() {\n    return this.points_;\n};\n\n/**\n * @private\n * @param {number} index\n * @returns {?Triangle}\n */\nTriangle.prototype.getNeighbor = function(index) {\n    return this.neighbors_[index];\n};\n\n/**\n * Test if this Triangle contains the Point object given as parameter as one of its vertices.\n * Only point references are compared, not values.\n * @public\n * @param {XY} point - point object with {x,y}\n * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,\n *         <code>false</code> otherwise.\n */\nTriangle.prototype.containsPoint = function(point) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    return (point === points[0] || point === points[1] || point === points[2]);\n};\n\n/**\n * Test if this Triangle contains the Edge object given as parameter as its\n * bounding edges. Only point references are compared, not values.\n * @private\n * @param {Edge} edge\n * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding\n *         edges, <code>false</code> otherwise.\n */\nTriangle.prototype.containsEdge = function(edge) {\n    return this.containsPoint(edge.p) && this.containsPoint(edge.q);\n};\n\n/**\n * Test if this Triangle contains the two Point objects given as parameters among its vertices.\n * Only point references are compared, not values.\n * @param {XY} p1 - point object with {x,y}\n * @param {XY} p2 - point object with {x,y}\n * @return {boolean}\n */\nTriangle.prototype.containsPoints = function(p1, p2) {\n    return this.containsPoint(p1) && this.containsPoint(p2);\n};\n\n/**\n * Has this triangle been marked as an interior triangle?\n * @returns {boolean}\n */\nTriangle.prototype.isInterior = function() {\n    return this.interior_;\n};\n\n/**\n * Mark this triangle as an interior triangle\n * @private\n * @param {boolean} interior\n * @returns {Triangle} this\n */\nTriangle.prototype.setInterior = function(interior) {\n    this.interior_ = interior;\n    return this;\n};\n\n/**\n * Update neighbor pointers.\n * @private\n * @param {XY} p1 - point object with {x,y}\n * @param {XY} p2 - point object with {x,y}\n * @param {Triangle} t Triangle object.\n * @throws {Error} if can't find objects\n */\nTriangle.prototype.markNeighborPointers = function(p1, p2, t) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {\n        this.neighbors_[0] = t;\n    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {\n        this.neighbors_[1] = t;\n    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {\n        this.neighbors_[2] = t;\n    } else {\n        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');\n    }\n};\n\n/**\n * Exhaustive search to update neighbor pointers\n * @private\n * @param {!Triangle} t\n */\nTriangle.prototype.markNeighbor = function(t) {\n    var points = this.points_;\n    if (t.containsPoints(points[1], points[2])) {\n        this.neighbors_[0] = t;\n        t.markNeighborPointers(points[1], points[2], this);\n    } else if (t.containsPoints(points[0], points[2])) {\n        this.neighbors_[1] = t;\n        t.markNeighborPointers(points[0], points[2], this);\n    } else if (t.containsPoints(points[0], points[1])) {\n        this.neighbors_[2] = t;\n        t.markNeighborPointers(points[0], points[1], this);\n    }\n};\n\n\nTriangle.prototype.clearNeighbors = function() {\n    this.neighbors_[0] = null;\n    this.neighbors_[1] = null;\n    this.neighbors_[2] = null;\n};\n\nTriangle.prototype.clearDelaunayEdges = function() {\n    this.delaunay_edge[0] = false;\n    this.delaunay_edge[1] = false;\n    this.delaunay_edge[2] = false;\n};\n\n/**\n * Returns the point clockwise to the given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.pointCW = function(p) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p === points[0]) {\n        return points[2];\n    } else if (p === points[1]) {\n        return points[0];\n    } else if (p === points[2]) {\n        return points[1];\n    } else {\n        return null;\n    }\n};\n\n/**\n * Returns the point counter-clockwise to the given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.pointCCW = function(p) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p === points[0]) {\n        return points[1];\n    } else if (p === points[1]) {\n        return points[2];\n    } else if (p === points[2]) {\n        return points[0];\n    } else {\n        return null;\n    }\n};\n\n/**\n * Returns the neighbor clockwise to given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.neighborCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.neighbors_[1];\n    } else if (p === this.points_[1]) {\n        return this.neighbors_[2];\n    } else {\n        return this.neighbors_[0];\n    }\n};\n\n/**\n * Returns the neighbor counter-clockwise to given point.\n * @private\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.neighborCCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.neighbors_[2];\n    } else if (p === this.points_[1]) {\n        return this.neighbors_[0];\n    } else {\n        return this.neighbors_[1];\n    }\n};\n\nTriangle.prototype.getConstrainedEdgeCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.constrained_edge[1];\n    } else if (p === this.points_[1]) {\n        return this.constrained_edge[2];\n    } else {\n        return this.constrained_edge[0];\n    }\n};\n\nTriangle.prototype.getConstrainedEdgeCCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.constrained_edge[2];\n    } else if (p === this.points_[1]) {\n        return this.constrained_edge[0];\n    } else {\n        return this.constrained_edge[1];\n    }\n};\n\n// Additional check from Java version (see issue #88)\nTriangle.prototype.getConstrainedEdgeAcross = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.constrained_edge[0];\n    } else if (p === this.points_[1]) {\n        return this.constrained_edge[1];\n    } else {\n        return this.constrained_edge[2];\n    }\n};\n\nTriangle.prototype.setConstrainedEdgeCW = function(p, ce) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.constrained_edge[1] = ce;\n    } else if (p === this.points_[1]) {\n        this.constrained_edge[2] = ce;\n    } else {\n        this.constrained_edge[0] = ce;\n    }\n};\n\nTriangle.prototype.setConstrainedEdgeCCW = function(p, ce) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.constrained_edge[2] = ce;\n    } else if (p === this.points_[1]) {\n        this.constrained_edge[0] = ce;\n    } else {\n        this.constrained_edge[1] = ce;\n    }\n};\n\nTriangle.prototype.getDelaunayEdgeCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.delaunay_edge[1];\n    } else if (p === this.points_[1]) {\n        return this.delaunay_edge[2];\n    } else {\n        return this.delaunay_edge[0];\n    }\n};\n\nTriangle.prototype.getDelaunayEdgeCCW = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.delaunay_edge[2];\n    } else if (p === this.points_[1]) {\n        return this.delaunay_edge[0];\n    } else {\n        return this.delaunay_edge[1];\n    }\n};\n\nTriangle.prototype.setDelaunayEdgeCW = function(p, e) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.delaunay_edge[1] = e;\n    } else if (p === this.points_[1]) {\n        this.delaunay_edge[2] = e;\n    } else {\n        this.delaunay_edge[0] = e;\n    }\n};\n\nTriangle.prototype.setDelaunayEdgeCCW = function(p, e) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        this.delaunay_edge[2] = e;\n    } else if (p === this.points_[1]) {\n        this.delaunay_edge[0] = e;\n    } else {\n        this.delaunay_edge[1] = e;\n    }\n};\n\n/**\n * The neighbor across to given point.\n * @private\n * @param {XY} p - point object with {x,y}\n * @returns {Triangle}\n */\nTriangle.prototype.neighborAcross = function(p) {\n    // Here we are comparing point references, not values\n    if (p === this.points_[0]) {\n        return this.neighbors_[0];\n    } else if (p === this.points_[1]) {\n        return this.neighbors_[1];\n    } else {\n        return this.neighbors_[2];\n    }\n};\n\n/**\n * @private\n * @param {!Triangle} t Triangle object.\n * @param {XY} p - point object with {x,y}\n */\nTriangle.prototype.oppositePoint = function(t, p) {\n    var cw = t.pointCW(p);\n    return this.pointCW(cw);\n};\n\n/**\n * Legalize triangle by rotating clockwise around oPoint\n * @private\n * @param {XY} opoint - point object with {x,y}\n * @param {XY} npoint - point object with {x,y}\n * @throws {Error} if oPoint can not be found\n */\nTriangle.prototype.legalize = function(opoint, npoint) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (opoint === points[0]) {\n        points[1] = points[0];\n        points[0] = points[2];\n        points[2] = npoint;\n    } else if (opoint === points[1]) {\n        points[2] = points[1];\n        points[1] = points[0];\n        points[0] = npoint;\n    } else if (opoint === points[2]) {\n        points[0] = points[2];\n        points[2] = points[1];\n        points[1] = npoint;\n    } else {\n        throw new Error('poly2tri Invalid Triangle.legalize() call');\n    }\n};\n\n/**\n * Returns the index of a point in the triangle. \n * The point *must* be a reference to one of the triangle's vertices.\n * @private\n * @param {XY} p - point object with {x,y}\n * @returns {number} index 0, 1 or 2\n * @throws {Error} if p can not be found\n */\nTriangle.prototype.index = function(p) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p === points[0]) {\n        return 0;\n    } else if (p === points[1]) {\n        return 1;\n    } else if (p === points[2]) {\n        return 2;\n    } else {\n        throw new Error('poly2tri Invalid Triangle.index() call');\n    }\n};\n\n/**\n * @private\n * @param {XY} p1 - point object with {x,y}\n * @param {XY} p2 - point object with {x,y}\n * @return {number} index 0, 1 or 2, or -1 if errror\n */\nTriangle.prototype.edgeIndex = function(p1, p2) {\n    var points = this.points_;\n    // Here we are comparing point references, not values\n    if (p1 === points[0]) {\n        if (p2 === points[1]) {\n            return 2;\n        } else if (p2 === points[2]) {\n            return 1;\n        }\n    } else if (p1 === points[1]) {\n        if (p2 === points[2]) {\n            return 0;\n        } else if (p2 === points[0]) {\n            return 2;\n        }\n    } else if (p1 === points[2]) {\n        if (p2 === points[0]) {\n            return 1;\n        } else if (p2 === points[1]) {\n            return 0;\n        }\n    }\n    return -1;\n};\n\n/**\n * Mark an edge of this triangle as constrained.\n * @private\n * @param {number} index - edge index\n */\nTriangle.prototype.markConstrainedEdgeByIndex = function(index) {\n    this.constrained_edge[index] = true;\n};\n/**\n * Mark an edge of this triangle as constrained.\n * @private\n * @param {Edge} edge instance\n */\nTriangle.prototype.markConstrainedEdgeByEdge = function(edge) {\n    this.markConstrainedEdgeByPoints(edge.p, edge.q);\n};\n/**\n * Mark an edge of this triangle as constrained.\n * This method takes two Point instances defining the edge of the triangle.\n * @private\n * @param {XY} p - point object with {x,y}\n * @param {XY} q - point object with {x,y}\n */\nTriangle.prototype.markConstrainedEdgeByPoints = function(p, q) {\n    var points = this.points_;\n    // Here we are comparing point references, not values        \n    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {\n        this.constrained_edge[2] = true;\n    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {\n        this.constrained_edge[1] = true;\n    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {\n        this.constrained_edge[0] = true;\n    }\n};\n\n\n// ---------------------------------------------------------Exports (public API)\n\nmodule.exports = Triangle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/triangle.js\n// module id = 12\n// module chunks = 0","// Copyright 2014, 2016 Todd Fleming\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n'use strict';\n\nimport { dist, cut, insideOutside, pocket, reduceCamPaths, separateTabs, vCarve } from './cam';\nimport { mmToClipperScale, offset, rawPathsToClipperPaths, union } from './mesh';\n\n// Convert mill paths to gcode.\n//      paths:          Array of CamPath\n//      ramp:           Ramp these paths?\n//      scale:          Factor to convert Clipper units to gcode units\n//      useZ:           Use Z coordinates in paths? (defaults to false, used for vPocket)\n//      offsetX:        Offset X (gcode units)\n//      offsetY:        Offset Y (gcode units)\n//      decimal:        Number of decimal places to keep in gcode\n//      topZ:           Top of area to cut (gcode units)\n//      botZ:           Bottom of area to cut (gcode units)\n//      safeZ:          Z position to safely move over uncut areas (gcode units)\n//      passDepth:      Cut depth for each pass (gcode units)\n//      plungeFeed:     Feedrate to plunge cutter (gcode units)\n//      cutFeed:        Feedrate for horizontal cuts (gcode units)\n//      tabGeometry:    Tab geometry (optional)\n//      tabZ:           Z position over tabs (required if tabGeometry is not empty) (gcode units)\nexport function getMillGcode(props) {\n    let { paths, ramp, scale, useZ, offsetX, offsetY, decimal, topZ, botZ, safeZ, passDepth,\n        plungeFeed, cutFeed, tabGeometry, tabZ, toolSpeed, useFluid } = props;\n\n    let plungeFeedGcode = ' F' + plungeFeed;\n    let cutFeedGcode = ' F' + cutFeed;\n\n    if (useZ === undefined)\n        useZ = false;\n\n    if (tabGeometry === undefined || tabZ <= botZ) {\n        tabGeometry = [];\n        tabZ = botZ;\n    }\n\n    let retractGcode =\n        '; Retract\\r\\n' +\n        'G0 Z' + safeZ.toFixed(decimal) + '\\r\\n';\n\n    let retractForTabGcode =\n        '; Retract for tab\\r\\n' +\n        'G0 Z' + tabZ.toFixed(decimal) + '\\r\\n';\n\n    let gcode = retractGcode;\n\n    function getX(p) {\n        return p.X * scale + offsetX;\n    }\n\n    function getY(p) {\n        return p.Y * scale + offsetY;\n    }\n\n    function convertPoint(p, useZ) {\n        let result = ' X' + (p.X * scale + offsetX).toFixed(decimal) + ' Y' + (p.Y * scale + offsetY).toFixed(decimal);\n        if (useZ)\n            result += ' Z' + (p.Z * scale + topZ).toFixed(decimal);\n        return result;\n    }\n\n    for (let pathIndex = 0; pathIndex < paths.length; ++pathIndex) {\n        let path = paths[pathIndex];\n        let origPath = path.path;\n        if (origPath.length === 0)\n            continue;\n        let separatedPaths = separateTabs(origPath, tabGeometry);\n\n        gcode +=\n            '\\r\\n' +\n            '; Path ' + pathIndex + '\\r\\n';\n\n        let currentZ = safeZ;\n        let finishedZ = topZ;\n        while (finishedZ > botZ || useZ) {\n            let nextZ = Math.max(finishedZ - passDepth, botZ);\n            if (currentZ < safeZ && (!path.safeToClose || tabGeometry.length > 0)) {\n                gcode += retractGcode;\n                currentZ = safeZ;\n            }\n\n            if (tabGeometry.length === 0)\n                currentZ = finishedZ;\n            else\n                currentZ = Math.max(finishedZ, tabZ);\n            gcode +=\n                '; Rapid to initial position\\r\\n' +\n                'G0' + convertPoint(origPath[0], false) + '\\r\\n' +\n                'G0 Z' + currentZ.toFixed(decimal) + '\\r\\n';\n\n            let selectedPaths;\n            if (nextZ >= tabZ || useZ)\n                selectedPaths = [origPath];\n            else\n                selectedPaths = separatedPaths;\n\n            for (let selectedIndex = 0; selectedIndex < selectedPaths.length; ++selectedIndex) {\n                let selectedPath = selectedPaths[selectedIndex];\n                if (selectedPath.length === 0)\n                    continue;\n\n                if (useFluid && useFluid.fluidOn) {\n                    gcode += `${useFluid.fluidOn}; Enable Fluid assist\\r\\n`;\n                }\n\n                if (!useZ) {\n                    let selectedZ;\n                    if (selectedIndex & 1)\n                        selectedZ = tabZ;\n                    else\n                        selectedZ = nextZ;\n\n                    if (selectedZ < currentZ) {\n                        let executedRamp = false;\n                        if (ramp) {\n                            let minPlungeTime = (currentZ - selectedZ) / plungeFeed;\n                            let idealDist = cutFeed * minPlungeTime;\n                            let end;\n                            let totalDist = 0;\n                            for (end = 1; end < selectedPath.length; ++end) {\n                                if (totalDist > idealDist)\n                                    break;\n                                totalDist += 2 * dist(getX(selectedPath[end - 1]), getY(selectedPath[end - 1]), getX(selectedPath[end]), getY(selectedPath[end]));\n                            }\n                            if (totalDist > 0) {\n                                gcode += '; ramp\\r\\n'\n                                executedRamp = true;\n                                let rampPath = selectedPath.slice(0, end).concat(selectedPath.slice(0, end - 1).reverse());\n                                let distTravelled = 0;\n                                for (let i = 1; i < rampPath.length; ++i) {\n                                    distTravelled += dist(getX(rampPath[i - 1]), getY(rampPath[i - 1]), getX(rampPath[i]), getY(rampPath[i]));\n                                    let newZ = currentZ + distTravelled / totalDist * (selectedZ - currentZ);\n                                    gcode += 'G1' + convertPoint(rampPath[i], false) + ' Z' + newZ.toFixed(decimal);\n                                    if (i === 1) {\n                                        gcode += ' F' + Math.min(totalDist / minPlungeTime, cutFeed).toFixed(decimal)\n                                        if (toolSpeed) gcode += ' S' + toolSpeed;\n                                    }\n                                    gcode += '\\r\\n';\n                                }\n                            }\n                        }\n                        if (!executedRamp)\n                            gcode +=\n                                '; plunge\\r\\n' +\n                                'G1 Z' + selectedZ.toFixed(decimal) + plungeFeedGcode\n                        if (toolSpeed) gcode += ' S' + toolSpeed;\n                        gcode += '\\r\\n';\n                    } else if (selectedZ > currentZ) {\n                        gcode += retractForTabGcode;\n                    }\n                    currentZ = selectedZ;\n                } // !useZ\n\n                gcode += '; cut\\r\\n';\n\n                for (let i = 1; i < selectedPath.length; ++i) {\n                    gcode += 'G1' + convertPoint(selectedPath[i], useZ);\n                    if (i === 1) {\n                        gcode += cutFeedGcode\n                        if (toolSpeed) gcode += ' S' + toolSpeed;\n                    }\n                    gcode += '\\r\\n';\n                }\n            } // selectedIndex\n            finishedZ = nextZ;\n            if (useZ)\n                break;\n        } // while (finishedZ > botZ)\n        if (useFluid && useFluid.fluidOff) {\n            gcode += `${useFluid.fluidOff}; Disable Fluid assist\\r\\n`;\n        }\n        gcode += retractGcode;\n    } // pathIndex\n\n    return gcode;\n}; // getMillGcode\n\nexport function getMillGcodeFromOp(settings, opIndex, op, geometry, openGeometry, tabGeometry, showAlert, done, progress) {\n    let ok = true;\n    if (op.millStartZ > op.millRapidZ) {\n        showAlert(\"millStartZ must be <= millRapidZ\", \"danger\");\n        ok = false;\n    }\n    if (op.passDepth <= 0) {\n        showAlert(\"Pass Depth must be greater than 0\", \"danger\");\n        ok = false;\n    }\n    if (op.type === 'Mill V Carve') {\n        if (op.toolAngle <= 0 || op.toolAngle >= 180) {\n            showAlert(\"Tool Angle must be in range (0, 180)\", \"danger\");\n            ok = false;\n        }\n    } else {\n        if (op.millEndZ >= op.millStartZ) {\n            showAlert(\"millEndZ must be < millStartZ\", \"danger\");\n            ok = false;\n        }\n        if (op.type !== 'Mill Cut' && op.toolDiameter <= 0) {\n            showAlert(\"Tool Diameter must be greater than 0\", \"danger\");\n            ok = false;\n        }\n        if (op.stepOver <= 0 || op.stepOver > 100) {\n            showAlert(\"Step Over must be in range 0-100%\", \"danger\");\n            ok = false;\n        }\n    }\n    if (op.plungeRate <= 0) {\n        showAlert(\"Plunge Rate must be greater than 0\", \"danger\");\n        ok = false;\n    }\n    if (op.cutRate <= 0) {\n        showAlert(\"Cut Rate must be greater than 0\", \"danger\");\n        ok = false;\n    }\n    if (!ok)\n        done(false);\n\n    if (tabGeometry && op.toolDiameter > 0)\n        tabGeometry = offset(tabGeometry, op.toolDiameter / 2 * mmToClipperScale);\n\n    let camPaths = [];\n    if (op.type === 'Mill Pocket') {\n        if (op.margin)\n            geometry = offset(geometry, -op.margin * mmToClipperScale);\n        camPaths = pocket(geometry, op.toolDiameter * mmToClipperScale, op.stepOver, op.direction === 'Climb');\n    } else if (op.type === 'Mill Cut') {\n        camPaths = cut(geometry, openGeometry, op.direction === 'Climb');\n    } else if (op.type === 'Mill Cut Inside') {\n        if (op.margin)\n            geometry = offset(geometry, -op.margin * mmToClipperScale);\n        camPaths = insideOutside(geometry, op.toolDiameter * mmToClipperScale, true, op.cutWidth * mmToClipperScale, op.stepOver, op.direction === 'Climb', true);\n    } else if (op.type === 'Mill Cut Outside') {\n        if (op.margin)\n            geometry = offset(geometry, op.margin * mmToClipperScale);\n        camPaths = insideOutside(geometry, op.toolDiameter * mmToClipperScale, false, op.cutWidth * mmToClipperScale, op.stepOver, op.direction === 'Climb', true);\n    } else if (op.type === 'Mill V Carve') {\n        camPaths = vCarve(geometry, op.toolAngle, op.passDepth * mmToClipperScale);\n    }\n\n    for (let camPath of camPaths) {\n        let path = camPath.path;\n        for (let point of path) {\n            point.X = Math.round(point.X / mmToClipperScale * 1000) * mmToClipperScale / 1000;\n            point.Y = Math.round(point.Y / mmToClipperScale * 1000) * mmToClipperScale / 1000;\n        }\n    }\n    reduceCamPaths(camPaths, op.segmentLength * mmToClipperScale);\n\n    let feedScale = 1;\n    if (settings.toolFeedUnits === 'mm/s')\n        feedScale = 60;\n\n    let gcode =\n        \"\\r\\n;\" +\n        \"\\r\\n; Operation:    \" + opIndex +\n        \"\\r\\n; Type:         \" + op.type +\n        \"\\r\\n; Paths:        \" + camPaths.length +\n        \"\\r\\n; Direction:    \" + op.direction +\n        \"\\r\\n; Rapid Z:      \" + op.millRapidZ +\n        \"\\r\\n; Start Z:      \" + op.millStartZ +\n        \"\\r\\n; End Z:        \" + op.millEndZ +\n        \"\\r\\n; Pass Depth:   \" + op.passDepth +\n        \"\\r\\n; Plunge rate:  \" + op.plungeRate + ' ' + settings.toolFeedUnits +\n        \"\\r\\n; Cut rate:     \" + op.cutRate + ' ' + settings.toolFeedUnits +\n        \"\\r\\n; Fluid:        \" + op.useFluid +\n        \"\\r\\n;\\r\\n\";\n\n    if (op.hookOperationStart.length) gcode += op.hookOperationStart;\n\n    gcode += getMillGcode({\n        paths: camPaths,\n        ramp: op.ramp,\n        scale: 1 / mmToClipperScale,\n        useZ: op.type === 'Mill V Carve',\n        useFluid: op.useFluid ? {\n            fluidOn: settings.machineFluidGcodeOn,\n            fluidOff: settings.machineFluidGcodeOff,\n        } : false,\n        offsetX: 0,\n        offsetY: 0,\n        decimal: 3,\n        topZ: op.millStartZ,\n        botZ: op.millEndZ,\n        safeZ: op.millRapidZ,\n        passDepth: op.passDepth,\n        plungeFeed: op.plungeRate * feedScale,\n        cutFeed: op.cutRate * feedScale,\n        tabGeometry: op.type === 'Mill V Carve' ? [] : tabGeometry,\n        tabZ: -op.tabDepth,\n        toolSpeed: op.toolSpeed\n    });\n\n    if (op.hookOperationEnd.length) gcode += op.hookOperationEnd;\n\n    done(gcode)\n\n} // getMillGcodeFromOp\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cam-gcode-mill.js","// Copyright 2014, 2016 Todd Fleming\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n'use strict';\n\nimport ClipperLib from 'clipper-lib';\nimport { mat3, vec2 } from 'gl-matrix';\n\nimport { diff, offset, cPathsToClipperPaths, cPathsToCamPaths, clipperBounds, clipperPathsToCPaths, clipperToCppScale } from './mesh';\n\n//const Module = require('raw-loader!web-cam-cpp');\nimport Module from 'raw-loader!web-cam-cpp';\n\nexport function dist(x1, y1, x2, y2) {\n    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\n// Does the line from p1 to p2 cross outside of bounds?\nfunction crosses(bounds, p1, p2) {\n    if (bounds === null)\n        return true;\n    if (p1.X === p2.X && p1.Y === p2.Y)\n        return false;\n    let clipper = new ClipperLib.Clipper();\n    clipper.AddPath([p1, p2], ClipperLib.PolyType.ptSubject, false);\n    clipper.AddPaths(bounds, ClipperLib.PolyType.ptClip, true);\n    let result = new ClipperLib.PolyTree();\n    clipper.Execute(ClipperLib.ClipType.ctIntersection, result, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    if (result.ChildCount() === 1) {\n        let child = result.Childs()[0];\n        let points = child.Contour();\n        if (points.length === 2) {\n            if (points[0].X === p1.X && points[1].X === p2.X && points[0].Y === p1.Y && points[1].Y === p2.Y)\n                return false;\n            if (points[0].X === p2.X && points[1].X === p1.X && points[0].Y === p2.Y && points[1].Y === p1.Y)\n                return false;\n        }\n    }\n    return true;\n}\n\nfunction pathIsClosed(clipperPath) {\n    return (\n        clipperPath.length >= 2 &&\n        clipperPath[0].X === clipperPath[clipperPath.length - 1].X &&\n        clipperPath[0].Y === clipperPath[clipperPath.length - 1].Y);\n}\n\n// Close all paths\nfunction closeClipperPaths(paths) {\n    for (let path of paths)\n        path.push(path[0]);\n}\n\n// CamPath has this format: {\n//      path:               Clipper path\n//      safeToClose:        Is it safe to close the path without retracting?\n// }\n\n// Try to merge paths. A merged path doesn't cross outside of bounds. Returns array of CamPath.\n// If paths contains both open and closed paths, then the closed paths must be before the open\n// paths within the array.\nfunction mergePaths(bounds, paths) {\n    if (paths.length === 0)\n        return [];\n\n    let currentPath = paths[0];\n    if (pathIsClosed(currentPath))\n        currentPath.push(currentPath[0]);\n    let currentPoint = currentPath[currentPath.length - 1];\n    paths[0] = [];\n\n    let mergedPaths = [];\n    let numLeft = paths.length - 1;\n    while (numLeft > 0) {\n        let closestPathIndex = null;\n        let closestPointIndex = null;\n        let closestPointDist = null;\n        let closestReverse = false;\n        for (let pathIndex = 0; pathIndex < paths.length; ++pathIndex) {\n            let path = paths[pathIndex];\n            function check(pointIndex) {\n                let point = path[pointIndex];\n                let dist = (currentPoint.X - point.X) * (currentPoint.X - point.X) + (currentPoint.Y - point.Y) * (currentPoint.Y - point.Y);\n                if (closestPointDist === null || dist < closestPointDist) {\n                    closestPathIndex = pathIndex;\n                    closestPointIndex = pointIndex;\n                    closestPointDist = dist;\n                    closestReverse = false;\n                    return true;\n                }\n                else\n                    return false;\n            }\n            if (pathIsClosed(path)) {\n                for (let pointIndex = 0; pointIndex < path.length; ++pointIndex)\n                    check(pointIndex);\n            } else if (path.length) {\n                check(0);\n                if (check(path.length - 1))\n                    closestReverse = true;\n            }\n        }\n\n        let path = paths[closestPathIndex];\n        paths[closestPathIndex] = [];\n        numLeft -= 1;\n        let needNew;\n        if (pathIsClosed(path)) {\n            needNew = crosses(bounds, currentPoint, path[closestPointIndex]);\n            path = path.slice(closestPointIndex, path.length).concat(path.slice(1, closestPointIndex));\n            path.push(path[0]);\n        } else {\n            needNew = true;\n            if (closestReverse) {\n                path = path.slice();\n                path.reverse();\n            }\n        }\n        if (needNew) {\n            mergedPaths.push(currentPath);\n            currentPath = path;\n            currentPoint = currentPath[currentPath.length - 1];\n        }\n        else {\n            currentPath = currentPath.concat(path);\n            currentPoint = currentPath[currentPath.length - 1];\n        }\n    }\n    mergedPaths.push(currentPath);\n\n    let camPaths = [];\n    for (let i = 0; i < mergedPaths.length; ++i) {\n        let path = mergedPaths[i];\n        camPaths.push({\n            path: path,\n            safeToClose: !crosses(bounds, path[0], path[path.length - 1])\n        });\n    }\n\n    return camPaths;\n}\n\n// Compute paths for pocket operation on Clipper geometry. Returns array\n// of CamPath. cutterDia is in Clipper units. stepover is in the range (0, 100).\nexport function pocket(geometry, cutterDia, stepover, climb) {\n    stepover = stepover / 100;\n    let current = offset(geometry, -cutterDia / 2);\n    let bounds = current.slice(0);\n    let allPaths = [];\n    while (current.length !== 0) {\n        if (!climb)\n            for (let i = 0; i < current.length; ++i)\n                current[i].reverse();\n        allPaths = current.concat(allPaths);\n        current = offset(current, -cutterDia * stepover);\n    }\n    closeClipperPaths(allPaths);\n    return mergePaths(bounds, allPaths);\n};\n\n// Compute paths for inside/outside operation on Clipper geometry. Returns array\n// of CamPath. cutterDia and width are in Clipper units. stepover is in the\n// range (0, 100].\nexport function insideOutside(geometry, cutterDia, isInside, width, stepover, climb, allowRecutInBounds) {\n\n    stepover = stepover / 100;\n    width = Math.max(width, cutterDia);\n\n    let currentWidth = cutterDia;\n    let allPaths = [];\n    let eachWidth = cutterDia * stepover;\n\n    let current;\n    let bounds = null;\n    let eachOffset;\n    let needReverse;\n\n    if (isInside) {\n        current = offset(geometry, -cutterDia / 2);\n        if (allowRecutInBounds)\n            bounds = diff(current, offset(geometry, -(width - cutterDia / 2)));\n        eachOffset = -eachWidth;\n        needReverse = !climb;\n    } else {\n        current = offset(geometry, cutterDia / 2);\n        if (allowRecutInBounds)\n            bounds = diff(offset(geometry, width - cutterDia / 2), current);\n        eachOffset = eachWidth;\n        needReverse = climb;\n    }\n\n    while (currentWidth <= width) {\n        if (needReverse)\n            for (let i = 0; i < current.length; ++i)\n                current[i].reverse();\n        allPaths = current.concat(allPaths);\n        let nextWidth = currentWidth + eachWidth;\n        if (nextWidth > width && width - currentWidth > 0) {\n            current = offset(current, width - currentWidth);\n            if (needReverse)\n                for (let i = 0; i < current.length; ++i)\n                    current[i].reverse();\n            allPaths = current.concat(allPaths);\n            break;\n        }\n        currentWidth = nextWidth;\n        if (currentWidth <= width)\n            current = offset(current, eachOffset);\n    }\n    closeClipperPaths(allPaths);\n    return mergePaths(bounds, allPaths);\n};\n\n// Compute paths for cut operation on Clipper geometry. Returns array\n// of CamPath.\nexport function cut(geometry, openGeometry, climb) {\n    let allPaths = [];\n    for (let i = 0; i < geometry.length; ++i) {\n        let path = geometry[i].slice(0);\n        if (climb)\n            path.reverse();\n        path.push(path[0]);\n        allPaths.push(path);\n    }\n    for (let path of openGeometry)\n        allPaths.push(path.slice());\n    let result = mergePaths(null, allPaths);\n    for (let i = 0; i < result.length; ++i)\n        result[i].safeToClose = pathIsClosed(result[i].path);\n    return result;\n};\n\nexport function fillPath(geometry, lineDistance, angle) {\n    if (!geometry.length || !geometry[0].length)\n        return [];\n    let bounds = clipperBounds(geometry);\n    let cx = (bounds.minX + bounds.maxX) / 2;\n    let cy = (bounds.minY + bounds.maxY) / 2;\n    let r = dist(cx, cy, bounds.minX, bounds.minY) + lineDistance;\n\n    let m = mat3.fromTranslation([], [cx, cy]);\n    m = mat3.rotate([], m, angle * Math.PI / 180);\n    m = mat3.translate([], m, [-cx, -cy]);\n    let makePoint = (x, y) => {\n        let p = vec2.transformMat3([], [x, y], m);\n        return { X: p[0], Y: p[1] };\n    }\n\n    let scan = [];\n    for (let y = cy - r; y < cy + r; y += lineDistance * 2) {\n        scan.push(\n            makePoint(cx - r, y),\n            makePoint(cx + r, y),\n            makePoint(cx + r, y + lineDistance),\n            makePoint(cx - r, y + lineDistance),\n        );\n    }\n\n    let allPaths = [];\n    let separated = separateTabs(scan, geometry);\n    for (let i = 1; i < separated.length; i += 2)\n        allPaths.push(separated[i]);\n    return mergePaths(null, allPaths);\n};\n\nexport function vCarve(geometry, cutterAngle, passDepth) {\n    if (cutterAngle <= 0 || cutterAngle >= 180)\n        return [];\n\n    let memoryBlocks = [];\n    let resultPathsRef = Module._malloc(4);\n    let resultNumPathsRef = Module._malloc(4);\n    let resultPathSizesRef = Module._malloc(4);\n    let cGeometry = clipperPathsToCPaths(memoryBlocks, geometry);\n    memoryBlocks.push(resultPathsRef);\n    memoryBlocks.push(resultNumPathsRef);\n    memoryBlocks.push(resultPathSizesRef);\n\n    let debugArg0 = 0, debugArg1 = 0;\n\n    //extern \"C\" void vCarve(\n    //    int debugArg0, int debugArg1,\n    //    double** paths, int numPaths, int* pathSizes,\n    //    double cutterAngle, double passDepth,\n    //    double**& resultPaths, int& resultNumPaths, int*& resultPathSizes)\n    Module.ccall(\n        'vCarve',\n        'void', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number'],\n        [\n            debugArg0, debugArg1, cGeometry[0], cGeometry[1], cGeometry[2],\n            cutterAngle, passDepth * clipperToCppScale,\n            resultPathsRef, resultNumPathsRef, resultPathSizesRef\n        ]);\n\n    let result = cPathsToCamPaths(memoryBlocks, resultPathsRef, resultNumPathsRef, resultPathSizesRef);\n\n    for (let i = 0; i < memoryBlocks.length; ++i)\n        Module._free(memoryBlocks[i]);\n\n    return result;\n};\n\nexport function reduceCamPaths(camPaths, minDist) {\n    let minDistSqr = minDist * minDist;\n    let distSqr = (p1, p2) => (p1.X - p2.X) * (p1.X - p2.X) + (p1.Y - p2.Y) * (p1.Y - p2.Y);\n    for (let camPath of camPaths) {\n        let path = camPath.path;\n        let newPath = [path[0]];\n        for (let i = 1; i < path.length - 1; ++i) {\n            let sq = distSqr(path[i], newPath[newPath.length - 1]);\n            if (sq > 0 && sq >= minDistSqr)\n                newPath.push(path[i]);\n        }\n        newPath.push(path[path.length - 1]);\n        camPath.path = newPath;\n    }\n}\n\n// Convert array of CamPath to array of Clipper path\nexport function getClipperPathsFromCamPaths(paths) {\n    let result = [];\n    if (paths !== null)\n        for (let i = 0; i < paths.length; ++i)\n            result.push(paths[i].path);\n    return result;\n}\n\nlet displayedCppTabError1 = false;\nlet displayedCppTabError2 = false;\n\nexport function separateTabs(cutterPath, tabGeometry) {\n    if (tabGeometry.length === 0)\n        return [cutterPath];\n    if (typeof Module === 'undefined') {\n        if (!displayedCppTabError1) {\n            showAlert(\"Failed to load cam-cpp.js; tabs will be missing. This message will not repeat.\", \"danger\", false);\n            displayedCppTabError1 = true;\n        }\n        return cutterPath;\n    }\n\n    let memoryBlocks = [];\n\n    let cCutterPath = clipperPathsToCPaths(memoryBlocks, [cutterPath]);\n    let cTabGeometry = clipperPathsToCPaths(memoryBlocks, tabGeometry);\n\n    let errorRef = Module._malloc(4);\n    let resultPathsRef = Module._malloc(4);\n    let resultNumPathsRef = Module._malloc(4);\n    let resultPathSizesRef = Module._malloc(4);\n    memoryBlocks.push(errorRef);\n    memoryBlocks.push(resultPathsRef);\n    memoryBlocks.push(resultNumPathsRef);\n    memoryBlocks.push(resultPathSizesRef);\n\n    //extern \"C\" void separateTabs(\n    //    double** pathPolygons, int numPaths, int* pathSizes,\n    //    double** tabPolygons, int numTabPolygons, int* tabPolygonSizes,\n    //    bool& error,\n    //    double**& resultPaths, int& resultNumPaths, int*& resultPathSizes)\n    Module.ccall(\n        'separateTabs',\n        'void', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number'],\n        [cCutterPath[0], cCutterPath[1], cCutterPath[2], cTabGeometry[0], cTabGeometry[1], cTabGeometry[2], errorRef, resultPathsRef, resultNumPathsRef, resultPathSizesRef]);\n\n    if (Module.HEAPU32[errorRef >> 2] && !displayedCppTabError2) {\n        showAlert(\"Internal error processing tabs; tabs will be missing. This message will not repeat.\", \"danger\", false);\n        displayedCppTabError2 = true;\n    }\n\n    let result = cPathsToClipperPaths(memoryBlocks, resultPathsRef, resultNumPathsRef, resultPathSizesRef);\n\n    for (let i = 0; i < memoryBlocks.length; ++i)\n        Module._free(memoryBlocks[i]);\n\n    return result;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./lib/cam.js","import { getMillGcodeFromOp } from '../cam-gcode-mill'\n\nonmessage = (event) => {\n\n    const {settings, opIndex, op, geometry=[], openGeometry=[], tabGeometry=[]} = event.data\n    const errors = [];\n\n    const showAlert = (message, level) => {\n        errors.push({ message, level })\n    };\n    const progress = () => {\n        postMessage(JSON.stringify({ event: \"onProgress\", gcode, errors }))\n    };\n    const done = (gcode) => {\n        if (gcode === false && errors.length) {\n            postMessage(JSON.stringify({ event: \"onError\", errors }))\n        } else {\n            postMessage(JSON.stringify({ event: \"onDone\", gcode }))\n        }\n    };\n\n    getMillGcodeFromOp.apply(this, [settings, opIndex, op, geometry, openGeometry, tabGeometry, showAlert, done, progress])\n\n}\n\n\n// WEBPACK FOOTER //\n// ./lib/workers/cam-mill.js","import * as glMatrix from \"./gl-matrix/common.js\";\r\nimport * as mat2 from \"./gl-matrix/mat2.js\";\r\nimport * as mat2d from \"./gl-matrix/mat2d.js\";\r\nimport * as mat3 from \"./gl-matrix/mat3.js\";\r\nimport * as mat4 from \"./gl-matrix/mat4.js\";\r\nimport * as quat from \"./gl-matrix/quat.js\";\r\nimport * as quat2 from \"./gl-matrix/quat2.js\";\r\nimport * as vec2 from \"./gl-matrix/vec2.js\";\r\nimport * as vec3 from \"./gl-matrix/vec3.js\";\r\nimport * as vec4 from \"./gl-matrix/vec4.js\";\r\n\r\nexport { glMatrix, mat2, mat2d, mat3, mat4, quat, quat2, vec2, vec3, vec4 };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/gl-matrix/lib/gl-matrix.js\n// module id = 16\n// module chunks = 0","import * as glMatrix from \"./common.js\";\r\n\r\n/**\r\n * 2x2 Matrix\r\n * @module mat2\r\n */\r\n\r\n/**\r\n * Creates a new identity mat2\r\n *\r\n * @returns {mat2} a new 2x2 matrix\r\n */\r\nexport function create() {\r\n  var out = new glMatrix.ARRAY_TYPE(4);\r\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n  }\r\n  out[0] = 1;\r\n  out[3] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new mat2 initialized with values from an existing matrix\r\n *\r\n * @param {mat2} a matrix to clone\r\n * @returns {mat2} a new 2x2 matrix\r\n */\r\nexport function clone(a) {\r\n  var out = new glMatrix.ARRAY_TYPE(4);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one mat2 to another\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\r\nexport function copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set a mat2 to the identity matrix\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @returns {mat2} out\r\n */\r\nexport function identity(out) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Create a new mat2 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\r\n * @returns {mat2} out A new 2x2 matrix\r\n */\r\nexport function fromValues(m00, m01, m10, m11) {\r\n  var out = new glMatrix.ARRAY_TYPE(4);\r\n  out[0] = m00;\r\n  out[1] = m01;\r\n  out[2] = m10;\r\n  out[3] = m11;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a mat2 to the given values\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\r\n * @returns {mat2} out\r\n */\r\nexport function set(out, m00, m01, m10, m11) {\r\n  out[0] = m00;\r\n  out[1] = m01;\r\n  out[2] = m10;\r\n  out[3] = m11;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transpose the values of a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\r\nexport function transpose(out, a) {\r\n  // If we are transposing ourselves we can skip a few steps but have to cache\r\n  // some values\r\n  if (out === a) {\r\n    var a1 = a[1];\r\n    out[1] = a[2];\r\n    out[2] = a1;\r\n  } else {\r\n    out[0] = a[0];\r\n    out[1] = a[2];\r\n    out[2] = a[1];\r\n    out[3] = a[3];\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Inverts a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\r\nexport function invert(out, a) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n\r\n  // Calculate the determinant\r\n  var det = a0 * a3 - a2 * a1;\r\n\r\n  if (!det) {\r\n    return null;\r\n  }\r\n  det = 1.0 / det;\r\n\r\n  out[0] = a3 * det;\r\n  out[1] = -a1 * det;\r\n  out[2] = -a2 * det;\r\n  out[3] = a0 * det;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the adjugate of a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\r\nexport function adjoint(out, a) {\r\n  // Caching this value is nessecary if out == a\r\n  var a0 = a[0];\r\n  out[0] = a[3];\r\n  out[1] = -a[1];\r\n  out[2] = -a[2];\r\n  out[3] = a0;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the determinant of a mat2\r\n *\r\n * @param {mat2} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\r\nexport function determinant(a) {\r\n  return a[0] * a[3] - a[2] * a[1];\r\n}\r\n\r\n/**\r\n * Multiplies two mat2's\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @returns {mat2} out\r\n */\r\nexport function multiply(out, a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3];\r\n  out[0] = a0 * b0 + a2 * b1;\r\n  out[1] = a1 * b0 + a3 * b1;\r\n  out[2] = a0 * b2 + a2 * b3;\r\n  out[3] = a1 * b2 + a3 * b3;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a mat2 by the given angle\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2} out\r\n */\r\nexport function rotate(out, a, rad) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  out[0] = a0 * c + a2 * s;\r\n  out[1] = a1 * c + a3 * s;\r\n  out[2] = a0 * -s + a2 * c;\r\n  out[3] = a1 * -s + a3 * c;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Scales the mat2 by the dimensions in the given vec2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the matrix to rotate\r\n * @param {vec2} v the vec2 to scale the matrix by\r\n * @returns {mat2} out\r\n **/\r\nexport function scale(out, a, v) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var v0 = v[0],\r\n      v1 = v[1];\r\n  out[0] = a0 * v0;\r\n  out[1] = a1 * v0;\r\n  out[2] = a2 * v1;\r\n  out[3] = a3 * v1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2.identity(dest);\r\n *     mat2.rotate(dest, dest, rad);\r\n *\r\n * @param {mat2} out mat2 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2} out\r\n */\r\nexport function fromRotation(out, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  out[0] = c;\r\n  out[1] = s;\r\n  out[2] = -s;\r\n  out[3] = c;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2.identity(dest);\r\n *     mat2.scale(dest, dest, vec);\r\n *\r\n * @param {mat2} out mat2 receiving operation result\r\n * @param {vec2} v Scaling vector\r\n * @returns {mat2} out\r\n */\r\nexport function fromScaling(out, v) {\r\n  out[0] = v[0];\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = v[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a string representation of a mat2\r\n *\r\n * @param {mat2} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\r\nexport function str(a) {\r\n  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\r\n}\r\n\r\n/**\r\n * Returns Frobenius norm of a mat2\r\n *\r\n * @param {mat2} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\r\nexport function frob(a) {\r\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));\r\n}\r\n\r\n/**\r\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\r\n * @param {mat2} L the lower triangular matrix\r\n * @param {mat2} D the diagonal matrix\r\n * @param {mat2} U the upper triangular matrix\r\n * @param {mat2} a the input matrix to factorize\r\n */\r\n\r\nexport function LDU(L, D, U, a) {\r\n  L[2] = a[2] / a[0];\r\n  U[0] = a[0];\r\n  U[1] = a[1];\r\n  U[3] = a[3] - L[2] * U[1];\r\n  return [L, D, U];\r\n}\r\n\r\n/**\r\n * Adds two mat2's\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @returns {mat2} out\r\n */\r\nexport function add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  out[3] = a[3] + b[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @returns {mat2} out\r\n */\r\nexport function subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  out[2] = a[2] - b[2];\r\n  out[3] = a[3] - b[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat2} a The first matrix.\r\n * @param {mat2} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nexport function exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat2} a The first matrix.\r\n * @param {mat2} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nexport function equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3];\r\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\r\n}\r\n\r\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat2} out\r\n */\r\nexport function multiplyScalar(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  out[3] = a[3] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat2} out the receiving vector\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat2} out\r\n */\r\nexport function multiplyScalarAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  out[2] = a[2] + b[2] * scale;\r\n  out[3] = a[3] + b[3] * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Alias for {@link mat2.multiply}\r\n * @function\r\n */\r\nexport var mul = multiply;\r\n\r\n/**\r\n * Alias for {@link mat2.subtract}\r\n * @function\r\n */\r\nexport var sub = subtract;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/gl-matrix/lib/gl-matrix/mat2.js\n// module id = 17\n// module chunks = 0","import * as glMatrix from \"./common.js\";\r\n\r\n/**\r\n * 2x3 Matrix\r\n * @module mat2d\r\n *\r\n * @description\r\n * A mat2d contains six elements defined as:\r\n * <pre>\r\n * [a, c, tx,\r\n *  b, d, ty]\r\n * </pre>\r\n * This is a short form for the 3x3 matrix:\r\n * <pre>\r\n * [a, c, tx,\r\n *  b, d, ty,\r\n *  0, 0, 1]\r\n * </pre>\r\n * The last row is ignored so the array is shorter and operations are faster.\r\n */\r\n\r\n/**\r\n * Creates a new identity mat2d\r\n *\r\n * @returns {mat2d} a new 2x3 matrix\r\n */\r\nexport function create() {\r\n  var out = new glMatrix.ARRAY_TYPE(6);\r\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n    out[4] = 0;\r\n    out[5] = 0;\r\n  }\r\n  out[0] = 1;\r\n  out[3] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new mat2d initialized with values from an existing matrix\r\n *\r\n * @param {mat2d} a matrix to clone\r\n * @returns {mat2d} a new 2x3 matrix\r\n */\r\nexport function clone(a) {\r\n  var out = new glMatrix.ARRAY_TYPE(6);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one mat2d to another\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the source matrix\r\n * @returns {mat2d} out\r\n */\r\nexport function copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set a mat2d to the identity matrix\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @returns {mat2d} out\r\n */\r\nexport function identity(out) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 1;\r\n  out[4] = 0;\r\n  out[5] = 0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Create a new mat2d with the given values\r\n *\r\n * @param {Number} a Component A (index 0)\r\n * @param {Number} b Component B (index 1)\r\n * @param {Number} c Component C (index 2)\r\n * @param {Number} d Component D (index 3)\r\n * @param {Number} tx Component TX (index 4)\r\n * @param {Number} ty Component TY (index 5)\r\n * @returns {mat2d} A new mat2d\r\n */\r\nexport function fromValues(a, b, c, d, tx, ty) {\r\n  var out = new glMatrix.ARRAY_TYPE(6);\r\n  out[0] = a;\r\n  out[1] = b;\r\n  out[2] = c;\r\n  out[3] = d;\r\n  out[4] = tx;\r\n  out[5] = ty;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a mat2d to the given values\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {Number} a Component A (index 0)\r\n * @param {Number} b Component B (index 1)\r\n * @param {Number} c Component C (index 2)\r\n * @param {Number} d Component D (index 3)\r\n * @param {Number} tx Component TX (index 4)\r\n * @param {Number} ty Component TY (index 5)\r\n * @returns {mat2d} out\r\n */\r\nexport function set(out, a, b, c, d, tx, ty) {\r\n  out[0] = a;\r\n  out[1] = b;\r\n  out[2] = c;\r\n  out[3] = d;\r\n  out[4] = tx;\r\n  out[5] = ty;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Inverts a mat2d\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the source matrix\r\n * @returns {mat2d} out\r\n */\r\nexport function invert(out, a) {\r\n  var aa = a[0],\r\n      ab = a[1],\r\n      ac = a[2],\r\n      ad = a[3];\r\n  var atx = a[4],\r\n      aty = a[5];\r\n\r\n  var det = aa * ad - ab * ac;\r\n  if (!det) {\r\n    return null;\r\n  }\r\n  det = 1.0 / det;\r\n\r\n  out[0] = ad * det;\r\n  out[1] = -ab * det;\r\n  out[2] = -ac * det;\r\n  out[3] = aa * det;\r\n  out[4] = (ac * aty - ad * atx) * det;\r\n  out[5] = (ab * atx - aa * aty) * det;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the determinant of a mat2d\r\n *\r\n * @param {mat2d} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\r\nexport function determinant(a) {\r\n  return a[0] * a[3] - a[1] * a[2];\r\n}\r\n\r\n/**\r\n * Multiplies two mat2d's\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\r\nexport function multiply(out, a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3],\r\n      a4 = a[4],\r\n      a5 = a[5];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3],\r\n      b4 = b[4],\r\n      b5 = b[5];\r\n  out[0] = a0 * b0 + a2 * b1;\r\n  out[1] = a1 * b0 + a3 * b1;\r\n  out[2] = a0 * b2 + a2 * b3;\r\n  out[3] = a1 * b2 + a3 * b3;\r\n  out[4] = a0 * b4 + a2 * b5 + a4;\r\n  out[5] = a1 * b4 + a3 * b5 + a5;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a mat2d by the given angle\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2d} out\r\n */\r\nexport function rotate(out, a, rad) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3],\r\n      a4 = a[4],\r\n      a5 = a[5];\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  out[0] = a0 * c + a2 * s;\r\n  out[1] = a1 * c + a3 * s;\r\n  out[2] = a0 * -s + a2 * c;\r\n  out[3] = a1 * -s + a3 * c;\r\n  out[4] = a4;\r\n  out[5] = a5;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Scales the mat2d by the dimensions in the given vec2\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to translate\r\n * @param {vec2} v the vec2 to scale the matrix by\r\n * @returns {mat2d} out\r\n **/\r\nexport function scale(out, a, v) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3],\r\n      a4 = a[4],\r\n      a5 = a[5];\r\n  var v0 = v[0],\r\n      v1 = v[1];\r\n  out[0] = a0 * v0;\r\n  out[1] = a1 * v0;\r\n  out[2] = a2 * v1;\r\n  out[3] = a3 * v1;\r\n  out[4] = a4;\r\n  out[5] = a5;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Translates the mat2d by the dimensions in the given vec2\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to translate\r\n * @param {vec2} v the vec2 to translate the matrix by\r\n * @returns {mat2d} out\r\n **/\r\nexport function translate(out, a, v) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3],\r\n      a4 = a[4],\r\n      a5 = a[5];\r\n  var v0 = v[0],\r\n      v1 = v[1];\r\n  out[0] = a0;\r\n  out[1] = a1;\r\n  out[2] = a2;\r\n  out[3] = a3;\r\n  out[4] = a0 * v0 + a2 * v1 + a4;\r\n  out[5] = a1 * v0 + a3 * v1 + a5;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.rotate(dest, dest, rad);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2d} out\r\n */\r\nexport function fromRotation(out, rad) {\r\n  var s = Math.sin(rad),\r\n      c = Math.cos(rad);\r\n  out[0] = c;\r\n  out[1] = s;\r\n  out[2] = -s;\r\n  out[3] = c;\r\n  out[4] = 0;\r\n  out[5] = 0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.scale(dest, dest, vec);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {vec2} v Scaling vector\r\n * @returns {mat2d} out\r\n */\r\nexport function fromScaling(out, v) {\r\n  out[0] = v[0];\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = v[1];\r\n  out[4] = 0;\r\n  out[5] = 0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.translate(dest, dest, vec);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {vec2} v Translation vector\r\n * @returns {mat2d} out\r\n */\r\nexport function fromTranslation(out, v) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 1;\r\n  out[4] = v[0];\r\n  out[5] = v[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a string representation of a mat2d\r\n *\r\n * @param {mat2d} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\r\nexport function str(a) {\r\n  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';\r\n}\r\n\r\n/**\r\n * Returns Frobenius norm of a mat2d\r\n *\r\n * @param {mat2d} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\r\nexport function frob(a) {\r\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);\r\n}\r\n\r\n/**\r\n * Adds two mat2d's\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\r\nexport function add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  out[3] = a[3] + b[3];\r\n  out[4] = a[4] + b[4];\r\n  out[5] = a[5] + b[5];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\r\nexport function subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  out[2] = a[2] - b[2];\r\n  out[3] = a[3] - b[3];\r\n  out[4] = a[4] - b[4];\r\n  out[5] = a[5] - b[5];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat2d} out\r\n */\r\nexport function multiplyScalar(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  out[3] = a[3] * b;\r\n  out[4] = a[4] * b;\r\n  out[5] = a[5] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat2d} out the receiving vector\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat2d} out\r\n */\r\nexport function multiplyScalarAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  out[2] = a[2] + b[2] * scale;\r\n  out[3] = a[3] + b[3] * scale;\r\n  out[4] = a[4] + b[4] * scale;\r\n  out[5] = a[5] + b[5] * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat2d} a The first matrix.\r\n * @param {mat2d} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nexport function exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat2d} a The first matrix.\r\n * @param {mat2d} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nexport function equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3],\r\n      a4 = a[4],\r\n      a5 = a[5];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3],\r\n      b4 = b[4],\r\n      b5 = b[5];\r\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));\r\n}\r\n\r\n/**\r\n * Alias for {@link mat2d.multiply}\r\n * @function\r\n */\r\nexport var mul = multiply;\r\n\r\n/**\r\n * Alias for {@link mat2d.subtract}\r\n * @function\r\n */\r\nexport var sub = subtract;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/gl-matrix/lib/gl-matrix/mat2d.js\n// module id = 18\n// module chunks = 0","import * as glMatrix from \"./common.js\";\r\nimport * as quat from \"./quat.js\";\r\nimport * as mat4 from \"./mat4.js\";\r\n\r\n/**\r\n * Dual Quaternion<br>\r\n * Format: [real, dual]<br>\r\n * Quaternion format: XYZW<br>\r\n * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>\r\n * @module quat2\r\n */\r\n\r\n/**\r\n * Creates a new identity dual quat\r\n *\r\n * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]\r\n */\r\nexport function create() {\r\n  var dq = new glMatrix.ARRAY_TYPE(8);\r\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\r\n    dq[0] = 0;\r\n    dq[1] = 0;\r\n    dq[2] = 0;\r\n    dq[4] = 0;\r\n    dq[5] = 0;\r\n    dq[6] = 0;\r\n    dq[7] = 0;\r\n  }\r\n  dq[3] = 1;\r\n  return dq;\r\n}\r\n\r\n/**\r\n * Creates a new quat initialized with values from an existing quaternion\r\n *\r\n * @param {quat2} a dual quaternion to clone\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\r\nexport function clone(a) {\r\n  var dq = new glMatrix.ARRAY_TYPE(8);\r\n  dq[0] = a[0];\r\n  dq[1] = a[1];\r\n  dq[2] = a[2];\r\n  dq[3] = a[3];\r\n  dq[4] = a[4];\r\n  dq[5] = a[5];\r\n  dq[6] = a[6];\r\n  dq[7] = a[7];\r\n  return dq;\r\n}\r\n\r\n/**\r\n * Creates a new dual quat initialized with the given values\r\n *\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component\r\n * @param {Number} y2 Y component\r\n * @param {Number} z2 Z component\r\n * @param {Number} w2 W component\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\r\nexport function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {\r\n  var dq = new glMatrix.ARRAY_TYPE(8);\r\n  dq[0] = x1;\r\n  dq[1] = y1;\r\n  dq[2] = z1;\r\n  dq[3] = w1;\r\n  dq[4] = x2;\r\n  dq[5] = y2;\r\n  dq[6] = z2;\r\n  dq[7] = w2;\r\n  return dq;\r\n}\r\n\r\n/**\r\n * Creates a new dual quat from the given values (quat and translation)\r\n *\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component (translation)\r\n * @param {Number} y2 Y component (translation)\r\n * @param {Number} z2 Z component (translation)\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\r\nexport function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {\r\n  var dq = new glMatrix.ARRAY_TYPE(8);\r\n  dq[0] = x1;\r\n  dq[1] = y1;\r\n  dq[2] = z1;\r\n  dq[3] = w1;\r\n  var ax = x2 * 0.5,\r\n      ay = y2 * 0.5,\r\n      az = z2 * 0.5;\r\n  dq[4] = ax * w1 + ay * z1 - az * y1;\r\n  dq[5] = ay * w1 + az * x1 - ax * z1;\r\n  dq[6] = az * w1 + ax * y1 - ay * x1;\r\n  dq[7] = -ax * x1 - ay * y1 - az * z1;\r\n  return dq;\r\n}\r\n\r\n/**\r\n * Creates a dual quat from a quaternion and a translation\r\n *\r\n * @param {quat2} dual quaternion receiving operation result\r\n * @param {quat} q quaternion\r\n * @param {vec3} t tranlation vector\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\r\nexport function fromRotationTranslation(out, q, t) {\r\n  var ax = t[0] * 0.5,\r\n      ay = t[1] * 0.5,\r\n      az = t[2] * 0.5,\r\n      bx = q[0],\r\n      by = q[1],\r\n      bz = q[2],\r\n      bw = q[3];\r\n  out[0] = bx;\r\n  out[1] = by;\r\n  out[2] = bz;\r\n  out[3] = bw;\r\n  out[4] = ax * bw + ay * bz - az * by;\r\n  out[5] = ay * bw + az * bx - ax * bz;\r\n  out[6] = az * bw + ax * by - ay * bx;\r\n  out[7] = -ax * bx - ay * by - az * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a dual quat from a translation\r\n *\r\n * @param {quat2} dual quaternion receiving operation result\r\n * @param {vec3} t translation vector\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\r\nexport function fromTranslation(out, t) {\r\n  out[0] = 0;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 1;\r\n  out[4] = t[0] * 0.5;\r\n  out[5] = t[1] * 0.5;\r\n  out[6] = t[2] * 0.5;\r\n  out[7] = 0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a dual quat from a quaternion\r\n *\r\n * @param {quat2} dual quaternion receiving operation result\r\n * @param {quat} q the quaternion\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\r\nexport function fromRotation(out, q) {\r\n  out[0] = q[0];\r\n  out[1] = q[1];\r\n  out[2] = q[2];\r\n  out[3] = q[3];\r\n  out[4] = 0;\r\n  out[5] = 0;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new dual quat from a matrix (4x4)\r\n *\r\n * @param {quat2} out the dual quaternion\r\n * @param {mat4} a the matrix\r\n * @returns {quat2} dual quat receiving operation result\r\n * @function\r\n */\r\nexport function fromMat4(out, a) {\r\n  //TODO Optimize this\r\n  var outer = quat.create();\r\n  mat4.getRotation(outer, a);\r\n  var t = new glMatrix.ARRAY_TYPE(3);\r\n  mat4.getTranslation(t, a);\r\n  fromRotationTranslation(out, outer, t);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one dual quat to another\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the source dual quaternion\r\n * @returns {quat2} out\r\n * @function\r\n */\r\nexport function copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  out[6] = a[6];\r\n  out[7] = a[7];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set a dual quat to the identity dual quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @returns {quat2} out\r\n */\r\nexport function identity(out) {\r\n  out[0] = 0;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 1;\r\n  out[4] = 0;\r\n  out[5] = 0;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a dual quat to the given values\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component\r\n * @param {Number} y2 Y component\r\n * @param {Number} z2 Z component\r\n * @param {Number} w2 W component\r\n * @returns {quat2} out\r\n * @function\r\n */\r\nexport function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {\r\n  out[0] = x1;\r\n  out[1] = y1;\r\n  out[2] = z1;\r\n  out[3] = w1;\r\n\r\n  out[4] = x2;\r\n  out[5] = y2;\r\n  out[6] = z2;\r\n  out[7] = w2;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Gets the real part of a dual quat\r\n * @param  {quat} out real part\r\n * @param  {quat2} a Dual Quaternion\r\n * @return {quat} real part\r\n */\r\nexport var getReal = quat.copy;\r\n\r\n/**\r\n * Gets the dual part of a dual quat\r\n * @param  {quat} out dual part\r\n * @param  {quat2} a Dual Quaternion\r\n * @return {quat} dual part\r\n */\r\nexport function getDual(out, a) {\r\n  out[0] = a[4];\r\n  out[1] = a[5];\r\n  out[2] = a[6];\r\n  out[3] = a[7];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the real component of a dual quat to the given quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {quat} q a quaternion representing the real part\r\n * @returns {quat2} out\r\n * @function\r\n */\r\nexport var setReal = quat.copy;\r\n\r\n/**\r\n * Set the dual component of a dual quat to the given quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {quat} q a quaternion representing the dual part\r\n * @returns {quat2} out\r\n * @function\r\n */\r\nexport function setDual(out, q) {\r\n  out[4] = q[0];\r\n  out[5] = q[1];\r\n  out[6] = q[2];\r\n  out[7] = q[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Gets the translation of a normalized dual quat\r\n * @param  {vec3} out translation\r\n * @param  {quat2} a Dual Quaternion to be decomposed\r\n * @return {vec3} translation\r\n */\r\nexport function getTranslation(out, a) {\r\n  var ax = a[4],\r\n      ay = a[5],\r\n      az = a[6],\r\n      aw = a[7],\r\n      bx = -a[0],\r\n      by = -a[1],\r\n      bz = -a[2],\r\n      bw = a[3];\r\n  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\r\n  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\r\n  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Translates a dual quat by the given vector\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to translate\r\n * @param {vec3} v vector to translate by\r\n * @returns {quat2} out\r\n */\r\nexport function translate(out, a, v) {\r\n  var ax1 = a[0],\r\n      ay1 = a[1],\r\n      az1 = a[2],\r\n      aw1 = a[3],\r\n      bx1 = v[0] * 0.5,\r\n      by1 = v[1] * 0.5,\r\n      bz1 = v[2] * 0.5,\r\n      ax2 = a[4],\r\n      ay2 = a[5],\r\n      az2 = a[6],\r\n      aw2 = a[7];\r\n  out[0] = ax1;\r\n  out[1] = ay1;\r\n  out[2] = az1;\r\n  out[3] = aw1;\r\n  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;\r\n  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;\r\n  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;\r\n  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a dual quat around the X axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\r\nexport function rotateX(out, a, rad) {\r\n  var bx = -a[0],\r\n      by = -a[1],\r\n      bz = -a[2],\r\n      bw = a[3],\r\n      ax = a[4],\r\n      ay = a[5],\r\n      az = a[6],\r\n      aw = a[7],\r\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\r\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\r\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\r\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\r\n  quat.rotateX(out, a, rad);\r\n  bx = out[0];\r\n  by = out[1];\r\n  bz = out[2];\r\n  bw = out[3];\r\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\r\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\r\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\r\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a dual quat around the Y axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\r\nexport function rotateY(out, a, rad) {\r\n  var bx = -a[0],\r\n      by = -a[1],\r\n      bz = -a[2],\r\n      bw = a[3],\r\n      ax = a[4],\r\n      ay = a[5],\r\n      az = a[6],\r\n      aw = a[7],\r\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\r\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\r\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\r\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\r\n  quat.rotateY(out, a, rad);\r\n  bx = out[0];\r\n  by = out[1];\r\n  bz = out[2];\r\n  bw = out[3];\r\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\r\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\r\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\r\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a dual quat around the Z axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\r\nexport function rotateZ(out, a, rad) {\r\n  var bx = -a[0],\r\n      by = -a[1],\r\n      bz = -a[2],\r\n      bw = a[3],\r\n      ax = a[4],\r\n      ay = a[5],\r\n      az = a[6],\r\n      aw = a[7],\r\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\r\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\r\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\r\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\r\n  quat.rotateZ(out, a, rad);\r\n  bx = out[0];\r\n  by = out[1];\r\n  bz = out[2];\r\n  bw = out[3];\r\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\r\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\r\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\r\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a dual quat by a given quaternion (a * q)\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {quat} q quaternion to rotate by\r\n * @returns {quat2} out\r\n */\r\nexport function rotateByQuatAppend(out, a, q) {\r\n  var qx = q[0],\r\n      qy = q[1],\r\n      qz = q[2],\r\n      qw = q[3],\r\n      ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n\r\n  out[0] = ax * qw + aw * qx + ay * qz - az * qy;\r\n  out[1] = ay * qw + aw * qy + az * qx - ax * qz;\r\n  out[2] = az * qw + aw * qz + ax * qy - ay * qx;\r\n  out[3] = aw * qw - ax * qx - ay * qy - az * qz;\r\n  ax = a[4];\r\n  ay = a[5];\r\n  az = a[6];\r\n  aw = a[7];\r\n  out[4] = ax * qw + aw * qx + ay * qz - az * qy;\r\n  out[5] = ay * qw + aw * qy + az * qx - ax * qz;\r\n  out[6] = az * qw + aw * qz + ax * qy - ay * qx;\r\n  out[7] = aw * qw - ax * qx - ay * qy - az * qz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a dual quat by a given quaternion (q * a)\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat} q quaternion to rotate by\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @returns {quat2} out\r\n */\r\nexport function rotateByQuatPrepend(out, q, a) {\r\n  var qx = q[0],\r\n      qy = q[1],\r\n      qz = q[2],\r\n      qw = q[3],\r\n      bx = a[0],\r\n      by = a[1],\r\n      bz = a[2],\r\n      bw = a[3];\r\n\r\n  out[0] = qx * bw + qw * bx + qy * bz - qz * by;\r\n  out[1] = qy * bw + qw * by + qz * bx - qx * bz;\r\n  out[2] = qz * bw + qw * bz + qx * by - qy * bx;\r\n  out[3] = qw * bw - qx * bx - qy * by - qz * bz;\r\n  bx = a[4];\r\n  by = a[5];\r\n  bz = a[6];\r\n  bw = a[7];\r\n  out[4] = qx * bw + qw * bx + qy * bz - qz * by;\r\n  out[5] = qy * bw + qw * by + qz * bx - qx * bz;\r\n  out[6] = qz * bw + qw * bz + qx * by - qy * bx;\r\n  out[7] = qw * bw - qx * bx - qy * by - qz * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a dual quat around a given axis. Does the normalisation automatically\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {vec3} axis the axis to rotate around\r\n * @param {Number} rad how far the rotation should be\r\n * @returns {quat2} out\r\n */\r\nexport function rotateAroundAxis(out, a, axis, rad) {\r\n  //Special case for rad = 0\r\n  if (Math.abs(rad) < glMatrix.EPSILON) {\r\n    return copy(out, a);\r\n  }\r\n  var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\r\n\r\n  rad = rad * 0.5;\r\n  var s = Math.sin(rad);\r\n  var bx = s * axis[0] / axisLength;\r\n  var by = s * axis[1] / axisLength;\r\n  var bz = s * axis[2] / axisLength;\r\n  var bw = Math.cos(rad);\r\n\r\n  var ax1 = a[0],\r\n      ay1 = a[1],\r\n      az1 = a[2],\r\n      aw1 = a[3];\r\n  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\r\n  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\r\n  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\r\n  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\r\n\r\n  var ax = a[4],\r\n      ay = a[5],\r\n      az = a[6],\r\n      aw = a[7];\r\n  out[4] = ax * bw + aw * bx + ay * bz - az * by;\r\n  out[5] = ay * bw + aw * by + az * bx - ax * bz;\r\n  out[6] = az * bw + aw * bz + ax * by - ay * bx;\r\n  out[7] = aw * bw - ax * bx - ay * by - az * bz;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two dual quat's\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @returns {quat2} out\r\n * @function\r\n */\r\nexport function add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  out[3] = a[3] + b[3];\r\n  out[4] = a[4] + b[4];\r\n  out[5] = a[5] + b[5];\r\n  out[6] = a[6] + b[6];\r\n  out[7] = a[7] + b[7];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Multiplies two dual quat's\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @returns {quat2} out\r\n */\r\nexport function multiply(out, a, b) {\r\n  var ax0 = a[0],\r\n      ay0 = a[1],\r\n      az0 = a[2],\r\n      aw0 = a[3],\r\n      bx1 = b[4],\r\n      by1 = b[5],\r\n      bz1 = b[6],\r\n      bw1 = b[7],\r\n      ax1 = a[4],\r\n      ay1 = a[5],\r\n      az1 = a[6],\r\n      aw1 = a[7],\r\n      bx0 = b[0],\r\n      by0 = b[1],\r\n      bz0 = b[2],\r\n      bw0 = b[3];\r\n  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;\r\n  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;\r\n  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;\r\n  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;\r\n  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;\r\n  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;\r\n  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;\r\n  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Alias for {@link quat2.multiply}\r\n * @function\r\n */\r\nexport var mul = multiply;\r\n\r\n/**\r\n * Scales a dual quat by a scalar number\r\n *\r\n * @param {quat2} out the receiving dual quat\r\n * @param {quat2} a the dual quat to scale\r\n * @param {Number} b amount to scale the dual quat by\r\n * @returns {quat2} out\r\n * @function\r\n */\r\nexport function scale(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  out[3] = a[3] * b;\r\n  out[4] = a[4] * b;\r\n  out[5] = a[5] * b;\r\n  out[6] = a[6] * b;\r\n  out[7] = a[7] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the dot product of two dual quat's (The dot product of the real parts)\r\n *\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n * @function\r\n */\r\nexport var dot = quat.dot;\r\n\r\n/**\r\n * Performs a linear interpolation between two dual quats's\r\n * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)\r\n *\r\n * @param {quat2} out the receiving dual quat\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat2} out\r\n */\r\nexport function lerp(out, a, b, t) {\r\n  var mt = 1 - t;\r\n  if (dot(a, b) < 0) t = -t;\r\n\r\n  out[0] = a[0] * mt + b[0] * t;\r\n  out[1] = a[1] * mt + b[1] * t;\r\n  out[2] = a[2] * mt + b[2] * t;\r\n  out[3] = a[3] * mt + b[3] * t;\r\n  out[4] = a[4] * mt + b[4] * t;\r\n  out[5] = a[5] * mt + b[5] * t;\r\n  out[6] = a[6] * mt + b[6] * t;\r\n  out[7] = a[7] * mt + b[7] * t;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a dual quat to calculate inverse of\r\n * @returns {quat2} out\r\n */\r\nexport function invert(out, a) {\r\n  var sqlen = squaredLength(a);\r\n  out[0] = -a[0] / sqlen;\r\n  out[1] = -a[1] / sqlen;\r\n  out[2] = -a[2] / sqlen;\r\n  out[3] = a[3] / sqlen;\r\n  out[4] = -a[4] / sqlen;\r\n  out[5] = -a[5] / sqlen;\r\n  out[6] = -a[6] / sqlen;\r\n  out[7] = a[7] / sqlen;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the conjugate of a dual quat\r\n * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {quat2} a quat to calculate conjugate of\r\n * @returns {quat2} out\r\n */\r\nexport function conjugate(out, a) {\r\n  out[0] = -a[0];\r\n  out[1] = -a[1];\r\n  out[2] = -a[2];\r\n  out[3] = a[3];\r\n  out[4] = -a[4];\r\n  out[5] = -a[5];\r\n  out[6] = -a[6];\r\n  out[7] = a[7];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the length of a dual quat\r\n *\r\n * @param {quat2} a dual quat to calculate length of\r\n * @returns {Number} length of a\r\n * @function\r\n */\r\nexport var length = quat.length;\r\n\r\n/**\r\n * Alias for {@link quat2.length}\r\n * @function\r\n */\r\nexport var len = length;\r\n\r\n/**\r\n * Calculates the squared length of a dual quat\r\n *\r\n * @param {quat2} a dual quat to calculate squared length of\r\n * @returns {Number} squared length of a\r\n * @function\r\n */\r\nexport var squaredLength = quat.squaredLength;\r\n\r\n/**\r\n * Alias for {@link quat2.squaredLength}\r\n * @function\r\n */\r\nexport var sqrLen = squaredLength;\r\n\r\n/**\r\n * Normalize a dual quat\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a dual quaternion to normalize\r\n * @returns {quat2} out\r\n * @function\r\n */\r\nexport function normalize(out, a) {\r\n  var magnitude = squaredLength(a);\r\n  if (magnitude > 0) {\r\n    magnitude = Math.sqrt(magnitude);\r\n\r\n    var a0 = a[0] / magnitude;\r\n    var a1 = a[1] / magnitude;\r\n    var a2 = a[2] / magnitude;\r\n    var a3 = a[3] / magnitude;\r\n\r\n    var b0 = a[4];\r\n    var b1 = a[5];\r\n    var b2 = a[6];\r\n    var b3 = a[7];\r\n\r\n    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;\r\n\r\n    out[0] = a0;\r\n    out[1] = a1;\r\n    out[2] = a2;\r\n    out[3] = a3;\r\n\r\n    out[4] = (b0 - a0 * a_dot_b) / magnitude;\r\n    out[5] = (b1 - a1 * a_dot_b) / magnitude;\r\n    out[6] = (b2 - a2 * a_dot_b) / magnitude;\r\n    out[7] = (b3 - a3 * a_dot_b) / magnitude;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a string representation of a dual quatenion\r\n *\r\n * @param {quat2} a dual quaternion to represent as a string\r\n * @returns {String} string representation of the dual quat\r\n */\r\nexport function str(a) {\r\n  return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';\r\n}\r\n\r\n/**\r\n * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {quat2} a the first dual quaternion.\r\n * @param {quat2} b the second dual quaternion.\r\n * @returns {Boolean} true if the dual quaternions are equal, false otherwise.\r\n */\r\nexport function exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];\r\n}\r\n\r\n/**\r\n * Returns whether or not the dual quaternions have approximately the same elements in the same position.\r\n *\r\n * @param {quat2} a the first dual quat.\r\n * @param {quat2} b the second dual quat.\r\n * @returns {Boolean} true if the dual quats are equal, false otherwise.\r\n */\r\nexport function equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3],\r\n      a4 = a[4],\r\n      a5 = a[5],\r\n      a6 = a[6],\r\n      a7 = a[7];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3],\r\n      b4 = b[4],\r\n      b5 = b[5],\r\n      b6 = b[6],\r\n      b7 = b[7];\r\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));\r\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/gl-matrix/lib/gl-matrix/quat2.js\n// module id = 19\n// module chunks = 0","import * as glMatrix from \"./common.js\";\r\n\r\n/**\r\n * 2 Dimensional Vector\r\n * @module vec2\r\n */\r\n\r\n/**\r\n * Creates a new, empty vec2\r\n *\r\n * @returns {vec2} a new 2D vector\r\n */\r\nexport function create() {\r\n  var out = new glMatrix.ARRAY_TYPE(2);\r\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\r\n    out[0] = 0;\r\n    out[1] = 0;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new vec2 initialized with values from an existing vector\r\n *\r\n * @param {vec2} a vector to clone\r\n * @returns {vec2} a new 2D vector\r\n */\r\nexport function clone(a) {\r\n  var out = new glMatrix.ARRAY_TYPE(2);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new vec2 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} a new 2D vector\r\n */\r\nexport function fromValues(x, y) {\r\n  var out = new glMatrix.ARRAY_TYPE(2);\r\n  out[0] = x;\r\n  out[1] = y;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one vec2 to another\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the source vector\r\n * @returns {vec2} out\r\n */\r\nexport function copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a vec2 to the given values\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} out\r\n */\r\nexport function set(out, x, y) {\r\n  out[0] = x;\r\n  out[1] = y;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nexport function add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nexport function subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Multiplies two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nexport function multiply(out, a, b) {\r\n  out[0] = a[0] * b[0];\r\n  out[1] = a[1] * b[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Divides two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nexport function divide(out, a, b) {\r\n  out[0] = a[0] / b[0];\r\n  out[1] = a[1] / b[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.ceil the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to ceil\r\n * @returns {vec2} out\r\n */\r\nexport function ceil(out, a) {\r\n  out[0] = Math.ceil(a[0]);\r\n  out[1] = Math.ceil(a[1]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.floor the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to floor\r\n * @returns {vec2} out\r\n */\r\nexport function floor(out, a) {\r\n  out[0] = Math.floor(a[0]);\r\n  out[1] = Math.floor(a[1]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the minimum of two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nexport function min(out, a, b) {\r\n  out[0] = Math.min(a[0], b[0]);\r\n  out[1] = Math.min(a[1], b[1]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the maximum of two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nexport function max(out, a, b) {\r\n  out[0] = Math.max(a[0], b[0]);\r\n  out[1] = Math.max(a[1], b[1]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.round the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to round\r\n * @returns {vec2} out\r\n */\r\nexport function round(out, a) {\r\n  out[0] = Math.round(a[0]);\r\n  out[1] = Math.round(a[1]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Scales a vec2 by a scalar number\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec2} out\r\n */\r\nexport function scale(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two vec2's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec2} out\r\n */\r\nexport function scaleAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the euclidian distance between two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\r\nexport function distance(a, b) {\r\n  var x = b[0] - a[0],\r\n      y = b[1] - a[1];\r\n  return Math.sqrt(x * x + y * y);\r\n}\r\n\r\n/**\r\n * Calculates the squared euclidian distance between two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\r\nexport function squaredDistance(a, b) {\r\n  var x = b[0] - a[0],\r\n      y = b[1] - a[1];\r\n  return x * x + y * y;\r\n}\r\n\r\n/**\r\n * Calculates the length of a vec2\r\n *\r\n * @param {vec2} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\r\nexport function length(a) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  return Math.sqrt(x * x + y * y);\r\n}\r\n\r\n/**\r\n * Calculates the squared length of a vec2\r\n *\r\n * @param {vec2} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\r\nexport function squaredLength(a) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  return x * x + y * y;\r\n}\r\n\r\n/**\r\n * Negates the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to negate\r\n * @returns {vec2} out\r\n */\r\nexport function negate(out, a) {\r\n  out[0] = -a[0];\r\n  out[1] = -a[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the inverse of the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to invert\r\n * @returns {vec2} out\r\n */\r\nexport function inverse(out, a) {\r\n  out[0] = 1.0 / a[0];\r\n  out[1] = 1.0 / a[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Normalize a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to normalize\r\n * @returns {vec2} out\r\n */\r\nexport function normalize(out, a) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  var len = x * x + y * y;\r\n  if (len > 0) {\r\n    //TODO: evaluate use of glm_invsqrt here?\r\n    len = 1 / Math.sqrt(len);\r\n    out[0] = a[0] * len;\r\n    out[1] = a[1] * len;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the dot product of two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\r\nexport function dot(a, b) {\r\n  return a[0] * b[0] + a[1] * b[1];\r\n}\r\n\r\n/**\r\n * Computes the cross product of two vec2's\r\n * Note that the cross product must by definition produce a 3D vector\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec3} out\r\n */\r\nexport function cross(out, a, b) {\r\n  var z = a[0] * b[1] - a[1] * b[0];\r\n  out[0] = out[1] = 0;\r\n  out[2] = z;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Performs a linear interpolation between two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec2} out\r\n */\r\nexport function lerp(out, a, b, t) {\r\n  var ax = a[0],\r\n      ay = a[1];\r\n  out[0] = ax + t * (b[0] - ax);\r\n  out[1] = ay + t * (b[1] - ay);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec2} out\r\n */\r\nexport function random(out, scale) {\r\n  scale = scale || 1.0;\r\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\r\n  out[0] = Math.cos(r) * scale;\r\n  out[1] = Math.sin(r) * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec2 with a mat2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat2} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\nexport function transformMat2(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  out[0] = m[0] * x + m[2] * y;\r\n  out[1] = m[1] * x + m[3] * y;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec2 with a mat2d\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat2d} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\nexport function transformMat2d(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  out[0] = m[0] * x + m[2] * y + m[4];\r\n  out[1] = m[1] * x + m[3] * y + m[5];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec2 with a mat3\r\n * 3rd vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat3} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\nexport function transformMat3(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  out[0] = m[0] * x + m[3] * y + m[6];\r\n  out[1] = m[1] * x + m[4] * y + m[7];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec2 with a mat4\r\n * 3rd vector component is implicitly '0'\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\nexport function transformMat4(out, a, m) {\r\n  var x = a[0];\r\n  var y = a[1];\r\n  out[0] = m[0] * x + m[4] * y + m[12];\r\n  out[1] = m[1] * x + m[5] * y + m[13];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotate a 2D vector\r\n * @param {vec2} out The receiving vec2\r\n * @param {vec2} a The vec2 point to rotate\r\n * @param {vec2} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec2} out\r\n */\r\nexport function rotate(out, a, b, c) {\r\n  //Translate point to the origin\r\n  var p0 = a[0] - b[0],\r\n      p1 = a[1] - b[1],\r\n      sinC = Math.sin(c),\r\n      cosC = Math.cos(c);\r\n\r\n  //perform rotation and translate to correct position\r\n  out[0] = p0 * cosC - p1 * sinC + b[0];\r\n  out[1] = p0 * sinC + p1 * cosC + b[1];\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Get the angle between two 2D vectors\r\n * @param {vec2} a The first operand\r\n * @param {vec2} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\r\nexport function angle(a, b) {\r\n  var x1 = a[0],\r\n      y1 = a[1],\r\n      x2 = b[0],\r\n      y2 = b[1];\r\n\r\n  var len1 = x1 * x1 + y1 * y1;\r\n  if (len1 > 0) {\r\n    //TODO: evaluate use of glm_invsqrt here?\r\n    len1 = 1 / Math.sqrt(len1);\r\n  }\r\n\r\n  var len2 = x2 * x2 + y2 * y2;\r\n  if (len2 > 0) {\r\n    //TODO: evaluate use of glm_invsqrt here?\r\n    len2 = 1 / Math.sqrt(len2);\r\n  }\r\n\r\n  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;\r\n\r\n  if (cosine > 1.0) {\r\n    return 0;\r\n  } else if (cosine < -1.0) {\r\n    return Math.PI;\r\n  } else {\r\n    return Math.acos(cosine);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {vec2} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\r\nexport function str(a) {\r\n  return 'vec2(' + a[0] + ', ' + a[1] + ')';\r\n}\r\n\r\n/**\r\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec2} a The first vector.\r\n * @param {vec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nexport function exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1];\r\n}\r\n\r\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {vec2} a The first vector.\r\n * @param {vec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nexport function equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1];\r\n  var b0 = b[0],\r\n      b1 = b[1];\r\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\r\n}\r\n\r\n/**\r\n * Alias for {@link vec2.length}\r\n * @function\r\n */\r\nexport var len = length;\r\n\r\n/**\r\n * Alias for {@link vec2.subtract}\r\n * @function\r\n */\r\nexport var sub = subtract;\r\n\r\n/**\r\n * Alias for {@link vec2.multiply}\r\n * @function\r\n */\r\nexport var mul = multiply;\r\n\r\n/**\r\n * Alias for {@link vec2.divide}\r\n * @function\r\n */\r\nexport var div = divide;\r\n\r\n/**\r\n * Alias for {@link vec2.distance}\r\n * @function\r\n */\r\nexport var dist = distance;\r\n\r\n/**\r\n * Alias for {@link vec2.squaredDistance}\r\n * @function\r\n */\r\nexport var sqrDist = squaredDistance;\r\n\r\n/**\r\n * Alias for {@link vec2.squaredLength}\r\n * @function\r\n */\r\nexport var sqrLen = squaredLength;\r\n\r\n/**\r\n * Perform some operation over an array of vec2s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\r\nexport var forEach = function () {\r\n  var vec = create();\r\n\r\n  return function (a, stride, offset, count, fn, arg) {\r\n    var i = void 0,\r\n        l = void 0;\r\n    if (!stride) {\r\n      stride = 2;\r\n    }\r\n\r\n    if (!offset) {\r\n      offset = 0;\r\n    }\r\n\r\n    if (count) {\r\n      l = Math.min(count * stride + offset, a.length);\r\n    } else {\r\n      l = a.length;\r\n    }\r\n\r\n    for (i = offset; i < l; i += stride) {\r\n      vec[0] = a[i];vec[1] = a[i + 1];\r\n      fn(vec, vec, arg);\r\n      a[i] = vec[0];a[i + 1] = vec[1];\r\n    }\r\n\r\n    return a;\r\n  };\r\n}();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/gl-matrix/lib/gl-matrix/vec2.js\n// module id = 20\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n *\n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n *\n * All rights reserved.\n *\n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/*\n * Function added in the JavaScript version (was not present in the c++ version)\n */\n\n/**\n * assert and throw an exception.\n *\n * @private\n * @param {boolean} condition   the condition which is asserted\n * @param {string} message      the message which is display is condition is falsy\n */\nfunction assert(condition, message) {\n    if (!condition) {\n        throw new Error(message || \"Assert Failed\");\n    }\n}\nmodule.exports = assert;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/assert.js\n// module id = 21\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar xy = require('./xy');\n\n// ------------------------------------------------------------------------Point\n/**\n * Construct a point\n * @example\n *      var point = new poly2tri.Point(150, 150);\n * @public\n * @constructor\n * @struct\n * @param {number=} x    coordinate (0 if undefined)\n * @param {number=} y    coordinate (0 if undefined)\n */\nvar Point = function(x, y) {\n    /**\n     * @type {number}\n     * @expose\n     */\n    this.x = +x || 0;\n    /**\n     * @type {number}\n     * @expose\n     */\n    this.y = +y || 0;\n\n    // All extra fields added to Point are prefixed with _p2t_\n    // to avoid collisions if custom Point class is used.\n\n    /**\n     * The edges this point constitutes an upper ending point\n     * @private\n     * @type {Array.<Edge>}\n     */\n    this._p2t_edge_list = null;\n};\n\n/**\n * For pretty printing\n * @example\n *      \"p=\" + new poly2tri.Point(5,42)\n *      //  \"p=(5;42)\"\n * @returns {string} <code>\"(x;y)\"</code>\n */\nPoint.prototype.toString = function() {\n    return xy.toStringBase(this);\n};\n\n/**\n * JSON output, only coordinates\n * @example\n *      JSON.stringify(new poly2tri.Point(1,2))\n *      //  '{\"x\":1,\"y\":2}'\n */\nPoint.prototype.toJSON = function() {\n    return { x: this.x, y: this.y };\n};\n\n/**\n * Creates a copy of this Point object.\n * @return {Point} new cloned point\n */\nPoint.prototype.clone = function() {\n    return new Point(this.x, this.y);\n};\n\n/**\n * Set this Point instance to the origo. <code>(0; 0)</code>\n * @return {Point} this (for chaining)\n */\nPoint.prototype.set_zero = function() {\n    this.x = 0.0;\n    this.y = 0.0;\n    return this; // for chaining\n};\n\n/**\n * Set the coordinates of this instance.\n * @param {number} x   coordinate\n * @param {number} y   coordinate\n * @return {Point} this (for chaining)\n */\nPoint.prototype.set = function(x, y) {\n    this.x = +x || 0;\n    this.y = +y || 0;\n    return this; // for chaining\n};\n\n/**\n * Negate this Point instance. (component-wise)\n * @return {Point} this (for chaining)\n */\nPoint.prototype.negate = function() {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this; // for chaining\n};\n\n/**\n * Add another Point object to this instance. (component-wise)\n * @param {!Point} n - Point object.\n * @return {Point} this (for chaining)\n */\nPoint.prototype.add = function(n) {\n    this.x += n.x;\n    this.y += n.y;\n    return this; // for chaining\n};\n\n/**\n * Subtract this Point instance with another point given. (component-wise)\n * @param {!Point} n - Point object.\n * @return {Point} this (for chaining)\n */\nPoint.prototype.sub = function(n) {\n    this.x -= n.x;\n    this.y -= n.y;\n    return this; // for chaining\n};\n\n/**\n * Multiply this Point instance by a scalar. (component-wise)\n * @param {number} s   scalar.\n * @return {Point} this (for chaining)\n */\nPoint.prototype.mul = function(s) {\n    this.x *= s;\n    this.y *= s;\n    return this; // for chaining\n};\n\n/**\n * Return the distance of this Point instance from the origo.\n * @return {number} distance\n */\nPoint.prototype.length = function() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n};\n\n/**\n * Normalize this Point instance (as a vector).\n * @return {number} The original distance of this instance from the origo.\n */\nPoint.prototype.normalize = function() {\n    var len = this.length();\n    this.x /= len;\n    this.y /= len;\n    return len;\n};\n\n/**\n * Test this Point object with another for equality.\n * @param {!XY} p - any \"Point like\" object with {x,y}\n * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.\n */\nPoint.prototype.equals = function(p) {\n    return this.x === p.x && this.y === p.y;\n};\n\n\n// -----------------------------------------------------Point (\"static\" methods)\n\n/**\n * Negate a point component-wise and return the result as a new Point object.\n * @param {!XY} p - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.negate = function(p) {\n    return new Point(-p.x, -p.y);\n};\n\n/**\n * Add two points component-wise and return the result as a new Point object.\n * @param {!XY} a - any \"Point like\" object with {x,y}\n * @param {!XY} b - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.add = function(a, b) {\n    return new Point(a.x + b.x, a.y + b.y);\n};\n\n/**\n * Subtract two points component-wise and return the result as a new Point object.\n * @param {!XY} a - any \"Point like\" object with {x,y}\n * @param {!XY} b - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.sub = function(a, b) {\n    return new Point(a.x - b.x, a.y - b.y);\n};\n\n/**\n * Multiply a point by a scalar and return the result as a new Point object.\n * @param {number} s - the scalar\n * @param {!XY} p - any \"Point like\" object with {x,y}\n * @return {Point} the resulting Point object.\n */\nPoint.mul = function(s, p) {\n    return new Point(s * p.x, s * p.y);\n};\n\n/**\n * Perform the cross product on either two points (this produces a scalar)\n * or a point and a scalar (this produces a point).\n * This function requires two parameters, either may be a Point object or a\n * number.\n * @param  {XY|number} a - Point object or scalar.\n * @param  {XY|number} b - Point object or scalar.\n * @return {Point|number} a Point object or a number, depending on the parameters.\n */\nPoint.cross = function(a, b) {\n    if (typeof(a) === 'number') {\n        if (typeof(b) === 'number') {\n            return a * b;\n        } else {\n            return new Point(-a * b.y, a * b.x);\n        }\n    } else {\n        if (typeof(b) === 'number') {\n            return new Point(b * a.y, -b * a.x);\n        } else {\n            return a.x * b.y - a.y * b.x;\n        }\n    }\n};\n\n\n// -----------------------------------------------------------------\"Point-Like\"\n/*\n * The following functions operate on \"Point\" or any \"Point like\" object \n * with {x,y} (duck typing).\n */\n\nPoint.toString = xy.toString;\nPoint.compare = xy.compare;\nPoint.cmp = xy.compare; // backward compatibility\nPoint.equals = xy.equals;\n\n/**\n * Peform the dot product on two vectors.\n * @public\n * @param {!XY} a - any \"Point like\" object with {x,y}\n * @param {!XY} b - any \"Point like\" object with {x,y}\n * @return {number} The dot product\n */\nPoint.dot = function(a, b) {\n    return a.x * b.x + a.y * b.y;\n};\n\n\n// ---------------------------------------------------------Exports (public API)\n\nmodule.exports = Point;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/point.js\n// module id = 22\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint latedef:nofunc, maxcomplexity:9 */\n\n\"use strict\";\n\n/**\n * This 'Sweep' module is present in order to keep this JavaScript version\n * as close as possible to the reference C++ version, even though almost all\n * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.\n * @module\n * @private\n */\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar assert = require('./assert');\nvar PointError = require('./pointerror');\nvar Triangle = require('./triangle');\nvar Node = require('./advancingfront').Node;\n\n\n// ------------------------------------------------------------------------utils\n\nvar utils = require('./utils');\n\n/** @const */\nvar EPSILON = utils.EPSILON;\n\n/** @const */\nvar Orientation = utils.Orientation;\n/** @const */\nvar orient2d = utils.orient2d;\n/** @const */\nvar inScanArea = utils.inScanArea;\n/** @const */\nvar isAngleObtuse = utils.isAngleObtuse;\n\n\n// ------------------------------------------------------------------------Sweep\n\n/**\n * Triangulate the polygon with holes and Steiner points.\n * Do this AFTER you've added the polyline, holes, and Steiner points\n * @private\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction triangulate(tcx) {\n    tcx.initTriangulation();\n    tcx.createAdvancingFront();\n    // Sweep points; build mesh\n    sweepPoints(tcx);\n    // Clean up\n    finalizationPolygon(tcx);\n}\n\n/**\n * Start sweeping the Y-sorted point set from bottom to top\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction sweepPoints(tcx) {\n    var i, len = tcx.pointCount();\n    for (i = 1; i < len; ++i) {\n        var point = tcx.getPoint(i);\n        var node = pointEvent(tcx, point);\n        var edges = point._p2t_edge_list;\n        for (var j = 0; edges && j < edges.length; ++j) {\n            edgeEventByEdge(tcx, edges[j], node);\n        }\n    }\n}\n\n/**\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction finalizationPolygon(tcx) {\n    // Get an Internal triangle to start with\n    var t = tcx.front().head().next.triangle;\n    var p = tcx.front().head().next.point;\n    while (!t.getConstrainedEdgeCW(p)) {\n        t = t.neighborCCW(p);\n    }\n\n    // Collect interior triangles constrained by edges\n    tcx.meshClean(t);\n}\n\n/**\n * Find closes node to the left of the new point and\n * create a new triangle. If needed new holes and basins\n * will be filled to.\n * @param {!SweepContext} tcx - SweepContext object\n * @param {!XY} point   Point\n */\nfunction pointEvent(tcx, point) {\n    var node = tcx.locateNode(point);\n    var new_node = newFrontTriangle(tcx, point, node);\n\n    // Only need to check +epsilon since point never have smaller\n    // x value than node due to how we fetch nodes from the front\n    if (point.x <= node.point.x + (EPSILON)) {\n        fill(tcx, node);\n    }\n\n    //tcx.AddNode(new_node);\n\n    fillAdvancingFront(tcx, new_node);\n    return new_node;\n}\n\nfunction edgeEventByEdge(tcx, edge, node) {\n    tcx.edge_event.constrained_edge = edge;\n    tcx.edge_event.right = (edge.p.x > edge.q.x);\n\n    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {\n        return;\n    }\n\n    // For now we will do all needed filling\n    // TODO: integrate with flip process might give some better performance\n    //       but for now this avoid the issue with cases that needs both flips and fills\n    fillEdgeEvent(tcx, edge, node);\n    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);\n}\n\nfunction edgeEventByPoints(tcx, ep, eq, triangle, point) {\n    if (isEdgeSideOfTriangle(triangle, ep, eq)) {\n        return;\n    }\n\n    var p1 = triangle.pointCCW(point);\n    var o1 = orient2d(eq, p1, ep);\n    if (o1 === Orientation.COLLINEAR) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision 09880a869095 dated March 8, 2011)\n        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);\n    }\n\n    var p2 = triangle.pointCW(point);\n    var o2 = orient2d(eq, p2, ep);\n    if (o2 === Orientation.COLLINEAR) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision 09880a869095 dated March 8, 2011)\n        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);\n    }\n\n    if (o1 === o2) {\n        // Need to decide if we are rotating CW or CCW to get to a triangle\n        // that will cross edge\n        if (o1 === Orientation.CW) {\n            triangle = triangle.neighborCCW(point);\n        } else {\n            triangle = triangle.neighborCW(point);\n        }\n        edgeEventByPoints(tcx, ep, eq, triangle, point);\n    } else {\n        // This triangle crosses constraint so lets flippin start!\n        flipEdgeEvent(tcx, ep, eq, triangle, point);\n    }\n}\n\nfunction isEdgeSideOfTriangle(triangle, ep, eq) {\n    var index = triangle.edgeIndex(ep, eq);\n    if (index !== -1) {\n        triangle.markConstrainedEdgeByIndex(index);\n        var t = triangle.getNeighbor(index);\n        if (t) {\n            t.markConstrainedEdgeByPoints(ep, eq);\n        }\n        return true;\n    }\n    return false;\n}\n\n/**\n * Creates a new front triangle and legalize it\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction newFrontTriangle(tcx, point, node) {\n    var triangle = new Triangle(point, node.point, node.next.point);\n\n    triangle.markNeighbor(node.triangle);\n    tcx.addToMap(triangle);\n\n    var new_node = new Node(point);\n    new_node.next = node.next;\n    new_node.prev = node;\n    node.next.prev = new_node;\n    node.next = new_node;\n\n    if (!legalize(tcx, triangle)) {\n        tcx.mapTriangleToNodes(triangle);\n    }\n\n    return new_node;\n}\n\n/**\n * Adds a triangle to the advancing front to fill a hole.\n * @param {!SweepContext} tcx - SweepContext object\n * @param node - middle node, that is the bottom of the hole\n */\nfunction fill(tcx, node) {\n    var triangle = new Triangle(node.prev.point, node.point, node.next.point);\n\n    // TODO: should copy the constrained_edge value from neighbor triangles\n    //       for now constrained_edge values are copied during the legalize\n    triangle.markNeighbor(node.prev.triangle);\n    triangle.markNeighbor(node.triangle);\n\n    tcx.addToMap(triangle);\n\n    // Update the advancing front\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n\n\n    // If it was legalized the triangle has already been mapped\n    if (!legalize(tcx, triangle)) {\n        tcx.mapTriangleToNodes(triangle);\n    }\n\n    //tcx.removeNode(node);\n}\n\n/**\n * Fills holes in the Advancing Front\n * @param {!SweepContext} tcx - SweepContext object\n */\nfunction fillAdvancingFront(tcx, n) {\n    // Fill right holes\n    var node = n.next;\n    while (node.next) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision acf81f1f1764 dated April 7, 2012)\n        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {\n            break;\n        }\n        fill(tcx, node);\n        node = node.next;\n    }\n\n    // Fill left holes\n    node = n.prev;\n    while (node.prev) {\n        // TODO integrate here changes from C++ version\n        // (C++ repo revision acf81f1f1764 dated April 7, 2012)\n        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {\n            break;\n        }\n        fill(tcx, node);\n        node = node.prev;\n    }\n\n    // Fill right basins\n    if (n.next && n.next.next) {\n        if (isBasinAngleRight(n)) {\n            fillBasin(tcx, n);\n        }\n    }\n}\n\n/**\n * The basin angle is decided against the horizontal line [1,0].\n * @param {Node} node\n * @return {boolean} true if angle < 3*/4\n */\nfunction isBasinAngleRight(node) {\n    var ax = node.point.x - node.next.next.point.x;\n    var ay = node.point.y - node.next.next.point.y;\n    assert(ay >= 0, \"unordered y\");\n    return (ax >= 0 || Math.abs(ax) < ay);\n}\n\n/**\n * Returns true if triangle was legalized\n * @param {!SweepContext} tcx - SweepContext object\n * @return {boolean}\n */\nfunction legalize(tcx, t) {\n    // To legalize a triangle we start by finding if any of the three edges\n    // violate the Delaunay condition\n    for (var i = 0; i < 3; ++i) {\n        if (t.delaunay_edge[i]) {\n            continue;\n        }\n        var ot = t.getNeighbor(i);\n        if (ot) {\n            var p = t.getPoint(i);\n            var op = ot.oppositePoint(t, p);\n            var oi = ot.index(op);\n\n            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)\n            // then we should not try to legalize\n            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {\n                t.constrained_edge[i] = ot.constrained_edge[oi];\n                continue;\n            }\n\n            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);\n            if (inside) {\n                // Lets mark this shared edge as Delaunay\n                t.delaunay_edge[i] = true;\n                ot.delaunay_edge[oi] = true;\n\n                // Lets rotate shared edge one vertex CW to legalize it\n                rotateTrianglePair(t, p, ot, op);\n\n                // We now got one valid Delaunay Edge shared by two triangles\n                // This gives us 4 new edges to check for Delaunay\n\n                // Make sure that triangle to node mapping is done only one time for a specific triangle\n                var not_legalized = !legalize(tcx, t);\n                if (not_legalized) {\n                    tcx.mapTriangleToNodes(t);\n                }\n\n                not_legalized = !legalize(tcx, ot);\n                if (not_legalized) {\n                    tcx.mapTriangleToNodes(ot);\n                }\n                // Reset the Delaunay edges, since they only are valid Delaunay edges\n                // until we add a new triangle or point.\n                // XXX: need to think about this. Can these edges be tried after we\n                //      return to previous recursive level?\n                t.delaunay_edge[i] = false;\n                ot.delaunay_edge[oi] = false;\n\n                // If triangle have been legalized no need to check the other edges since\n                // the recursive legalization will handles those so we can end here.\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * <b>Requirement</b>:<br>\n * 1. a,b and c form a triangle.<br>\n * 2. a and d is know to be on opposite side of bc<br>\n * <pre>\n *                a\n *                +\n *               / \\\n *              /   \\\n *            b/     \\c\n *            +-------+\n *           /    d    \\\n *          /           \\\n * </pre>\n * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by\n *  a,b and c<br>\n *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>\n *  This preknowledge gives us a way to optimize the incircle test\n * @param pa - triangle point, opposite d\n * @param pb - triangle point\n * @param pc - triangle point\n * @param pd - point opposite a\n * @return {boolean} true if d is inside circle, false if on circle edge\n */\nfunction inCircle(pa, pb, pc, pd) {\n    var adx = pa.x - pd.x;\n    var ady = pa.y - pd.y;\n    var bdx = pb.x - pd.x;\n    var bdy = pb.y - pd.y;\n\n    var adxbdy = adx * bdy;\n    var bdxady = bdx * ady;\n    var oabd = adxbdy - bdxady;\n    if (oabd <= 0) {\n        return false;\n    }\n\n    var cdx = pc.x - pd.x;\n    var cdy = pc.y - pd.y;\n\n    var cdxady = cdx * ady;\n    var adxcdy = adx * cdy;\n    var ocad = cdxady - adxcdy;\n    if (ocad <= 0) {\n        return false;\n    }\n\n    var bdxcdy = bdx * cdy;\n    var cdxbdy = cdx * bdy;\n\n    var alift = adx * adx + ady * ady;\n    var blift = bdx * bdx + bdy * bdy;\n    var clift = cdx * cdx + cdy * cdy;\n\n    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;\n    return det > 0;\n}\n\n/**\n * Rotates a triangle pair one vertex CW\n *<pre>\n *       n2                    n2\n *  P +-----+             P +-----+\n *    | t  /|               |\\  t |\n *    |   / |               | \\   |\n *  n1|  /  |n3           n1|  \\  |n3\n *    | /   |    after CW   |   \\ |\n *    |/ oT |               | oT \\|\n *    +-----+ oP            +-----+\n *       n4                    n4\n * </pre>\n */\nfunction rotateTrianglePair(t, p, ot, op) {\n    var n1, n2, n3, n4;\n    n1 = t.neighborCCW(p);\n    n2 = t.neighborCW(p);\n    n3 = ot.neighborCCW(op);\n    n4 = ot.neighborCW(op);\n\n    var ce1, ce2, ce3, ce4;\n    ce1 = t.getConstrainedEdgeCCW(p);\n    ce2 = t.getConstrainedEdgeCW(p);\n    ce3 = ot.getConstrainedEdgeCCW(op);\n    ce4 = ot.getConstrainedEdgeCW(op);\n\n    var de1, de2, de3, de4;\n    de1 = t.getDelaunayEdgeCCW(p);\n    de2 = t.getDelaunayEdgeCW(p);\n    de3 = ot.getDelaunayEdgeCCW(op);\n    de4 = ot.getDelaunayEdgeCW(op);\n\n    t.legalize(p, op);\n    ot.legalize(op, p);\n\n    // Remap delaunay_edge\n    ot.setDelaunayEdgeCCW(p, de1);\n    t.setDelaunayEdgeCW(p, de2);\n    t.setDelaunayEdgeCCW(op, de3);\n    ot.setDelaunayEdgeCW(op, de4);\n\n    // Remap constrained_edge\n    ot.setConstrainedEdgeCCW(p, ce1);\n    t.setConstrainedEdgeCW(p, ce2);\n    t.setConstrainedEdgeCCW(op, ce3);\n    ot.setConstrainedEdgeCW(op, ce4);\n\n    // Remap neighbors\n    // XXX: might optimize the markNeighbor by keeping track of\n    //      what side should be assigned to what neighbor after the\n    //      rotation. Now mark neighbor does lots of testing to find\n    //      the right side.\n    t.clearNeighbors();\n    ot.clearNeighbors();\n    if (n1) {\n        ot.markNeighbor(n1);\n    }\n    if (n2) {\n        t.markNeighbor(n2);\n    }\n    if (n3) {\n        t.markNeighbor(n3);\n    }\n    if (n4) {\n        ot.markNeighbor(n4);\n    }\n    t.markNeighbor(ot);\n}\n\n/**\n * Fills a basin that has formed on the Advancing Front to the right\n * of given node.<br>\n * First we decide a left,bottom and right node that forms the\n * boundaries of the basin. Then we do a reqursive fill.\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param node - starting node, this or next node will be left node\n */\nfunction fillBasin(tcx, node) {\n    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n        tcx.basin.left_node = node.next.next;\n    } else {\n        tcx.basin.left_node = node.next;\n    }\n\n    // Find the bottom and right node\n    tcx.basin.bottom_node = tcx.basin.left_node;\n    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {\n        tcx.basin.bottom_node = tcx.basin.bottom_node.next;\n    }\n    if (tcx.basin.bottom_node === tcx.basin.left_node) {\n        // No valid basin\n        return;\n    }\n\n    tcx.basin.right_node = tcx.basin.bottom_node;\n    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {\n        tcx.basin.right_node = tcx.basin.right_node.next;\n    }\n    if (tcx.basin.right_node === tcx.basin.bottom_node) {\n        // No valid basins\n        return;\n    }\n\n    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;\n    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;\n\n    fillBasinReq(tcx, tcx.basin.bottom_node);\n}\n\n/**\n * Recursive algorithm to fill a Basin with triangles\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param node - bottom_node\n */\nfunction fillBasinReq(tcx, node) {\n    // if shallow stop filling\n    if (isShallow(tcx, node)) {\n        return;\n    }\n\n    fill(tcx, node);\n\n    var o;\n    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {\n        return;\n    } else if (node.prev === tcx.basin.left_node) {\n        o = orient2d(node.point, node.next.point, node.next.next.point);\n        if (o === Orientation.CW) {\n            return;\n        }\n        node = node.next;\n    } else if (node.next === tcx.basin.right_node) {\n        o = orient2d(node.point, node.prev.point, node.prev.prev.point);\n        if (o === Orientation.CCW) {\n            return;\n        }\n        node = node.prev;\n    } else {\n        // Continue with the neighbor node with lowest Y value\n        if (node.prev.point.y < node.next.point.y) {\n            node = node.prev;\n        } else {\n            node = node.next;\n        }\n    }\n\n    fillBasinReq(tcx, node);\n}\n\nfunction isShallow(tcx, node) {\n    var height;\n    if (tcx.basin.left_highest) {\n        height = tcx.basin.left_node.point.y - node.point.y;\n    } else {\n        height = tcx.basin.right_node.point.y - node.point.y;\n    }\n\n    // if shallow stop filling\n    if (tcx.basin.width > height) {\n        return true;\n    }\n    return false;\n}\n\nfunction fillEdgeEvent(tcx, edge, node) {\n    if (tcx.edge_event.right) {\n        fillRightAboveEdgeEvent(tcx, edge, node);\n    } else {\n        fillLeftAboveEdgeEvent(tcx, edge, node);\n    }\n}\n\nfunction fillRightAboveEdgeEvent(tcx, edge, node) {\n    while (node.next.point.x < edge.p.x) {\n        // Check if next node is below the edge\n        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {\n            fillRightBelowEdgeEvent(tcx, edge, node);\n        } else {\n            node = node.next;\n        }\n    }\n}\n\nfunction fillRightBelowEdgeEvent(tcx, edge, node) {\n    if (node.point.x < edge.p.x) {\n        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n            // Concave\n            fillRightConcaveEdgeEvent(tcx, edge, node);\n        } else {\n            // Convex\n            fillRightConvexEdgeEvent(tcx, edge, node);\n            // Retry this one\n            fillRightBelowEdgeEvent(tcx, edge, node);\n        }\n    }\n}\n\nfunction fillRightConcaveEdgeEvent(tcx, edge, node) {\n    fill(tcx, node.next);\n    if (node.next.point !== edge.p) {\n        // Next above or below edge?\n        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {\n            // Below\n            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {\n                // Next is concave\n                fillRightConcaveEdgeEvent(tcx, edge, node);\n            } else {\n                // Next is convex\n                /* jshint noempty:false */\n            }\n        }\n    }\n}\n\nfunction fillRightConvexEdgeEvent(tcx, edge, node) {\n    // Next concave or convex?\n    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {\n        // Concave\n        fillRightConcaveEdgeEvent(tcx, edge, node.next);\n    } else {\n        // Convex\n        // Next above or below edge?\n        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {\n            // Below\n            fillRightConvexEdgeEvent(tcx, edge, node.next);\n        } else {\n            // Above\n            /* jshint noempty:false */\n        }\n    }\n}\n\nfunction fillLeftAboveEdgeEvent(tcx, edge, node) {\n    while (node.prev.point.x > edge.p.x) {\n        // Check if next node is below the edge\n        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {\n            fillLeftBelowEdgeEvent(tcx, edge, node);\n        } else {\n            node = node.prev;\n        }\n    }\n}\n\nfunction fillLeftBelowEdgeEvent(tcx, edge, node) {\n    if (node.point.x > edge.p.x) {\n        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {\n            // Concave\n            fillLeftConcaveEdgeEvent(tcx, edge, node);\n        } else {\n            // Convex\n            fillLeftConvexEdgeEvent(tcx, edge, node);\n            // Retry this one\n            fillLeftBelowEdgeEvent(tcx, edge, node);\n        }\n    }\n}\n\nfunction fillLeftConvexEdgeEvent(tcx, edge, node) {\n    // Next concave or convex?\n    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {\n        // Concave\n        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);\n    } else {\n        // Convex\n        // Next above or below edge?\n        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {\n            // Below\n            fillLeftConvexEdgeEvent(tcx, edge, node.prev);\n        } else {\n            // Above\n            /* jshint noempty:false */\n        }\n    }\n}\n\nfunction fillLeftConcaveEdgeEvent(tcx, edge, node) {\n    fill(tcx, node.prev);\n    if (node.prev.point !== edge.p) {\n        // Next above or below edge?\n        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {\n            // Below\n            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {\n                // Next is concave\n                fillLeftConcaveEdgeEvent(tcx, edge, node);\n            } else {\n                // Next is convex\n                /* jshint noempty:false */\n            }\n        }\n    }\n}\n\nfunction flipEdgeEvent(tcx, ep, eq, t, p) {\n    var ot = t.neighborAcross(p);\n    assert(ot, \"FLIP failed due to missing triangle!\");\n\n    var op = ot.oppositePoint(t, p);\n\n    // Additional check from Java version (see issue #88)\n    if (t.getConstrainedEdgeAcross(p)) {\n        var index = t.index(p);\n        throw new PointError(\"poly2tri Intersecting Constraints\",\n                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);\n    }\n\n    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {\n        // Lets rotate shared edge one vertex CW\n        rotateTrianglePair(t, p, ot, op);\n        tcx.mapTriangleToNodes(t);\n        tcx.mapTriangleToNodes(ot);\n\n        // XXX: in the original C++ code for the next 2 lines, we are\n        // comparing point values (and not pointers). In this JavaScript\n        // code, we are comparing point references (pointers). This works\n        // because we can't have 2 different points with the same values.\n        // But to be really equivalent, we should use \"Point.equals\" here.\n        if (p === eq && op === ep) {\n            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {\n                t.markConstrainedEdgeByPoints(ep, eq);\n                ot.markConstrainedEdgeByPoints(ep, eq);\n                legalize(tcx, t);\n                legalize(tcx, ot);\n            } else {\n                // XXX: I think one of the triangles should be legalized here?\n                /* jshint noempty:false */\n            }\n        } else {\n            var o = orient2d(eq, op, ep);\n            t = nextFlipTriangle(tcx, o, t, ot, p, op);\n            flipEdgeEvent(tcx, ep, eq, t, p);\n        }\n    } else {\n        var newP = nextFlipPoint(ep, eq, ot, op);\n        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);\n        edgeEventByPoints(tcx, ep, eq, t, p);\n    }\n}\n\n/**\n * After a flip we have two triangles and know that only one will still be\n * intersecting the edge. So decide which to contiune with and legalize the other\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param o - should be the result of an orient2d( eq, op, ep )\n * @param t - triangle 1\n * @param ot - triangle 2\n * @param p - a point shared by both triangles\n * @param op - another point shared by both triangles\n * @return returns the triangle still intersecting the edge\n */\nfunction nextFlipTriangle(tcx, o, t, ot, p, op) {\n    var edge_index;\n    if (o === Orientation.CCW) {\n        // ot is not crossing edge after flip\n        edge_index = ot.edgeIndex(p, op);\n        ot.delaunay_edge[edge_index] = true;\n        legalize(tcx, ot);\n        ot.clearDelaunayEdges();\n        return t;\n    }\n\n    // t is not crossing edge after flip\n    edge_index = t.edgeIndex(p, op);\n\n    t.delaunay_edge[edge_index] = true;\n    legalize(tcx, t);\n    t.clearDelaunayEdges();\n    return ot;\n}\n\n/**\n * When we need to traverse from one triangle to the next we need\n * the point in current triangle that is the opposite point to the next\n * triangle.\n */\nfunction nextFlipPoint(ep, eq, ot, op) {\n    var o2d = orient2d(eq, op, ep);\n    if (o2d === Orientation.CW) {\n        // Right\n        return ot.pointCCW(op);\n    } else if (o2d === Orientation.CCW) {\n        // Left\n        return ot.pointCW(op);\n    } else {\n        throw new PointError(\"poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!\", [eq, op, ep]);\n    }\n}\n\n/**\n * Scan part of the FlipScan algorithm<br>\n * When a triangle pair isn't flippable we will scan for the next\n * point that is inside the flip triangle scan area. When found\n * we generate a new flipEdgeEvent\n *\n * @param {!SweepContext} tcx - SweepContext object\n * @param ep - last point on the edge we are traversing\n * @param eq - first point on the edge we are traversing\n * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge\n * @param t\n * @param p\n */\nfunction flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {\n    var ot = t.neighborAcross(p);\n    assert(ot, \"FLIP failed due to missing triangle\");\n\n    var op = ot.oppositePoint(t, p);\n\n    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {\n        // flip with new edge op.eq\n        flipEdgeEvent(tcx, eq, op, ot, op);\n    } else {\n        var newP = nextFlipPoint(ep, eq, ot, op);\n        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);\n    }\n}\n\n\n// ----------------------------------------------------------------------Exports\n\nexports.triangulate = triangulate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/sweep.js\n// module id = 23\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n/* jshint maxcomplexity:6 */\n\n\"use strict\";\n\n\n/*\n * Note\n * ====\n * the structure of this JavaScript version of poly2tri intentionally follows\n * as closely as possible the structure of the reference C++ version, to make it \n * easier to keep the 2 versions in sync.\n */\n\nvar PointError = require('./pointerror');\nvar Point = require('./point');\nvar Triangle = require('./triangle');\nvar sweep = require('./sweep');\nvar AdvancingFront = require('./advancingfront');\nvar Node = AdvancingFront.Node;\n\n\n// ------------------------------------------------------------------------utils\n\n/**\n * Initial triangle factor, seed triangle will extend 30% of\n * PointSet width to both left and right.\n * @private\n * @const\n */\nvar kAlpha = 0.3;\n\n\n// -------------------------------------------------------------------------Edge\n/**\n * Represents a simple polygon's edge\n * @constructor\n * @struct\n * @private\n * @param {Point} p1\n * @param {Point} p2\n * @throw {PointError} if p1 is same as p2\n */\nvar Edge = function(p1, p2) {\n    this.p = p1;\n    this.q = p2;\n\n    if (p1.y > p2.y) {\n        this.q = p1;\n        this.p = p2;\n    } else if (p1.y === p2.y) {\n        if (p1.x > p2.x) {\n            this.q = p1;\n            this.p = p2;\n        } else if (p1.x === p2.x) {\n            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);\n        }\n    }\n\n    if (!this.q._p2t_edge_list) {\n        this.q._p2t_edge_list = [];\n    }\n    this.q._p2t_edge_list.push(this);\n};\n\n\n// ------------------------------------------------------------------------Basin\n/**\n * @constructor\n * @struct\n * @private\n */\nvar Basin = function() {\n    /** @type {Node} */\n    this.left_node = null;\n    /** @type {Node} */\n    this.bottom_node = null;\n    /** @type {Node} */\n    this.right_node = null;\n    /** @type {number} */\n    this.width = 0.0;\n    /** @type {boolean} */\n    this.left_highest = false;\n};\n\nBasin.prototype.clear = function() {\n    this.left_node = null;\n    this.bottom_node = null;\n    this.right_node = null;\n    this.width = 0.0;\n    this.left_highest = false;\n};\n\n// --------------------------------------------------------------------EdgeEvent\n/**\n * @constructor\n * @struct\n * @private\n */\nvar EdgeEvent = function() {\n    /** @type {Edge} */\n    this.constrained_edge = null;\n    /** @type {boolean} */\n    this.right = false;\n};\n\n// ----------------------------------------------------SweepContext (public API)\n/**\n * SweepContext constructor option\n * @typedef {Object} SweepContextOptions\n * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters\n *                  (contour, holes). Points inside arrays are never copied.\n *                  Default is <code>false</code> : keep a reference to the array arguments,\n *                  who will be modified in place.\n */\n/**\n * Constructor for the triangulation context.\n * It accepts a simple polyline (with non repeating points), \n * which defines the constrained edges.\n *\n * @example\n *          var contour = [\n *              new poly2tri.Point(100, 100),\n *              new poly2tri.Point(100, 300),\n *              new poly2tri.Point(300, 300),\n *              new poly2tri.Point(300, 100)\n *          ];\n *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});\n * @example\n *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];\n *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});\n * @constructor\n * @public\n * @struct\n * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,\n *          or any \"Point like\" custom class with <code>{x, y}</code> attributes.\n * @param {SweepContextOptions=} options - constructor options\n */\nvar SweepContext = function(contour, options) {\n    options = options || {};\n    this.triangles_ = [];\n    this.map_ = [];\n    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);\n    this.edge_list = [];\n\n    // Bounding box of all points. Computed at the start of the triangulation, \n    // it is stored in case it is needed by the caller.\n    this.pmin_ = this.pmax_ = null;\n\n    /**\n     * Advancing front\n     * @private\n     * @type {AdvancingFront}\n     */\n    this.front_ = null;\n\n    /**\n     * head point used with advancing front\n     * @private\n     * @type {Point}\n     */\n    this.head_ = null;\n\n    /**\n     * tail point used with advancing front\n     * @private\n     * @type {Point}\n     */\n    this.tail_ = null;\n\n    /**\n     * @private\n     * @type {Node}\n     */\n    this.af_head_ = null;\n    /**\n     * @private\n     * @type {Node}\n     */\n    this.af_middle_ = null;\n    /**\n     * @private\n     * @type {Node}\n     */\n    this.af_tail_ = null;\n\n    this.basin = new Basin();\n    this.edge_event = new EdgeEvent();\n\n    this.initEdges(this.points_);\n};\n\n\n/**\n * Add a hole to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var hole = [\n *          new poly2tri.Point(200, 200),\n *          new poly2tri.Point(200, 250),\n *          new poly2tri.Point(250, 250)\n *      ];\n *      swctx.addHole(hole);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);\n * @public\n * @param {Array.<XY>} polyline - array of \"Point like\" objects with {x,y}\n */\nSweepContext.prototype.addHole = function(polyline) {\n    this.initEdges(polyline);\n    var i, len = polyline.length;\n    for (i = 0; i < len; i++) {\n        this.points_.push(polyline[i]);\n    }\n    return this; // for chaining\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode SweepContext#addHole} instead\n */\nSweepContext.prototype.AddHole = SweepContext.prototype.addHole;\n\n\n/**\n * Add several holes to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var holes = [\n *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],\n *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]\n *      ];\n *      swctx.addHoles(holes);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var holes = [\n *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],\n *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]\n *      ];\n *      swctx.addHoles(holes);\n * @public\n * @param {Array.<Array.<XY>>} holes - array of array of \"Point like\" objects with {x,y}\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.addHoles = function(holes) {\n    var i, len = holes.length;\n    for (i = 0; i < len; i++) {\n        this.initEdges(holes[i]);\n    }\n    this.points_ = this.points_.concat.apply(this.points_, holes);\n    return this; // for chaining\n};\n\n\n/**\n * Add a Steiner point to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var point = new poly2tri.Point(150, 150);\n *      swctx.addPoint(point);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.addPoint({x:150, y:150});\n * @public\n * @param {XY} point - any \"Point like\" object with {x,y}\n */\nSweepContext.prototype.addPoint = function(point) {\n    this.points_.push(point);\n    return this; // for chaining\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode SweepContext#addPoint} instead\n */\nSweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;\n\n\n/**\n * Add several Steiner points to the constraints\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      var points = [\n *          new poly2tri.Point(150, 150),\n *          new poly2tri.Point(200, 250),\n *          new poly2tri.Point(250, 250)\n *      ];\n *      swctx.addPoints(points);\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);\n * @public\n * @param {Array.<XY>} points - array of \"Point like\" object with {x,y}\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.addPoints = function(points) {\n    this.points_ = this.points_.concat(points);\n    return this; // for chaining\n};\n\n\n/**\n * Triangulate the polygon with holes and Steiner points.\n * Do this AFTER you've added the polyline, holes, and Steiner points\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n * @public\n */\n// Shortcut method for sweep.triangulate(SweepContext).\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.triangulate = function() {\n    sweep.triangulate(this);\n    return this; // for chaining\n};\n\n\n/**\n * Get the bounding box of the provided constraints (contour, holes and \n * Steinter points). Warning : these values are not available if the triangulation \n * has not been done yet.\n * @public\n * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point\n */\n// Method added in the JavaScript version (was not present in the c++ version)\nSweepContext.prototype.getBoundingBox = function() {\n    return {min: this.pmin_, max: this.pmax_};\n};\n\n/**\n * Get result of triangulation.\n * The output triangles have vertices which are references\n * to the initial input points (not copies): any custom fields in the\n * initial points can be retrieved in the output triangles.\n * @example\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n * @example\n *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];\n *      var swctx = new poly2tri.SweepContext(contour);\n *      swctx.triangulate();\n *      var triangles = swctx.getTriangles();\n *      typeof triangles[0].getPoint(0).id\n *      //  \"number\"\n * @public\n * @returns {array<Triangle>}   array of triangles\n */\nSweepContext.prototype.getTriangles = function() {\n    return this.triangles_;\n};\n\n/**\n * For backward compatibility\n * @function\n * @deprecated use {@linkcode SweepContext#getTriangles} instead\n */\nSweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;\n\n\n// ---------------------------------------------------SweepContext (private API)\n\n/** @private */\nSweepContext.prototype.front = function() {\n    return this.front_;\n};\n\n/** @private */\nSweepContext.prototype.pointCount = function() {\n    return this.points_.length;\n};\n\n/** @private */\nSweepContext.prototype.head = function() {\n    return this.head_;\n};\n\n/** @private */\nSweepContext.prototype.setHead = function(p1) {\n    this.head_ = p1;\n};\n\n/** @private */\nSweepContext.prototype.tail = function() {\n    return this.tail_;\n};\n\n/** @private */\nSweepContext.prototype.setTail = function(p1) {\n    this.tail_ = p1;\n};\n\n/** @private */\nSweepContext.prototype.getMap = function() {\n    return this.map_;\n};\n\n/** @private */\nSweepContext.prototype.initTriangulation = function() {\n    var xmax = this.points_[0].x;\n    var xmin = this.points_[0].x;\n    var ymax = this.points_[0].y;\n    var ymin = this.points_[0].y;\n\n    // Calculate bounds\n    var i, len = this.points_.length;\n    for (i = 1; i < len; i++) {\n        var p = this.points_[i];\n        /* jshint expr:true */\n        (p.x > xmax) && (xmax = p.x);\n        (p.x < xmin) && (xmin = p.x);\n        (p.y > ymax) && (ymax = p.y);\n        (p.y < ymin) && (ymin = p.y);\n    }\n    this.pmin_ = new Point(xmin, ymin);\n    this.pmax_ = new Point(xmax, ymax);\n\n    var dx = kAlpha * (xmax - xmin);\n    var dy = kAlpha * (ymax - ymin);\n    this.head_ = new Point(xmax + dx, ymin - dy);\n    this.tail_ = new Point(xmin - dx, ymin - dy);\n\n    // Sort points along y-axis\n    this.points_.sort(Point.compare);\n};\n\n/** @private */\nSweepContext.prototype.initEdges = function(polyline) {\n    var i, len = polyline.length;\n    for (i = 0; i < len; ++i) {\n        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));\n    }\n};\n\n/** @private */\nSweepContext.prototype.getPoint = function(index) {\n    return this.points_[index];\n};\n\n/** @private */\nSweepContext.prototype.addToMap = function(triangle) {\n    this.map_.push(triangle);\n};\n\n/** @private */\nSweepContext.prototype.locateNode = function(point) {\n    return this.front_.locateNode(point.x);\n};\n\n/** @private */\nSweepContext.prototype.createAdvancingFront = function() {\n    var head;\n    var middle;\n    var tail;\n    // Initial triangle\n    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);\n\n    this.map_.push(triangle);\n\n    head = new Node(triangle.getPoint(1), triangle);\n    middle = new Node(triangle.getPoint(0), triangle);\n    tail = new Node(triangle.getPoint(2));\n\n    this.front_ = new AdvancingFront(head, tail);\n\n    head.next = middle;\n    middle.next = tail;\n    middle.prev = head;\n    tail.prev = middle;\n};\n\n/** @private */\nSweepContext.prototype.removeNode = function(node) {\n    // do nothing\n    /* jshint unused:false */\n};\n\n/** @private */\nSweepContext.prototype.mapTriangleToNodes = function(t) {\n    for (var i = 0; i < 3; ++i) {\n        if (!t.getNeighbor(i)) {\n            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));\n            if (n) {\n                n.triangle = t;\n            }\n        }\n    }\n};\n\n/** @private */\nSweepContext.prototype.removeFromMap = function(triangle) {\n    var i, map = this.map_, len = map.length;\n    for (i = 0; i < len; i++) {\n        if (map[i] === triangle) {\n            map.splice(i, 1);\n            break;\n        }\n    }\n};\n\n/**\n * Do a depth first traversal to collect triangles\n * @private\n * @param {Triangle} triangle start\n */\nSweepContext.prototype.meshClean = function(triangle) {\n    // New implementation avoids recursive calls and use a loop instead.\n    // Cf. issues # 57, 65 and 69.\n    var triangles = [triangle], t, i;\n    /* jshint boss:true */\n    while (t = triangles.pop()) {\n        if (!t.isInterior()) {\n            t.setInterior(true);\n            this.triangles_.push(t);\n            for (i = 0; i < 3; i++) {\n                if (!t.constrained_edge[i]) {\n                    triangles.push(t.getNeighbor(i));\n                }\n            }\n        }\n    }\n};\n\n// ----------------------------------------------------------------------Exports\n\nmodule.exports = SweepContext;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/sweepcontext.js\n// module id = 24\n// module chunks = 0","/*\n * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors\n * http://code.google.com/p/poly2tri/\n * \n * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors\n * https://github.com/r3mi/poly2tri.js\n * \n * All rights reserved.\n * \n * Distributed under the 3-clause BSD License, see LICENSE.txt\n */\n\n\"use strict\";\n\n/**\n * Precision to detect repeated or collinear points\n * @private\n * @const {number}\n * @default\n */\nvar EPSILON = 1e-12;\nexports.EPSILON = EPSILON;\n\n/**\n * @private\n * @enum {number}\n * @readonly\n */\nvar Orientation = {\n    \"CW\": 1,\n    \"CCW\": -1,\n    \"COLLINEAR\": 0\n};\nexports.Orientation = Orientation;\n\n\n/**\n * Formula to calculate signed area<br>\n * Positive if CCW<br>\n * Negative if CW<br>\n * 0 if collinear<br>\n * <pre>\n * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)\n *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)\n * </pre>\n *\n * @private\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n * @return {Orientation}\n */\nfunction orient2d(pa, pb, pc) {\n    var detleft = (pa.x - pc.x) * (pb.y - pc.y);\n    var detright = (pa.y - pc.y) * (pb.x - pc.x);\n    var val = detleft - detright;\n    if (val > -(EPSILON) && val < (EPSILON)) {\n        return Orientation.COLLINEAR;\n    } else if (val > 0) {\n        return Orientation.CCW;\n    } else {\n        return Orientation.CW;\n    }\n}\nexports.orient2d = orient2d;\n\n\n/**\n *\n * @private\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n * @param {!XY} pd  point object with {x,y}\n * @return {boolean}\n */\nfunction inScanArea(pa, pb, pc, pd) {\n    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);\n    if (oadb >= -EPSILON) {\n        return false;\n    }\n\n    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);\n    if (oadc <= EPSILON) {\n        return false;\n    }\n    return true;\n}\nexports.inScanArea = inScanArea;\n\n\n/**\n * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > /2 || angle < -/2)\n *\n * @private\n * @param {!XY} pa  point object with {x,y}\n * @param {!XY} pb  point object with {x,y}\n * @param {!XY} pc  point object with {x,y}\n * @return {boolean} true if angle is obtuse\n */\nfunction isAngleObtuse(pa, pb, pc) {\n    var ax = pb.x - pa.x;\n    var ay = pb.y - pa.y;\n    var bx = pc.x - pa.x;\n    var by = pc.y - pa.y;\n    return (ax * bx + ay * by) < 0;\n}\nexports.isAngleObtuse = isAngleObtuse;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/poly2tri/src/utils.js\n// module id = 25\n// module chunks = 0","export default \"\\n\\n// The Module object: Our interface to the outside world. We import\\n// and export values on it. There are various ways Module can be used:\\n// 1. Not defined. We create it here\\n// 2. A function parameter, function(Module) { ..generated code.. }\\n// 3. pre-run appended it, var Module = {}; ..generated code..\\n// 4. External script tag defines var Module.\\n// We need to check if Module already exists (e.g. case 3 above).\\n// Substitution will be replaced with actual code on later stage of the build,\\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\\n// Note that if you want to run closure, and also to use Module\\n// after the generated code, you will need to define   var Module = {};\\n// before the code. Then that object will be used in the code, and you\\n// can continue to use Module afterwards as well.\\nvar Module = typeof Module !== 'undefined' ? Module : {};\\n\\n// --pre-jses are emitted after the Module integration code, so that they can\\n// refer to Module (if they choose; they can also define Module)\\n// {{PRE_JSES}}\\n\\n// Sometimes an existing Module object exists with properties\\n// meant to overwrite the default module functionality. Here\\n// we collect those properties and reapply _after_ we configure\\n// the current environment's defaults to avoid having to be so\\n// defensive during initialization.\\nvar moduleOverrides = {};\\nvar key;\\nfor (key in Module) {\\n  if (Module.hasOwnProperty(key)) {\\n    moduleOverrides[key] = Module[key];\\n  }\\n}\\n\\nvar arguments_ = [];\\nvar thisProgram = './this.program';\\nvar quit_ = function(status, toThrow) {\\n  throw toThrow;\\n};\\n\\n// Determine the runtime environment we are in. You can customize this by\\n// setting the ENVIRONMENT setting at compile time (see settings.js).\\n\\nvar ENVIRONMENT_IS_WEB = true;\\nvar ENVIRONMENT_IS_WORKER = false;\\nvar ENVIRONMENT_IS_NODE = false;\\nvar ENVIRONMENT_IS_SHELL = false;\\n\\n// `/` should be present at the end if `scriptDirectory` is not empty\\nvar scriptDirectory = '';\\nfunction locateFile(path) {\\n  if (Module['locateFile']) {\\n    return Module['locateFile'](path, scriptDirectory);\\n  }\\n  return scriptDirectory + path;\\n}\\n\\n// Hooks that are implemented differently in different runtime environments.\\nvar read_,\\n    readAsync,\\n    readBinary,\\n    setWindowTitle;\\n\\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\\n// ENVIRONMENT_IS_NODE.\\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\\n    scriptDirectory = self.location.href;\\n  } else if (typeof document !== 'undefined' && document.currentScript) { // web\\n    scriptDirectory = document.currentScript.src;\\n  }\\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\\n  // otherwise, slice off the final part of the url to find the script directory.\\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\\n  // and scriptDirectory will correctly be replaced with an empty string.\\n  if (scriptDirectory.indexOf('blob:') !== 0) {\\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);\\n  } else {\\n    scriptDirectory = '';\\n  }\\n\\n  // Differentiate the Web Worker from the Node Worker case, as reading must\\n  // be done differently.\\n  {\\n\\n// include: web_or_worker_shell_read.js\\n\\n\\n  read_ = function(url) {\\n    try {\\n      var xhr = new XMLHttpRequest();\\n      xhr.open('GET', url, false);\\n      xhr.send(null);\\n      return xhr.responseText;\\n    } catch (err) {\\n      var data = tryParseAsDataURI(url);\\n      if (data) {\\n        return intArrayToString(data);\\n      }\\n      throw err;\\n    }\\n  };\\n\\n  if (ENVIRONMENT_IS_WORKER) {\\n    readBinary = function(url) {\\n      try {\\n        var xhr = new XMLHttpRequest();\\n        xhr.open('GET', url, false);\\n        xhr.responseType = 'arraybuffer';\\n        xhr.send(null);\\n        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));\\n      } catch (err) {\\n        var data = tryParseAsDataURI(url);\\n        if (data) {\\n          return data;\\n        }\\n        throw err;\\n      }\\n    };\\n  }\\n\\n  readAsync = function(url, onload, onerror) {\\n    var xhr = new XMLHttpRequest();\\n    xhr.open('GET', url, true);\\n    xhr.responseType = 'arraybuffer';\\n    xhr.onload = function() {\\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\\n        onload(xhr.response);\\n        return;\\n      }\\n      var data = tryParseAsDataURI(url);\\n      if (data) {\\n        onload(data.buffer);\\n        return;\\n      }\\n      onerror();\\n    };\\n    xhr.onerror = onerror;\\n    xhr.send(null);\\n  };\\n\\n// end include: web_or_worker_shell_read.js\\n  }\\n\\n  setWindowTitle = function(title) { document.title = title };\\n} else\\n{\\n}\\n\\n// Set up the out() and err() hooks, which are how we can print to stdout or\\n// stderr, respectively.\\nvar out = Module['print'] || console.log.bind(console);\\nvar err = Module['printErr'] || console.warn.bind(console);\\n\\n// Merge back in the overrides\\nfor (key in moduleOverrides) {\\n  if (moduleOverrides.hasOwnProperty(key)) {\\n    Module[key] = moduleOverrides[key];\\n  }\\n}\\n// Free the object hierarchy contained in the overrides, this lets the GC\\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\\nmoduleOverrides = null;\\n\\n// Emit code to handle expected values on the Module object. This applies Module.x\\n// to the proper local x. This has two benefits: first, we only emit it if it is\\n// expected to arrive, and second, by using a local everywhere else that can be\\n// minified.\\n\\nif (Module['arguments']) arguments_ = Module['arguments'];\\n\\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];\\n\\nif (Module['quit']) quit_ = Module['quit'];\\n\\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\\n\\n\\n\\n\\nvar STACK_ALIGN = 16;\\n\\nfunction alignMemory(size, factor) {\\n  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\\n  return Math.ceil(size / factor) * factor;\\n}\\n\\nfunction getNativeTypeSize(type) {\\n  switch (type) {\\n    case 'i1': case 'i8': return 1;\\n    case 'i16': return 2;\\n    case 'i32': return 4;\\n    case 'i64': return 8;\\n    case 'float': return 4;\\n    case 'double': return 8;\\n    default: {\\n      if (type[type.length-1] === '*') {\\n        return 4; // A pointer\\n      } else if (type[0] === 'i') {\\n        var bits = Number(type.substr(1));\\n        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\\n        return bits / 8;\\n      } else {\\n        return 0;\\n      }\\n    }\\n  }\\n}\\n\\nfunction warnOnce(text) {\\n  if (!warnOnce.shown) warnOnce.shown = {};\\n  if (!warnOnce.shown[text]) {\\n    warnOnce.shown[text] = 1;\\n    err(text);\\n  }\\n}\\n\\n// include: runtime_functions.js\\n\\n\\n// Wraps a JS function as a wasm function with a given signature.\\nfunction convertJsFunctionToWasm(func, sig) {\\n\\n  // If the type reflection proposal is available, use the new\\n  // \\\"WebAssembly.Function\\\" constructor.\\n  // Otherwise, construct a minimal wasm module importing the JS function and\\n  // re-exporting it.\\n  if (typeof WebAssembly.Function === \\\"function\\\") {\\n    var typeNames = {\\n      'i': 'i32',\\n      'j': 'i64',\\n      'f': 'f32',\\n      'd': 'f64'\\n    };\\n    var type = {\\n      parameters: [],\\n      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]\\n    };\\n    for (var i = 1; i < sig.length; ++i) {\\n      type.parameters.push(typeNames[sig[i]]);\\n    }\\n    return new WebAssembly.Function(type, func);\\n  }\\n\\n  // The module is static, with the exception of the type section, which is\\n  // generated based on the signature passed in.\\n  var typeSection = [\\n    0x01, // id: section,\\n    0x00, // length: 0 (placeholder)\\n    0x01, // count: 1\\n    0x60, // form: func\\n  ];\\n  var sigRet = sig.slice(0, 1);\\n  var sigParam = sig.slice(1);\\n  var typeCodes = {\\n    'i': 0x7f, // i32\\n    'j': 0x7e, // i64\\n    'f': 0x7d, // f32\\n    'd': 0x7c, // f64\\n  };\\n\\n  // Parameters, length + signatures\\n  typeSection.push(sigParam.length);\\n  for (var i = 0; i < sigParam.length; ++i) {\\n    typeSection.push(typeCodes[sigParam[i]]);\\n  }\\n\\n  // Return values, length + signatures\\n  // With no multi-return in MVP, either 0 (void) or 1 (anything else)\\n  if (sigRet == 'v') {\\n    typeSection.push(0x00);\\n  } else {\\n    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);\\n  }\\n\\n  // Write the overall length of the type section back into the section header\\n  // (excepting the 2 bytes for the section id and length)\\n  typeSection[1] = typeSection.length - 2;\\n\\n  // Rest of the module is static\\n  var bytes = new Uint8Array([\\n    0x00, 0x61, 0x73, 0x6d, // magic (\\\"\\\\0asm\\\")\\n    0x01, 0x00, 0x00, 0x00, // version: 1\\n  ].concat(typeSection, [\\n    0x02, 0x07, // import section\\n      // (import \\\"e\\\" \\\"f\\\" (func 0 (type 0)))\\n      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,\\n    0x07, 0x05, // export section\\n      // (export \\\"f\\\" (func 0 (type 0)))\\n      0x01, 0x01, 0x66, 0x00, 0x00,\\n  ]));\\n\\n   // We can compile this wasm module synchronously because it is very small.\\n  // This accepts an import (at \\\"e.f\\\"), that it reroutes to an export (at \\\"f\\\")\\n  var module = new WebAssembly.Module(bytes);\\n  var instance = new WebAssembly.Instance(module, {\\n    'e': {\\n      'f': func\\n    }\\n  });\\n  var wrappedFunc = instance.exports['f'];\\n  return wrappedFunc;\\n}\\n\\nvar freeTableIndexes = [];\\n\\n// Weak map of functions in the table to their indexes, created on first use.\\nvar functionsInTableMap;\\n\\nfunction getEmptyTableSlot() {\\n  // Reuse a free index if there is one, otherwise grow.\\n  if (freeTableIndexes.length) {\\n    return freeTableIndexes.pop();\\n  }\\n  // Grow the table\\n  try {\\n    wasmTable.grow(1);\\n  } catch (err) {\\n    if (!(err instanceof RangeError)) {\\n      throw err;\\n    }\\n    throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';\\n  }\\n  return wasmTable.length - 1;\\n}\\n\\n// Add a wasm function to the table.\\nfunction addFunctionWasm(func, sig) {\\n  // Check if the function is already in the table, to ensure each function\\n  // gets a unique index. First, create the map if this is the first use.\\n  if (!functionsInTableMap) {\\n    functionsInTableMap = new WeakMap();\\n    for (var i = 0; i < wasmTable.length; i++) {\\n      var item = wasmTable.get(i);\\n      // Ignore null values.\\n      if (item) {\\n        functionsInTableMap.set(item, i);\\n      }\\n    }\\n  }\\n  if (functionsInTableMap.has(func)) {\\n    return functionsInTableMap.get(func);\\n  }\\n\\n  // It's not in the table, add it now.\\n\\n  var ret = getEmptyTableSlot();\\n\\n  // Set the new value.\\n  try {\\n    // Attempting to call this with JS function will cause of table.set() to fail\\n    wasmTable.set(ret, func);\\n  } catch (err) {\\n    if (!(err instanceof TypeError)) {\\n      throw err;\\n    }\\n    var wrapped = convertJsFunctionToWasm(func, sig);\\n    wasmTable.set(ret, wrapped);\\n  }\\n\\n  functionsInTableMap.set(func, ret);\\n\\n  return ret;\\n}\\n\\nfunction removeFunction(index) {\\n  functionsInTableMap.delete(wasmTable.get(index));\\n  freeTableIndexes.push(index);\\n}\\n\\n// 'sig' parameter is required for the llvm backend but only when func is not\\n// already a WebAssembly function.\\nfunction addFunction(func, sig) {\\n\\n  return addFunctionWasm(func, sig);\\n}\\n\\n// end include: runtime_functions.js\\n// include: runtime_debug.js\\n\\n\\n// end include: runtime_debug.js\\nfunction makeBigInt(low, high, unsigned) {\\n  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));\\n}\\n\\nvar tempRet0 = 0;\\n\\nvar setTempRet0 = function(value) {\\n  tempRet0 = value;\\n};\\n\\nvar getTempRet0 = function() {\\n  return tempRet0;\\n};\\n\\n\\n\\n// === Preamble library stuff ===\\n\\n// Documentation for the public APIs defined in this file must be updated in:\\n//    site/source/docs/api_reference/preamble.js.rst\\n// A prebuilt local version of the documentation is available at:\\n//    site/build/text/docs/api_reference/preamble.js.txt\\n// You can also build docs locally as HTML or other formats in site/\\n// An online HTML version (which may be of a different version of Emscripten)\\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\\n\\nvar wasmBinary;\\nif (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\\nvar noExitRuntime = Module['noExitRuntime'] || true;\\n\\nif (typeof WebAssembly !== 'object') {\\n  abort('no native wasm support detected');\\n}\\n\\n// include: runtime_safe_heap.js\\n\\n\\n// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.\\n// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)\\n\\n/** @param {number} ptr\\n    @param {number} value\\n    @param {string} type\\n    @param {number|boolean=} noSafe */\\nfunction setValue(ptr, value, type, noSafe) {\\n  type = type || 'i8';\\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\\n    switch(type) {\\n      case 'i1': HEAP8[((ptr)>>0)] = value; break;\\n      case 'i8': HEAP8[((ptr)>>0)] = value; break;\\n      case 'i16': HEAP16[((ptr)>>1)] = value; break;\\n      case 'i32': HEAP32[((ptr)>>2)] = value; break;\\n      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;\\n      case 'float': HEAPF32[((ptr)>>2)] = value; break;\\n      case 'double': HEAPF64[((ptr)>>3)] = value; break;\\n      default: abort('invalid type for setValue: ' + type);\\n    }\\n}\\n\\n/** @param {number} ptr\\n    @param {string} type\\n    @param {number|boolean=} noSafe */\\nfunction getValue(ptr, type, noSafe) {\\n  type = type || 'i8';\\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\\n    switch(type) {\\n      case 'i1': return HEAP8[((ptr)>>0)];\\n      case 'i8': return HEAP8[((ptr)>>0)];\\n      case 'i16': return HEAP16[((ptr)>>1)];\\n      case 'i32': return HEAP32[((ptr)>>2)];\\n      case 'i64': return HEAP32[((ptr)>>2)];\\n      case 'float': return HEAPF32[((ptr)>>2)];\\n      case 'double': return HEAPF64[((ptr)>>3)];\\n      default: abort('invalid type for getValue: ' + type);\\n    }\\n  return null;\\n}\\n\\n// end include: runtime_safe_heap.js\\n// Wasm globals\\n\\nvar wasmMemory;\\n\\n//========================================\\n// Runtime essentials\\n//========================================\\n\\n// whether we are quitting the application. no code should run after this.\\n// set in exit() and abort()\\nvar ABORT = false;\\n\\n// set by exit() and abort().  Passed to 'onExit' handler.\\n// NOTE: This is also used as the process return code code in shell environments\\n// but only when noExitRuntime is false.\\nvar EXITSTATUS;\\n\\n/** @type {function(*, string=)} */\\nfunction assert(condition, text) {\\n  if (!condition) {\\n    abort('Assertion failed: ' + text);\\n  }\\n}\\n\\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\\nfunction getCFunc(ident) {\\n  var func = Module['_' + ident]; // closure exported function\\n  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\\n  return func;\\n}\\n\\n// C calling interface.\\n/** @param {string|null=} returnType\\n    @param {Array=} argTypes\\n    @param {Arguments|Array=} args\\n    @param {Object=} opts */\\nfunction ccall(ident, returnType, argTypes, args, opts) {\\n  // For fast lookup of conversion functions\\n  var toC = {\\n    'string': function(str) {\\n      var ret = 0;\\n      if (str !== null && str !== undefined && str !== 0) { // null string\\n        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\\\0'\\n        var len = (str.length << 2) + 1;\\n        ret = stackAlloc(len);\\n        stringToUTF8(str, ret, len);\\n      }\\n      return ret;\\n    },\\n    'array': function(arr) {\\n      var ret = stackAlloc(arr.length);\\n      writeArrayToMemory(arr, ret);\\n      return ret;\\n    }\\n  };\\n\\n  function convertReturnValue(ret) {\\n    if (returnType === 'string') return UTF8ToString(ret);\\n    if (returnType === 'boolean') return Boolean(ret);\\n    return ret;\\n  }\\n\\n  var func = getCFunc(ident);\\n  var cArgs = [];\\n  var stack = 0;\\n  if (args) {\\n    for (var i = 0; i < args.length; i++) {\\n      var converter = toC[argTypes[i]];\\n      if (converter) {\\n        if (stack === 0) stack = stackSave();\\n        cArgs[i] = converter(args[i]);\\n      } else {\\n        cArgs[i] = args[i];\\n      }\\n    }\\n  }\\n  var ret = func.apply(null, cArgs);\\n\\n  ret = convertReturnValue(ret);\\n  if (stack !== 0) stackRestore(stack);\\n  return ret;\\n}\\n\\n/** @param {string=} returnType\\n    @param {Array=} argTypes\\n    @param {Object=} opts */\\nfunction cwrap(ident, returnType, argTypes, opts) {\\n  argTypes = argTypes || [];\\n  // When the function takes numbers and returns a number, we can just return\\n  // the original function\\n  var numericArgs = argTypes.every(function(type){ return type === 'number'});\\n  var numericRet = returnType !== 'string';\\n  if (numericRet && numericArgs && !opts) {\\n    return getCFunc(ident);\\n  }\\n  return function() {\\n    return ccall(ident, returnType, argTypes, arguments, opts);\\n  }\\n}\\n\\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\\n\\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\\n//             is a little tricky (see docs right below). The reason is that it is optimized\\n//             for multiple syntaxes to save space in generated code. So you should\\n//             normally not use allocate(), and instead allocate memory using _malloc(),\\n//             initialize it with setValue(), and so forth.\\n// @slab: An array of data.\\n// @allocator: How to allocate memory, see ALLOC_*\\n/** @type {function((Uint8Array|Array<number>), number)} */\\nfunction allocate(slab, allocator) {\\n  var ret;\\n\\n  if (allocator == ALLOC_STACK) {\\n    ret = stackAlloc(slab.length);\\n  } else {\\n    ret = _malloc(slab.length);\\n  }\\n\\n  if (slab.subarray || slab.slice) {\\n    HEAPU8.set(/** @type {!Uint8Array} */(slab), ret);\\n  } else {\\n    HEAPU8.set(new Uint8Array(slab), ret);\\n  }\\n  return ret;\\n}\\n\\n// include: runtime_strings.js\\n\\n\\n// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.\\n\\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\\n// a copy of that string as a Javascript String object.\\n\\nvar UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\\n\\n/**\\n * @param {number} idx\\n * @param {number=} maxBytesToRead\\n * @return {string}\\n */\\nfunction UTF8ArrayToString(heap, idx, maxBytesToRead) {\\n  var endIdx = idx + maxBytesToRead;\\n  var endPtr = idx;\\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\\n  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;\\n\\n  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\\n    return UTF8Decoder.decode(heap.subarray(idx, endPtr));\\n  } else {\\n    var str = '';\\n    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\\n    while (idx < endPtr) {\\n      // For UTF8 byte structure, see:\\n      // http://en.wikipedia.org/wiki/UTF-8#Description\\n      // https://www.ietf.org/rfc/rfc2279.txt\\n      // https://tools.ietf.org/html/rfc3629\\n      var u0 = heap[idx++];\\n      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\\n      var u1 = heap[idx++] & 63;\\n      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\\n      var u2 = heap[idx++] & 63;\\n      if ((u0 & 0xF0) == 0xE0) {\\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\\n      } else {\\n        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);\\n      }\\n\\n      if (u0 < 0x10000) {\\n        str += String.fromCharCode(u0);\\n      } else {\\n        var ch = u0 - 0x10000;\\n        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\\n      }\\n    }\\n  }\\n  return str;\\n}\\n\\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\\n// copy of that string as a Javascript String object.\\n// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\\n//                 this parameter to scan the string until the first \\\\0 byte. If maxBytesToRead is\\n//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\\n//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\\n//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\\n//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\\n//                 throw JS JIT optimizations off, so it is worth to consider consistently using one\\n//                 style or the other.\\n/**\\n * @param {number} ptr\\n * @param {number=} maxBytesToRead\\n * @return {string}\\n */\\nfunction UTF8ToString(ptr, maxBytesToRead) {\\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\\n}\\n\\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\\n// Parameters:\\n//   str: the Javascript string to copy.\\n//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.\\n//   outIdx: The starting offset in the array to begin the copying.\\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array.\\n//                    This count should include the null terminator,\\n//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\\n// Returns the number of bytes written, EXCLUDING the null terminator.\\n\\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\\n    return 0;\\n\\n  var startIdx = outIdx;\\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\\n  for (var i = 0; i < str.length; ++i) {\\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\\n    var u = str.charCodeAt(i); // possibly a lead surrogate\\n    if (u >= 0xD800 && u <= 0xDFFF) {\\n      var u1 = str.charCodeAt(++i);\\n      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\\n    }\\n    if (u <= 0x7F) {\\n      if (outIdx >= endIdx) break;\\n      heap[outIdx++] = u;\\n    } else if (u <= 0x7FF) {\\n      if (outIdx + 1 >= endIdx) break;\\n      heap[outIdx++] = 0xC0 | (u >> 6);\\n      heap[outIdx++] = 0x80 | (u & 63);\\n    } else if (u <= 0xFFFF) {\\n      if (outIdx + 2 >= endIdx) break;\\n      heap[outIdx++] = 0xE0 | (u >> 12);\\n      heap[outIdx++] = 0x80 | ((u >> 6) & 63);\\n      heap[outIdx++] = 0x80 | (u & 63);\\n    } else {\\n      if (outIdx + 3 >= endIdx) break;\\n      heap[outIdx++] = 0xF0 | (u >> 18);\\n      heap[outIdx++] = 0x80 | ((u >> 12) & 63);\\n      heap[outIdx++] = 0x80 | ((u >> 6) & 63);\\n      heap[outIdx++] = 0x80 | (u & 63);\\n    }\\n  }\\n  // Null-terminate the pointer to the buffer.\\n  heap[outIdx] = 0;\\n  return outIdx - startIdx;\\n}\\n\\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\\n// Returns the number of bytes written, EXCLUDING the null terminator.\\n\\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\\n}\\n\\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\\nfunction lengthBytesUTF8(str) {\\n  var len = 0;\\n  for (var i = 0; i < str.length; ++i) {\\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\\n    var u = str.charCodeAt(i); // possibly a lead surrogate\\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\\n    if (u <= 0x7F) ++len;\\n    else if (u <= 0x7FF) len += 2;\\n    else if (u <= 0xFFFF) len += 3;\\n    else len += 4;\\n  }\\n  return len;\\n}\\n\\n// end include: runtime_strings.js\\n// include: runtime_strings_extra.js\\n\\n\\n// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.\\n\\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\\n// a copy of that string as a Javascript String object.\\n\\nfunction AsciiToString(ptr) {\\n  var str = '';\\n  while (1) {\\n    var ch = HEAPU8[((ptr++)>>0)];\\n    if (!ch) return str;\\n    str += String.fromCharCode(ch);\\n  }\\n}\\n\\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\\n\\nfunction stringToAscii(str, outPtr) {\\n  return writeAsciiToMemory(str, outPtr, false);\\n}\\n\\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\\n// a copy of that string as a Javascript String object.\\n\\nvar UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\\n\\nfunction UTF16ToString(ptr, maxBytesToRead) {\\n  var endPtr = ptr;\\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\\n  var idx = endPtr >> 1;\\n  var maxIdx = idx + maxBytesToRead / 2;\\n  // If maxBytesToRead is not passed explicitly, it will be undefined, and this\\n  // will always evaluate to true. This saves on code size.\\n  while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\\n  endPtr = idx << 1;\\n\\n  if (endPtr - ptr > 32 && UTF16Decoder) {\\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\\n  } else {\\n    var str = '';\\n\\n    // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition\\n    // will always evaluate to true. The loop is then terminated on the first null char.\\n    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\\n      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\\n      if (codeUnit == 0) break;\\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\\n      str += String.fromCharCode(codeUnit);\\n    }\\n\\n    return str;\\n  }\\n}\\n\\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\\n// Parameters:\\n//   str: the Javascript string to copy.\\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\\n// Returns the number of bytes written, EXCLUDING the null terminator.\\n\\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\\n  if (maxBytesToWrite === undefined) {\\n    maxBytesToWrite = 0x7FFFFFFF;\\n  }\\n  if (maxBytesToWrite < 2) return 0;\\n  maxBytesToWrite -= 2; // Null terminator.\\n  var startPtr = outPtr;\\n  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\\n  for (var i = 0; i < numCharsToWrite; ++i) {\\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\\n    HEAP16[((outPtr)>>1)] = codeUnit;\\n    outPtr += 2;\\n  }\\n  // Null-terminate the pointer to the HEAP.\\n  HEAP16[((outPtr)>>1)] = 0;\\n  return outPtr - startPtr;\\n}\\n\\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\\n\\nfunction lengthBytesUTF16(str) {\\n  return str.length*2;\\n}\\n\\nfunction UTF32ToString(ptr, maxBytesToRead) {\\n  var i = 0;\\n\\n  var str = '';\\n  // If maxBytesToRead is not passed explicitly, it will be undefined, and this\\n  // will always evaluate to true. This saves on code size.\\n  while (!(i >= maxBytesToRead / 4)) {\\n    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\\n    if (utf32 == 0) break;\\n    ++i;\\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\\n    if (utf32 >= 0x10000) {\\n      var ch = utf32 - 0x10000;\\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\\n    } else {\\n      str += String.fromCharCode(utf32);\\n    }\\n  }\\n  return str;\\n}\\n\\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\\n// Parameters:\\n//   str: the Javascript string to copy.\\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\\n// Returns the number of bytes written, EXCLUDING the null terminator.\\n\\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\\n  if (maxBytesToWrite === undefined) {\\n    maxBytesToWrite = 0x7FFFFFFF;\\n  }\\n  if (maxBytesToWrite < 4) return 0;\\n  var startPtr = outPtr;\\n  var endPtr = startPtr + maxBytesToWrite - 4;\\n  for (var i = 0; i < str.length; ++i) {\\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\\n      var trailSurrogate = str.charCodeAt(++i);\\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\\n    }\\n    HEAP32[((outPtr)>>2)] = codeUnit;\\n    outPtr += 4;\\n    if (outPtr + 4 > endPtr) break;\\n  }\\n  // Null-terminate the pointer to the HEAP.\\n  HEAP32[((outPtr)>>2)] = 0;\\n  return outPtr - startPtr;\\n}\\n\\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\\n\\nfunction lengthBytesUTF32(str) {\\n  var len = 0;\\n  for (var i = 0; i < str.length; ++i) {\\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\\n    var codeUnit = str.charCodeAt(i);\\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\\n    len += 4;\\n  }\\n\\n  return len;\\n}\\n\\n// Allocate heap space for a JS string, and write it there.\\n// It is the responsibility of the caller to free() that memory.\\nfunction allocateUTF8(str) {\\n  var size = lengthBytesUTF8(str) + 1;\\n  var ret = _malloc(size);\\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\\n  return ret;\\n}\\n\\n// Allocate stack space for a JS string, and write it there.\\nfunction allocateUTF8OnStack(str) {\\n  var size = lengthBytesUTF8(str) + 1;\\n  var ret = stackAlloc(size);\\n  stringToUTF8Array(str, HEAP8, ret, size);\\n  return ret;\\n}\\n\\n// Deprecated: This function should not be called because it is unsafe and does not provide\\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\\n// to be secure from out of bounds writes.\\n/** @deprecated\\n    @param {boolean=} dontAddNull */\\nfunction writeStringToMemory(string, buffer, dontAddNull) {\\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\\n\\n  var /** @type {number} */ lastChar, /** @type {number} */ end;\\n  if (dontAddNull) {\\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\\n    // character that existed at the location where the null will be placed, and restore\\n    // that after the write (below).\\n    end = buffer + lengthBytesUTF8(string);\\n    lastChar = HEAP8[end];\\n  }\\n  stringToUTF8(string, buffer, Infinity);\\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\\n}\\n\\nfunction writeArrayToMemory(array, buffer) {\\n  HEAP8.set(array, buffer);\\n}\\n\\n/** @param {boolean=} dontAddNull */\\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\\n  for (var i = 0; i < str.length; ++i) {\\n    HEAP8[((buffer++)>>0)] = str.charCodeAt(i);\\n  }\\n  // Null-terminate the pointer to the HEAP.\\n  if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;\\n}\\n\\n// end include: runtime_strings_extra.js\\n// Memory management\\n\\nfunction alignUp(x, multiple) {\\n  if (x % multiple > 0) {\\n    x += multiple - (x % multiple);\\n  }\\n  return x;\\n}\\n\\nvar HEAP,\\n/** @type {ArrayBuffer} */\\n  buffer,\\n/** @type {Int8Array} */\\n  HEAP8,\\n/** @type {Uint8Array} */\\n  HEAPU8,\\n/** @type {Int16Array} */\\n  HEAP16,\\n/** @type {Uint16Array} */\\n  HEAPU16,\\n/** @type {Int32Array} */\\n  HEAP32,\\n/** @type {Uint32Array} */\\n  HEAPU32,\\n/** @type {Float32Array} */\\n  HEAPF32,\\n/** @type {Float64Array} */\\n  HEAPF64;\\n\\nfunction updateGlobalBufferAndViews(buf) {\\n  buffer = buf;\\n  Module['HEAP8'] = HEAP8 = new Int8Array(buf);\\n  Module['HEAP16'] = HEAP16 = new Int16Array(buf);\\n  Module['HEAP32'] = HEAP32 = new Int32Array(buf);\\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);\\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);\\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);\\n}\\n\\nvar TOTAL_STACK = 5242880;\\n\\nvar INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;\\n\\n// include: runtime_init_table.js\\n// In regular non-RELOCATABLE mode the table is exported\\n// from the wasm module and this will be assigned once\\n// the exports are available.\\nvar wasmTable;\\n\\n// end include: runtime_init_table.js\\n// include: runtime_stack_check.js\\n\\n\\n// end include: runtime_stack_check.js\\n// include: runtime_assertions.js\\n\\n\\n// end include: runtime_assertions.js\\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\\nvar __ATINIT__    = []; // functions called during startup\\nvar __ATMAIN__    = []; // functions called when main() is to be run\\nvar __ATEXIT__    = []; // functions called during shutdown\\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\\n\\nvar runtimeInitialized = false;\\nvar runtimeExited = false;\\n\\n__ATINIT__.push({ func: function() { ___wasm_call_ctors() } });\\n\\nfunction preRun() {\\n\\n  if (Module['preRun']) {\\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\\n    while (Module['preRun'].length) {\\n      addOnPreRun(Module['preRun'].shift());\\n    }\\n  }\\n\\n  callRuntimeCallbacks(__ATPRERUN__);\\n}\\n\\nfunction initRuntime() {\\n  runtimeInitialized = true;\\n\\n  \\n  callRuntimeCallbacks(__ATINIT__);\\n}\\n\\nfunction preMain() {\\n  \\n  callRuntimeCallbacks(__ATMAIN__);\\n}\\n\\nfunction exitRuntime() {\\n  runtimeExited = true;\\n}\\n\\nfunction postRun() {\\n\\n  if (Module['postRun']) {\\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\\n    while (Module['postRun'].length) {\\n      addOnPostRun(Module['postRun'].shift());\\n    }\\n  }\\n\\n  callRuntimeCallbacks(__ATPOSTRUN__);\\n}\\n\\nfunction addOnPreRun(cb) {\\n  __ATPRERUN__.unshift(cb);\\n}\\n\\nfunction addOnInit(cb) {\\n  __ATINIT__.unshift(cb);\\n}\\n\\nfunction addOnPreMain(cb) {\\n  __ATMAIN__.unshift(cb);\\n}\\n\\nfunction addOnExit(cb) {\\n}\\n\\nfunction addOnPostRun(cb) {\\n  __ATPOSTRUN__.unshift(cb);\\n}\\n\\n// include: runtime_math.js\\n\\n\\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\\n\\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\\n\\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\\n\\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\\n\\n// end include: runtime_math.js\\n// A counter of dependencies for calling run(). If we need to\\n// do asynchronous work before running, increment this and\\n// decrement it. Incrementing must happen in a place like\\n// Module.preRun (used by emcc to add file preloading).\\n// Note that you can add dependencies in preRun, even though\\n// it happens right before run - run will be postponed until\\n// the dependencies are met.\\nvar runDependencies = 0;\\nvar runDependencyWatcher = null;\\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\\n\\nfunction getUniqueRunDependency(id) {\\n  return id;\\n}\\n\\nfunction addRunDependency(id) {\\n  runDependencies++;\\n\\n  if (Module['monitorRunDependencies']) {\\n    Module['monitorRunDependencies'](runDependencies);\\n  }\\n\\n}\\n\\nfunction removeRunDependency(id) {\\n  runDependencies--;\\n\\n  if (Module['monitorRunDependencies']) {\\n    Module['monitorRunDependencies'](runDependencies);\\n  }\\n\\n  if (runDependencies == 0) {\\n    if (runDependencyWatcher !== null) {\\n      clearInterval(runDependencyWatcher);\\n      runDependencyWatcher = null;\\n    }\\n    if (dependenciesFulfilled) {\\n      var callback = dependenciesFulfilled;\\n      dependenciesFulfilled = null;\\n      callback(); // can add another dependenciesFulfilled\\n    }\\n  }\\n}\\n\\nModule[\\\"preloadedImages\\\"] = {}; // maps url to image data\\nModule[\\\"preloadedAudios\\\"] = {}; // maps url to audio data\\n\\n/** @param {string|number=} what */\\nfunction abort(what) {\\n  if (Module['onAbort']) {\\n    Module['onAbort'](what);\\n  }\\n\\n  what += '';\\n  err(what);\\n\\n  ABORT = true;\\n  EXITSTATUS = 1;\\n\\n  what = 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.';\\n\\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\\n  // exception, which means we'd run destructors on it. We need the error to\\n  // simply make the program stop.\\n  var e = new WebAssembly.RuntimeError(what);\\n\\n  // Throw the error whether or not MODULARIZE is set because abort is used\\n  // in code paths apart from instantiation where an exception is expected\\n  // to be thrown when abort is called.\\n  throw e;\\n}\\n\\n// {{MEM_INITIALIZER}}\\n\\n// include: memoryprofiler.js\\n\\n\\n// end include: memoryprofiler.js\\n// include: URIUtils.js\\n\\n\\nfunction hasPrefix(str, prefix) {\\n  return String.prototype.startsWith ?\\n      str.startsWith(prefix) :\\n      str.indexOf(prefix) === 0;\\n}\\n\\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\\n\\n// Indicates whether filename is a base64 data URI.\\nfunction isDataURI(filename) {\\n  return hasPrefix(filename, dataURIPrefix);\\n}\\n\\nvar fileURIPrefix = \\\"file://\\\";\\n\\n// Indicates whether filename is delivered via file protocol (as opposed to http/https)\\nfunction isFileURI(filename) {\\n  return hasPrefix(filename, fileURIPrefix);\\n}\\n\\n// end include: URIUtils.js\\nvar wasmBinaryFile = 'data:application/octet-stream;base64,AGFzbQEAAAAB0oOAgAA/YAF/AX9gAn9/AX9gAn9/AGADf39/AGADf39/AX9gAX8AYAR/f39/AGAFf39/f38AYAR/f39/AX9gBX9/f39/AX9gBn9/f39/fwF/YAZ/f39/f38AYAABf2ABfwF8YAJ/fwF8YAV/fn5+fgBgBH5+fn4Bf2AAAGAGf39+fn9/AGACf3wBf2ABfAF8YAJ/fwF+YAN/f38BfGACfH8BfGAIf39/f39/f38AYAl/f39/f39/f38AYAR/fn5/AGAFf35+f38AYAZ/fn5/f38AYAd/fn5/f39/AGAEfHx/fwBgAXwBf2ACf34Bf2AFf35+fn4Bf2AGf3x/f39/AX9gAn5/AX9gA39+fwF+YAABfGADfHx/AXxgB39/f39/f38AYAp/f39/f39/f39/AGAGf39/f398AGAKf39/f398fH9/fwBgBX9/f398AGADf39+AGACf34AYAJ/fABgB39/f39/f38Bf2AEf35+fwF/YAl/fn5+fn5+fn4Bf2ADf3x/AX9gA398fAF/YAR/fHx/AX9gBH98fHwBf2ADfn9/AX9gAn5+AX9gAnx/AX9gAXwBfmADf39/AX5gBH9/fn8BfmACfn4BfGAEfn5+fgF8YAJ8fAF8AquBgIAABwNlbnYYX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uAAADZW52C19fY3hhX3Rocm93AAMDZW52BWFib3J0ABEDZW52FmVtc2NyaXB0ZW5fcmVzaXplX2hlYXAAAANlbnYVZW1zY3JpcHRlbl9tZW1jcHlfYmlnAAQWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQhmZF93cml0ZQAIA2VudgtzZXRUZW1wUmV0MAAFA4KbgIAAgBsRBwABAAEAAAEBBgABAAEGAAACAAAEAgAAAAACAgAFAAAAAgIFAAEBAQAABAABAAAAAAAHBQAAAwAAAAACAwACAgIDAwIFAAAEAAMAAQgCAAADAwEAAAEABAAAAQABAAABBAABAAYCAgUFAAAADAEBAQAADAQAAAABBAAABQEBAAAAAgACAAQAAAAABwUAAwAAAAACAwICAgQAAwABCAIAAwMBAAQAAQAGAgIFBQAAAAAAAAAAAQQAAAAAAwAAAwMCAAIAKAAAAAAHAAABAAAAAQMCBQMCAAIBAQEBAAEAAgUBAAABAAAABwABAQEAAQIBAgMDAwIAAAMAAgEAAQICAgAAAQABAwAAAQIAAAEAAwAAAAEDAQABHQEEBAwBAAAAAwACAAAGAAAAAAICBQUFAAQBAAAAAAcFAAADAAAAAAIDAAICAgABAAEBAQgCAAEAAAACAgAAAAQAAwABCAIAAAMDAQAEAAEABgICBQUAAAAAAAAAAAEEAAAAAAMAAAMDAgACAAEBAAAACAIAAAACAgAABAQAAAQAAAIDAgAAAwABAQMCAAAEAAAAAQEDAgICBQAEAQAAAAAEAAEABgICBQUAAwAAAAAAAQQAAAAAAAAHAAADAAAAAwADAQECAwACAgICAAQDAAEDAwEBAQAAAAAAAAAAAAAAAgIAAAICAAQBAQMGAAECAgAEBQAFAAQBAAAEAQAAAAQAAAADAAABCAIAAAMAAwAAAAQAAQAGAgIFBQADAAAAAAAAAAAAAAABBAAAAAAHAAIDAAICAgIAAAQAAAADAAEIAgAAAwADAQAAAAQAAQAGAgIFBQADAAAAAAAAAAAAAAABBAAAAAAHAAMAAAMDAQIDAAICAgIAAQACAgAGAAAABgAAAQEAAAEAAAEAAQABAAEBAAIAAAMGAAAAAQgAAgQAAAgAAwcHBQABAAQAAAEAAgQAAgABAAAAAAQAAAAABwAAAAAAAAAAAAACAgABAAQAAAAAAQABAAAAAAAAAAIDAgMAAAICAAMBAgEAAAMAAAEBAQAAAgEAAQARCwAAAgEBAQEBAQEAAAEBAgIADAQBAgIAAAEAAAEACgMCAQEBAQAAAQAFAAUABAEAAAACAgQEAgEAAAAIAgAAAAICAAQBAQAEAwMDAgACAgMEAggJCgMEAQIBAgABAAAEAAEABgICBQUAAwAAAAAAAQQAAAAAAAAHAAAAAgMAAgICAgAEAAMAAQMDAAAAAAAABAEAAAABAAICAQAEAAAAAwAAAQgCAAADAAMAAAAEAAEABgICBQUAAwAAAAAAAAAAAAAAAQQAAAAABwACAwACAgICAAEABAAAAAABAAAEAAAABwAGAAABBAEAAAAAAAQABAABBAQAAAcAAgAAAAIAAAAAAAQAAAAABAAEBwAAAAAAAQABBwEEAAAAAAAABQUAAgAAAgIDAgMAAQEABQIFAgUCAgABAAgBBAEAAAgAAAwCBgICAgABAQAAAQkKAwECAQEBAQAEBAAIBAQBBgMAAwMCAgIDBAIICQoDBAECAQECAgEBBAMEAQQECDEhAQQGAAADAgICAhAAAAEAAAMDAwEBAQMBAwEDAAEEAxAMAAIhAQICMAICAgIAAgIDAwMDAwMBAwMABgAABAMABgAAAQQAAAAEAAEEBAAAAwAAAAACAAAAAAAEAAQDAAAAAAABAAEDAAAAAAICAwIDAgICAwQICQoDBAQEAgUCBQIAAQECBgYEAwQAAAMDBAAAAAECBgQAAAQEAAYABAQAAQIDAwQICQoDBAQABQMCAwICAgAAAgEAAwMDAQUCAQADAwUCBQICAAUCAwMCCAkKAwQBAAAAAgIBAQADCQEAEhwBAQEEAgIEAQAFAAQBAAAABAAAAAMAAAEIAgAAAwADAAAABAABAAYCAgUFAAMAAAAAAAAAAAAAAAEEAAAAAAcAAgMAAgICAgABAwIICQoDBAQIBAQEAQQAAAgBAQESGwABAgIABAUDBAgJCgMECAQEBAEGAwADAwEFAgYFBgMDAwICAiorAAAAAAYAAAEAAwAAAAABAAICCQACBwABAAAAAQACAAABAAAAAAAAAAAGAAAAAwIFAwEAAAAAAQEDAAgBAw0GDggCAAAAASkAAAAAAAUAAAACBwAAAgEAAAABAQAFAgYJBCUBAQAABQAAAQADAwAAAAAAAAAAAAEBBAECAAEBBAQDAAIFAgAAAQICAAAEAAUFBQcBAQAABgYBAQICAQECAAEBAQMBAAAAAAECAAABAAMAAAABAwEAAR0AAQQEAAAGDQAGBgMAAgIAARYGAAAAAAAAAAUABAEAAAAEAAAGAAABCAIAAAYABgQAAAAEAAEABgICBQUAAwAAAAAAAAAAAAAAAQQAAAAABwADAAADAAMCAwACAgICAAAAAAQBAAAEAQAABAEAAAAAAAABAQAEAQAAAAQBAAAAAAAEAQAAAAQAAAAAAAAABAAAAAABAAAAAAABAAAAAgIAAAAEAAAAAwABCAIAAAMAAwAAAAQAAQAFBgICBQUAAwAAAAAAAAAAAAAAAQQAAAAABwACAwACAgICAAMDAgICAAMBBAQBAQACAAEAAAABAAICAAAAAQEAAAABBQEBAQEAAQAAAAoABwAAAgAAAScBAQAADg0ONAAABQEBBQAAAQAABAACAQIAAgACAQQEAAICAAAAAQAAAAIAAAQEAAAAAAEAAAAAAAAACAIAAAAACAIAAAAIAgAAAAQAAQAFBgIAAgUFAAMAAAAAAAEEAAAAAAAABwAAAAIDAAICAgIAAAAEAAEABQYCAAIFBQADAAAAAAABBAAAAAAAAAcAAAACAwACAgICAAAABAABAAUGAgACBQUAAwAAAAAAAQQAAAAAAAAHAAAAAgMAAgICAgADAQEEAgIBAwQCCAkKAwQABD0fAAAADgEBAgIABAQBAAAEAQEAAAQCAAAEBgEBBAQAAgIEAAMAAQMDAAAAAAAAAAQEAAMCAAECAAQEBAIAAAECAwEABAEAAAACAAADAAAEAAEAAgIABAQAAwABAwMAAAAAAAAACAkAAwAGAAABAQAABAAABAQBAAABBAQAAAMAAAAAAgEAAAQAAAIAAQEIBggJCAAWCRYAAAAQDQAAAgAABAAEAwAAAAAAAAEAAQMAAAAAAgIDAgMAAgIBBgEABAAAAAMAAAEIAgAAAwADAAAABAABAAUGAgIFBQADAAAAAAAAAAAAAAABBAAAAAAHAAIDAAICAgIAAQAABAEAAQAAAQAEBAQIAwMDAwEAAAEAAAMFAQEBAAAAAAkEAQEAAAYCAgcCAAIAAgICAQACAAgAAAAIBwkLCQsIBwQCAAIAADMAAQECDTUNGAAAEwMDAwIDAQICAgMZAQABAwEZAxgNASADAw4DEw0TEwAAAQEEDQMDAwIEAAAABwcLAAQCIAADAQYOAgYAAQ0GAAADAwMDBQYCAwAAMgIBBSwABgIABgADAAADAAMAAAAAAgAAAwAAAAEEBAADAAAAAAIABAAEAAABAAEDAAAAAgADAwACAgEGAQAEAAAAAwAAAQgCAAADAAMAAAAEAAEABQYCAgUFAAMAAAAAAAAAAAAAAAEEAAAAAAcAAgMAAgICAgABAAAEAAEEBAEBBAIAAAEAAgIEAAMAAQMDAAAAAAAAAAMFAgIGAgIHAAICAgICAQEAAAEBBAICAAEBAAEBAQQCAgABAQABAAICAAQBAAECAgAEAQACAAIABAAAAwABCAIAAAMAAwAAAAQAAQAGAgIFBQADAAAAAAAAAAAAAAEAAQQAAAAABwACAwACAgICAAEHBwcAAgICAAMDAwUCBQIFAgIAAQMDAggJCgMEAAAAAAICAQEAAwkBABIcAQEBBAICBAEABQAEAQAAAAQAAAADAAABCAIAAAMAAwAA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eCB3IHhGIXlBASF6QQEheyB5IHtxIXwgeiF9AkAgfA0AIAUoArACIX4gBSgC2AEhf0EUIYABIH8ggAFqIYEBIIEBEA0hggEgfiGDASCCASGEASCDASCEAUYhhQEghQEhfQsgfSGGASAFKALcASGHAUEBIYgBIIYBIIgBcSGJASCHASCJAToAIEHoASGKASAFIIoBaiGLASCLASGMASCMARCXAhoMAAsAC0GgAiGNASAFII0BaiGOASCOASGPASCPARCYAiGQASAFIJABNgLQAUGgAiGRASAFIJEBaiGSASCSASGTASCTARCZAiGUASAFIJQBNgLIASAFKALQASGVASAFKALIASGWAUEDIZcBIJUBIJYBIJcBEJsCQaACIZgBIAUgmAFqIZkBIJkBIZoBIJoBEJgCIZsBIAUgmwE2AsABAkADQEGgAiGcASAFIJwBaiGdASCdASGeASCeARCZAiGfASAFIJ8BNgK4AUHAASGgASAFIKABaiGhASChASGiAUG4ASGjASAFIKMBaiGkASCkASGlASCiASClARCUAiGmAUEBIacBIKYBIKcBcSGoASCoAUUNAUHAASGpASAFIKkBaiGqASCqASGrAUEBIawBIKsBIKwBEJwCIa0BIAUgrQE2ArABQcABIa4BIAUgrgFqIa8BIK8BIbABILABEJ0CIbEBILEBLQAgIbIBQQEhswEgsgEgswFxIbQBAkAgtAFFDQADQEGgAiG1ASAFILUBaiG2ASC2ASG3ASC3ARCZAiG4ASAFILgBNgKoAUGwASG5ASAFILkBaiG6ASC6ASG7AUGoASG8ASAFILwBaiG9ASC9ASG+ASC7ASC+ARCUAiG/AUEAIcABQQEhwQEgvwEgwQFxIcIBIMABIcMBAkAgwgFFDQBBsAEhxAEgBSDEAWohxQEgxQEhxgEgxgEQnQIhxwEgxwEtACAhyAFBACHJAUEBIcoBIMgBIMoBcSHLASDJASHDASDLAUUNAEGwASHMASAFIMwBaiHNASDNARCdAiHOAUEYIc8BIM4BIM8BaiHQASDQASkDACGABCDOASkDECGBBEHAASHRASAFINEBaiHSASDSARCdAiHTASDTASDPAWoh1AEg1AEpAwAhggQg0wEpAxAhgwQggQQggAQggwQgggQQpRoh1QEg1QFFIdYBINYBIcMBCyDDASHXAUEBIdgBINcBINgBcSHZAQJAINkBRQ0AQbABIdoBIAUg2gFqIdsBINsBIdwBINwBEJcCGgwBCwsLQaABId0BIAUg3QFqId4BIN4BId8BQcABIeABIAUg4AFqIeEBIOEBIeIBIOIBKAIAIeMBIN8BIOMBNgIAAkADQEGgASHkASAFIOQBaiHlASDlASHmAUGwASHnASAFIOcBaiHoASDoASHpASDmASDpARCeAiHqAUEBIesBIOoBIOsBcSHsASDsAUUNAUGgASHtASAFIO0BaiHuASDuASHvASDvARCdAiHwASDwASgCCCHxASAFIPEBNgKcAUGgASHyASAFIPIBaiHzASDzASH0ASD0ARCdAiH1ASD1ASgCCCH2AUEMIfcBIPYBIPcBaiH4ASD4ARANIfkBQaABIfoBIAUg+gFqIfsBIPsBIfwBIPwBEJ0CIf0BIP0BKAIIIf4BQRQh/wEg/gEg/wFqIYACIIACEA0hgQIg+QEhggIggQIhgwIgggIggwJHIYQCQQEhhQIghAIghQJxIYYCAkAghgJFDQAgBSgCsAIhhwIgBSgCnAEhiAJBDCGJAiCIAiCJAmohigIgigIQDSGLAiCHAiGMAiCLAiGNAiCMAiCNAkYhjgJBoAEhjwIgBSCPAmohkAIgkAIhkQIgkQIQnQIhkgJBASGTAiCOAiCTAnEhlAIgkgIglAI6ACEgBSgCsAIhlQIgBSgCnAEhlgJBFCGXAiCWAiCXAmohmAIgmAIQDSGZAiCVAiGaAiCZAiGbAiCaAiCbAkYhnAJBoAEhnQIgBSCdAmohngIgngIhnwIgnwIQnQIhoAJBASGhAiCcAiChAnEhogIgoAIgogI6ACILQaABIaMCIAUgowJqIaQCIKQCIaUCIKUCEJcCGgwACwALIAUoArACIaYCQcABIacCIAUgpwJqIagCIKgCEJ0CIakCQRghqgIgqQIgqgJqIasCIKsCKQMAIYQEIKkCKQMQIYUEQZgBIawCIAUgrAJqIa0CIK0CIa4CQcABIa8CIAUgrwJqIbACILACIbECILECKAIAIbICIK4CILICNgIAQZABIbMCIAUgswJqIbQCILQCIbUCQbABIbYCIAUgtgJqIbcCILcCIbgCILgCKAIAIbkCILUCILkCNgIAIAUoApgBIboCIAUoApABIbsCQbgCIbwCIAUgvAJqIb0CIKYCIIUEIIQEILoCILsCIAIgvQIQnwIDQEHAASG+AiAFIL4CaiG/AiC/AiHAAkGwASHBAiAFIMECaiHCAiDCAiHDAiDAAiDDAhCeAiHEAkEAIcUCQQEhxgIgxAIgxgJxIccCIMUCIcgCAkAgxwJFDQBBwAEhyQIgBSDJAmohygIgygIhywIgywIQnQIhzAIgzAIoAgghzQJBDCHOAiDNAiDOAmohzwIgzwIQDSHQAkHAASHRAiAFINECaiHSAiDSAiHTAiDTAhCdAiHUAiDUAigCCCHVAkEUIdYCINUCINYCaiHXAiDXAhANIdgCINACIdkCINgCIdoCINkCINoCRyHbAkEBIdwCQQEh3QIg2wIg3QJxId4CINwCId8CAkAg3gINAEHAASHgAiAFIOACaiHhAiDhAiHiAiDiAhCdAiHjAiDjAi0AIiHkAiDkAiHfAgsg3wIh5QIg5QIhyAILIMgCIeYCQQEh5wIg5gIg5wJxIegCAkAg6AJFDQBBwAEh6QIgBSDpAmoh6gIg6gIh6wIg6wIQlwIaDAELC0GIASHsAiAFIOwCaiHtAiDtAiHuAkHAASHvAiAFIO8CaiHwAiDwAiHxAiDxAigCACHyAiDuAiDyAjYCAAJAA0BBiAEh8wIgBSDzAmoh9AIg9AIh9QJBsAEh9gIgBSD2Amoh9wIg9wIh+AIg9QIg+AIQngIh+QJBASH6AiD5AiD6AnEh+wIg+wJFDQFBiAEh/AIgBSD8Amoh/QIg/QIQnQIh/gIg/gIoAggh/wJBFCGAAyD/AiCAA2ohgQMggQMQDiGCA0EYIYMDIAUggwNqIYQDIIQDIIIDELEaQSAhhQMgBSCFA2ohhgMghgMpAwAhhgQgBSkDGCGHBEGIASGHAyAFIIcDaiGIAyCIAxCdAiGJA0EYIYoDIIkDIIoDaiGLAyCLAyCGBDcDACCJAyCHBDcDEEGIASGMAyAFIIwDaiGNAyCNAyGOAyCOAxCdAiGPA0EAIZADII8DIJADOgAhQYgBIZEDIAUgkQNqIZIDIJIDIZMDIJMDEJ0CIZQDQQEhlQMglAMglQM6ACJBiAEhlgMgBSCWA2ohlwMglwMhmAMgmAMQlwIaDAALAAsMAAsAC0GgAiGZAyAFIJkDaiGaAyCaAyGbAyCbAxCSAiGcAyAFIJwDNgJwQaACIZ0DIAUgnQNqIZ4DIJ4DIZ8DIJ8DEJMCIaADIAUgoAM2AmggBSgCcCGhAyAFKAJoIaIDIKEDIKIDEKACIaMDIAUgowM2AnhBgAEhpAMgBSCkA2ohpQMgpQMhpgNB+AAhpwMgBSCnA2ohqAMgqAMhqQNBACGqAyCmAyCpAyCqAxChAhpBoAIhqwMgBSCrA2ohrAMgrAMhrQMgrQMQkwIhrgMgBSCuAzYCUEHYACGvAyAFIK8DaiGwAyCwAyGxA0HQACGyAyAFILIDaiGzAyCzAyG0A0EAIbUDILEDILQDILUDEKECGiAFKAKAASG2AyAFKAJYIbcDQaACIbgDIAUguANqIbkDILkDIboDILoDILYDILcDEKICIbsDIAUguwM2AkgQowIhvAMgBSC8AzYCsAJBoAIhvQMgBSC9A2ohvgMgvgMhvwMgBSC/AzYCRCAFKAJEIcADIMADEJICIcEDIAUgwQM2AkAgBSgCRCHCAyDCAxCTAiHDAyAFIMMDNgI4AkADQEHAACHEAyAFIMQDaiHFAyDFAyHGA0E4IccDIAUgxwNqIcgDIMgDIckDIMYDIMkDEJQCIcoDQQEhywMgygMgywNxIcwDIMwDRQ0BQcAAIc0DIAUgzQNqIc4DIM4DIc8DIM8DEJUCIdADIAUg0AM2AjQgBSgCNCHRAyDRAygCCCHSA0EUIdMDINIDINMDaiHUAyDUAxANIdUDIAUg1QM2AjBBsAIh1gMgBSDWA2oh1wMg1wMh2ANBMCHZAyAFINkDaiHaAyDaAyHbAyDYAyDbAxCkAiHcAyDcAygCACHdAyAFIN0DNgKwAkHAACHeAyAFIN4DaiHfAyDfAyHgAyDgAxCXAhoMAAsAC0HIAiHhAyAFIOEDaiHiAyDiAyHjA0HAAiHkAyAFIOQDaiHlAyDlAyHmAyDjAyDmAxDTASHnA0EBIegDIOcDIOgDcSHpAwJAIOkDRQ0AQcgCIeoDIAUg6gNqIesDIOsDIewDIOwDEOMBIe0DQQwh7gMg7QMg7gNqIe8DIO8DEA0h8AMgBSDwAzYCLEGwAiHxAyAFIPEDaiHyAyDyAyHzA0EsIfQDIAUg9ANqIfUDIPUDIfYDIPMDIPYDEKQCIfcDIPcDKAIAIfgDIAUg+AM2ArACCwwBCwtBoAIh+QMgBSD5A2oh+gMg+gMh+wMg+wMQpQIaC0HQAiH8AyAFIPwDaiH9AyD9AyQADwt5ARB/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhggBCABNgIQQRghBSAEIAVqIQYgBiEHIAcQpwIhCEEQIQkgBCAJaiEKIAohCyALEKcCIQxBCCENIAQgDWohDiAOIQ8gCCAMIA8QqAJBICEQIAQgEGohESARJAAPC9UBAR5/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAhwhBSADIAU2AgggAygCDCEGQQwhByAGIAdqIQggCBANIQkgAygCDCEKQRQhCyAKIAtqIQwgDBANIQ0gCSEOIA0hDyAOIA9GIRBBASERIBAgEXEhEgJAIBJFDQAgAygCCCETQQAhFCAUIBNrIRUgAyAVNgIICyADKAIIIRZBACEXIBYhGCAXIRkgGCAZSCEaQQEhGyAaIBtxIRxBECEdIAMgHWohHiAeJAAgHA8LgwEBDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQKCEGIAQhByAHIAYQqQEaIAQoAgghCCAIECghCSAEKAIMIQogCiAJEOgBGiAEIQsgCxAoIQwgBCgCCCENIA0gDBDoARpBECEOIAQgDmohDyAPJAAPC6UBARJ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgggBCgCCCEFIAQgBTYCDCAFEB8aIAEQqQIhBkEAIQcgBiEIIAchCSAIIAlLIQpBASELIAogC3EhDAJAIAxFDQAgARCpAiENIAUgDRCqAiABEKsCIQ4gARCsAiEPIAEQqQIhECAFIA4gDyAQEK0CCyAEKAIMIRFBECESIAQgEmohEyATJAAgEQ8LSwEJfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIAIQYgBCgCCCEHQQwhCCAHIAhsIQkgBiAJaiEKIAoPC0sBCX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCACEGIAQoAgghB0EDIQggByAIdCEJIAYgCWohCiAKDwtoAQp/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBhCuAiEHIAUgBzYCACAEKAIIIQggCBCvAiEJIAUgCTYCBEEQIQogBCAKaiELIAskACAFDwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgAhBSAFELACIQZBECEHIAMgB2ohCCAIJAAgBg8LoQEBF38jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCACEGIAQoAgghByAHKAIAIQggBiEJIAghCiAJIApGIQtBACEMQQEhDSALIA1xIQ4gDCEPAkAgDkUNACAFKAIEIRAgBCgCCCERIBEoAgQhEiAQIRMgEiEUIBMgFEYhFSAVIQ8LIA8hFkEBIRcgFiAXcSEYIBgPC0wBC38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBCgCBCEGIAUhByAGIQggByAIRiEJQQEhCiAJIApxIQsgCw8LoQEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAFECchByAHKAIAIQggBiEJIAghCiAJIApJIQtBASEMIAsgDHEhDQJAAkAgDUUNACAEKAIIIQ4gDhCxAiEPIAUgDxCyAgwBCyAEKAIIIRAgEBCxAiERIAUgERCzAgtBECESIAQgEmohEyATJAAPC3oBDn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCBCEFIAQQICEGIAYoAgAhByAFIQggByEJIAggCUkhCkEBIQsgCiALcSEMAkACQCAMRQ0AIAQQtAIMAQsgBBC1AgtBECENIAMgDWohDiAOJAAPC1UBCH8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYoAgAhByAFIAc2AgAgBCgCCCEIIAgoAgQhCSAFIAk2AgQgBQ8LQgEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEELYCIAQQtwIaQRAhBSADIAVqIQYgBiQAIAQPC4UBAQ9/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQMRpBACEFIAQgBTYCAEEAIQYgBCAGNgIEQQghByAEIAdqIQhBACEJIAMgCTYCCEEIIQogAyAKaiELIAshDCADIQ0gCCAMIA0QuAIaQRAhDiADIA5qIQ8gDyQAIAQPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQzwIhBiAEKAIIIQcgBxDPAiEIIAYhCSAIIQogCSAKSSELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIAIQUgBRDVAiEGQRAhByADIAdqIQggCCQAIAYPC1UBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBCgCACEFIAQgBRDWAiEGIAMgBjYCCCADKAIIIQdBECEIIAMgCGohCSAJJAAgBw8LVQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEKAIEIQUgBCAFENYCIQYgAyAGNgIIIAMoAgghB0EQIQggAyAIaiEJIAkkACAHDwvMBgFxfyMAIQVBgAEhBiAFIAZrIQcgByQAIAcgATYCeCAHIAI2AnAgByAANgJsIAMhCCAHIAg6AGsgBCEJIAcgCToAakHwACEKIAcgCmohCyALIQxB+AAhDSAHIA1qIQ4gDiEPIAwgDxDQAiEQIAcgEDYCZEEAIREgByARNgJgAkADQCAHKAJgIRIgBygCZCETIBIhFCATIRUgFCAVSSEWQQEhFyAWIBdxIRggGEUNASAHKAJgIRlB+AAhGiAHIBpqIRsgGyEcIBwgGRDRAiEdIAcgHTYCXCAHKAJgIR5BASEfIB4gH2ohICAHKAJkISEgICEiICEhIyAiICNJISRBASElICQgJXEhJgJAAkAgJkUNACAHKAJgISdBASEoICcgKGohKUH4ACEqIAcgKmohKyArISwgLCApENECIS0gByAtNgJYDAELIActAGshLkEBIS8gLiAvcSEwAkACQCAwRQ0AQfgAITEgByAxaiEyIDIhM0EAITQgMyA0ENECITUgByA1NgJYDAELDAMLCyAHLQBqITZBASE3QQEhOCA2IDhxITkgNyE6AkAgOQ0AIAcoAlwhO0HIACE8IAcgPGohPSA9IT4gPiA7EOIBGkHQACE/IAcgP2ohQCBAIUFByAAhQiAHIEJqIUMgQyFEIEEgRBD4ASAHKAJYIUVBOCFGIAcgRmohRyBHIUggSCBFEOIBGkHAACFJIAcgSWohSiBKIUtBOCFMIAcgTGohTSBNIU4gSyBOEPgBQdAAIU8gByBPaiFQIFAhUUHAACFSIAcgUmohUyBTIVQgUSBUENICIVUgVSE6CyA6IVZBASFXIFYgV3EhWAJAIFhFDQAgBygCbCFZIAcoAlwhWkEQIVsgByBbaiFcIFwhXSBdIFoQ4gEaIAcoAlghXkEIIV8gByBfaiFgIGAhYSBhIF4Q4gEaQRghYiAHIGJqIWMgYyFkQRAhZSAHIGVqIWYgZiFnQQghaCAHIGhqIWkgaSFqQQEha0EBIWwgayBscSFtIGQgZyBqIG0Q0wIaQRghbiAHIG5qIW8gbyFwIFkgcBDUAgsgBygCYCFxQQEhciBxIHJqIXMgByBzNgJgDAALAAtBgAEhdCAHIHRqIXUgdSQADws9AQd/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFQQwhBiAFIAZqIQcgBCAHNgIAIAQPC1wBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCACEFQQghBiAEIAZqIQcgByEIIAggBRDOAhogBCgCCCEJQRAhCiAEIApqIQsgCyQAIAkPC1wBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCACEFQQghBiAEIAZqIQcgByEIIAggBRCNAxogBCgCCCEJQRAhCiAEIApqIQsgCyQAIAkPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQpwIhBiAEKAIIIQcgBxCnAiEIIAYhCSAIIQogCSAKRiELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LPQEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEI4DGkEQIQUgAyAFaiEGIAYkACAEDwtlAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEKcCIQYgBCgCCCEHIAcQpwIhCCAGIAhrIQlBBSEKIAkgCnUhC0EQIQwgBCAMaiENIA0kACALDwu0AQEUfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGIAUQjwMhByAGIQggByEJIAggCUshCkEBIQsgCiALcSEMAkAgDEUNACAFEJADIQ0gBCANNgIUIAQoAhghDiAFEIACIQ8gBCgCFCEQIAQhESARIA4gDyAQEJEDGiAEIRIgBSASEJIDIAQhEyATEJMDGgtBICEUIAQgFGohFSAVJAAPC0sBCX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCACEGIAQoAgghB0EFIQggByAIdCEJIAYgCWohCiAKDwtDAQd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgARANIQUgARAOIQYgACAFIAYQHBpBECEHIAQgB2ohCCAIJAAPC2IBCX8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAGEKABIQcgBSgCBCEIIAgQoAEhCSAAIAcgCRCbAxpBECEKIAUgCmohCyALJAAPC1sBCX8jACEDQRAhBCADIARrIQUgBSQAIAUgATYCDCAFIAI2AgggBSgCDCEGIAYQnAMhByAFKAIIIQggCBCdAyEJIAAgByAJEJ4DGkEQIQogBSAKaiELIAskAA8LYgEJfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAYQmAMhByAFKAIEIQggCBCZAyEJIAAgByAJEJoDGkEQIQogBSAKaiELIAskAA8LogEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAFEJQDIQcgBygCACEIIAYhCSAIIQogCSAKSSELQQEhDCALIAxxIQ0CQAJAIA1FDQAgBCgCCCEOIA4QlQMhDyAFIA8QlgMMAQsgBCgCCCEQIBAQlQMhESAFIBEQlwMLQRAhEiAEIBJqIRMgEyQADwtVAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQoAgAhBSAEIAUQsgMhBiADIAY2AgggAygCCCEHQRAhCCADIAhqIQkgCSQAIAcPC1UBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBCgCBCEFIAQgBRCyAyEGIAMgBjYCCCADKAIIIQdBECEIIAMgCGohCSAJJAAgBw8LsgwBxwF/IwAhA0GQASEEIAMgBGshBSAFJAAgBSABNgKIASAFIAI2AoABIAUgADYCfEHwACEGIAUgBmohByAHIQggCBCfAxpB4AAhCSAFIAlqIQogCiELIAsQoAMaQdAAIQwgBSAMaiENIA0hDiAOEKADGkEAIQ8gBSAPNgJMAkADQEGIASEQIAUgEGohESARIRJBgAEhEyAFIBNqIRQgFCEVIBIgFRCCAiEWQQEhFyAWIBdxIRggGEUNAUGIASEZIAUgGWohGiAaIRsgGxCDAiEcQRAhHSAcIB1qIR5B8AAhHyAFIB9qISAgICEhICEgHhChA0GIASEiIAUgImohIyAjISQgJBCDAiElIAUoAkwhJkEBIScgJiAnaiEoIAUgKDYCTCAFICY2AjRBOCEpIAUgKWohKiAqIStBNCEsIAUgLGohLSAtIS4gKyAlIC4QogNB4AAhLyAFIC9qITAgMCExQTghMiAFIDJqITMgMyE0IDEgNBCjA0GIASE1IAUgNWohNiA2ITcgNxCIAhoMAAsAC0HgACE4IAUgOGohOSA5ITogOhCkAyE7IAUgOzYCMEHgACE8IAUgPGohPSA9IT4gPhClAyE/IAUgPzYCKCAFKAIwIUAgBSgCKCFBQdAAIUIgBSBCaiFDIEMhRCBEIEAgQRCmA0EAIUUgBSBFNgIkAkADQCAFKAIkIUZB0AAhRyAFIEdqIUggSCFJIEkQpwMhSiBGIUsgSiFMIEsgTEkhTUEBIU4gTSBOcSFPIE9FDQEgBSgCfCFQIAUoAiQhUUHQACFSIAUgUmohUyBTIVQgVCBREKgDIVUgBSgCJCFWQdAAIVcgBSBXaiFYIFghWSBZIFYQqAMhWiBaKAIQIVtB8AAhXCAFIFxqIV0gXSFeIF4gWxCpAyFfQQghYCAFIGBqIWEgYSFiIGIgVSBfEKoDQQghYyAFIGNqIWQgZCFlIFAgZRCrAyAFIWYgZhCsAxogBSgCfCFnIGcQrQMhaCAFKAJ8IWkgaRCtAyFqQQghayBqIGtqIWwgBSFtIG0gaCBsEK4DIW5BASFvIG4gb3EhcCAFKAIkIXFB0AAhciAFIHJqIXMgcyF0IHQgcRCoAyF1IHUoAhAhdkHgACF3IAUgd2oheCB4IXkgeSB2EKgDIXogBSgCJCF7QdAAIXwgBSB8aiF9IH0hfiB+IHsQqAMhfyB/KAIQIYABQeAAIYEBIAUggQFqIYIBIIIBIYMBIIMBIIABEKgDIYQBQQghhQEghAEghQFqIYYBIAUhhwEghwEgeiCGARCuAyGIAUEBIYkBIIgBIIkBcSGKASBwIYsBIIoBIYwBIIsBIIwBRyGNAUEBIY4BII0BII4BcSGPAQJAII8BRQ0AIAUoAnwhkAEgkAEQrQMhkQEgkQEoAhQhkgFBfyGTASCSASCTAWwhlAEgkQEglAE2AhQLIAUoAiQhlQFB0AAhlgEgBSCWAWohlwEglwEhmAEgmAEglQEQqAMhmQEgmQEoAhAhmgFB4AAhmwEgBSCbAWohnAEgnAEhnQEgnQEgmgEQqAMhngEgngEQrwMhnwFBASGgASCfASCgAXEhoQECQCChAQ0AIAUoAnwhogEgogEQrQMhowEgowEQrwMhpAFBASGlASCkASClAXEhpgEgpgFFDQAgBSgCfCGnASCnARCtAyGoASCoASgCFCGpAUF/IaoBIKkBIKoBbCGrASCoASCrATYCFAsgBSgCfCGsASCsARCtAyGtAUEIIa4BIK0BIK4BaiGvASAFKAJ8IbABILABEK0DIbEBIAUhsgEgsgEgrwEgsQEQrgMhswFBASG0ASCzASC0AXEhtQECQCC1AUUNACAFKAJ8IbYBILYBEK0DIbcBIAUoAnwhuAEguAEQrQMhuQFBCCG6ASC5ASC6AWohuwEgtwEguwEQ3gELIAUoAiQhvAFBASG9ASC8ASC9AWohvgEgBSC+ATYCJAwACwALQdAAIb8BIAUgvwFqIcABIMABIcEBIMEBELADGkHgACHCASAFIMIBaiHDASDDASHEASDEARCwAxpB8AAhxQEgBSDFAWohxgEgxgEhxwEgxwEQsQMaQZABIcgBIAUgyAFqIckBIMkBJAAPC0QBCX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCgCACEGIAUgBmshB0EYIQggByAIbSEJIAkPC7QBARR/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAEKAIYIQYgBRC9AiEHIAYhCCAHIQkgCCAJSyEKQQEhCyAKIAtxIQwCQCAMRQ0AIAUQwAIhDSAEIA02AhQgBCgCGCEOIAUQ1gEhDyAEKAIUIRAgBCERIBEgDiAPIBAQ5AIaIAQhEiAFIBIQ5QIgBCETIBMQ5gIaC0EgIRQgBCAUaiEVIBUkAA8LZAEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhCzAyEHQX8hCCAHIAhzIQlBASEKIAkgCnEhC0EQIQwgBCAMaiENIA0kACALDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC98BAhl/AX4jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGKAIAIQcgBSAHNgIAQQQhCCAFIAhqIQkgBCgCCCEKQQQhCyAKIAtqIQwgDCkCACEbIAkgGzcCAEEMIQ0gBSANaiEOIAQoAgghD0EMIRAgDyAQaiERIA4gERCpARpBFCESIAUgEmohEyAEKAIIIRRBFCEVIBQgFWohFiATIBYQqQEaIAQoAgghFyAXKAIcIRggBSAYNgIcQRAhGSAEIBlqIRogGiQAIAUPC18BCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQhBkEAIQcgBiAHEA8aIAQoAgghCCAEIQkgBSAJIAgQtANBECEKIAQgCmohCyALJAAPC18BCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQhBkEBIQcgBiAHEA8aIAQoAgghCCAEIQkgBSAJIAgQtANBECEKIAQgCmohCyALJAAPC5QBARB/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIEIQYgBRDYAiEHIAcoAgAhCCAGIQkgCCEKIAkgCkchC0EBIQwgCyAMcSENAkACQCANRQ0AIAQoAgghDiAFIA4QtQMMAQsgBCgCCCEPIAUgDxC2AwtBECEQIAQgEGohESARJAAPCz0BB38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQVBGCEGIAUgBmohByAEIAc2AgAgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC0wBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQtwNBECEHIAQgB2ohCCAIJAAgBQ8LQgEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEELgDIAQQuQMaQRAhBSADIAVqIQYgBiQAIAQPC4EBARJ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBUEMIQYgBSAGaiEHIAcQDSEIIAQoAgghCUEMIQogCSAKaiELIAsQDSEMIAghDSAMIQ4gDSAOSCEPQQEhECAPIBBxIRFBECESIAQgEmohEyATJAAgEQ8LgAEBEH8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCGCAFIAE2AhAgBSACNgIMQRghBiAFIAZqIQcgByEIIAgQpwIhCUEQIQogBSAKaiELIAshDCAMEKcCIQ1BDCEOIAUgDmohDyAPIRAgCSANIBAQ4ApBICERIAUgEWohEiASJAAPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDpChpBECEFIAMgBWohBiAGJAAgBA8LTAELfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAEKAIEIQYgBSEHIAYhCCAHIAhGIQlBASEKIAkgCnEhCyALDwuSAQIMfwF+IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEOoKGiAEKAIIIQYgBSAGNgIIQRghByAFIAdqIQhCACEOIAggDjcDACAFIA43AxBBACEJIAUgCToAIEEAIQogBSAKOgAhQQAhCyAFIAs6ACJBECEMIAQgDGohDSANJAAgBQ8LlAEBEH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAFEOsKIQcgBygCACEIIAYhCSAIIQogCSAKRyELQQEhDCALIAxxIQ0CQAJAIA1FDQAgBCgCCCEOIAUgDhDsCgwBCyAEKAIIIQ8gBSAPEO0KC0EQIRAgBCAQaiERIBEkAA8LVQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEKAIAIQUgBCAFEO4KIQYgAyAGNgIIIAMoAgghB0EQIQggAyAIaiEJIAkkACAHDwtVAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQoAgQhBSAEIAUQ7gohBiADIAY2AgggAygCCCEHQRAhCCADIAhqIQkgCSQAIAcPC2QBDH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQ7wohB0F/IQggByAIcyEJQQEhCiAJIApxIQtBECEMIAQgDGohDSANJAAgCw8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwu/AgIkfwJ+IwAhA0HQACEEIAMgBGshBSAFJAAgBSABNgJMIAUgAjYCSCAFKAJMIQYgBSgCSCEHQQwhCCAHIAhqIQlBMCEKIAUgCmohCyALIAkQ4gEaQTghDCAFIAxqIQ1BMCEOIAUgDmohDyANIA8Q+AFBwAAhECAFIBBqIRFBOCESIAUgEmohEyARIBMQ4gEaIAUoAkghFEEUIRUgFCAVaiEWQRghFyAFIBdqIRggGCAWEOIBGkEgIRkgBSAZaiEaQRghGyAFIBtqIRwgGiAcEPgBQSghHSAFIB1qIR5BICEfIAUgH2ohICAeICAQ4gEaQcAAISEgBSAhaiEiQSghIyAFICNqISQgBSAGICIgJBCZCSAFKQMAIScgBSkDCCEoIAAgKDcDCCAAICc3AwBB0AAhJSAFICVqISYgJiQADws9AQd/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFQTAhBiAFIAZqIQcgBCAHNgIAIAQPC0wBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBCSAiEFIAMgBTYCCCADKAIIIQZBECEHIAMgB2ohCCAIJAAgBg8LTAEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEEJMCIQUgAyAFNgIIIAMoAgghBkEQIQcgAyAHaiEIIAgkACAGDwuBAQERfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGQRAhByAEIAdqIQggCCEJQQghCiAEIApqIQsgCyEMIAQhDSAFIAYgCSAMIA0Q8gohDkEBIQ8gDiAPcSEQQSAhESAEIBFqIRIgEiQAIBAPC4ABARB/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhggBSABNgIQIAUgAjYCDEEYIQYgBSAGaiEHIAchCCAIEPAKIQlBECEKIAUgCmohCyALIQwgDBDwCiENQQwhDiAFIA5qIQ8gDyEQIAkgDSAQEPEKQSAhESAFIBFqIRIgEiQADwuAAQEPfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQVBCCEGIAQgBmohByAHIQggBSgCACEJIAggCTYCACAEKAIAIQpBCCELIAQgC2ohDCAMIQ0gDSAKEPMKGiAEKAIIIQ5BECEPIAQgD2ohECAQJAAgDg8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIAIQUgBRD0CiEGQRAhByADIAdqIQggCCQAIAYPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ8AohBiAEKAIIIQcgBxDwCiEIIAYhCSAIIQogCSAKSSELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LxAICHX8EfiMAIQdB4AAhCCAHIAhrIQkgCSQAIAkgAzYCWCAJIAQ2AlAgCSAANgJMIAkgAjcDOCAJIAE3AzAgCSAFNgIsIAkgBjYCKCAJKAIsIQogCSgCTCELIAkpAzghJCAJKQMwISUgCSgCWCEMIAkgDDYCICAJKAJQIQ0gCSANNgIYIAkoAiAhDiAJKAIYIQ8gCiALICUgJCAOIA8Q9QogCSgCTCEQIAkpAzghJiAJKQMwISdBECERIAkgEWohEiASIRNB2AAhFCAJIBRqIRUgFSEWIBYoAgAhFyATIBc2AgBBCCEYIAkgGGohGSAZIRpB0AAhGyAJIBtqIRwgHCEdIB0oAgAhHiAaIB42AgAgCSgCKCEfIAkoAhAhICAJKAIIISEgECAnICYgICAhIB8Q9gpB4AAhIiAJICJqISMgIyQADwu4BQJdfwR+IwAhAkHAACEDIAIgA2shBCAEJAAgBCAANgIwIAQgATYCKEEQIQUgBCAFaiEGIAYhB0EwIQggBCAIaiEJIAkhCiAKKAIAIQsgByALNgIAQQghDCAEIAxqIQ0gDSEOQSghDyAEIA9qIRAgECERIBEoAgAhEiAOIBI2AgAgBCgCECETIAQoAgghFEEgIRUgBCAVaiEWIBYhFyATIBQgFxD9CiEYIAQgGDYCGEEwIRkgBCAZaiEaIBohG0EYIRwgBCAcaiEdIB0hHiAeKAIAIR8gGyAfNgIAQTAhICAEICBqISEgISEiQSghIyAEICNqISQgJCElICIgJRCUAiEmQQEhJyAmICdxISgCQCAoRQ0AIAQhKUEwISogBCAqaiErICshLCAsKAIAIS0gKSAtNgIAAkADQCAEIS4gLhCXAiEvQSghMCAEIDBqITEgMSEyIC8gMhCUAiEzQQEhNCAzIDRxITUgNUUNASAEITYgNhCVAiE3QSAhOCAEIDhqITkgOSE6IDogNxD+CiE7QQEhPCA7IDxxIT0CQCA9DQAgBCE+ID4QlQIhPyA/EP8KIUBBMCFBIAQgQWohQiBCIUMgQxCVAiFEIEApAwAhXyBEIF83AwBBHyFFIEQgRWohRiBAIEVqIUcgRygAACFIIEYgSDYAAEEYIUkgRCBJaiFKIEAgSWohSyBLKQMAIWAgSiBgNwMAQRAhTCBEIExqIU0gQCBMaiFOIE4pAwAhYSBNIGE3AwBBCCFPIEQgT2ohUCBAIE9qIVEgUSkDACFiIFAgYjcDAEEwIVIgBCBSaiFTIFMhVCBUEJcCGgsMAAsACwtBOCFVIAQgVWohViBWIVdBMCFYIAQgWGohWSBZIVogWigCACFbIFcgWzYCACAEKAI4IVxBwAAhXSAEIF1qIV4gXiQAIFwPC1oBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxDwCiEIIAYgCDYCAEEQIQkgBSAJaiEKIAokACAGDwvrAgEvfyMAIQNBMCEEIAMgBGshBSAFJAAgBSABNgIgIAUgAjYCGCAFIAA2AhQgBSgCFCEGIAYoAgAhByAGEJICIQggBSAINgIIQSAhCSAFIAlqIQogCiELQQghDCAFIAxqIQ0gDSEOIAsgDhD3CiEPQTAhECAPIBBsIREgByARaiESIAUgEjYCEEEgIRMgBSATaiEUIBQhFUEYIRYgBSAWaiEXIBchGCAVIBgQ+AohGUEBIRogGSAacSEbAkAgG0UNACAFKAIQIRxBGCEdIAUgHWohHiAeIR9BICEgIAUgIGohISAhISIgHyAiEPkKISNBMCEkICMgJGwhJSAcICVqISYgBigCBCEnIAUoAhAhKCAmICcgKBD6CiEpIAYgKRD7CiAFKAIQISpBUCErICogK2ohLCAGICwQ/AoLIAUoAhAhLSAGIC0Q7gohLiAFIC42AiggBSgCKCEvQTAhMCAFIDBqITEgMSQAIC8PCwwBAX8QtwkhACAADwtOAQh/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEKMGIQdBECEIIAQgCGohCSAJJAAgBw8LQgEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEIALIAQQgQsaQRAhBSADIAVqIQYgBiQAIAQPCzoBBn8jACEBQSAhAiABIAJrIQMgAyAANgIEIAMoAgQhBEEAIQUgBCAFNgIEQQAhBiAEIAY2AgggBA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwtaAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAUoAgQhCCAGIAcgCBDdC0EQIQkgBSAJaiEKIAokAA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgQhBSAFDwvLAQEXfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUQZiEHIAYhCCAHIQkgCCAJSyEKQQEhCyAKIAtxIQwCQCAMRQ0AIAUQtRoACyAFEDwhDSAEKAIIIQ4gDSAOEGohDyAFIA82AgQgBSAPNgIAIAUoAgAhECAEKAIIIRFBDCESIBEgEmwhEyAQIBNqIRQgBRAgIRUgFSAUNgIAQQAhFiAFIBYQbkEQIRcgBCAXaiEYIBgkAA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwtEAQl/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAQoAgQhBkEMIQcgBiAHbCEIIAUgCGohCSAJDwuVAQEPfyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIcIAYgATYCGCAGIAI2AhQgBiADNgIQIAYoAhwhByAGKAIQIQggBiEJIAkgByAIEE8aIAcQPCEKIAYoAhghCyAGKAIUIQwgBiENQQQhDiANIA5qIQ8gCiALIAwgDxDpCyAGIRAgEBBSGkEgIREgBiARaiESIBIkAA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LsgEBFX8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFQQghBiAEIAZqIQcgByEIQQEhCSAIIAUgCRCfARogBRBbIQogBCgCDCELIAsQlgEhDCAEKAIYIQ0gDRCxAiEOIAogDCAOEPQLIAQoAgwhD0EIIRAgDyAQaiERIAQgETYCDEEIIRIgBCASaiETIBMhFCAUEKIBGkEgIRUgBCAVaiEWIBYkAA8L2gEBGH8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAUQWyEGIAQgBjYCFCAFEAshB0EBIQggByAIaiEJIAUgCRCjASEKIAUQCyELIAQoAhQhDCAEIQ0gDSAKIAsgDBCkARogBCgCFCEOIAQoAgghDyAPEJYBIRAgBCgCGCERIBEQsQIhEiAOIBAgEhD0CyAEKAIIIRNBCCEUIBMgFGohFSAEIBU2AgggBCEWIAUgFhClASAEIRcgFxCmARpBICEYIAQgGGohGSAZJAAPC4IBAQ9/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAMhBUEBIQYgBSAEIAYQTxogBBA8IQcgAygCBCEIIAgQPyEJIAcgCRD3CyADKAIEIQpBDCELIAogC2ohDCADIAw2AgQgAyENIA0QUhpBECEOIAMgDmohDyAPJAAPC74BARZ/IwAhAUEgIQIgASACayEDIAMkACADIAA2AhwgAygCHCEEIAQQPCEFIAMgBTYCGCAEEAkhBkEBIQcgBiAHaiEIIAQgCBBTIQkgBBAJIQogAygCGCELIAMhDCAMIAkgCiALEFQaIAMoAhghDSADKAIIIQ4gDhA/IQ8gDSAPEPcLIAMoAgghEEEMIREgECARaiESIAMgEjYCCCADIRMgBCATEFUgAyEUIBQQVhpBICEVIAMgFWohFiAWJAAPC6kBARZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQvAIhBSAEELwCIQYgBBC9AiEHQQUhCCAHIAh0IQkgBiAJaiEKIAQQvAIhCyAEENYBIQxBBSENIAwgDXQhDiALIA5qIQ8gBBC8AiEQIAQQvQIhEUEFIRIgESASdCETIBAgE2ohFCAEIAUgCiAPIBQQvgJBECEVIAMgFWohFiAWJAAPC5UBARF/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgggAygCCCEEIAMgBDYCDCAEKAIAIQVBACEGIAUhByAGIQggByAIRyEJQQEhCiAJIApxIQsCQCALRQ0AIAQQvwIgBBDAAiEMIAQoAgAhDSAEEMECIQ4gDCANIA4QwgILIAMoAgwhD0EQIRAgAyAQaiERIBEkACAPDwtsAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQMyEIIAYgCBC5AhogBSgCBCEJIAkQNRogBhC6AhpBECEKIAUgCmohCyALJAAgBg8LVQEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQMxpBACEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQuwIaQRAhBSADIAVqIQYgBiQAIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgAhBSAFEMMCIQZBECEHIAMgB2ohCCAIJAAgBg8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMECIQVBECEGIAMgBmohByAHJAAgBQ8LNwEDfyMAIQVBICEGIAUgBmshByAHIAA2AhwgByABNgIYIAcgAjYCFCAHIAM2AhAgByAENgIMDwtDAQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgAhBSAEIAUQxwJBECEGIAMgBmohByAHJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEMkCIQdBECEIIAMgCGohCSAJJAAgBw8LXgEMfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMQCIQUgBSgCACEGIAQoAgAhByAGIAdrIQhBBSEJIAggCXUhCkEQIQsgAyALaiEMIAwkACAKDwtaAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAUoAgQhCCAGIAcgCBDIAkEQIQkgBSAJaiEKIAokAA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEMUCIQdBECEIIAMgCGohCSAJJAAgBw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMYCIQVBECEGIAMgBmohByAHJAAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC7wBARR/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIEIQYgBCAGNgIEAkADQCAEKAIIIQcgBCgCBCEIIAchCSAIIQogCSAKRyELQQEhDCALIAxxIQ0gDUUNASAFEMACIQ4gBCgCBCEPQWAhECAPIBBqIREgBCARNgIEIBEQwwIhEiAOIBIQygIMAAsACyAEKAIIIRMgBSATNgIEQRAhFCAEIBRqIRUgFSQADwthAQp/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHQQUhCCAHIAh0IQlBBCEKIAYgCSAKEElBECELIAUgC2ohDCAMJAAPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDNAiEFQRAhBiADIAZqIQcgByQAIAUPC0oBB38jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAQoAhghBiAFIAYQywJBICEHIAQgB2ohCCAIJAAPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCBCEFIAQoAgAhBiAFIAYQzAJBECEHIAQgB2ohCCAIJAAPCyIBA38jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCzkBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCACAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC2UBDH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ1wIhBiAEKAIIIQcgBxDXAiEIIAYgCGshCUEDIQogCSAKdSELQRAhDCAEIAxqIQ0gDSQAIAsPC0sBCX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCACEGIAQoAgghB0EDIQggByAIdCEJIAYgCWohCiAKDwtkAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEOQBIQdBfyEIIAcgCHMhCUEBIQogCSAKcSELQRAhDCAEIAxqIQ0gDSQAIAsPC40EAUh/IwAhBEEQIQUgBCAFayEGIAYkACAGIAA2AgggAyEHIAYgBzoAByAGKAIIIQggBiAINgIMIAgQ3AIaQQQhCSAIIAlqIQogChDdAhpBDCELIAggC2ohDCAMIAEQqQEaQRQhDSAIIA1qIQ4gDiACEKkBGkEBIQ8gCCAPNgIcIAYtAAchEEEBIREgECARcSESAkAgEkUNAEEMIRMgCCATaiEUIBQQDSEVQRQhFiAIIBZqIRcgFxANIRggFSEZIBghGiAZIBpKIRtBASEcIBsgHHEhHQJAAkAgHQ0AQQwhHiAIIB5qIR8gHxANISBBFCEhIAggIWohIiAiEA0hIyAgISQgIyElICQgJUYhJkEBIScgJiAncSEoIChFDQFBDCEpIAggKWohKiAqEA4hK0EUISwgCCAsaiEtIC0QDiEuICshLyAuITAgLyAwSiExQQEhMiAxIDJxITMgM0UNAQtBDCE0IAggNGohNUEUITYgCCA2aiE3IDUgNxDeASAIKAIcIThBfyE5IDggOWwhOiAIIDo2AhwLQQwhOyAIIDtqITwgPBANIT1BFCE+IAggPmohPyA/EA0hQCA9IUEgQCFCIEEgQkYhQ0EBIUQgQyBEcSFFAkAgRUUNACAIKAIcIUZBfyFHIEYgR2whSCAIIEg2AhwLCyAGKAIMIUlBECFKIAYgSmohSyBLJAAgSQ8LogEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAFENgCIQcgBygCACEIIAYhCSAIIQogCSAKSSELQQEhDCALIAxxIQ0CQAJAIA1FDQAgBCgCCCEOIA4Q2QIhDyAFIA8Q2gIMAQsgBCgCCCEQIBAQ2QIhESAFIBEQ2wILQRAhEiAEIBJqIRMgEyQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LXAEKfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIAIQVBCCEGIAQgBmohByAHIQggCCAFEIwDGiAEKAIIIQlBECEKIAQgCmohCyALJAAgCQ8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhDeAiEHQRAhCCADIAhqIQkgCSQAIAcPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwuzAQEVfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQVBCCEGIAQgBmohByAHIQhBASEJIAggBSAJEN8CGiAFEMACIQogBCgCDCELIAsQwwIhDCAEKAIYIQ0gDRDgAiEOIAogDCAOEOECIAQoAgwhD0EgIRAgDyAQaiERIAQgETYCDEEIIRIgBCASaiETIBMhFCAUEOICGkEgIRUgBCAVaiEWIBYkAA8L3QEBGH8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAUQwAIhBiAEIAY2AhQgBRDWASEHQQEhCCAHIAhqIQkgBSAJEOMCIQogBRDWASELIAQoAhQhDCAEIQ0gDSAKIAsgDBDkAhogBCgCFCEOIAQoAgghDyAPEMMCIRAgBCgCGCERIBEQ4AIhEiAOIBAgEhDhAiAEKAIIIRNBICEUIBMgFGohFSAEIBU2AgggBCEWIAUgFhDlAiAEIRcgFxDmAhpBICEYIAQgGGohGSAZJAAPCy8BBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBEEAIQUgBCAFNgIAIAQPC1ABCH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBEEAIQUgBCAFOgAAQQAhBiAEIAY6AAFBACEHIAQgBzoAAkEAIQggBCAINgIEIAQPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDnAiEFQRAhBiADIAZqIQcgByQAIAUPC4MBAQ1/IwAhA0EQIQQgAyAEayEFIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBiAHNgIAIAUoAgghCCAIKAIEIQkgBiAJNgIEIAUoAgghCiAKKAIEIQsgBSgCBCEMQQUhDSAMIA10IQ4gCyAOaiEPIAYgDzYCCCAGDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSgCHCEGIAUoAhghByAFKAIUIQggCBDgAiEJIAYgByAJEOgCQSAhCiAFIApqIQsgCyQADws5AQZ/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFIAQoAgAhBiAGIAU2AgQgBA8LsgIBJX8jACECQSAhAyACIANrIQQgBCQAIAQgADYCGCAEIAE2AhQgBCgCGCEFIAUQ6wIhBiAEIAY2AhAgBCgCFCEHIAQoAhAhCCAHIQkgCCEKIAkgCkshC0EBIQwgCyAMcSENAkAgDUUNACAFELUaAAsgBRC9AiEOIAQgDjYCDCAEKAIMIQ8gBCgCECEQQQEhESAQIBF2IRIgDyETIBIhFCATIBRPIRVBASEWIBUgFnEhFwJAAkAgF0UNACAEKAIQIRggBCAYNgIcDAELIAQoAgwhGUEBIRogGSAadCEbIAQgGzYCCEEIIRwgBCAcaiEdIB0hHkEUIR8gBCAfaiEgICAhISAeICEQZyEiICIoAgAhIyAEICM2AhwLIAQoAhwhJEEgISUgBCAlaiEmICYkACAkDwuuAgEgfyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIYIAYgATYCFCAGIAI2AhAgBiADNgIMIAYoAhghByAGIAc2AhxBDCEIIAcgCGohCUEAIQogBiAKNgIIIAYoAgwhC0EIIQwgBiAMaiENIA0hDiAJIA4gCxDsAhogBigCFCEPAkACQCAPRQ0AIAcQ7QIhECAGKAIUIREgECAREO4CIRIgEiETDAELQQAhFCAUIRMLIBMhFSAHIBU2AgAgBygCACEWIAYoAhAhF0EFIRggFyAYdCEZIBYgGWohGiAHIBo2AgggByAaNgIEIAcoAgAhGyAGKAIUIRxBBSEdIBwgHXQhHiAbIB5qIR8gBxDvAiEgICAgHzYCACAGKAIcISFBICEiIAYgImohIyAjJAAgIQ8L+wEBG38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQtgIgBRDAAiEGIAUoAgAhByAFKAIEIQggBCgCCCEJQQQhCiAJIApqIQsgBiAHIAggCxDwAiAEKAIIIQxBBCENIAwgDWohDiAFIA4Q8QJBBCEPIAUgD2ohECAEKAIIIRFBCCESIBEgEmohEyAQIBMQ8QIgBRDYAiEUIAQoAgghFSAVEO8CIRYgFCAWEPECIAQoAgghFyAXKAIEIRggBCgCCCEZIBkgGDYCACAFENYBIRogBSAaEPICIAUQ8wJBECEbIAQgG2ohHCAcJAAPC5UBARF/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgggAygCCCEEIAMgBDYCDCAEEPQCIAQoAgAhBUEAIQYgBSEHIAYhCCAHIAhHIQlBASEKIAkgCnEhCwJAIAtFDQAgBBDtAiEMIAQoAgAhDSAEEPUCIQ4gDCANIA4QwgILIAMoAgwhD0EQIRAgAyAQaiERIBEkACAPDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIUIAUgATYCECAFIAI2AgwgBSgCFCEGIAUoAhAhByAFKAIMIQggCBDgAiEJIAYgByAJEOkCQSAhCiAFIApqIQsgCyQADwtZAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHIAcQ4AIhCCAGIAgQ6gIaQRAhCSAFIAlqIQogCiQADwvfAQIZfwF+IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBigCACEHIAUgBzYCAEEEIQggBSAIaiEJIAQoAgghCkEEIQsgCiALaiEMIAwpAgAhGyAJIBs3AgBBDCENIAUgDWohDiAEKAIIIQ9BDCEQIA8gEGohESAOIBEQqQEaQRQhEiAFIBJqIRMgBCgCCCEUQRQhFSAUIBVqIRYgEyAWEKkBGiAEKAIIIRcgFygCHCEYIAUgGDYCHEEQIRkgBCAZaiEaIBokACAFDwuEAQERfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPYCIQUgBRD3AiEGIAMgBjYCCBB0IQcgAyAHNgIEQQghCCADIAhqIQkgCSEKQQQhCyADIAtqIQwgDCENIAogDRB1IQ4gDigCACEPQRAhECADIBBqIREgESQAIA8PC3sBDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxAzIQggBiAIELkCGkEEIQkgBiAJaiEKIAUoAgQhCyALEPwCIQwgCiAMEP0CGkEQIQ0gBSANaiEOIA4kACAGDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhD/AiEHQRAhCCADIAhqIQkgCSQAIAcPC1QBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBkEAIQcgBSAGIAcQ/gIhCEEQIQkgBCAJaiEKIAokACAIDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhCAAyEHQRAhCCADIAhqIQkgCSQAIAcPC+kBARp/IwAhBEEQIQUgBCAFayEGIAYkACAGIAA2AgwgBiABNgIIIAYgAjYCBCAGIAM2AgACQANAIAYoAgQhByAGKAIIIQggByEJIAghCiAJIApHIQtBASEMIAsgDHEhDSANRQ0BIAYoAgwhDiAGKAIAIQ8gDygCACEQQWAhESAQIBFqIRIgEhDDAiETIAYoAgQhFEFgIRUgFCAVaiEWIAYgFjYCBCAWEIIDIRcgDiATIBcQgwMgBigCACEYIBgoAgAhGUFgIRogGSAaaiEbIBggGzYCAAwACwALQRAhHCAGIBxqIR0gHSQADwufAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCEAyEGIAYoAgAhByAEIAc2AgQgBCgCCCEIIAgQhAMhCSAJKAIAIQogBCgCDCELIAsgCjYCAEEEIQwgBCAMaiENIA0hDiAOEIQDIQ8gDygCACEQIAQoAgghESARIBA2AgBBECESIAQgEmohEyATJAAPC7ABARZ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFELwCIQYgBRC8AiEHIAUQvQIhCEEFIQkgCCAJdCEKIAcgCmohCyAFELwCIQwgBRC9AiENQQUhDiANIA50IQ8gDCAPaiEQIAUQvAIhESAEKAIIIRJBBSETIBIgE3QhFCARIBRqIRUgBSAGIAsgECAVEL4CQRAhFiAEIBZqIRcgFyQADwsbAQN/IwAhAUEQIQIgASACayEDIAMgADYCDA8LQwEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCAFEIgDQRAhBiADIAZqIQcgByQADwteAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQiQMhBSAFKAIAIQYgBCgCACEHIAYgB2shCEEFIQkgCCAJdSEKQRAhCyADIAtqIQwgDCQAIAoPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEPkCIQdBECEIIAMgCGohCSAJJAAgBw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPgCIQVBECEGIAMgBmohByAHJAAgBQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEEPoCIQVBECEGIAMgBmohByAHJAAgBQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPsCIQVBECEGIAMgBmohByAHJAAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgxB////PyEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LUwEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQ/AIhByAFIAc2AgBBECEIIAQgCGohCSAJJAAgBQ8LnwEBE38jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBhD6AiEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AQeQIIQ4gDhCDAQALIAUoAgghD0EFIRAgDyAQdCERQQQhEiARIBIQhAEhE0EQIRQgBSAUaiEVIBUkACATDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQQhBSAEIAVqIQYgBhCBAyEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDnAiEFQRAhBiADIAZqIQcgByQAIAUPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEENkCIQVBECEGIAMgBmohByAHJAAgBQ8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSgCHCEGIAUoAhghByAFKAIUIQggCBCFAyEJIAYgByAJEIYDQSAhCiAFIApqIQsgCyQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC2EBCX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCFCAFIAE2AhAgBSACNgIMIAUoAhQhBiAFKAIQIQcgBSgCDCEIIAgQhQMhCSAGIAcgCRCHA0EgIQogBSAKaiELIAskAA8LWQEIfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAUoAgQhByAHEIUDIQggBiAIEIQCGkEQIQkgBSAJaiEKIAokAA8LSgEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhCKA0EQIQcgBCAHaiEIIAgkAA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQiwMhB0EQIQggAyAIaiEJIAkkACAHDwugAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUCQANAIAQoAgAhBiAFKAIIIQcgBiEIIAchCSAIIAlHIQpBASELIAogC3EhDCAMRQ0BIAUQ7QIhDSAFKAIIIQ5BYCEPIA4gD2ohECAFIBA2AgggEBDDAiERIA0gERDKAgwACwALQRAhEiAEIBJqIRMgEyQADws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQxgIhBUEQIQYgAyAGaiEHIAckACAFDws5AQV/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAY2AgAgBQ8LOQEFfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGNgIAIAUPC4UBAQ9/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQMRpBACEFIAQgBTYCAEEAIQYgBCAGNgIEQQghByAEIAdqIQhBACEJIAMgCTYCCEEIIQogAyAKaiELIAshDCADIQ0gCCAMIA0QugMaQRAhDiADIA5qIQ8gDyQAIAQPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBC+AyEFQRAhBiADIAZqIQcgByQAIAUPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEL8DIQdBECEIIAMgCGohCSAJJAAgBw8LrgIBIH8jACEEQSAhBSAEIAVrIQYgBiQAIAYgADYCGCAGIAE2AhQgBiACNgIQIAYgAzYCDCAGKAIYIQcgBiAHNgIcQQwhCCAHIAhqIQlBACEKIAYgCjYCCCAGKAIMIQtBCCEMIAYgDGohDSANIQ4gCSAOIAsQwAMaIAYoAhQhDwJAAkAgD0UNACAHEMEDIRAgBigCFCERIBAgERDCAyESIBIhEwwBC0EAIRQgFCETCyATIRUgByAVNgIAIAcoAgAhFiAGKAIQIRdBGCEYIBcgGGwhGSAWIBlqIRogByAaNgIIIAcgGjYCBCAHKAIAIRsgBigCFCEcQRghHSAcIB1sIR4gGyAeaiEfIAcQwwMhICAgIB82AgAgBigCHCEhQSAhIiAGICJqISMgIyQAICEPC/sBARt/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFELgDIAUQkAMhBiAFKAIAIQcgBSgCBCEIIAQoAgghCUEEIQogCSAKaiELIAYgByAIIAsQxAMgBCgCCCEMQQQhDSAMIA1qIQ4gBSAOEMUDQQQhDyAFIA9qIRAgBCgCCCERQQghEiARIBJqIRMgECATEMUDIAUQlAMhFCAEKAIIIRUgFRDDAyEWIBQgFhDFAyAEKAIIIRcgFygCBCEYIAQoAgghGSAZIBg2AgAgBRCAAiEaIAUgGhDGAyAFEMcDQRAhGyAEIBtqIRwgHCQADwuVAQERfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIIIAMoAgghBCADIAQ2AgwgBBDIAyAEKAIAIQVBACEGIAUhByAGIQggByAIRyEJQQEhCiAJIApxIQsCQCALRQ0AIAQQwQMhDCAEKAIAIQ0gBBDJAyEOIAwgDSAOEMoDCyADKAIMIQ9BECEQIAMgEGohESARJAAgDw8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQ3QMhB0EQIQggAyAIaiEJIAkkACAHDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LswEBFX8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFQQghBiAEIAZqIQcgByEIQQEhCSAIIAUgCRDsAxogBRCQAyEKIAQoAgwhCyALENkDIQwgBCgCGCENIA0QlQMhDiAKIAwgDhDtAyAEKAIMIQ9BGCEQIA8gEGohESAEIBE2AgxBCCESIAQgEmohEyATIRQgFBDuAxpBICEVIAQgFWohFiAWJAAPC90BARh/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAFEJADIQYgBCAGNgIUIAUQgAIhB0EBIQggByAIaiEJIAUgCRDvAyEKIAUQgAIhCyAEKAIUIQwgBCENIA0gCiALIAwQkQMaIAQoAhQhDiAEKAIIIQ8gDxDZAyEQIAQoAhghESAREJUDIRIgDiAQIBIQ7QMgBCgCCCETQRghFCATIBRqIRUgBCAVNgIIIAQhFiAFIBYQkgMgBCEXIBcQkwMaQSAhGCAEIBhqIRkgGSQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC4QBAgx/AX4jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxCYAyEIIAYgCBDzAxpBECEJIAYgCWohCiAFKAIEIQsgCxCZAyEMIAwpAgAhDyAKIA83AgBBECENIAUgDWohDiAOJAAgBg8LfAEMfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHEKABIQggBiAIEKkBGkEIIQkgBiAJaiEKIAUoAgQhCyALEKABIQwgCiAMEKkBGkEQIQ0gBSANaiEOIA4kACAGDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC30BDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxCcAyEIIAgoAgAhCSAGIAk2AgAgBSgCBCEKIAoQnQMhCyALKAIAIQwgBiAMNgIEQRAhDSAFIA1qIQ4gDiQAIAYPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD9AxpBECEFIAMgBWohBiAGJAAgBA8LPQEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEP4DGkEQIQUgAyAFaiEGIAYkACAEDwuUAQEQfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCBCEGIAUQ/wMhByAHKAIAIQggBiEJIAghCiAJIApHIQtBASEMIAsgDHEhDQJAAkAgDUUNACAEKAIIIQ4gBSAOEIAEDAELIAQoAgghDyAFIA8QgQQLQRAhECAEIBBqIREgESQADwtiAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBhCGBCEHIAUoAgQhCCAIEPYDIQkgACAHIAkQhwQaQRAhCiAFIApqIQsgCyQADwuiAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCBCEGIAUQggQhByAHKAIAIQggBiEJIAghCiAJIApJIQtBASEMIAsgDHEhDQJAAkAgDUUNACAEKAIIIQ4gDhCDBCEPIAUgDxCEBAwBCyAEKAIIIRAgEBCDBCERIAUgERCFBAtBECESIAQgEmohEyATJAAPC1UBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBCgCACEFIAQgBRCNBCEGIAMgBjYCCCADKAIIIQdBECEIIAMgCGohCSAJJAAgBw8LVQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEKAIEIQUgBCAFEI0EIQYgAyAGNgIIIAMoAgghB0EQIQggAyAIaiEJIAkkACAHDwvZAwFBfyMAIQNB0AAhBCADIARrIQUgBSQAIAUgATYCSCAFIAI2AkAgBSAANgI8QSghBiAFIAZqIQcgByEIQcgAIQkgBSAJaiEKIAohCyALKAIAIQwgCCAMNgIAQSAhDSAFIA1qIQ4gDiEPQcAAIRAgBSAQaiERIBEhEiASKAIAIRMgDyATNgIAIAUoAighFCAFKAIgIRUgFCAVEIgEIRZBMCEXIAUgF2ohGCAYIRkgGSAWEIkEGkEYIRogBSAaaiEbIBshHEHIACEdIAUgHWohHiAeIR8gHygCACEgIBwgIDYCAEEQISEgBSAhaiEiICIhI0HAACEkIAUgJGohJSAlISYgJigCACEnICMgJzYCACAFKAIYISggBSgCECEpQTAhKiAFICpqISsgKyEsICwgKCApEIoEIAUoAjwhLUEIIS4gBSAuaiEvIC8hMEHIACExIAUgMWohMiAyITMgMygCACE0IDAgNDYCACAFITVBwAAhNiAFIDZqITcgNyE4IDgoAgAhOSA1IDk2AgAgBSgCCCE6IAUoAgAhO0EwITwgBSA8aiE9ID0hPiAtID4gOiA7EIsEQTAhPyAFID9qIUAgQCFBIEEQjAQaQdAAIUIgBSBCaiFDIEMkAA8LRAEJfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgQhBSAEKAIAIQYgBSAGayEHQRQhCCAHIAhtIQkgCQ8LSwEJfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIAIQYgBCgCCCEHQRQhCCAHIAhsIQkgBiAJaiEKIAoPC0sBCX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCACEGIAQoAgghB0EDIQggByAIdCEJIAYgCWohCiAKDwtiAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBhCGBCEHIAUoAgQhCCAIEJAEIQkgACAHIAkQkQQaQRAhCiAFIApqIQsgCyQADwuiAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCBCEGIAUQlAMhByAHKAIAIQggBiEJIAghCiAJIApJIQtBASEMIAsgDHEhDQJAAkAgDUUNACAEKAIIIQ4gDhDgAyEPIAUgDxCOBAwBCyAEKAIIIRAgEBDgAyERIAUgERCPBAtBECESIAQgEmohEyATJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDws2AQd/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFQWghBiAFIAZqIQcgBw8LuwQBUn8jACEDQcAAIQQgAyAEayEFIAUkACAFIAA2AjggBSABNgI0IAUgAjYCMCAFKAI0IQZBKCEHIAUgB2ohCCAIIQlBACEKIAkgChAPGkEoIQsgBSALaiEMIAwhDSAGIA0QLyEOIAUoAjAhD0EgIRAgBSAQaiERIBEhEkEAIRMgEiATEA8aQSAhFCAFIBRqIRUgFSEWIA8gFhAvIRcgDiEYIBchGSAYIBlIIRpBASEbIBogG3EhHAJAAkAgHEUNAEEBIR1BASEeIB0gHnEhHyAFIB86AD8MAQsgBSgCNCEgQRghISAFICFqISIgIiEjQQAhJCAjICQQDxpBGCElIAUgJWohJiAmIScgICAnEC8hKCAFKAIwISlBECEqIAUgKmohKyArISxBACEtICwgLRAPGkEQIS4gBSAuaiEvIC8hMCApIDAQLyExICghMiAxITMgMiAzRiE0QQEhNSA0IDVxITYCQCA2RQ0AIAUoAjQhN0EIITggBSA4aiE5IDkhOkEBITsgOiA7EA8aQQghPCAFIDxqIT0gPSE+IDcgPhAvIT8gBSgCMCFAIAUhQUEBIUIgQSBCEA8aIAUhQyBAIEMQLyFEID8hRSBEIUYgRSBGSCFHQQEhSCBHIEhxIUkCQCBJRQ0AQQEhSkEBIUsgSiBLcSFMIAUgTDoAPwwCCwtBACFNQQEhTiBNIE5xIU8gBSBPOgA/CyAFLQA/IVBBASFRIFAgUXEhUkHAACFTIAUgU2ohVCBUJAAgUg8LrwEBGn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAMgBWohBiAGIQdBACEIIAcgCBAPGkEIIQkgAyAJaiEKIAohCyAEIAsQLyEMIAMoAgwhDUEIIQ4gDSAOaiEPIAMhEEEAIREgECAREA8aIAMhEiAPIBIQLyETIAwhFCATIRUgFCAVRiEWQQEhFyAWIBdxIRhBECEZIAMgGWohGiAaJAAgGA8LQgEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEJIEIAQQkwQaQRAhBSADIAVqIQYgBiQAIAQPC0IBBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCUBCAEEJUEGkEQIQUgAyAFaiEGIAYkACAEDwtcAQp/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgAhBUEIIQYgBCAGaiEHIAchCCAIIAUQ1AoaIAQoAgghCUEQIQogBCAKaiELIAskACAJDwttAQ5/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFENUKIQYgBCgCCCEHIAcQ1QohCCAGIQkgCCEKIAkgCkYhC0EBIQwgCyAMcSENQRAhDiAEIA5qIQ8gDyQAIA0PC1sBCX8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAI2AgggBSgCDCEGIAUhByAHIAEQLRogBSgCCCEIIAUhCSAGIAkgCBDWCkEQIQogBSAKaiELIAskAA8LswEBFX8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFQQghBiAEIAZqIQcgByEIQQEhCSAIIAUgCRDfAhogBRDAAiEKIAQoAgwhCyALEMMCIQwgBCgCGCENIA0QhQMhDiAKIAwgDhCDAyAEKAIMIQ9BICEQIA8gEGohESAEIBE2AgxBCCESIAQgEmohEyATIRQgFBDiAhpBICEVIAQgFWohFiAWJAAPC90BARh/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAFEMACIQYgBCAGNgIUIAUQ1gEhB0EBIQggByAIaiEJIAUgCRDjAiEKIAUQ1gEhCyAEKAIUIQwgBCENIA0gCiALIAwQ5AIaIAQoAhQhDiAEKAIIIQ8gDxDDAiEQIAQoAhghESAREIUDIRIgDiAQIBIQgwMgBCgCCCETQSAhFCATIBRqIRUgBCAVNgIIIAQhFiAFIBYQ5QIgBCEXIBcQ5gIaQSAhGCAEIBhqIRkgGSQADwvZAQEWfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBRDYCiAEKAIAIQYgBSAGENkKIAQoAgAhByAHKAIAIQggBSAINgIAIAQoAgAhCSAJKAIEIQogBSAKNgIEIAQoAgAhCyALENgCIQwgDCgCACENIAUQ2AIhDiAOIA02AgAgBCgCACEPIA8Q2AIhEEEAIREgECARNgIAIAQoAgAhEkEAIRMgEiATNgIEIAQoAgAhFEEAIRUgFCAVNgIAQRAhFiAEIBZqIRcgFyQADwupAQEWfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEENcDIQUgBBDXAyEGIAQQjwMhB0EYIQggByAIbCEJIAYgCWohCiAEENcDIQsgBBCAAiEMQRghDSAMIA1sIQ4gCyAOaiEPIAQQ1wMhECAEEI8DIRFBGCESIBEgEmwhEyAQIBNqIRQgBCAFIAogDyAUENgDQRAhFSADIBVqIRYgFiQADwuVAQERfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIIIAMoAgghBCADIAQ2AgwgBCgCACEFQQAhBiAFIQcgBiEIIAcgCEchCUEBIQogCSAKcSELAkAgC0UNACAEEN4KIAQQkAMhDCAEKAIAIQ0gBBC+AyEOIAwgDSAOEMoDCyADKAIMIQ9BECEQIAMgEGohESARJAAgDw8LbAEJfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHEDMhCCAGIAgQuwMaIAUoAgQhCSAJEDUaIAYQvAMaQRAhCiAFIApqIQsgCyQAIAYPC1UBCH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEDMaQQAhByAFIAc2AgBBECEIIAQgCGohCSAJJAAgBQ8LPQEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEEL0DGkEQIQUgAyAFaiEGIAYkACAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LXgEMfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMsDIQUgBSgCACEGIAQoAgAhByAGIAdrIQhBGCEJIAggCW0hCkEQIQsgAyALaiEMIAwkACAKDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQzgMhBUEQIQYgAyAGaiEHIAckACAFDwt7AQx/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQMyEIIAYgCBC7AxpBBCEJIAYgCWohCiAFKAIEIQsgCxDPAyEMIAogDBDQAxpBECENIAUgDWohDiAOJAAgBg8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQ0gMhB0EQIQggAyAIaiEJIAkkACAHDwtUAQl/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQZBACEHIAUgBiAHENEDIQhBECEJIAQgCWohCiAKJAAgCA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQ0wMhB0EQIQggAyAIaiEJIAkkACAHDwvpAQEafyMAIQRBECEFIAQgBWshBiAGJAAgBiAANgIMIAYgATYCCCAGIAI2AgQgBiADNgIAAkADQCAGKAIEIQcgBigCCCEIIAchCSAIIQogCSAKRyELQQEhDCALIAxxIQ0gDUUNASAGKAIMIQ4gBigCACEPIA8oAgAhEEFoIREgECARaiESIBIQ2QMhEyAGKAIEIRRBaCEVIBQgFWohFiAGIBY2AgQgFhDaAyEXIA4gEyAXENsDIAYoAgAhGCAYKAIAIRlBaCEaIBkgGmohGyAYIBs2AgAMAAsAC0EQIRwgBiAcaiEdIB0kAA8LnwEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ3AMhBiAGKAIAIQcgBCAHNgIEIAQoAgghCCAIENwDIQkgCSgCACEKIAQoAgwhCyALIAo2AgBBBCEMIAQgDGohDSANIQ4gDhDcAyEPIA8oAgAhECAEKAIIIREgESAQNgIAQRAhEiAEIBJqIRMgEyQADwuwAQEWfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRDXAyEGIAUQ1wMhByAFEI8DIQhBGCEJIAggCWwhCiAHIApqIQsgBRDXAyEMIAUQjwMhDUEYIQ4gDSAObCEPIAwgD2ohECAFENcDIREgBCgCCCESQRghEyASIBNsIRQgESAUaiEVIAUgBiALIBAgFRDYA0EQIRYgBCAWaiEXIBckAA8LGwEDfyMAIQFBECECIAEgAmshAyADIAA2AgwPC0MBB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCBCEFIAQgBRDkA0EQIQYgAyAGaiEHIAckAA8LXgEMfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOYDIQUgBSgCACEGIAQoAgAhByAGIAdrIQhBGCEJIAggCW0hCkEQIQsgAyALaiEMIAwkACAKDwtaAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAUoAgQhCCAGIAcgCBDlA0EQIQkgBSAJaiEKIAokAA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQzAMhB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQzQMhBUEQIQYgAyAGaiEHIAckACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtTAQh/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBhDPAyEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDwufAQETfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAGENQDIQggByEJIAghCiAJIApLIQtBASEMIAsgDHEhDQJAIA1FDQBB5AghDiAOEIMBAAsgBSgCCCEPQRghECAPIBBsIRFBBCESIBEgEhCEASETQRAhFCAFIBRqIRUgFSQAIBMPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBBCEFIAQgBWohBiAGENUDIQdBECEIIAMgCGohCSAJJAAgBw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEENYDIQVBECEGIAMgBmohByAHJAAgBQ8LJQEEfyMAIQFBECECIAEgAmshAyADIAA2AgxBqtWq1QAhBCAEDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgAhBSAFENkDIQZBECEHIAMgB2ohCCAIJAAgBg8LNwEDfyMAIQVBICEGIAUgBmshByAHIAA2AhwgByABNgIYIAcgAjYCFCAHIAM2AhAgByAENgIMDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOADIQVBECEGIAMgBmohByAHJAAgBQ8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSgCHCEGIAUoAhghByAFKAIUIQggCBDeAyEJIAYgByAJEN8DQSAhCiAFIApqIQsgCyQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEENYDIQVBECEGIAMgBmohByAHJAAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC2EBCX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCFCAFIAE2AhAgBSACNgIMIAUoAhQhBiAFKAIQIQcgBSgCDCEIIAgQ3gMhCSAGIAcgCRDhA0EgIQogBSAKaiELIAskAA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC1kBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQcgBxDeAyEIIAYgCBDiAxpBECEJIAUgCWohCiAKJAAPC3oCDH8BfiMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhDjAxpBECEHIAUgB2ohCCAEKAIIIQlBECEKIAkgCmohCyALKQIAIQ4gCCAONwIAQRAhDCAEIAxqIQ0gDSQAIAUPC3IBDH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQqQEaQQghByAFIAdqIQggBCgCCCEJQQghCiAJIApqIQsgCCALEKkBGkEQIQwgBCAMaiENIA0kACAFDwtKAQd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEOcDQRAhByAEIAdqIQggCCQADwthAQp/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHQRghCCAHIAhsIQlBBCEKIAYgCSAKEElBECELIAUgC2ohDCAMJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBDCEFIAQgBWohBiAGEOsDIQdBECEIIAMgCGohCSAJJAAgBw8LoAEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCBCEFAkADQCAEKAIAIQYgBSgCCCEHIAYhCCAHIQkgCCAJRyEKQQEhCyAKIAtxIQwgDEUNASAFEMEDIQ0gBSgCCCEOQWghDyAOIA9qIRAgBSAQNgIIIBAQ2QMhESANIBEQ6AMMAAsAC0EQIRIgBCASaiETIBMkAA8LSgEHfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGIAUgBhDpA0EgIQcgBCAHaiEIIAgkAA8LSgEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBCgCACEGIAUgBhDqA0EQIQcgBCAHaiEIIAgkAA8LIgEDfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQzQMhBUEQIQYgAyAGaiEHIAckACAFDwuDAQENfyMAIQNBECEEIAMgBGshBSAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAYgBzYCACAFKAIIIQggCCgCBCEJIAYgCTYCBCAFKAIIIQogCigCBCELIAUoAgQhDEEYIQ0gDCANbCEOIAsgDmohDyAGIA82AgggBg8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSgCHCEGIAUoAhghByAFKAIUIQggCBCVAyEJIAYgByAJEPADQSAhCiAFIApqIQsgCyQADws5AQZ/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFIAQoAgAhBiAGIAU2AgQgBA8LsgIBJX8jACECQSAhAyACIANrIQQgBCQAIAQgADYCGCAEIAE2AhQgBCgCGCEFIAUQ9wMhBiAEIAY2AhAgBCgCFCEHIAQoAhAhCCAHIQkgCCEKIAkgCkshC0EBIQwgCyAMcSENAkAgDUUNACAFELUaAAsgBRCPAyEOIAQgDjYCDCAEKAIMIQ8gBCgCECEQQQEhESAQIBF2IRIgDyETIBIhFCATIBRPIRVBASEWIBUgFnEhFwJAAkAgF0UNACAEKAIQIRggBCAYNgIcDAELIAQoAgwhGUEBIRogGSAadCEbIAQgGzYCCEEIIRwgBCAcaiEdIB0hHkEUIR8gBCAfaiEgICAhISAeICEQZyEiICIoAgAhIyAEICM2AhwLIAQoAhwhJEEgISUgBCAlaiEmICYkACAkDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhQgBSABNgIQIAUgAjYCDCAFKAIUIQYgBSgCECEHIAUoAgwhCCAIEJUDIQkgBiAHIAkQ8QNBICEKIAUgCmohCyALJAAPC1kBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQcgBxCVAyEIIAYgCBDyAxpBECEJIAUgCWohCiAKJAAPC4ABAQ5/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBhCYAyEHIAUgBxDzAxpBECEIIAUgCGohCSAEKAIIIQpBECELIAogC2ohDCAMEJkDIQ0gCSANEPQDGkEQIQ4gBCAOaiEPIA8kACAFDwtyAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEKkBGkEIIQcgBSAHaiEIIAQoAgghCUEIIQogCSAKaiELIAggCxCpARpBECEMIAQgDGohDSANJAAgBQ8LgQEBDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEPUDIQcgBygCACEIIAUgCDYCACAEKAIIIQlBBCEKIAkgCmohCyALEPYDIQwgDCgCACENIAUgDTYCBEEQIQ4gBCAOaiEPIA8kACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC4QBARF/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ+AMhBSAFEPkDIQYgAyAGNgIIEHQhByADIAc2AgRBCCEIIAMgCGohCSAJIQpBBCELIAMgC2ohDCAMIQ0gCiANEHUhDiAOKAIAIQ9BECEQIAMgEGohESARJAAgDw8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQ+wMhB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ+gMhBUEQIQYgAyAGaiEHIAckACAFDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQ1AMhBUEQIQYgAyAGaiEHIAckACAFDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ/AMhBUEQIQYgAyAGaiEHIAckACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LhQEBD38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBAxGkEAIQUgBCAFNgIAQQAhBiAEIAY2AgRBCCEHIAQgB2ohCEEAIQkgAyAJNgIIQQghCiADIApqIQsgCyEMIAMhDSAIIAwgDRCWBBpBECEOIAMgDmohDyAPJAAgBA8LhQEBD38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBAxGkEAIQUgBCAFNgIAQQAhBiAEIAY2AgRBCCEHIAQgB2ohCEEAIQkgAyAJNgIIQQghCiADIApqIQsgCyEMIAMhDSAIIAwgDRCaBBpBECEOIAMgDmohDyAPJAAgBA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQngQhB0EQIQggAyAIaiEJIAkkACAHDwuzAQEVfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQVBCCEGIAQgBmohByAHIQhBASEJIAggBSAJEJ8EGiAFEKAEIQogBCgCDCELIAsQoQQhDCAEKAIYIQ0gDRCiBCEOIAogDCAOEKMEIAQoAgwhD0EIIRAgDyAQaiERIAQgETYCDEEIIRIgBCASaiETIBMhFCAUEKQEGkEgIRUgBCAVaiEWIBYkAA8L3QEBGH8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAUQoAQhBiAEIAY2AhQgBRClBCEHQQEhCCAHIAhqIQkgBSAJEKYEIQogBRClBCELIAQoAhQhDCAEIQ0gDSAKIAsgDBCnBBogBCgCFCEOIAQoAgghDyAPEKEEIRAgBCgCGCERIBEQogQhEiAOIBAgEhCjBCAEKAIIIRNBCCEUIBMgFGohFSAEIBU2AgggBCEWIAUgFhCoBCAEIRcgFxCpBBpBICEYIAQgGGohGSAZJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGENcEIQdBECEIIAMgCGohCSAJJAAgBw8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC7MBARV/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBUEIIQYgBCAGaiEHIAchCEEBIQkgCCAFIAkQ2AQaIAUQ2QQhCiAEKAIMIQsgCxDaBCEMIAQoAhghDSANENsEIQ4gCiAMIA4Q3AQgBCgCDCEPQRQhECAPIBBqIREgBCARNgIMQQghEiAEIBJqIRMgEyEUIBQQ3QQaQSAhFSAEIBVqIRYgFiQADwvdAQEYfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBRDZBCEGIAQgBjYCFCAFEKcDIQdBASEIIAcgCGohCSAFIAkQ3gQhCiAFEKcDIQsgBCgCFCEMIAQhDSANIAogCyAMEN8EGiAEKAIUIQ4gBCgCCCEPIA8Q2gQhECAEKAIYIREgERDbBCESIA4gECASENwEIAQoAgghE0EUIRQgEyAUaiEVIAQgFTYCCCAEIRYgBSAWEOAEIAQhFyAXEOEEGkEgIRggBCAYaiEZIBkkAA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC3cBC38jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxCGBCEIIAYgCBDjAxogBSgCBCEJIAkQ9gMhCiAKKAIAIQsgBiALNgIQQRAhDCAFIAxqIQ0gDSQAIAYPC6YBARZ/IwAhAkEwIQMgAiADayEEIAQkACAEIAA2AiggBCABNgIgQRghBSAEIAVqIQYgBiEHQSghCCAEIAhqIQkgCSEKIAooAgAhCyAHIAs2AgBBECEMIAQgDGohDSANIQ5BICEPIAQgD2ohECAQIREgESgCACESIA4gEjYCACAEKAIYIRMgBCgCECEUIBMgFBCWBSEVQTAhFiAEIBZqIRcgFyQAIBUPC5sBARB/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgggBCABNgIEIAQoAgghBSAEIAU2AgwgBRCXBRogBCgCBCEGQQAhByAGIQggByEJIAggCUshCkEBIQsgCiALcSEMAkAgDEUNACAEKAIEIQ0gBSANEJgFIAQoAgQhDiAFIA4QmQULIAQoAgwhD0EQIRAgBCAQaiERIBEkACAPDwu/FAG5An8jACEDQZACIQQgAyAEayEFIAUkACAFIAE2AogCIAUgAjYCgAIgBSAANgL8AUHwASEGIAUgBmohByAHIQggCBCaBRpB6AEhCSAFIAlqIQogCiELQYgCIQwgBSAMaiENIA0hDiAOKAIAIQ8gCyAPNgIAQeABIRAgBSAQaiERIBEhEkGAAiETIAUgE2ohFCAUIRUgFSgCACEWIBIgFjYCAEHYASEXIAUgF2ohGCAYIRlBiAIhGiAFIBpqIRsgGyEcIBwoAgAhHSAZIB02AgBB0AEhHiAFIB5qIR8gHyEgQYACISEgBSAhaiEiICIhIyAjKAIAISQgICAkNgIAIAUoAtgBISUgBSgC0AEhJiAlICYQiAQhJyAFKALoASEoIAUoAuABISlB8AEhKiAFICpqISsgKyEsICggKSAnICwQmwVBwAEhLSAFIC1qIS4gLiEvIC8QnAUaQfABITAgBSAwaiExIDEhMiAyEJ0FITMgBSAzNgK4AUHwASE0IAUgNGohNSA1ITYgNhCeBSE3IAUgNzYCsAFBqAEhOCAFIDhqITkgOSE6QYgCITsgBSA7aiE8IDwhPSA9KAIAIT4gOiA+NgIAQaABIT8gBSA/aiFAIEAhQUGAAiFCIAUgQmohQyBDIUQgRCgCACFFIEEgRTYCACAFKAKoASFGIAUoAqABIUcgRiBHEIgEIUggBSgCuAEhSSAFKAKwASFKQcABIUsgBSBLaiFMIEwhTSBNIEkgSiBIEJ8FQZABIU4gBSBOaiFPIE8hUCBQEKAFGkGAASFRIAUgUWohUiBSIVMgUxCgAxpB8AEhVCAFIFRqIVUgVSFWIFYQoQUhV0GQASFYIAUgWGohWSBZIVogWiBXEKIFIVtBgAEhXCAFIFxqIV0gXSFeIFsgXhCjBRpBgAEhXyAFIF9qIWAgYCFhIGEQsAMaQcABIWIgBSBiaiFjIGMhZCBkEKQFIWUgBSBlNgJ4AkADQEHAASFmIAUgZmohZyBnIWggaBClBSFpIAUgaTYCcEH4ACFqIAUgamohayBrIWxB8AAhbSAFIG1qIW4gbiFvIGwgbxCmBSFwQQEhcSBwIHFxIXIgckUNAUHgACFzIAUgc2ohdCB0IXUgdRCgAxpB+AAhdiAFIHZqIXcgdyF4IHgQpwUheUGQASF6IAUgemoheyB7IXwgfCB5EKIFIX1B4AAhfiAFIH5qIX8gfyGAASB9IIABEKMFGkHgACGBASAFIIEBaiGCASCCASGDASCDARCwAxpB+AAhhAEgBSCEAWohhQEghQEhhgEghgEQqAUaDAALAAtB2AAhhwEgBSCHAWohiAEgiAEhiQFBiAIhigEgBSCKAWohiwEgiwEhjAEgjAEoAgAhjQEgiQEgjQE2AgACQANAQdgAIY4BIAUgjgFqIY8BII8BIZABQYACIZEBIAUgkQFqIZIBIJIBIZMBIJABIJMBEKkFIZQBQQEhlQEglAEglQFxIZYBIJYBRQ0BQdgAIZcBIAUglwFqIZgBIJgBIZkBIJkBEKoFIZoBIJoBEK8CIZsBIAUgmwE2AkxB2AAhnAEgBSCcAWohnQEgnQEhngEgngEQqgUhnwFBCCGgASCfASCgAWohoQEgoQEQrwIhogEgBSCiATYCSEHMACGjASAFIKMBaiGkASCkASGlAUHIACGmASAFIKYBaiGnASCnASGoASClASCoARCkAiGpAUGQASGqASAFIKoBaiGrASCrASGsASCsASCpARCrBSGtASAFIK0BNgJQQZABIa4BIAUgrgFqIa8BIK8BIbABILABEKwFIbEBIAUgsQE2AkBB0AAhsgEgBSCyAWohswEgswEhtAFBwAAhtQEgBSC1AWohtgEgtgEhtwEgtAEgtwEQrQUhuAFBASG5ASC4ASC5AXEhugECQCC6AUUNAEHQACG7ASAFILsBaiG8ASC8ASG9ASC9ARCuBRoLQdgAIb4BIAUgvgFqIb8BIL8BIcABIMABEKoFIcEBIMEBEK8CIcIBIAUgwgE2AjRB2AAhwwEgBSDDAWohxAEgxAEhxQEgxQEQqgUhxgFBCCHHASDGASDHAWohyAEgyAEQrwIhyQEgBSDJATYCMEE0IcoBIAUgygFqIcsBIMsBIcwBQTAhzQEgBSDNAWohzgEgzgEhzwEgzAEgzwEQrwUh0AFBkAEh0QEgBSDRAWoh0gEg0gEh0wEg0wEg0AEQsAUh1AEgBSDUATYCOAJAA0BB0AAh1QEgBSDVAWoh1gEg1gEh1wFBOCHYASAFINgBaiHZASDZASHaASDXASDaARCtBSHbAUEBIdwBINsBINwBcSHdASDdAUUNAUHQACHeASAFIN4BaiHfASDfASHgASDgARCxBSHhAUEEIeIBIOEBIOIBaiHjAUHYACHkASAFIOQBaiHlASDlASHmASDmARCqBSHnASDjASDnARCyBUHQACHoASAFIOgBaiHpASDpASHqASDqARCzBRoMAAsAC0HYACHrASAFIOsBaiHsASDsASHtASDtARC0BRoMAAsACyAFKAL8ASHuAUHwASHvASAFIO8BaiHwASDwASHxASDxARChBSHyAUGQASHzASAFIPMBaiH0ASD0ASH1ASD1ASDyARCiBSH2ASD2ARCkAyH3ASAFIPcBNgIoQfABIfgBIAUg+AFqIfkBIPkBIfoBIPoBEKEFIfsBQZABIfwBIAUg/AFqIf0BIP0BIf4BIP4BIPsBEKIFIf8BIP8BEKUDIYACIAUggAI2AiAgBSgCKCGBAiAFKAIgIYICIO4BIIECIIICELUFQcABIYMCIAUggwJqIYQCIIQCIYUCIIUCEKQFIYYCIAUghgI2AhgCQANAQcABIYcCIAUghwJqIYgCIIgCIYkCIIkCEKUFIYoCIAUgigI2AhBBGCGLAiAFIIsCaiGMAiCMAiGNAkEQIY4CIAUgjgJqIY8CII8CIZACII0CIJACEKYFIZECQQEhkgIgkQIgkgJxIZMCIJMCRQ0BIAUoAvwBIZQCQRghlQIgBSCVAmohlgIglgIhlwIglwIQpwUhmAJBkAEhmQIgBSCZAmohmgIgmgIhmwIgmwIgmAIQogUhnAIgnAIQpAMhnQIgBSCdAjYCCEEYIZ4CIAUgngJqIZ8CIJ8CIaACIKACEKcFIaECQZABIaICIAUgogJqIaMCIKMCIaQCIKQCIKECEKIFIaUCIKUCEKUDIaYCIAUgpgI2AgBBGCGnAiAFIKcCaiGoAiCoAiGpAiCpAhCnBSGqAiCqAigCACGrAiAFKAIIIawCIAUoAgAhrQIglAIgrAIgrQIgqwIQtgVBGCGuAiAFIK4CaiGvAiCvAiGwAiCwAhCoBRoMAAsAC0GQASGxAiAFILECaiGyAiCyAiGzAiCzAhC3BRpBwAEhtAIgBSC0AmohtQIgtQIhtgIgtgIQuAUaQfABIbcCIAUgtwJqIbgCILgCIbkCILkCELkFGkGQAiG6AiAFILoCaiG7AiC7AiQADwuQCwGqAX8jACEEQdABIQUgBCAFayEGIAYkACAGIAI2AsgBIAYgAzYCwAEgBiAANgK8ASAGIAE2ArgBQbABIQcgBiAHaiEIIAghCUHIASEKIAYgCmohCyALIQwgDCgCACENIAkgDTYCAAJAA0BBsAEhDiAGIA5qIQ8gDyEQQcABIREgBiARaiESIBIhEyAQIBMQqQUhFEEBIRUgFCAVcSEWIBZFDQFBsAEhFyAGIBdqIRggGCEZIBkQqgUhGiAGIBo2AqwBQbABIRsgBiAbaiEcIBwhHSAdEKoFIR4gHigCECEfIAYgHzYCqAEgBigCuAEhICAGKAKoASEhICAgIRC6BSEiIAYgIjYCpAEgBigCrAEhI0GQASEkIAYgJGohJSAlISZBACEnICYgJxAPGkGQASEoIAYgKGohKSApISogIyAqEC8hK0EBISwgKyAsaiEtIAYoAqwBIS5BiAEhLyAGIC9qITAgMCExQQEhMiAxIDIQDxpBiAEhMyAGIDNqITQgNCE1IC4gNRAvITZBmAEhNyAGIDdqITggOCE5IDkgLSA2EBwaIAYoAqwBITogOhCvAyE7QQAhPEEBIT0gOyA9cSE+IDwhPwJAID4NACAGKAKsASFAQYABIUEgBiBBaiFCIEIhQ0EAIUQgQyBEEA8aQYABIUUgBiBFaiFGIEYhRyBAIEcQLyFIIAYgSDYChAEgBigCrAEhSUH4ACFKIAYgSmohSyBLIUxBASFNIEwgTRAPGkH4ACFOIAYgTmohTyBPIVAgSSBQEC8hUSAGIFE2AnwgBigCrAEhUkEIIVMgUiBTaiFUQYQBIVUgBiBVaiFWIFYhV0H8ACFYIAYgWGohWSBZIVpBmAEhWyAGIFtqIVwgXCFdIFcgWiBUIF0QuwUhXiBeIT8LID8hX0EBIWAgXyBgcSFhAkACQCBhRQ0AQegAIWIgBiBiaiFjIGMhZCBkEBgaIAYoAqQBIWUgZRC8BSFmQegAIWcgBiBnaiFoIGghaSBpIGYQvQVB6AAhaiAGIGpqIWsgayFsIGwQ7gEhbSAGIG02AlhB4AAhbiAGIG5qIW8gbyFwQdgAIXEgBiBxaiFyIHIhc0EAIXQgcCBzIHQQvgUaIAYoAqQBIXUgdRC/BSF2IAYgdjYCUCAGKAKkASF3IHcQwAUheCAGIHg2AkggBigCYCF5IAYoAlAheiAGKAJIIXtB6AAhfCAGIHxqIX0gfSF+IH4geSB6IHsQwQUhfyAGIH82AkBBOCGAASAGIIABaiGBASCBASGCASCCARDCBRpB6AAhgwEgBiCDAWohhAEghAEhhQEghQEQ7QEhhgEgBiCGATYCMEHoACGHASAGIIcBaiGIASCIASGJASCJARDuASGKASAGIIoBNgIoIAYoAjAhiwEgBigCKCGMAUE4IY0BIAYgjQFqIY4BII4BIY8BIIsBIIwBII8BEMMFIAYoArwBIZABIAYoAqwBIZEBIAYoAqgBIZIBQegAIZMBIAYgkwFqIZQBIJQBIZUBIJUBEO0BIZYBIAYglgE2AiBB6AAhlwEgBiCXAWohmAEgmAEhmQEgmQEQ7gEhmgEgBiCaATYCGCAGKAIgIZsBIAYoAhghnAEgkAEgkQEgkgEgmwEgnAEQxAVB6AAhnQEgBiCdAWohngEgngEhnwEgnwEQGhoMAQsgBigCvAEhoAEgBigCrAEhoQEgBigCqAEhogEgBigCpAEhowEgowEQvwUhpAEgBiCkATYCECAGKAKkASGlASClARDABSGmASAGIKYBNgIIIAYoAhAhpwEgBigCCCGoASCgASChASCiASCnASCoARDFBQtBsAEhqQEgBiCpAWohqgEgqgEhqwEgqwEQtAUaDAALAAtB0AEhrAEgBiCsAWohrQEgrQEkAA8LQgEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMYFIAQQxwUaQRAhBSADIAVqIQYgBiQAIAQPC1wBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCACEFQQghBiAEIAZqIQcgByEIIAggBRDMChogBCgCCCEJQRAhCiAEIApqIQsgCyQAIAkPC7MBARV/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBUEIIQYgBCAGaiEHIAchCEEBIQkgCCAFIAkQ7AMaIAUQkAMhCiAEKAIMIQsgCxDZAyEMIAQoAhghDSANEM0KIQ4gCiAMIA4QzgogBCgCDCEPQRghECAPIBBqIREgBCARNgIMQQghEiAEIBJqIRMgEyEUIBQQ7gMaQSAhFSAEIBVqIRYgFiQADwvdAQEYfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBRCQAyEGIAQgBjYCFCAFEIACIQdBASEIIAcgCGohCSAFIAkQ7wMhCiAFEIACIQsgBCgCFCEMIAQhDSANIAogCyAMEJEDGiAEKAIUIQ4gBCgCCCEPIA8Q2QMhECAEKAIYIREgERDNCiESIA4gECASEM4KIAQoAgghE0EYIRQgEyAUaiEVIAQgFTYCCCAEIRYgBSAWEJIDIAQhFyAXEJMDGkEgIRggBCAYaiEZIBkkAA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC4QBAgx/AX4jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxCGBCEIIAYgCBDjAxpBECEJIAYgCWohCiAFKAIEIQsgCxCQBCEMIAwpAgAhDyAKIA83AgBBECENIAUgDWohDiAOJAAgBg8LqQEBFn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCFBSEFIAQQhQUhBiAEEOkEIQdBFCEIIAcgCGwhCSAGIAlqIQogBBCFBSELIAQQpwMhDEEUIQ0gDCANbCEOIAsgDmohDyAEEIUFIRAgBBDpBCERQRQhEiARIBJsIRMgECATaiEUIAQgBSAKIA8gFBCGBUEQIRUgAyAVaiEWIBYkAA8LlQEBEX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCCCADKAIIIQQgAyAENgIMIAQoAgAhBUEAIQYgBSEHIAYhCCAHIAhHIQlBASEKIAkgCnEhCwJAIAtFDQAgBBDKCCAEENkEIQwgBCgCACENIAQQ9wQhDiAMIA0gDhD0BAsgAygCDCEPQRAhECADIBBqIREgESQAIA8PC6kBARZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQzAQhBSAEEMwEIQYgBBCwBCEHQQMhCCAHIAh0IQkgBiAJaiEKIAQQzAQhCyAEEKUEIQxBAyENIAwgDXQhDiALIA5qIQ8gBBDMBCEQIAQQsAQhEUEDIRIgESASdCETIBAgE2ohFCAEIAUgCiAPIBQQzQRBECEVIAMgFWohFiAWJAAPC5UBARF/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgggAygCCCEEIAMgBDYCDCAEKAIAIQVBACEGIAUhByAGIQggByAIRyEJQQEhCiAJIApxIQsCQCALRQ0AIAQQ0gogBBCgBCEMIAQoAgAhDSAEEL4EIQ4gDCANIA4QuwQLIAMoAgwhD0EQIRAgAyAQaiERIBEkACAPDwtsAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQMyEIIAYgCBCXBBogBSgCBCEJIAkQNRogBhCYBBpBECEKIAUgCmohCyALJAAgBg8LVQEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQMxpBACEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQmQQaQRAhBSADIAVqIQYgBiQAIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtsAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQMyEIIAYgCBCbBBogBSgCBCEJIAkQNRogBhCcBBpBECEKIAUgCmohCyALJAAgBg8LVQEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQMxpBACEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQnQQaQRAhBSADIAVqIQYgBiQAIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQqgQhBUEQIQYgAyAGaiEHIAckACAFDwuDAQENfyMAIQNBECEEIAMgBGshBSAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAYgBzYCACAFKAIIIQggCCgCBCEJIAYgCTYCBCAFKAIIIQogCigCBCELIAUoAgQhDEEDIQ0gDCANdCEOIAsgDmohDyAGIA82AgggBg8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQrAQhB0EQIQggAyAIaiEJIAkkACAHDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC2EBCX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCHCAFIAE2AhggBSACNgIUIAUoAhwhBiAFKAIYIQcgBSgCFCEIIAgQogQhCSAGIAcgCRCrBEEgIQogBSAKaiELIAskAA8LOQEGfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgQhBSAEKAIAIQYgBiAFNgIEIAQPC0QBCX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCgCACEGIAUgBmshB0EDIQggByAIdSEJIAkPC7ICASV/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhggBCABNgIUIAQoAhghBSAFEK8EIQYgBCAGNgIQIAQoAhQhByAEKAIQIQggByEJIAghCiAJIApLIQtBASEMIAsgDHEhDQJAIA1FDQAgBRC1GgALIAUQsAQhDiAEIA42AgwgBCgCDCEPIAQoAhAhEEEBIREgECARdiESIA8hEyASIRQgEyAUTyEVQQEhFiAVIBZxIRcCQAJAIBdFDQAgBCgCECEYIAQgGDYCHAwBCyAEKAIMIRlBASEaIBkgGnQhGyAEIBs2AghBCCEcIAQgHGohHSAdIR5BFCEfIAQgH2ohICAgISEgHiAhEGchIiAiKAIAISMgBCAjNgIcCyAEKAIcISRBICElIAQgJWohJiAmJAAgJA8LrgIBIH8jACEEQSAhBSAEIAVrIQYgBiQAIAYgADYCGCAGIAE2AhQgBiACNgIQIAYgAzYCDCAGKAIYIQcgBiAHNgIcQQwhCCAHIAhqIQlBACEKIAYgCjYCCCAGKAIMIQtBCCEMIAYgDGohDSANIQ4gCSAOIAsQsQQaIAYoAhQhDwJAAkAgD0UNACAHELIEIRAgBigCFCERIBAgERCzBCESIBIhEwwBC0EAIRQgFCETCyATIRUgByAVNgIAIAcoAgAhFiAGKAIQIRdBAyEYIBcgGHQhGSAWIBlqIRogByAaNgIIIAcgGjYCBCAHKAIAIRsgBigCFCEcQQMhHSAcIB10IR4gGyAeaiEfIAcQtAQhICAgIB82AgAgBigCHCEhQSAhIiAGICJqISMgIyQAICEPC/sBARt/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEJQEIAUQoAQhBiAFKAIAIQcgBSgCBCEIIAQoAgghCUEEIQogCSAKaiELIAYgByAIIAsQtQQgBCgCCCEMQQQhDSAMIA1qIQ4gBSAOELYEQQQhDyAFIA9qIRAgBCgCCCERQQghEiARIBJqIRMgECATELYEIAUQ/wMhFCAEKAIIIRUgFRC0BCEWIBQgFhC2BCAEKAIIIRcgFygCBCEYIAQoAgghGSAZIBg2AgAgBRClBCEaIAUgGhC3BCAFELgEQRAhGyAEIBtqIRwgHCQADwuVAQERfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIIIAMoAgghBCADIAQ2AgwgBBC5BCAEKAIAIQVBACEGIAUhByAGIQggByAIRyEJQQEhCiAJIApxIQsCQCALRQ0AIAQQsgQhDCAEKAIAIQ0gBBC6BCEOIAwgDSAOELsECyADKAIMIQ9BECEQIAMgEGohESARJAAgDw8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC2EBCX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCFCAFIAE2AhAgBSACNgIMIAUoAhQhBiAFKAIQIQcgBSgCDCEIIAgQogQhCSAGIAcgCRCtBEEgIQogBSAKaiELIAskAA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEK4EIQVBECEGIAMgBmohByAHJAAgBQ8LYQIIfwF+IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHIAcQogQhCCAIKQIAIQsgBiALNwIAQRAhCSAFIAlqIQogCiQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LhAEBEX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBC8BCEFIAUQvQQhBiADIAY2AggQdCEHIAMgBzYCBEEIIQggAyAIaiEJIAkhCkEEIQsgAyALaiEMIAwhDSAKIA0QdSEOIA4oAgAhD0EQIRAgAyAQaiERIBEkACAPDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQvgQhBUEQIQYgAyAGaiEHIAckACAFDwt7AQx/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQMyEIIAYgCBCXBBpBBCEJIAYgCWohCiAFKAIEIQsgCxDGBCEMIAogDBDHBBpBECENIAUgDWohDiAOJAAgBg8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQyQQhB0EQIQggAyAIaiEJIAkkACAHDwtUAQl/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQZBACEHIAUgBiAHEMgEIQhBECEJIAQgCWohCiAKJAAgCA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQygQhB0EQIQggAyAIaiEJIAkkACAHDwuBAgEffyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIcIAYgATYCGCAGIAI2AhQgBiADNgIQIAYoAhQhByAGKAIYIQggByAIayEJQQMhCiAJIAp1IQsgBiALNgIMIAYoAgwhDCAGKAIQIQ0gDSgCACEOQQAhDyAPIAxrIRBBAyERIBAgEXQhEiAOIBJqIRMgDSATNgIAIAYoAgwhFEEAIRUgFCEWIBUhFyAWIBdKIRhBASEZIBggGXEhGgJAIBpFDQAgBigCECEbIBsoAgAhHCAGKAIYIR0gBigCDCEeQQMhHyAeIB90ISAgHCAdICAQ4xoaC0EgISEgBiAhaiEiICIkAA8LnwEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQzgQhBiAGKAIAIQcgBCAHNgIEIAQoAgghCCAIEM4EIQkgCSgCACEKIAQoAgwhCyALIAo2AgBBBCEMIAQgDGohDSANIQ4gDhDOBCEPIA8oAgAhECAEKAIIIREgESAQNgIAQRAhEiAEIBJqIRMgEyQADwuwAQEWfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRDMBCEGIAUQzAQhByAFELAEIQhBAyEJIAggCXQhCiAHIApqIQsgBRDMBCEMIAUQsAQhDUEDIQ4gDSAOdCEPIAwgD2ohECAFEMwEIREgBCgCCCESQQMhEyASIBN0IRQgESAUaiEVIAUgBiALIBAgFRDNBEEQIRYgBCAWaiEXIBckAA8LGwEDfyMAIQFBECECIAEgAmshAyADIAA2AgwPC0MBB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCBCEFIAQgBRDPBEEQIQYgAyAGaiEHIAckAA8LXgEMfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEENEEIQUgBSgCACEGIAQoAgAhByAGIAdrIQhBAyEJIAggCXUhCkEQIQsgAyALaiEMIAwkACAKDwtaAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAUoAgQhCCAGIAcgCBDQBEEQIQkgBSAJaiEKIAokAA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQwAQhB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQvwQhBUEQIQYgAyAGaiEHIAckACAFDwteAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQwwQhBSAFKAIAIQYgBCgCACEHIAYgB2shCEEDIQkgCCAJdSEKQRAhCyADIAtqIQwgDCQAIAoPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBDBBCEFQRAhBiADIAZqIQcgByQAIAUPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDCBCEFQRAhBiADIAZqIQcgByQAIAUPCyUBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMQf////8BIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEMQEIQdBECEIIAMgCGohCSAJJAAgBw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMUEIQVBECEGIAMgBmohByAHJAAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtTAQh/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBhDGBCEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDwufAQETfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAGEMEEIQggByEJIAghCiAJIApLIQtBASEMIAsgDHEhDQJAIA1FDQBB5AghDiAOEIMBAAsgBSgCCCEPQQMhECAPIBB0IRFBBCESIBEgEhCEASETQRAhFCAFIBRqIRUgFSQAIBMPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBBCEFIAQgBWohBiAGEMsEIQdBECEIIAMgCGohCSAJJAAgBw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEKoEIQVBECEGIAMgBmohByAHJAAgBQ8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgAhBSAFEKEEIQZBECEHIAMgB2ohCCAIJAAgBg8LNwEDfyMAIQVBICEGIAUgBmshByAHIAA2AhwgByABNgIYIAcgAjYCFCAHIAM2AhAgByAENgIMDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LSgEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhDSBEEQIQcgBCAHaiEIIAgkAA8LYQEKfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAUoAgQhB0EDIQggByAIdCEJQQQhCiAGIAkgChBJQRAhCyAFIAtqIQwgDCQADwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhDWBCEHQRAhCCADIAhqIQkgCSQAIAcPC6ABARJ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgQhBQJAA0AgBCgCACEGIAUoAgghByAGIQggByEJIAggCUchCkEBIQsgCiALcSEMIAxFDQEgBRCyBCENIAUoAgghDkF4IQ8gDiAPaiEQIAUgEDYCCCAQEKEEIREgDSARENMEDAALAAtBECESIAQgEmohEyATJAAPC0oBB38jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAQoAhghBiAFIAYQ1ARBICEHIAQgB2ohCCAIJAAPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCBCEFIAQoAgAhBiAFIAYQ1QRBECEHIAQgB2ohCCAIJAAPCyIBA38jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMUEIQVBECEGIAMgBmohByAHJAAgBQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOIEIQVBECEGIAMgBmohByAHJAAgBQ8LgwEBDX8jACEDQRAhBCADIARrIQUgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAGIAc2AgAgBSgCCCEIIAgoAgQhCSAGIAk2AgQgBSgCCCEKIAooAgQhCyAFKAIEIQxBFCENIAwgDWwhDiALIA5qIQ8gBiAPNgIIIAYPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEOQEIQdBECEIIAMgCGohCSAJJAAgBw8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhwgBSABNgIYIAUgAjYCFCAFKAIcIQYgBSgCGCEHIAUoAhQhCCAIENsEIQkgBiAHIAkQ4wRBICEKIAUgCmohCyALJAAPCzkBBn8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCgCACEGIAYgBTYCBCAEDwuyAgElfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIYIAQgATYCFCAEKAIYIQUgBRDoBCEGIAQgBjYCECAEKAIUIQcgBCgCECEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AIAUQtRoACyAFEOkEIQ4gBCAONgIMIAQoAgwhDyAEKAIQIRBBASERIBAgEXYhEiAPIRMgEiEUIBMgFE8hFUEBIRYgFSAWcSEXAkACQCAXRQ0AIAQoAhAhGCAEIBg2AhwMAQsgBCgCDCEZQQEhGiAZIBp0IRsgBCAbNgIIQQghHCAEIBxqIR0gHSEeQRQhHyAEIB9qISAgICEhIB4gIRBnISIgIigCACEjIAQgIzYCHAsgBCgCHCEkQSAhJSAEICVqISYgJiQAICQPC64CASB/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhggBiABNgIUIAYgAjYCECAGIAM2AgwgBigCGCEHIAYgBzYCHEEMIQggByAIaiEJQQAhCiAGIAo2AgggBigCDCELQQghDCAGIAxqIQ0gDSEOIAkgDiALEOoEGiAGKAIUIQ8CQAJAIA9FDQAgBxDrBCEQIAYoAhQhESAQIBEQ7AQhEiASIRMMAQtBACEUIBQhEwsgEyEVIAcgFTYCACAHKAIAIRYgBigCECEXQRQhGCAXIBhsIRkgFiAZaiEaIAcgGjYCCCAHIBo2AgQgBygCACEbIAYoAhQhHEEUIR0gHCAdbCEeIBsgHmohHyAHEO0EISAgICAfNgIAIAYoAhwhIUEgISIgBiAiaiEjICMkACAhDwv7AQEbfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCSBCAFENkEIQYgBSgCACEHIAUoAgQhCCAEKAIIIQlBBCEKIAkgCmohCyAGIAcgCCALEO4EIAQoAgghDEEEIQ0gDCANaiEOIAUgDhDvBEEEIQ8gBSAPaiEQIAQoAgghEUEIIRIgESASaiETIBAgExDvBCAFEIIEIRQgBCgCCCEVIBUQ7QQhFiAUIBYQ7wQgBCgCCCEXIBcoAgQhGCAEKAIIIRkgGSAYNgIAIAUQpwMhGiAFIBoQ8AQgBRDxBEEQIRsgBCAbaiEcIBwkAA8LlQEBEX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCCCADKAIIIQQgAyAENgIMIAQQ8gQgBCgCACEFQQAhBiAFIQcgBiEIIAcgCEchCUEBIQogCSAKcSELAkAgC0UNACAEEOsEIQwgBCgCACENIAQQ8wQhDiAMIA0gDhD0BAsgAygCDCEPQRAhECADIBBqIREgESQAIA8PCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhQgBSABNgIQIAUgAjYCDCAFKAIUIQYgBSgCECEHIAUoAgwhCCAIENsEIQkgBiAHIAkQ5QRBICEKIAUgCmohCyALJAAPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDnBCEFQRAhBiADIAZqIQcgByQAIAUPC1kBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQcgBxDbBCEIIAYgCBDmBBpBECEJIAUgCWohCiAKJAAPC2IBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQ8wMaIAQoAgghByAHKAIQIQggBSAINgIQQRAhCSAEIAlqIQogCiQAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwuEAQERfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPUEIQUgBRD2BCEGIAMgBjYCCBB0IQcgAyAHNgIEQQghCCADIAhqIQkgCSEKQQQhCyADIAtqIQwgDCENIAogDRB1IQ4gDigCACEPQRAhECADIBBqIREgESQAIA8PCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD3BCEFQRAhBiADIAZqIQcgByQAIAUPC3sBDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxAzIQggBiAIEJsEGkEEIQkgBiAJaiEKIAUoAgQhCyALEP8EIQwgCiAMEIAFGkEQIQ0gBSANaiEOIA4kACAGDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhCCBSEHQRAhCCADIAhqIQkgCSQAIAcPC1QBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBkEAIQcgBSAGIAcQgQUhCEEQIQkgBCAJaiEKIAokACAIDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhCDBSEHQRAhCCADIAhqIQkgCSQAIAcPC+kBARp/IwAhBEEQIQUgBCAFayEGIAYkACAGIAA2AgwgBiABNgIIIAYgAjYCBCAGIAM2AgACQANAIAYoAgQhByAGKAIIIQggByEJIAghCiAJIApHIQtBASEMIAsgDHEhDSANRQ0BIAYoAgwhDiAGKAIAIQ8gDygCACEQQWwhESAQIBFqIRIgEhDaBCETIAYoAgQhFEFsIRUgFCAVaiEWIAYgFjYCBCAWEIcFIRcgDiATIBcQiAUgBigCACEYIBgoAgAhGUFsIRogGSAaaiEbIBggGzYCAAwACwALQRAhHCAGIBxqIR0gHSQADwufAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCJBSEGIAYoAgAhByAEIAc2AgQgBCgCCCEIIAgQiQUhCSAJKAIAIQogBCgCDCELIAsgCjYCAEEEIQwgBCAMaiENIA0hDiAOEIkFIQ8gDygCACEQIAQoAgghESARIBA2AgBBECESIAQgEmohEyATJAAPC7ABARZ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEIUFIQYgBRCFBSEHIAUQ6QQhCEEUIQkgCCAJbCEKIAcgCmohCyAFEIUFIQwgBRDpBCENQRQhDiANIA5sIQ8gDCAPaiEQIAUQhQUhESAEKAIIIRJBFCETIBIgE2whFCARIBRqIRUgBSAGIAsgECAVEIYFQRAhFiAEIBZqIRcgFyQADwsbAQN/IwAhAUEQIQIgASACayEDIAMgADYCDA8LQwEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCAFEI4FQRAhBiADIAZqIQcgByQADwteAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQkAUhBSAFKAIAIQYgBCgCACEHIAYgB2shCEEUIQkgCCAJbSEKQRAhCyADIAtqIQwgDCQAIAoPC1oBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBSgCBCEIIAYgByAIEI8FQRAhCSAFIAlqIQogCiQADwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhD5BCEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD4BCEFQRAhBiADIAZqIQcgByQAIAUPC14BDH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD8BCEFIAUoAgAhBiAEKAIAIQcgBiAHayEIQRQhCSAIIAltIQpBECELIAMgC2ohDCAMJAAgCg8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEEPoEIQVBECEGIAMgBmohByAHJAAgBQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPsEIQVBECEGIAMgBmohByAHJAAgBQ8LJQEEfyMAIQFBECECIAEgAmshAyADIAA2AgxBzJmz5gAhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQ/QQhB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ/gQhBUEQIQYgAyAGaiEHIAckACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC1MBCH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEP8EIQcgBSAHNgIAQRAhCCAEIAhqIQkgCSQAIAUPC58BARN/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAYQ+gQhCCAHIQkgCCEKIAkgCkshC0EBIQwgCyAMcSENAkAgDUUNAEHkCCEOIA4QgwEACyAFKAIIIQ9BFCEQIA8gEGwhEUEEIRIgESASEIQBIRNBECEUIAUgFGohFSAVJAAgEw8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEEIQUgBCAFaiEGIAYQhAUhB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ4gQhBUEQIQYgAyAGaiEHIAckACAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC0UBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAUQ2gQhBkEQIQcgAyAHaiEIIAgkACAGDws3AQN/IwAhBUEgIQYgBSAGayEHIAcgADYCHCAHIAE2AhggByACNgIUIAcgAzYCECAHIAQ2AgwPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCDBCEFQRAhBiADIAZqIQcgByQAIAUPC2EBCX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCHCAFIAE2AhggBSACNgIUIAUoAhwhBiAFKAIYIQcgBSgCFCEIIAgQigUhCSAGIAcgCRCLBUEgIQogBSAKaiELIAskAA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhQgBSABNgIQIAUgAjYCDCAFKAIUIQYgBSgCECEHIAUoAgwhCCAIEIoFIQkgBiAHIAkQjAVBICEKIAUgCmohCyALJAAPC1kBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQcgBxCKBSEIIAYgCBCNBRpBECEJIAUgCWohCiAKJAAPC2IBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQ4wMaIAQoAgghByAHKAIQIQggBSAINgIQQRAhCSAEIAlqIQogCiQAIAUPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQkQVBECEHIAQgB2ohCCAIJAAPC2EBCn8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQdBFCEIIAcgCGwhCUEEIQogBiAJIAoQSUEQIQsgBSALaiEMIAwkAA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQlQUhB0EQIQggAyAIaiEJIAkkACAHDwugAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUCQANAIAQoAgAhBiAFKAIIIQcgBiEIIAchCSAIIAlHIQpBASELIAogC3EhDCAMRQ0BIAUQ6wQhDSAFKAIIIQ5BbCEPIA4gD2ohECAFIBA2AgggEBDaBCERIA0gERCSBQwACwALQRAhEiAEIBJqIRMgEyQADwtKAQd/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAEKAIYIQYgBSAGEJMFQSAhByAEIAdqIQggCCQADwtKAQd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgQhBSAEKAIAIQYgBSAGEJQFQRAhByAEIAdqIQggCCQADwsiAQN/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AggPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD+BCEFQRAhBiADIAZqIQcgByQAIAUPC14BDH8jACECQSAhAyACIANrIQQgBCQAIAQgADYCGCAEIAE2AhBBECEFIAQgBWohBiAGIQdBGCEIIAQgCGohCSAJIQogByAKEMgFIQtBICEMIAQgDGohDSANJAAgCw8LhQEBD38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBAxGkEAIQUgBCAFNgIAQQAhBiAEIAY2AgRBCCEHIAQgB2ohCEEAIQkgAyAJNgIIQQghCiADIApqIQsgCyEMIAMhDSAIIAwgDRDKBRpBECEOIAMgDmohDyAPJAAgBA8L0AEBF38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFEMsFIQcgBiEIIAchCSAIIAlLIQpBASELIAogC3EhDAJAIAxFDQAgBRC1GgALIAUQzAUhDSAEKAIIIQ4gDSAOEM0FIQ8gBSAPNgIEIAUgDzYCACAFKAIAIRAgBCgCCCERQQwhEiARIBJsIRMgECATaiEUIAUQzgUhFSAVIBQ2AgBBACEWIAUgFhDPBUEQIRcgBCAXaiEYIBgkAA8L3AEBGn8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAQoAhghBkEIIQcgBCAHaiEIIAghCSAJIAUgBhDQBRoCQANAIAQoAgwhCiAEKAIQIQsgCiEMIAshDSAMIA1HIQ5BASEPIA4gD3EhECAQRQ0BIAUQzAUhESAEKAIMIRIgEhDRBSETIBEgExDSBSAEKAIMIRRBDCEVIBQgFWohFiAEIBY2AgwMAAsAC0EIIRcgBCAXaiEYIBghGSAZENMFGkEgIRogBCAaaiEbIBskAA8LPQEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPwFGkEQIQUgAyAFaiEGIAYkACAEDwvxDQHgAX8jACEEQcABIQUgBCAFayEGIAYkACAGIAA2ArgBIAYgATYCsAEgBiACNgKsASAGIAM2AqgBQZgBIQcgBiAHaiEIIAghCSAJEJ8DGiAGKAKsASEKQQEhCyAKIAt0IQxBmAEhDSAGIA1qIQ4gDiEPIA8gDBD9BUGQASEQIAYgEGohESARIRJBuAEhEyAGIBNqIRQgFCEVIBUoAgAhFiASIBY2AgACQANAQZABIRcgBiAXaiEYIBghGUGwASEaIAYgGmohGyAbIRwgGSAcEKkFIR1BASEeIB0gHnEhHyAfRQ0BQZABISAgBiAgaiEhICEhIiAiEKoFISMgIxCvAiEkQZABISUgBiAlaiEmICYhJyAnEKoFIShBCCEpICggKWohKiAqEK8CISsgJCEsICshLSAsIC1IIS5BASEvQX8hMEEBITEgLiAxcSEyIC8gMCAyGyEzIAYgMzYCjAFBkAEhNCAGIDRqITUgNSE2IDYQqgUhNyA3EK8CITggBiA4NgJ8QYABITkgBiA5aiE6IDohO0H8ACE8IAYgPGohPSA9IT5BjAEhPyAGID9qIUAgQCFBIDsgPiBBEP4FQZgBIUIgBiBCaiFDIEMhREGAASFFIAYgRWohRiBGIUcgRCBHEP8FQZABIUggBiBIaiFJIEkhSiBKEKoFIUtBCCFMIEsgTGohTSBNEK8CIU4gBiBONgJsIAYoAowBIU9BACFQIFAgT2shUSAGIFE2AmhB8AAhUiAGIFJqIVMgUyFUQewAIVUgBiBVaiFWIFYhV0HoACFYIAYgWGohWSBZIVogVCBXIFoQgAZBmAEhWyAGIFtqIVwgXCFdQfAAIV4gBiBeaiFfIF8hYCBdIGAQ/wVBkAEhYSAGIGFqIWIgYiFjIGMQtAUaDAALAAtBmAEhZCAGIGRqIWUgZSFmIGYQgQYhZyAGIGc2AmBBmAEhaCAGIGhqIWkgaSFqIGoQggYhayAGIGs2AlggBigCYCFsIAYoAlghbSBsIG0QgwYgBigCqAEhbkGYASFvIAYgb2ohcCBwIXEgcRClBCFyIG4gchCEBiAGKAKoASFzQZgBIXQgBiB0aiF1IHUhdiB2EIUGIXdBACF4IAYgeDYCLEEAIXkgBiB5NgIoQTAheiAGIHpqIXsgeyF8QSwhfSAGIH1qIX4gfiF/QSghgAEgBiCAAWohgQEggQEhggEgfCB/IIIBEIAGQTghgwEgBiCDAWohhAEghAEhhQFBMCGGASAGIIYBaiGHASCHASGIASCFASB3IIgBEIYGQcgAIYkBIAYgiQFqIYoBIIoBIYsBQTghjAEgBiCMAWohjQEgjQEhjgEgiwEgjgEQhwYaQcgAIY8BIAYgjwFqIZABIJABIZEBIHMgkQEQiAZBmAEhkgEgBiCSAWohkwEgkwEhlAEglAEQgQYhlQEgBiCVATYCIAJAA0BBmAEhlgEgBiCWAWohlwEglwEhmAEgmAEQggYhmQEgBiCZATYCGEEgIZoBIAYgmgFqIZsBIJsBIZwBQRghnQEgBiCdAWohngEgngEhnwEgnAEgnwEQiQYhoAFBASGhASCgASChAXEhogEgogFFDQFBICGjASAGIKMBaiGkASCkASGlASClARCKBiGmASCmASgCACGnASAGKAKoASGoASCoARCLBiGpASCpASgCACGqASCnASGrASCqASGsASCrASCsAUchrQFBASGuASCtASCuAXEhrwECQCCvAUUNACAGKAKoASGwAUEgIbEBIAYgsQFqIbIBILIBIbMBILMBEIoGIbQBIAYoAqgBIbUBILUBEIsGIbYBQQQhtwEgtgEgtwFqIbgBQQghuQEgBiC5AWohugEgugEhuwEguwEgtAEguAEQjAZBCCG8ASAGILwBaiG9ASC9ASG+ASCwASC+ARCIBgtBICG/ASAGIL8BaiHAASDAASHBASDBARCKBiHCASDCASgCBCHDAUEAIcQBIMMBIcUBIMQBIcYBIMUBIMYBSCHHAUEBIcgBIMcBIMgBcSHJAQJAIMkBRQ0AQSAhygEgBiDKAWohywEgywEhzAEgzAEQigYhzQEgzQEoAgQhzgEgBigCqAEhzwEgzwEQiwYh0AEg0AEoAggh0QEg0QEgzgFrIdIBINABINIBNgIIC0EgIdMBIAYg0wFqIdQBINQBIdUBINUBEIoGIdYBINYBKAIEIdcBIAYoAqgBIdgBINgBEIsGIdkBINkBKAIEIdoBINoBINcBaiHbASDZASDbATYCBEEgIdwBIAYg3AFqId0BIN0BId4BIN4BEI0GGgwACwALQZgBId8BIAYg3wFqIeABIOABIeEBIOEBELEDGkHAASHiASAGIOIBaiHjASDjASQADws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQjgYaQRAhBSADIAVqIQYgBiQAIAQPC1UBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBCgCACEFIAQgBRCVBiEGIAMgBjYCCCADKAIIIQdBECEIIAMgCGohCSAJJAAgBw8LVQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEKAIEIQUgBCAFEJUGIQYgAyAGNgIIIAMoAgghB0EQIQggAyAIaiEJIAkkACAHDwujCwG3AX8jACEEQeAAIQUgBCAFayEGIAYkACAGIAE2AlggBiACNgJQIAYgADYCTCAGIAM2AkhB2AAhByAGIAdqIQggCCEJQdAAIQogBiAKaiELIAshDCAJIAwQjwYhDUEBIQ4gDSAOcSEPAkACQCAPRQ0ADAELIAYoAkghEEEeIREgECESIBEhEyASIBNJIRRBASEVIBQgFXEhFgJAIBZFDQAMAQsgBigCSCEXIAYgFzYCREHAACEYIAYgGGohGSAZIRpB2AAhGyAGIBtqIRwgHCEdIB0oAgAhHiAaIB42AgBBACEfIAYgHzYCPEEAISAgBiAgNgI4QTAhISAGICFqISIgIiEjQdgAISQgBiAkaiElICUhJiAmKAIAIScgIyAnNgIAQSghKCAGIChqISkgKSEqQdAAISsgBiAraiEsICwhLSAtKAIAIS4gKiAuNgIAIAYoAjAhLyAGKAIoITAgLyAwEJAGITEgBiAxNgI0QSAhMiAGIDJqITMgMyE0QdgAITUgBiA1aiE2IDYhNyA3KAIAITggNCA4NgIAAkADQEEgITkgBiA5aiE6IDohO0HQACE8IAYgPGohPSA9IT4gOyA+EJEGIT9BASFAID8gQHEhQSBBRQ0BIAYoAjwhQiAGKAI0IUNBAyFEIEMgRG4hRSBCIUYgRSFHIEYgR0khSEEBIUkgSCBJcSFKAkACQCBKRQ0ADAELIAYoAjQhSyAGKAI8IUwgSyBMayFNIAYoAjQhTkEDIU8gTiBPbiFQIE0hUSBQIVIgUSBSSSFTQQEhVCBTIFRxIVUCQCBVRQ0ADAMLQSAhViAGIFZqIVcgVyFYIFgQkgYhWSBZKAIEIVogBigCRCFbIFohXCBbIV0gXCBdSSFeQQEhXyBeIF9xIWACQCBgRQ0AQcAAIWEgBiBhaiFiIGIhY0EgIWQgBiBkaiFlIGUhZiBmKAIAIWcgYyBnNgIAQcAAIWggBiBoaiFpIGkhaiBqEJIGIWsgaygCBCFsIAYgbDYCRCAGKAI8IW0gBiBtNgI4CwtBICFuIAYgbmohbyBvIXAgcBCTBhogBigCPCFxQQEhciBxIHJqIXMgBiBzNgI8DAALAAsgBigCOCF0AkACQCB0RQ0AQcAAIXUgBiB1aiF2IHYhdyB3EJIGIXggeCgCBCF5IAYoAkghekEJIXsgeiB7biF8IHkhfSB8IX4gfSB+SyF/QQEhgAEgfyCAAXEhgQEggQFFDQELDAELIAYoAkwhggFBGCGDASAGIIMBaiGEASCEASGFAUHYACGGASAGIIYBaiGHASCHASGIASCIASgCACGJASCFASCJATYCAEEQIYoBIAYgigFqIYsBIIsBIYwBQcAAIY0BIAYgjQFqIY4BII4BIY8BII8BKAIAIZABIIwBIJABNgIAQcAAIZEBIAYgkQFqIZIBIJIBIZMBIJMBEJIGIZQBIJQBKAIEIZUBQcAAIZYBIAYglgFqIZcBIJcBIZgBIJgBEJIGIZkBIJkBKAIIIZoBIJUBIJoBaiGbASAGKAIYIZwBIAYoAhAhnQEgggEgnAEgnQEgmwEQnwUgBigCTCGeAUHAACGfASAGIJ8BaiGgASCgASGhASChARCSBiGiASCeASCiARCUBiAGKAJMIaMBQQghpAEgBiCkAWohpQEgpQEhpgFBwAAhpwEgBiCnAWohqAEgqAEhqQEgqQEoAgAhqgEgpgEgqgE2AgAgBiGrAUHQACGsASAGIKwBaiGtASCtASGuASCuASgCACGvASCrASCvATYCACAGKAJIIbABQcAAIbEBIAYgsQFqIbIBILIBIbMBILMBEJIGIbQBILQBKAIIIbUBILABILUBayG2ASAGKAIIIbcBIAYoAgAhuAEgowEgtwEguAEgtgEQnwULQeAAIbkBIAYguQFqIboBILoBJAAPC2MBDH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAMgBWohBiAGIQcgBxCWBhpBCCEIIAMgCGohCSAJIQogBCAKEJcGGkEQIQsgAyALaiEMIAwkACAEDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC8YBARp/IwAhAkEwIQMgAiADayEEIAQkACAEIAA2AiwgBCABNgIoIAQoAiwhBSAEKAIoIQYgBCgCKCEHIAcQmAYhCCAEIAg2AhgQmQZBICEJIAQgCWohCiAKIQtBqAkhDEEYIQ0gBCANaiEOIA4hD0EQIRAgBCAQaiERIBEhEiALIAUgBiAMIA8gEhCaBkEgIRMgBCATaiEUIBQhFSAVEJsGIRYgFhCcBiEXQQQhGCAXIBhqIRlBMCEaIAQgGmohGyAbJAAgGQ8LTAEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhCdBkEQIQcgBCAHaiEIIAgkACAFDwtVAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQoAgAhBSAEIAUQngYhBiADIAY2AgggAygCCCEHQRAhCCADIAhqIQkgCSQAIAcPC1UBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBCgCBCEFIAQgBRCeBiEGIAMgBjYCCCADKAIIIQdBECEIIAMgCGohCSAJJAAgBw8LZAEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhCfBiEHQX8hCCAHIAhzIQlBASEKIAkgCnEhC0EQIQwgBCAMaiENIA0kACALDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPCz0BB38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQVBBCEGIAUgBmohByAEIAc2AgAgBA8LZAEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhCgBiEHQX8hCCAHIAhzIQlBASEKIAkgCnEhC0EQIQwgBCAMaiENIA0kACALDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC3oBDX8jACECQSAhAyACIANrIQQgBCQAIAQgADYCFCAEIAE2AhAgBCgCFCEFIAQoAhAhBiAFIAYQoQYhByAEIAc2AgggBCgCCCEIQRghCSAEIAlqIQogCiELIAsgCBCiBhogBCgCGCEMQSAhDSAEIA1qIQ4gDiQAIAwPC2oBDH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBClBiEFIAMgBTYCACADKAIAIQZBCCEHIAMgB2ohCCAIIQkgCSAGEKIGGiADKAIIIQpBECELIAMgC2ohDCAMJAAgCg8LWQEKfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhCkBiEHQQEhCCAHIAhxIQlBECEKIAQgCmohCyALJAAgCQ8LPQEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEKYGGkEQIQUgAyAFaiEGIAYkACAEDwtOAQh/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEKgGIQdBECEIIAQgCGohCSAJJAAgBw8LegENfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIUIAQgATYCECAEKAIUIQUgBCgCECEGIAUgBhCnBiEHIAQgBzYCCCAEKAIIIQhBGCEJIAQgCWohCiAKIQsgCyAIEKIGGiAEKAIYIQxBICENIAQgDWohDiAOJAAgDA8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEJsGIQUgBRCcBiEGQRAhByADIAdqIQggCCQAIAYPC5QBARB/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIEIQYgBRCCBCEHIAcoAgAhCCAGIQkgCCEKIAkgCkchC0EBIQwgCyAMcSENAkACQCANRQ0AIAQoAgghDiAFIA4QqQYMAQsgBCgCCCEPIAUgDxCqBgtBECEQIAQgEGohESARJAAPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCrBhpBECEFIAMgBWohBiAGJAAgBA8LPQEHfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBUEUIQYgBSAGaiEHIAQgBzYCACAEDwuuAQEVfyMAIQNBICEEIAMgBGshBSAFJAAgBSABNgIYIAUgAjYCECAFIAA2AgwgBSgCDCEGQQghByAFIAdqIQggCCEJQRghCiAFIApqIQsgCyEMIAwoAgAhDSAJIA02AgAgBSEOQRAhDyAFIA9qIRAgECERIBEoAgAhEiAOIBI2AgAQrAYhEyAFKAIIIRQgBSgCACEVIAYgFCAVIBMQtgVBICEWIAUgFmohFyAXJAAPC7kjAYYEfyMAIQRBwAQhBSAEIAVrIQYgBiQAIAYgATYCuAQgBiACNgKwBCAGIAA2AqwEIAYgAzYCqARBmAQhByAGIAdqIQggCCEJIAkQGBpBgAQhCiAGIApqIQsgCyEMQbgEIQ0gBiANaiEOIA4hDyAPKAIAIRAgDCAQNgIAQfgDIREgBiARaiESIBIhE0GwBCEUIAYgFGohFSAVIRYgFigCACEXIBMgFzYCACAGKAKABCEYIAYoAvgDIRlBiAQhGiAGIBpqIRsgGyEcIBwgGCAZEK0GGkEAIR0gBiAdNgL0AwJAA0AgBigC9AMhHkGIBCEfIAYgH2ohICAgISEgIRCnAyEiIB4hIyAiISQgIyAkSSElQQEhJiAlICZxIScgJ0UNASAGKAL0AyEoQYgEISkgBiApaiEqICohKyArICgQqAMhLEEIIS0gLCAtaiEuIAYoAvQDIS9BiAQhMCAGIDBqITEgMSEyIDIgLxCoAyEzIC4gMxCuBiE0QQEhNSA0IDVxITYCQCA2RQ0AIAYoAvQDITdBiAQhOCAGIDhqITkgOSE6IDogNxCoAyE7IAYoAvQDITxBiAQhPSAGID1qIT4gPiE/ID8gPBCoAyFAQQghQSBAIEFqIUIgOyBCEN4BCyAGKAL0AyFDQQEhRCBDIERqIUUgBiBFNgL0AwwACwALQYgEIUYgBiBGaiFHIEchSCBIEKQDIUkgBiBJNgL4AUGIBCFKIAYgSmohSyBLIUwgTBClAyFNIAYgTTYC8AEgBigC+AEhTiAGKALwASFPIE4gTxCvBkGIBCFQIAYgUGohUSBRIVIgUhCkAyFTIAYgUzYC6AECQANAQYgEIVQgBiBUaiFVIFUhViBWEKUDIVcgBiBXNgLgAUHoASFYIAYgWGohWSBZIVpB4AEhWyAGIFtqIVwgXCFdIFogXRCpBSFeQQEhXyBeIF9xIWAgYEUNAUHoASFhIAYgYWohYiBiIWMgYxCqBSFkIAYgZDYC3AEgBigC3AEhZUGYBCFmIAYgZmohZyBnIWggaCBlELAGIAYoAtwBIWlBCCFqIGkgamoha0GYBCFsIAYgbGohbSBtIW4gbiBrELAGIAYoAqwEIW9B6AEhcCAGIHBqIXEgcSFyIHIQqgUhcyBzKAIQIXQgbyB0ELoFIXUgBiB1NgLYASAGKALYASF2IHYQsQYhdyAGIHc2AtABAkADQCAGKALYASF4IHgQsgYheSAGIHk2AsgBQdABIXogBiB6aiF7IHshfEHIASF9IAYgfWohfiB+IX8gfCB/ELMGIYABQQEhgQEggAEggQFxIYIBIIIBRQ0BQdABIYMBIAYggwFqIYQBIIQBIYUBIIUBELQGIYYBIIYBEK8CIYcBIAYoAqgEIYgBIIcBIYkBIIgBIYoBIIkBIIoBTiGLAUEBIYwBIIsBIIwBcSGNAQJAII0BRQ0AQdABIY4BIAYgjgFqIY8BII8BIZABIJABELQGIZEBQZgEIZIBIAYgkgFqIZMBIJMBIZQBIJQBIJEBELAGC0HQASGVASAGIJUBaiGWASCWASGXASCXARC1BhoMAAsACyAGKALcASGYASCYARCvAiGZASAGKAKoBCGaASCZASGbASCaASGcASCbASCcAU4hnQFBACGeAUEBIZ8BIJ0BIJ8BcSGgASCeASGhAQJAIKABRQ0AIAYoAtwBIaIBQQghowEgogEgowFqIaQBIKQBEK8CIaUBIAYoAqgEIaYBIKUBIacBIKYBIagBIKcBIKgBTiGpASCpASGhAQsgoQEhqgFBASGrASCqASCrAXEhrAEgBiCsAToAxwFBwAEhrQEgBiCtAWohrgEgrgEhrwFB6AEhsAEgBiCwAWohsQEgsQEhsgEgsgEoAgAhswEgrwEgswE2AgACQANAQYgEIbQBIAYgtAFqIbUBILUBIbYBILYBEKUDIbcBIAYgtwE2ArgBQcABIbgBIAYguAFqIbkBILkBIboBQbgBIbsBIAYguwFqIbwBILwBIb0BILoBIL0BEKkFIb4BQQEhvwEgvgEgvwFxIcABIMABRQ0BQcABIcEBIAYgwQFqIcIBIMIBIcMBIMMBEKoFIcQBIAYgxAE2ArQBIAYtAMcBIcUBQQEhxgEgxQEgxgFxIccBAkACQAJAIMcBDQAgBigCtAEhyAEgyAEQrwIhyQEgBigCqAQhygEgyQEhywEgygEhzAEgywEgzAFOIc0BQQEhzgEgzQEgzgFxIc8BIM8BRQ0BIAYoArQBIdABQQgh0QEg0AEg0QFqIdIBINIBEK8CIdMBIAYoAqgEIdQBINMBIdUBINQBIdYBINUBINYBTiHXAUEBIdgBINcBINgBcSHZASDZAUUNAQsgBigC3AEh2gEgBigCtAEh2wEg2gEg2wEQtgYh3AFBASHdASDcASDdAXEh3gECQCDeAUUNAAwCCyAGKAK0ASHfAUGoASHgASAGIOABaiHhASDhASHiAUEAIeMBIOIBIOMBEA8aQagBIeQBIAYg5AFqIeUBIOUBIeYBIN8BIOYBEC8h5wEgBiDnATYCsAEgBigCtAEh6AFBCCHpASDoASDpAWoh6gFBoAEh6wEgBiDrAWoh7AEg7AEh7QFBACHuASDtASDuARAPGkGgASHvASAGIO8BaiHwASDwASHxASDqASDxARAvIfIBIAYg8gE2AqQBQbABIfMBIAYg8wFqIfQBIPQBIfUBQaQBIfYBIAYg9gFqIfcBIPcBIfgBIPUBIPgBEKQCIfkBIPkBKAIAIfoBIAYoAtwBIfsBQQgh/AEg+wEg/AFqIf0BQZgBIf4BIAYg/gFqIf8BIP8BIYACQQAhgQIggAIggQIQDxpBmAEhggIgBiCCAmohgwIggwIhhAIg/QEghAIQLyGFAiAGIIUCNgKcASAGKALcASGGAkGQASGHAiAGIIcCaiGIAiCIAiGJAkEAIYoCIIkCIIoCEA8aQZABIYsCIAYgiwJqIYwCIIwCIY0CIIYCII0CEC8hjgIgBiCOAjYClAFBnAEhjwIgBiCPAmohkAIgkAIhkQJBlAEhkgIgBiCSAmohkwIgkwIhlAIgkQIglAIQrwUhlQIglQIoAgAhlgIg+gEhlwIglgIhmAIglwIgmAJOIZkCQQEhmgIgmQIgmgJxIZsCAkAgmwJFDQAMBAsgBigC3AEhnAIgBigCtAEhnQIgnAIgnQIQ5AEhngJBASGfAiCeAiCfAnEhoAICQAJAIKACDQAgBigC3AEhoQJBCCGiAiChAiCiAmohowIgBigCtAEhpAJBCCGlAiCkAiClAmohpgIgowIgpgIQ5AEhpwJBASGoAiCnAiCoAnEhqQIgqQJFDQELDAILQYgBIaoCIAYgqgJqIasCIKsCIawCIKwCELcGGiAGKALcASGtAiAGKAK0ASGuAkGAAiGvAiAGIK8CaiGwAiCwAiGxAkGIASGyAiAGILICaiGzAiCzAiG0AkEAIbUCQQEhtgIgtQIgtgJxIbcCQQEhuAIgtQIguAJxIbkCILECILQCIK0CIK4CILcCILkCELgGIboCQQEhuwIgugIguwJxIbwCAkAgvAJFDQBBmAQhvQIgBiC9AmohvgIgvgIhvwJBiAEhwAIgBiDAAmohwQIgwQIhwgIgvwIgwgIQsAYgBigCrAQhwwJBwAEhxAIgBiDEAmohxQIgxQIhxgIgxgIQqgUhxwIgxwIoAhAhyAIgwwIgyAIQugUhyQJBgAEhygIgBiDKAmohywIgywIhzAJBiAEhzQIgBiDNAmohzgIgzgIhzwIgzAIgyQIgzwIQuQYgBigCrAQh0AJB6AEh0QIgBiDRAmoh0gIg0gIh0wIg0wIQqgUh1AIg1AIoAhAh1QIg0AIg1QIQugUh1gJB+AAh1wIgBiDXAmoh2AIg2AIh2QJBiAEh2gIgBiDaAmoh2wIg2wIh3AIg2QIg1gIg3AIQuQYLCwtBwAEh3QIgBiDdAmoh3gIg3gIh3wIg3wIQtAUaDAALAAtB6AEh4AIgBiDgAmoh4QIg4QIh4gIg4gIQtAUaDAALAAtBmAQh4wIgBiDjAmoh5AIg5AIh5QIg5QIQ7QEh5gIgBiDmAjYCcEGYBCHnAiAGIOcCaiHoAiDoAiHpAiDpAhDuASHqAiAGIOoCNgJoIAYoAnAh6wIgBigCaCHsAiDrAiDsAhC6BkGYBCHtAiAGIO0CaiHuAiDuAiHvAiDvAhDtASHwAiAGIPACNgJYQZgEIfECIAYg8QJqIfICIPICIfMCIPMCEO4BIfQCIAYg9AI2AlAgBigCWCH1AiAGKAJQIfYCIPUCIPYCELsGIfcCIAYg9wI2AmBBmAQh+AIgBiD4Amoh+QIg+QIh+gIg+gIQ7QEh+wIgBiD7AjYCSEGIBCH8AiAGIPwCaiH9AiD9AiH+AiD+AhCkAyH/AiAGIP8CNgJAAkADQEGIBCGAAyAGIIADaiGBAyCBAyGCAyCCAxClAyGDAyAGIIMDNgI4QcAAIYQDIAYghANqIYUDIIUDIYYDQTghhwMgBiCHA2ohiAMgiAMhiQMghgMgiQMQqQUhigNBASGLAyCKAyCLA3EhjAMgjANFDQFBwAAhjQMgBiCNA2ohjgMgjgMhjwMgjwMQqgUhkAMgBiCQAzYCNEHAACGRAyAGIJEDaiGSAyCSAyGTAyCTAxCqBSGUAyCUAygCECGVAyAGIJUDNgIwIAYoAjQhlgMgBigCNCGXA0EIIZgDIJcDIJgDaiGZAyCWAyCZAxC8BiGaA0EoIZsDIAYgmwNqIZwDIJwDIZ0DIJ0DIJoDEOIBGiAGKAI0IZ4DIAYoAjQhnwNBCCGgAyCfAyCgA2ohoQMgngMgoQMQvQYhogNBICGjAyAGIKMDaiGkAyCkAyGlAyClAyCiAxDiARoDQEHIACGmAyAGIKYDaiGnAyCnAyGoA0HgACGpAyAGIKkDaiGqAyCqAyGrAyCoAyCrAxC+BiGsA0EAIa0DQQEhrgMgrAMgrgNxIa8DIK0DIbADAkAgrwNFDQBByAAhsQMgBiCxA2ohsgMgsgMhswMgswMQvwYhtAMgtAMQrgIhtQNBKCG2AyAGILYDaiG3AyC3AyG4AyC4AxCuAiG5AyC1AyG6AyC5AyG7AyC6AyC7A0ghvAMgvAMhsAMLILADIb0DQQEhvgMgvQMgvgNxIb8DAkAgvwNFDQBByAAhwAMgBiDAA2ohwQMgwQMhwgMgwgMQwAYaDAELC0EYIcMDIAYgwwNqIcQDIMQDIcUDQcgAIcYDIAYgxgNqIccDIMcDIcgDIMgDKAIAIckDIMUDIMkDNgIAA0BBGCHKAyAGIMoDaiHLAyDLAyHMA0HgACHNAyAGIM0DaiHOAyDOAyHPAyDMAyDPAxC+BiHQA0EAIdEDQQEh0gMg0AMg0gNxIdMDINEDIdQDAkAg0wNFDQBBGCHVAyAGINUDaiHWAyDWAyHXAyDXAxC/BiHYAyDYAxCuAiHZA0EgIdoDIAYg2gNqIdsDINsDIdwDINwDEK4CId0DINkDId4DIN0DId8DIN4DIN8DTCHgAyDgAyHUAwsg1AMh4QNBASHiAyDhAyDiA3Eh4wMCQCDjA0UNAEEYIeQDIAYg5ANqIeUDIOUDIeYDIOYDEL8GIecDQRAh6AMgBiDoA2oh6QMg6QMh6gMg6gMg5wMQ4gEaIAYoAjQh6wNBECHsAyAGIOwDaiHtAyDtAyHuAyDuAyDrAxDBBiHvA0EBIfADIO8DIPADcSHxAwJAIPEDRQ0AIAYoAqwEIfIDIAYoAjAh8wMg8gMg8wMQugUh9ANBGCH1AyAGIPUDaiH2AyD2AyH3AyD3AxC/BiH4A0EIIfkDIAYg+QNqIfoDIPoDIfsDIPsDIPQDIPgDELkGC0EYIfwDIAYg/ANqIf0DIP0DIf4DIP4DEMAGGgwBCwtBwAAh/wMgBiD/A2ohgAQggAQhgQQggQQQtAUaDAALAAtBiAQhggQgBiCCBGohgwQggwQhhAQghAQQsAMaQZgEIYUEIAYghQRqIYYEIIYEIYcEIIcEEBoaQcAEIYgEIAYgiARqIYkEIIkEJAAPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDCBhpBECEFIAMgBWohBiAGJAAgBA8LQgEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMMGIAQQxAYaQRAhBSADIAVqIQYgBiQAIAQPC0IBBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDFBiAEEMYGGkEQIQUgAyAFaiEGIAYkACAEDwtLAQl/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgAhBiAEKAIIIQdBDCEIIAcgCGwhCSAGIAlqIQogCg8LsQQCPn8QfiMAIQRB4AAhBSAEIAVrIQYgBiQAIAYgADYCXCAGIAE2AlggBiACNgJUIAYgAzYCUCAGKAJUIQcgBiAHNgJIIAYoAlAhCCAGIAg2AkwgBigCTCEJQTghCiAGIApqIQsgCyEMQQEhDSAMIA0QDxpBOCEOIAYgDmohDyAPIRAgCSAQEC8hESARIRIgEqwhQiAGKAJYIRMgEygCACEUIBQhFSAVrCFDIEIgQ30hRCAGIEQ3A0AgBigCSCEWQSghFyAGIBdqIRggGCEZQQEhGiAZIBoQDxpBKCEbIAYgG2ohHCAcIR0gFiAdEC8hHiAeIR8gH6whRSAGKAJYISAgICgCACEhICEhIiAirCFGIEUgRn0hRyAGIEc3AzAgBigCTCEjQRghJCAGICRqISUgJSEmQQAhJyAmICcQDxpBGCEoIAYgKGohKSApISogIyAqEC8hKyArISwgLKwhSCAGKAJcIS0gLSgCACEuIC4hLyAvrCFJIEggSX0hSiAGIEo3AyAgBigCSCEwQQghMSAGIDFqITIgMiEzQQAhNCAzIDQQDxpBCCE1IAYgNWohNiA2ITcgMCA3EC8hOCA4ITkgOawhSyAGKAJcITogOigCACE7IDshPCA8rCFMIEsgTH0hTSAGIE03AxAgBikDECFOIAYpAzAhTyAGKQMgIVAgBikDQCFRIE4gTyBQIFEQtgkhPUEBIT4gPSA+cSE/QeAAIUAgBiBAaiFBIEEkACA/DwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQlwohBSAFKAIAIQZBECEHIAMgB2ohCCAIJAAgBg8LsgEBFH8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAQoAhghBiAFEJEBIQcgBiEIIAchCSAIIAlLIQpBASELIAogC3EhDAJAIAxFDQAgBRBbIQ0gBCANNgIUIAQoAhghDiAFEAshDyAEKAIUIRAgBCERIBEgDiAPIBAQpAEaIAQhEiAFIBIQpQEgBCETIBMQpgEaC0EgIRQgBCAUaiEVIBUkAA8LWgEIfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHENcCIQggBiAINgIAQRAhCSAFIAlqIQogCiQAIAYPC0wBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBCgCiEFIAMgBTYCCCADKAIIIQZBECEHIAMgB2ohCCAIJAAgBg8LTAEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEEKEKIQUgAyAFNgIIIAMoAgghBkEQIQcgAyAHaiEIIAgkACAGDwvkCwG4AX8jACEEQaABIQUgBCAFayEGIAYkACAGIAE2ApABIAYgAjYCiAEgBiADNgKAASAGIAA2AnwgBigCfCEHIAcoAgAhCCAHEO0BIQkgBiAJNgJwQZABIQogBiAKaiELIAshDEHwACENIAYgDWohDiAOIQ8gDCAPEJgKIRBBAyERIBAgEXQhEiAIIBJqIRMgBiATNgJ4QegAIRQgBiAUaiEVIBUhFkGIASEXIAYgF2ohGCAYIRkgGSgCACEaIBYgGjYCAEHgACEbIAYgG2ohHCAcIR1BgAEhHiAGIB5qIR8gHyEgICAoAgAhISAdICE2AgAgBigCaCEiIAYoAmAhIyAiICMQmQohJCAGICQ2AmwgBigCbCElQQAhJiAlIScgJiEoICcgKEohKUEBISogKSAqcSErAkAgK0UNACAGKAJsISwgBxAnIS0gLSgCACEuIAcoAgQhLyAuIC9rITBBAyExIDAgMXUhMiAsITMgMiE0IDMgNEwhNUEBITYgNSA2cSE3AkACQCA3RQ0AIAYoAmwhOCAGIDg2AlwgBygCBCE5IAYgOTYCWEHQACE6IAYgOmohOyA7ITxBgAEhPSAGID1qIT4gPiE/ID8oAgAhQCA8IEA2AgAgBygCBCFBIAYoAnghQiBBIEJrIUNBAyFEIEMgRHUhRSAGIEU2AkwgBigCbCFGIAYoAkwhRyBGIUggRyFJIEggSUohSkEBIUsgSiBLcSFMAkAgTEUNAEHQACFNIAYgTWohTiBOIU9BiAEhUCAGIFBqIVEgUSFSIFIoAgAhUyBPIFM2AgAgBygCBCFUIAYoAnghVSBUIFVrIVZBAyFXIFYgV3UhWCAGIFg2AkggBigCSCFZQdAAIVogBiBaaiFbIFshXCBcIFkQmgpBwAAhXSAGIF1qIV4gXiFfQdAAIWAgBiBgaiFhIGEhYiBiKAIAIWMgXyBjNgIAQTghZCAGIGRqIWUgZSFmQYABIWcgBiBnaiFoIGghaSBpKAIAIWogZiBqNgIAIAYoAmwhayAGKAJIIWwgayBsayFtIAYoAkAhbiAGKAI4IW8gByBuIG8gbRCbCiAGKAJMIXAgBiBwNgJsCyAGKAJsIXFBACFyIHEhcyByIXQgcyB0SiF1QQEhdiB1IHZxIXcCQCB3RQ0AIAYoAngheCAGKAJYIXkgBigCeCF6IAYoAlwhe0EDIXwgeyB8dCF9IHogfWohfiAHIHggeSB+EJwKQTAhfyAGIH9qIYABIIABIYEBQYgBIYIBIAYgggFqIYMBIIMBIYQBIIQBKAIAIYUBIIEBIIUBNgIAQSghhgEgBiCGAWohhwEghwEhiAFB0AAhiQEgBiCJAWohigEgigEhiwEgiwEoAgAhjAEgiAEgjAE2AgAgBigCeCGNASAGKAIwIY4BIAYoAighjwEgjgEgjwEgjQEQnQoaCwwBCyAHEFshkAEgBiCQATYCJCAHEAshkQEgBigCbCGSASCRASCSAWohkwEgByCTARCjASGUASAGKAJ4IZUBIAcoAgAhlgEglQEglgFrIZcBQQMhmAEglwEgmAF1IZkBIAYoAiQhmgFBECGbASAGIJsBaiGcASCcASGdASCdASCUASCZASCaARCkARpBCCGeASAGIJ4BaiGfASCfASGgAUGIASGhASAGIKEBaiGiASCiASGjASCjASgCACGkASCgASCkATYCACAGIaUBQYABIaYBIAYgpgFqIacBIKcBIagBIKgBKAIAIakBIKUBIKkBNgIAIAYoAgghqgEgBigCACGrAUEQIawBIAYgrAFqIa0BIK0BIa4BIK4BIKoBIKsBEJ4KIAYoAnghrwFBECGwASAGILABaiGxASCxASGyASAHILIBIK8BEJ8KIbMBIAYgswE2AnhBECG0ASAGILQBaiG1ASC1ASG2ASC2ARCmARoLCyAGKAJ4IbcBIAcgtwEQ1gIhuAEgBiC4ATYCmAEgBigCmAEhuQFBoAEhugEgBiC6AWohuwEguwEkACC5AQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC6cBARR/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhggBSABNgIQIAUgAjYCDEEIIQYgBSAGaiEHIAchCEEYIQkgBSAJaiEKIAohCyALKAIAIQwgCCAMNgIAIAUhDUEQIQ4gBSAOaiEPIA8hECAQKAIAIREgDSARNgIAIAUoAgwhEiAFKAIIIRMgBSgCACEUIBMgFCASEKIKQSAhFSAFIBVqIRYgFiQADwu/AwE9fyMAIQVB0AAhBiAFIAZrIQcgByQAIAcgAzYCSCAHIAQ2AkAgByAANgI8IAcgATYCOCAHIAI2AjRBMCEIIAcgCGohCSAJIQpByAAhCyAHIAtqIQwgDCENIA0oAgAhDiAKIA42AgBBKCEPIAcgD2ohECAQIRFByAAhEiAHIBJqIRMgEyEUIBQoAgAhFSARIBU2AgBBKCEWIAcgFmohFyAXIRggGBDABhoCQANAQSghGSAHIBlqIRogGiEbQcAAIRwgByAcaiEdIB0hHiAbIB4QvgYhH0EBISAgHyAgcSEhICFFDQEgBygCPCEiQTAhIyAHICNqISQgJCElICUQvwYhJkEoIScgByAnaiEoICghKSApEL8GISogByErICsgJiAqEPQIGkEQISwgByAsaiEtIC0hLiAHIS9BNCEwIAcgMGohMSAxITIgLiAvIDIQowpBECEzIAcgM2ohNCA0ITUgIiA1EKMDQTAhNiAHIDZqITcgNyE4QSghOSAHIDlqITogOiE7IDsoAgAhPCA4IDw2AgBBKCE9IAcgPWohPiA+IT8gPxDABhoMAAsAC0HQACFAIAcgQGohQSBBJAAPC78DAT1/IwAhBUHQACEGIAUgBmshByAHJAAgByADNgJIIAcgBDYCQCAHIAA2AjwgByABNgI4IAcgAjYCNEEwIQggByAIaiEJIAkhCkHIACELIAcgC2ohDCAMIQ0gDSgCACEOIAogDjYCAEEoIQ8gByAPaiEQIBAhEUHIACESIAcgEmohEyATIRQgFCgCACEVIBEgFTYCAEEoIRYgByAWaiEXIBchGCAYELUGGgJAA0BBKCEZIAcgGWohGiAaIRtBwAAhHCAHIBxqIR0gHSEeIBsgHhCzBiEfQQEhICAfICBxISEgIUUNASAHKAI8ISJBMCEjIAcgI2ohJCAkISUgJRC0BiEmQSghJyAHICdqISggKCEpICkQtAYhKiAHISsgKyAmICoQpAoaQRAhLCAHICxqIS0gLSEuIAchL0E0ITAgByAwaiExIDEhMiAuIC8gMhCjCkEQITMgByAzaiE0IDQhNSAiIDUQowNBMCE2IAcgNmohNyA3IThBKCE5IAcgOWohOiA6ITsgOygCACE8IDggPDYCAEEoIT0gByA9aiE+ID4hPyA/ELUGGgwACwALQdAAIUAgByBAaiFBIEEkAA8LqQEBFn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDcBSEFIAQQ3AUhBiAEEN0FIQdBDCEIIAcgCGwhCSAGIAlqIQogBBDcBSELIAQQwQohDEEMIQ0gDCANbCEOIAsgDmohDyAEENwFIRAgBBDdBSERQQwhEiARIBJsIRMgECATaiEUIAQgBSAKIA8gFBDeBUEQIRUgAyAVaiEWIBYkAA8LlQEBEX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCCCADKAIIIQQgAyAENgIMIAQoAgAhBUEAIQYgBSEHIAYhCCAHIAhHIQlBASEKIAkgCnEhCwJAIAtFDQAgBBDCCiAEEMwFIQwgBCgCACENIAQQ5QUhDiAMIA0gDhDDCgsgAygCDCEPQRAhECADIBBqIREgESQAIA8PC2UBDH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQyQUhBiAEKAIIIQcgBxDJBSEIIAYgCGshCUEUIQogCSAKbSELQRAhDCAEIAxqIQ0gDSQAIAsPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBQ8LbAEJfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHEDMhCCAGIAgQ1AUaIAUoAgQhCSAJEDUaIAYQ1QUaQRAhCiAFIApqIQsgCyQAIAYPC4QBARF/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ1wUhBSAFENgFIQYgAyAGNgIIEHQhByADIAc2AgRBCCEIIAMgCGohCSAJIQpBBCELIAMgC2ohDCAMIQ0gCiANEHUhDiAOKAIAIQ9BECEQIAMgEGohESARJAAgDw8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQ2gUhB0EQIQggAyAIaiEJIAkkACAHDwtUAQl/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQZBACEHIAUgBiAHENkFIQhBECEJIAQgCWohCiAKJAAgCA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQ2wUhB0EQIQggAyAIaiEJIAkkACAHDwuwAQEWfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRDcBSEGIAUQ3AUhByAFEN0FIQhBDCEJIAggCWwhCiAHIApqIQsgBRDcBSEMIAUQ3QUhDUEMIQ4gDSAObCEPIAwgD2ohECAFENwFIREgBCgCCCESQQwhEyASIBNsIRQgESAUaiEVIAUgBiALIBAgFRDeBUEQIRYgBCAWaiEXIBckAA8LgwEBDX8jACEDQRAhBCADIARrIQUgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAGIAc2AgAgBSgCCCEIIAgoAgQhCSAGIAk2AgQgBSgCCCEKIAooAgQhCyAFKAIEIQxBDCENIAwgDWwhDiALIA5qIQ8gBiAPNgIIIAYPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtKAQd/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAEKAIYIQYgBSAGEOkFQSAhByAEIAdqIQggCCQADws5AQZ/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFIAQoAgAhBiAGIAU2AgQgBA8LVQEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQMxpBACEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQ1gUaQRAhBSADIAVqIQYgBiQAIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhDgBSEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDfBSEFQRAhBiADIAZqIQcgByQAIAUPC58BARN/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAYQ4QUhCCAHIQkgCCEKIAkgCkshC0EBIQwgCyAMcSENAkAgDUUNAEHkCCEOIA4QgwEACyAFKAIIIQ9BDCEQIA8gEGwhEUEEIRIgESASEIQBIRNBECEUIAUgFGohFSAVJAAgEw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOMFIQVBECEGIAMgBmohByAHJAAgBQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOQFIQVBECEGIAMgBmohByAHJAAgBQ8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIAIQUgBRDRBSEGQRAhByADIAdqIQggCCQAIAYPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDlBSEFQRAhBiADIAZqIQcgByQAIAUPCzcBA38jACEFQSAhBiAFIAZrIQcgByAANgIcIAcgATYCGCAHIAI2AhQgByADNgIQIAcgBDYCDA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEEOEFIQVBECEGIAMgBmohByAHJAAgBQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOIFIQVBECEGIAMgBmohByAHJAAgBQ8LJQEEfyMAIQFBECECIAEgAmshAyADIAA2AgxB1arVqgEhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwteAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ5gUhBSAFKAIAIQYgBCgCACEHIAYgB2shCEEMIQkgCCAJbSEKQRAhCyADIAtqIQwgDCQAIAoPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEOcFIQdBECEIIAMgCGohCSAJJAAgBw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOgFIQVBECEGIAMgBmohByAHJAAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCBCEFIAQoAgAhBiAFIAYQ6gVBECEHIAQgB2ohCCAIJAAPC0IBBn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCCCEFIAUQ6wUaQRAhBiAEIAZqIQcgByQADwtOAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSADIAVqIQYgBiEHIAQgBxDsBRpBECEIIAMgCGohCSAJJAAgBA8LmgEBEX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFQQQhBiAFIAZqIQcgBxDtBRpBCCEIIAUgCGohCUEAIQogBCAKNgIEIAQoAgghC0EEIQwgBCAMaiENIA0hDiAJIA4gCxDuBRogBRDvBSEPIAUQ8AUhECAQIA82AgBBECERIAQgEWohEiASJAAgBQ8LQwEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPEFGiAEEPIFGkEQIQUgAyAFaiEGIAYkACAEDwtxAQp/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQ9gMhCCAGIAgQ8wUaIAUoAgQhCSAJEPQFIQogBiAKEPUFGkEQIQsgBSALaiEMIAwkACAGDwtQAQp/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQQhBSAEIAVqIQYgBhD2BSEHIAcQ9wUhCEEQIQkgAyAJaiEKIAokACAIDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LPQEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEEPgFGkEQIQUgAyAFaiEGIAYkACAEDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQ+QUaQRAhBSADIAVqIQYgBiQAIAQPC1oBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEPYDIQcgBygCACEIIAUgCDYCAEEQIQkgBCAJaiEKIAokACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LSwEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQ9AUaQRAhByAEIAdqIQggCCQAIAUPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD7BSEFQRAhBiADIAZqIQcgByQAIAUPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD6BSEFQRAhBiADIAZqIQcgByQAIAUPCy8BBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBEEAIQUgBCAFNgIAIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC4UBAQ9/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQMRpBACEFIAQgBTYCAEEAIQYgBCAGNgIEQQghByAEIAdqIQhBACEJIAMgCTYCCEEIIQogAyAKaiELIAshDCADIQ0gCCAMIA0QxwYaQRAhDiADIA5qIQ8gDyQAIAQPC7QBARR/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAEKAIYIQYgBRCwBCEHIAYhCCAHIQkgCCAJSyEKQQEhCyAKIAtxIQwCQCAMRQ0AIAUQoAQhDSAEIA02AhQgBCgCGCEOIAUQpQQhDyAEKAIUIRAgBCERIBEgDiAPIBAQpwQaIAQhEiAFIBIQqAQgBCETIBMQqQQaC0EgIRQgBCAUaiEVIBUkAA8LWwEJfyMAIQNBECEEIAMgBGshBSAFJAAgBSABNgIMIAUgAjYCCCAFKAIMIQYgBhD2AyEHIAUoAgghCCAIEJ0DIQkgACAHIAkQzgYaQRAhCiAFIApqIQsgCyQADwuiAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCBCEGIAUQ/wMhByAHKAIAIQggBiEJIAghCiAJIApJIQtBASEMIAsgDHEhDQJAAkAgDUUNACAEKAIIIQ4gDhDLBiEPIAUgDxDMBgwBCyAEKAIIIRAgEBDLBiERIAUgERDNBgtBECESIAQgEmohEyATJAAPC1sBCX8jACEDQRAhBCADIARrIQUgBSQAIAUgATYCDCAFIAI2AgggBSgCDCEGIAYQ9gMhByAFKAIIIQggCBD2AyEJIAAgByAJEM8GGkEQIQogBSAKaiELIAskAA8LVQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEKAIAIQUgBCAFENEGIQYgAyAGNgIIIAMoAgghB0EQIQggAyAIaiEJIAkkACAHDwtVAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQoAgQhBSAEIAUQ0QYhBiADIAY2AgggAygCCCEHQRAhCCADIAhqIQkgCSQAIAcPC5cBARN/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhggBCABNgIQQQghBSAEIAVqIQYgBiEHQRghCCAEIAhqIQkgCSEKIAooAgAhCyAHIAs2AgAgBCEMQRAhDSAEIA1qIQ4gDiEPIA8oAgAhECAMIBA2AgAgBCgCCCERIAQoAgAhEiARIBIQ0AZBICETIAQgE2ohFCAUJAAPC7QBARR/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAEKAIYIQYgBRDSBiEHIAYhCCAHIQkgCCAJSyEKQQEhCyAKIAtxIQwCQCAMRQ0AIAUQ0wYhDSAEIA02AhQgBCgCGCEOIAUQ1AYhDyAEKAIUIRAgBCERIBEgDiAPIBAQ1QYaIAQhEiAFIBIQ1gYgBCETIBMQ1wYaC0EgIRQgBCAUaiEVIBUkAA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwtbAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAE2AgwgBSACNgIIIAUoAgwhBiAGEJ0DIQcgBSgCCCEIIAgQ3AYhCSAAIAcgCRDdBhpBECEKIAUgCmohCyALJAAPC4YBAQ9/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBhD2AyEHIAcoAgAhCCAFIAg2AgBBBCEJIAUgCWohCiAEKAIIIQtBBCEMIAsgDGohDSANENwGIQ4gCiAOEN4GGkEQIQ8gBCAPaiEQIBAkACAFDwuiAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCBCEGIAUQ2AYhByAHKAIAIQggBiEJIAghCiAJIApJIQtBASEMIAsgDHEhDQJAAkAgDUUNACAEKAIIIQ4gDhDZBiEPIAUgDxDaBgwBCyAEKAIIIRAgEBDZBiERIAUgERDbBgtBECESIAQgEmohEyATJAAPC2QBDH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQ3wYhB0F/IQggByAIcyEJQQEhCiAJIApxIQtBECEMIAQgDGohDSANJAAgCw8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDws2AQd/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFQXQhBiAFIAZqIQcgBw8LWwEJfyMAIQNBECEEIAMgBGshBSAFJAAgBSABNgIMIAUgAjYCCCAFKAIMIQYgBhCdAyEHIAUoAgghCCAIEOAGIQkgACAHIAkQ4QYaQRAhCiAFIApqIQsgCyQADws9AQd/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFQQghBiAFIAZqIQcgBCAHNgIAIAQPC4UBAQ9/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQMRpBACEFIAQgBTYCAEEAIQYgBCAGNgIEQQghByAEIAdqIQhBACEJIAMgCTYCCEEIIQogAyAKaiELIAshDCADIQ0gCCAMIA0QqgcaQRAhDiADIA5qIQ8gDyQAIAQPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQrgchBiAEKAIIIQcgBxCuByEIIAYhCSAIIQogCSAKRiELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LpgEBFn8jACECQTAhAyACIANrIQQgBCQAIAQgADYCKCAEIAE2AiBBGCEFIAQgBWohBiAGIQdBKCEIIAQgCGohCSAJIQogCigCACELIAcgCzYCAEEQIQwgBCAMaiENIA0hDkEgIQ8gBCAPaiEQIBAhESARKAIAIRIgDiASNgIAIAQoAhghEyAEKAIQIRQgEyAUEK8HIRVBMCEWIAQgFmohFyAXJAAgFQ8LZAEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhCPBiEHQX8hCCAHIAhzIQlBASEKIAkgCnEhC0EQIQwgBCAMaiENIA0kACALDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPCz0BB38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQVBDCEGIAUgBmohByAEIAc2AgAgBA8LlAEBEH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAFELAHIQcgBygCACEIIAYhCSAIIQogCSAKRyELQQEhDCALIAxxIQ0CQAJAIA1FDQAgBCgCCCEOIAUgDhCxBwwBCyAEKAIIIQ8gBSAPELIHC0EQIRAgBCAQaiERIBEkAA8LXAEKfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIAIQVBCCEGIAQgBmohByAHIQggCCAFEO0HGiAEKAIIIQlBECEKIAQgCmohCyALJAAgCQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgQgAygCBCEEIAQPC5oBARF/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBUEEIQYgBSAGaiEHIAcQ7gcaQQghCCAFIAhqIQlBACEKIAQgCjYCBCAEKAIIIQtBBCEMIAQgDGohDSANIQ4gCSAOIAsQ7wcaIAUQ8AchDyAFEPEHIRAgECAPNgIAQRAhESAEIBFqIRIgEiQAIAUPC1wBC38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBC4ByEFQQghBiADIAZqIQcgByEIIAggBRCCCBogAygCCCEJQRAhCiADIApqIQsgCyQAIAkPCwMADwvHAwE3fyMAIQZBwAAhByAGIAdrIQggCCQAIAggATYCPCAIIAI2AjggCCADNgI0IAggBDYCMCAIIAU2AiwgCCgCPCEJIAgoAjghCkEoIQsgCCALaiEMIAwhDSAJIA0gChD3ByEOIAggDjYCJCAIKAIkIQ8gDygCACEQIAggEDYCIEEAIREgCCAROgAfIAgoAiQhEiASKAIAIRNBACEUIBMhFSAUIRYgFSAWRiEXQQEhGCAXIBhxIRkCQCAZRQ0AIAgoAjQhGiAaEPgHIRsgCCgCMCEcIBwQ+QchHSAIKAIsIR4gHhD6ByEfQRAhICAIICBqISEgISEiICIgCSAbIB0gHxD7ByAIKAIoISMgCCgCJCEkQRAhJSAIICVqISYgJiEnICcQ/AchKCAJICMgJCAoEP0HQRAhKSAIIClqISogKiErICsQ/gchLCAIICw2AiBBASEtIAggLToAH0EQIS4gCCAuaiEvIC8hMCAwEP8HGgsgCCgCICExQQghMiAIIDJqITMgMyE0IDQgMRCACBpBCCE1IAggNWohNiA2ITdBHyE4IAggOGohOSA5ITogACA3IDoQgQgaQcAAITsgCCA7aiE8IDwkAA8LUAEKfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEIMIIQVBECEGIAUgBmohByAHEIQIIQhBECEJIAMgCWohCiAKJAAgCA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC9kBARZ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgQhBSAFEMYIIAQoAgAhBiAFIAYQxwggBCgCACEHIAcoAgAhCCAFIAg2AgAgBCgCACEJIAkoAgQhCiAFIAo2AgQgBCgCACELIAsQggQhDCAMKAIAIQ0gBRCCBCEOIA4gDTYCACAEKAIAIQ8gDxCCBCEQQQAhESAQIBE2AgAgBCgCACESQQAhEyASIBM2AgQgBCgCACEUQQAhFSAUIBU2AgBBECEWIAQgFmohFyAXJAAPC1wBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCACEFQQghBiAEIAZqIQcgByEIIAggBRDOCBogBCgCCCEJQRAhCiAEIApqIQsgCyQAIAkPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQzwghBiAEKAIIIQcgBxDPCCEIIAYhCSAIIQogCSAKRiELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LbQEOfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRDJBSEGIAQoAgghByAHEMkFIQggBiEJIAghCiAJIApGIQtBASEMIAsgDHEhDUEQIQ4gBCAOaiEPIA8kACANDwtuAQt/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgQhBSAEKAIAIQYgBRCFCCEHIAUQ8AchCCAFIAYgByAIENAIIQkgBCAJNgIIIAQoAgghCkEQIQsgBCALaiEMIAwkACAKDwtIAQh/IwAhAkEQIQMgAiADayEEIAQgATYCCCAEIAA2AgQgBCgCBCEFQQghBiAEIAZqIQcgByEIIAgoAgAhCSAFIAk2AgAgBQ8LkQEBEX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCACEFIAQoAgQhBkEIIQcgBCAHaiEIIAghCSAJIAUgBhDSCCEKQQEhCyAKIAtxIQwCQAJAIAxFDQAgBCgCACENIA0hDgwBCyAEKAIEIQ8gDyEOCyAOIRBBECERIAQgEWohEiASJAAgEA8LZAEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhDTCCEHQX8hCCAHIAhzIQlBASEKIAkgCnEhC0EQIQwgBCAMaiENIA0kACALDwtjAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQ8QchBSAFKAIAIQZBCCEHIAMgB2ohCCAIIQkgCSAGENEIGiADKAIIIQpBECELIAMgC2ohDCAMJAAgCg8LTAEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIAIQUgBRDUCCEGIAQgBjYCAEEQIQcgAyAHaiEIIAgkACAEDwtuAQt/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgQhBSAEKAIAIQYgBRCFCCEHIAUQ8AchCCAFIAYgByAIENYIIQkgBCAJNgIIIAQoAgghCkEQIQsgBCALaiEMIAwkACAKDwuRAQERfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBCgCACEGQQghByAEIAdqIQggCCEJIAkgBSAGENIIIQpBASELIAogC3EhDAJAAkAgDEUNACAEKAIAIQ0gDSEODAELIAQoAgQhDyAPIQ4LIA4hEEEQIREgBCARaiESIBIkACAQDwuzAQEVfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQVBCCEGIAQgBmohByAHIQhBASEJIAggBSAJENgEGiAFENkEIQogBCgCDCELIAsQ2gQhDCAEKAIYIQ0gDRCKBSEOIAogDCAOEIgFIAQoAgwhD0EUIRAgDyAQaiERIAQgETYCDEEIIRIgBCASaiETIBMhFCAUEN0EGkEgIRUgBCAVaiEWIBYkAA8L3QEBGH8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAUQ2QQhBiAEIAY2AhQgBRCnAyEHQQEhCCAHIAhqIQkgBSAJEN4EIQogBRCnAyELIAQoAhQhDCAEIQ0gDSAKIAsgDBDfBBogBCgCFCEOIAQoAgghDyAPENoEIRAgBCgCGCERIBEQigUhEiAOIBAgEhCIBSAEKAIIIRNBFCEUIBMgFGohFSAEIBU2AgggBCEWIAUgFhDgBCAEIRcgFxDhBBpBICEYIAQgGGohGSAZJAAPC0wBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAUQ1wghBiAEIAY2AgBBECEHIAMgB2ohCCAIJAAgBA8LDAEBfxDZCCEAIAAPC4QDATF/IwAhA0HAACEEIAMgBGshBSAFJAAgBSABNgI4IAUgAjYCMCAFIAA2AiwgBSgCLCEGIAUgBjYCPCAGEP4DGkEgIQcgBSAHaiEIIAghCUE4IQogBSAKaiELIAshDCAMKAIAIQ0gCSANNgIAQRghDiAFIA5qIQ8gDyEQQTAhESAFIBFqIRIgEiETIBMoAgAhFCAQIBQ2AgAgBSgCICEVIAUoAhghFiAVIBYQiAQhFyAFIBc2AiggBSgCKCEYQQAhGSAYIRogGSEbIBogG0shHEEBIR0gHCAdcSEeAkAgHkUNACAFKAIoIR8gBiAfENoIQRAhICAFICBqISEgISEiQTghIyAFICNqISQgJCElICUoAgAhJiAiICY2AgBBCCEnIAUgJ2ohKCAoISlBMCEqIAUgKmohKyArISwgLCgCACEtICkgLTYCACAFKAIoIS4gBSgCECEvIAUoAgghMCAGIC8gMCAuENsICyAFKAI8ITFBwAAhMiAFIDJqITMgMyQAIDEPC+cBASJ/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgAhBiAEKAIIIQcgBygCACEIIAYhCSAIIQogCSAKSCELQQEhDEEBIQ0gCyANcSEOIAwhDwJAIA4NACAFKAIAIRAgBCgCCCERIBEoAgAhEiAQIRMgEiEUIBMgFEYhFUEAIRZBASEXIBUgF3EhGCAWIRkCQCAYRQ0AIAUoAgQhGiAEKAIIIRsgGygCBCEcIBohHSAcIR4gHSAeSCEfIB8hGQsgGSEgICAhDwsgDyEhQQEhIiAhICJxISMgIw8LlwEBE38jACECQSAhAyACIANrIQQgBCQAIAQgADYCGCAEIAE2AhBBCCEFIAQgBWohBiAGIQdBGCEIIAQgCGohCSAJIQogCigCACELIAcgCzYCACAEIQxBECENIAQgDWohDiAOIQ8gDygCACEQIAwgEDYCACAEKAIIIREgBCgCACESIBEgEhDcCEEgIRMgBCATaiEUIBQkAA8LkwEBEH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAFECchByAHKAIAIQggBiEJIAghCiAJIApHIQtBASEMIAsgDHEhDQJAAkAgDUUNACAEKAIIIQ4gBSAOEN0IDAELIAQoAgghDyAFIA8Q3ggLQRAhECAEIBBqIREgESQADwtqAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQ3wghBSADIAU2AgAgAygCACEGQQghByADIAdqIQggCCEJIAkgBhDgCBogAygCCCEKQRAhCyADIAtqIQwgDCQAIAoPC2oBDH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBDiCCEFIAMgBTYCACADKAIAIQZBCCEHIAMgB2ohCCAIIQkgCSAGEOAIGiADKAIIIQpBECELIAMgC2ohDCAMJAAgCg8LZAEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhDhCCEHQX8hCCAHIAhzIQlBASEKIAkgCnEhC0EQIQwgBCAMaiENIA0kACALDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ4wghBUEQIQYgBSAGaiEHQRAhCCADIAhqIQkgCSQAIAcPC0wBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAUQ1wghBiAEIAY2AgBBECEHIAMgB2ohCCAIJAAgBA8LqQEBFn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQ5AEhB0EAIQhBASEJIAcgCXEhCiAIIQsCQCAKRQ0AIAQoAgwhDEEIIQ0gDCANaiEOIAQoAgghD0EIIRAgDyAQaiERIA4gERDkASESIBIhCwsgCyETQQEhFCATIBRxIRVBECEWIAQgFmohFyAXJAAgFQ8LMQIEfwF+IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQRCACEFIAQgBTcCACAEDwuJBQFQfyMAIQZBMCEHIAYgB2shCCAIJAAgCCAANgIoIAggATYCJCAIIAI2AiAgCCADNgIcIAQhCSAIIAk6ABsgBSEKIAggCjoAGiAIKAIoIQsgCC0AGyEMQQEhDSAMIA1xIQ4CQAJAIA4NACAIKAIgIQ8gCCgCHCEQIA8gEBDkCCERQQEhEiARIBJxIRMgEw0AQQAhFEEBIRUgFCAVcSEWIAggFjoALwwBCyAIKAIkIRcgCCgCICEYIAgoAhwhGSAILQAbIRpBACEbQQEhHCAaIBxxIR1BASEeIBsgHnEhHyAXIBggGSAdIB8Q5QghIEEBISEgICAhcSEiIAggIjoAGSAILQAbISNBASEkICMgJHEhJQJAAkAgJQ0AIAgtABkhJkEBIScgJiAncSEoAkAgKEUNACAIKAIkISlBECEqIAggKmohKyArISwgLCApEOIBGiAIKAIgIS1BECEuIAggLmohLyAvITAgMCAtEMEGITFBASEyIDEgMnEhMwJAIDNFDQAgCCgCJCE0QQghNSAIIDVqITYgNiE3IDcgNBDiARogCCgCHCE4QQghOSAIIDlqITogOiE7IDsgOBDBBiE8QQEhPSA8ID1xIT4gPkUNAEEBIT9BASFAID8gQHEhQSAIIEE6AC8MBAsLDAELIAgtABkhQkEBIUMgQiBDcSFEIAggRDoALwwBCyAIKAIkIUUgCCgCICFGIAgoAhwhRyAILQAbIUggCC0AGiFJQQEhSiBIIEpxIUtBASFMIEkgTHEhTSALIEUgRiBHIEsgTRDmCCFOQQEhTyBOIE9xIVAgCCBQOgAvCyAILQAvIVFBASFSIFEgUnEhU0EwIVQgCCBUaiFVIFUkACBTDwtcAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAE2AgwgBSACNgIIIAUoAgwhBiAFKAIIIQcgBSEIIAggBiAHEOcIIAUhCSAAIAkQ6AgaQRAhCiAFIApqIQsgCyQADwuXAQETfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIYIAQgATYCEEEIIQUgBCAFaiEGIAYhB0EYIQggBCAIaiEJIAkhCiAKKAIAIQsgByALNgIAIAQhDEEQIQ0gBCANaiEOIA4hDyAPKAIAIRAgDCAQNgIAIAQoAgghESAEKAIAIRIgESASEOkIQSAhEyAEIBNqIRQgFCQADwu0AQEXfyMAIQJBMCEDIAIgA2shBCAEJAAgBCAANgIgIAQgATYCGEEQIQUgBCAFaiEGIAYhB0EgIQggBCAIaiEJIAkhCiAKKAIAIQsgByALNgIAQQghDCAEIAxqIQ0gDSEOQRghDyAEIA9qIRAgECERIBEoAgAhEiAOIBI2AgAgBCgCECETIAQoAgghFCATIBQQ6gghFSAEIBU2AiggBCgCKCEWQTAhFyAEIBdqIRggGCQAIBYPC04BCH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQ6wghB0EQIQggBCAIaiEJIAkkACAHDwtOAQh/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEOwIIQdBECEIIAQgCGohCSAJJAAgBw8LZAEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhDtCCEHQX8hCCAHIAhzIQlBASEKIAkgCnEhC0EQIQwgBCAMaiENIA0kACALDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPCz0BB38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQVBCCEGIAUgBmohByAEIAc2AgAgBA8LsxABgAJ/IwAhAkHQASEDIAIgA2shBCAEJAAgBCABNgLIASAEKALIASEFQQghBiAFIAZqIQcgACAHEOQBIQhBASEJIAggCXEhCgJAAkAgCkUNAEEBIQtBASEMIAsgDHEhDSAEIA06AM8BDAELIAQoAsgBIQ4gACAOEOQBIQ9BASEQIA8gEHEhEQJAIBFFDQBBASESQQEhEyASIBNxIRQgBCAUOgDPAQwBC0G4ASEVIAQgFWohFiAWIRcgFxDuCBogBCgCyAEhGCAEKALIASEZQQghGiAZIBpqIRtBuAEhHCAEIBxqIR0gHSEeIB4gGCAbEO8IGkGwASEfIAQgH2ohICAgISEgISAAEOIBGkG4ASEiIAQgImohIyAjISRBsAEhJSAEICVqISYgJiEnQQEhKEEBISkgKCApcSEqICQgJyAqEPAIIStBASEsICsgLHEhLQJAAkAgLUUNACAEKALIASEuIC4QrwMhL0EBITAgLyAwcSExAkACQCAxDQAgBCgCyAEhMiAyEPEIITNBASE0IDMgNHEhNSA1RQ0BC0EBITZBASE3IDYgN3EhOCAEIDg6AM8BDAMLDAELQQAhOUEBITogOSA6cSE7IAQgOzoAzwEMAQtBqAEhPCAEIDxqIT0gPSE+QQAhPyA+ID8QDxpBqAEhQCAEIEBqIUEgQSFCIAAgQhAvIUMgBCBDNgKsAUGgASFEIAQgRGohRSBFIUZBASFHIEYgRxAPGkGgASFIIAQgSGohSSBJIUogACBKEC8hSyAEIEs2AqQBIAQoAsgBIUwgBCgCyAEhTUEIIU4gTSBOaiFPQawBIVAgBCBQaiFRIFEhUkGkASFTIAQgU2ohVCBUIVUgUiBVIEwgTxDyCCFWQQEhVyBWIFdxIVgCQCBYRQ0AQZgBIVkgBCBZaiFaIFohWyBbIAAQ4gEaIAQoAsgBIVxBkAEhXSAEIF1qIV4gXiFfIF8gXBDiARogBCgCyAEhYEEIIWEgYCBhaiFiQYgBIWMgBCBjaiFkIGQhZSBlIGIQ4gEaQZgBIWYgBCBmaiFnIGchaEGQASFpIAQgaWohaiBqIWtBiAEhbCAEIGxqIW0gbSFuIGggayBuEPMIIW9BASFwIG8gcHEhcSBxRQ0AQQEhckEBIXMgciBzcSF0IAQgdDoAzwEMAQtB+AAhdSAEIHVqIXYgdiF3QQAheCB3IHgQDxpB+AAheSAEIHlqIXogeiF7IAAgexAvIXxB8AAhfSAEIH1qIX4gfiF/QQEhgAEgfyCAARAPGkHwACGBASAEIIEBaiGCASCCASGDASAAIIMBEC8hhAFBASGFASCEASCFAWohhgFBgAEhhwEgBCCHAWohiAEgiAEhiQEgiQEgfCCGARAcGkHgACGKASAEIIoBaiGLASCLASGMAUEAIY0BIIwBII0BEA8aQeAAIY4BIAQgjgFqIY8BII8BIZABIAAgkAEQLyGRAUEBIZIBIJEBIJIBaiGTAUHYACGUASAEIJQBaiGVASCVASGWAUEBIZcBIJYBIJcBEA8aQdgAIZgBIAQgmAFqIZkBIJkBIZoBIAAgmgEQLyGbAUHoACGcASAEIJwBaiGdASCdASGeASCeASCTASCbARAcGkHIACGfASAEIJ8BaiGgASCgASGhAUEAIaIBIKEBIKIBEA8aQcgAIaMBIAQgowFqIaQBIKQBIaUBIAAgpQEQLyGmAUEBIacBIKYBIKcBaiGoAUHAACGpASAEIKkBaiGqASCqASGrAUEBIawBIKsBIKwBEA8aQcAAIa0BIAQgrQFqIa4BIK4BIa8BIAAgrwEQLyGwAUEBIbEBILABILEBaiGyAUHQACGzASAEILMBaiG0ASC0ASG1ASC1ASCoASCyARAcGkEwIbYBIAQgtgFqIbcBILcBIbgBQdAAIbkBIAQguQFqIboBILoBIbsBILgBIAAguwEQ9AgaIAQoAsgBIbwBQTAhvQEgBCC9AWohvgEgvgEhvwEgvwEgvAEQ5AghwAFBASHBASDAASDBAXEhwgECQCDCAUUNAEEoIcMBIAQgwwFqIcQBIMQBIcUBQdAAIcYBIAQgxgFqIccBIMcBIcgBIMUBIMgBEOIBGiAEKALIASHJAUEoIcoBIAQgygFqIcsBIMsBIcwBIMwBIMkBEPUIIc0BIM0BRQ0AQQEhzgFBASHPASDOASDPAXEh0AEgBCDQAToAzwEMAQtBGCHRASAEINEBaiHSASDSASHTAUGAASHUASAEINQBaiHVASDVASHWAUHoACHXASAEINcBaiHYASDYASHZASDTASDWASDZARD0CBogBCgCyAEh2gFBGCHbASAEINsBaiHcASDcASHdASDdASDaARDkCCHeAUEBId8BIN4BIN8BcSHgAQJAIOABRQ0AQRAh4QEgBCDhAWoh4gEg4gEh4wFBgAEh5AEgBCDkAWoh5QEg5QEh5gEg4wEg5gEQ4gEaIAQoAsgBIecBQRAh6AEgBCDoAWoh6QEg6QEh6gEg6gEg5wEQ9Qgh6wEg6wFFDQBBCCHsASAEIOwBaiHtASDtASHuAUHoACHvASAEIO8BaiHwASDwASHxASDuASDxARDiARogBCgCyAEh8gFBCCHzASAEIPMBaiH0ASD0ASH1ASD1ASDyARD1CCH2ASD2AUUNAEEBIfcBQQEh+AEg9wEg+AFxIfkBIAQg+QE6AM8BDAELQQAh+gFBASH7ASD6ASD7AXEh/AEgBCD8AToAzwELIAQtAM8BIf0BQQEh/gEg/QEg/gFxIf8BQdABIYACIAQggAJqIYECIIECJAAg/wEPC0UBB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCFCCEFIAQgBRCSCkEQIQYgAyAGaiEHIAckACAEDwupAQEWfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOIHIQUgBBDiByEGIAQQxgchB0ECIQggByAIdCEJIAYgCWohCiAEEOIHIQsgBBC7ByEMQQIhDSAMIA10IQ4gCyAOaiEPIAQQ4gchECAEEMYHIRFBAiESIBEgEnQhEyAQIBNqIRQgBCAFIAogDyAUEOMHQRAhFSADIBVqIRYgFiQADwuVAQERfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIIIAMoAgghBCADIAQ2AgwgBCgCACEFQQAhBiAFIQcgBiEIIAcgCEchCUEBIQogCSAKcSELAkAgC0UNACAEEJMKIAQQtgchDCAEKAIAIQ0gBBDUByEOIAwgDSAOENEHCyADKAIMIQ9BECEQIAMgEGohESARJAAgDw8LqQEBFn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCQByEFIAQQkAchBiAEENIGIQdBDCEIIAcgCGwhCSAGIAlqIQogBBCQByELIAQQ1AYhDEEMIQ0gDCANbCEOIAsgDmohDyAEEJAHIRAgBBDSBiERQQwhEiARIBJsIRMgECATaiEUIAQgBSAKIA8gFBCRB0EQIRUgAyAVaiEWIBYkAA8LlQEBEX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCCCADKAIIIQQgAyAENgIMIAQoAgAhBUEAIQYgBSEHIAYhCCAHIAhHIQlBASEKIAkgCnEhCwJAIAtFDQAgBBCVCiAEENMGIQwgBCgCACENIAQQ9wYhDiAMIA0gDhCDBwsgAygCDCEPQRAhECADIBBqIREgESQAIA8PC2wBCX8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxAzIQggBiAIEMgGGiAFKAIEIQkgCRA1GiAGEMkGGkEQIQogBSAKaiELIAskACAGDwtVAQh/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBhAzGkEAIQcgBSAHNgIAQRAhCCAEIAhqIQkgCSQAIAUPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBDKBhpBECEFIAMgBWohBiAGJAAgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwuzAQEVfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQVBCCEGIAQgBmohByAHIQhBASEJIAggBSAJEJ8EGiAFEKAEIQogBCgCDCELIAsQoQQhDCAEKAIYIQ0gDRDcBiEOIAogDCAOEOIGIAQoAgwhD0EIIRAgDyAQaiERIAQgETYCDEEIIRIgBCASaiETIBMhFCAUEKQEGkEgIRUgBCAVaiEWIBYkAA8L3QEBGH8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAUQoAQhBiAEIAY2AhQgBRClBCEHQQEhCCAHIAhqIQkgBSAJEKYEIQogBRClBCELIAQoAhQhDCAEIQ0gDSAKIAsgDBCnBBogBCgCFCEOIAQoAgghDyAPEKEEIRAgBCgCGCERIBEQ3AYhEiAOIBAgEhDiBiAEKAIIIRNBCCEUIBMgFGohFSAEIBU2AgggBCEWIAUgFhCoBCAEIRcgFxCpBBpBICEYIAQgGGohGSAZJAAPC30BDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxD2AyEIIAgoAgAhCSAGIAk2AgAgBSgCBCEKIAoQnQMhCyALKAIAIQwgBiAMNgIEQRAhDSAFIA1qIQ4gDiQAIAYPC30BDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxD2AyEIIAgoAgAhCSAGIAk2AgAgBSgCBCEKIAoQ9gMhCyALKAIAIQwgBiAMNgIEQRAhDSAFIA1qIQ4gDiQAIAYPC5cBARN/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhggBCABNgIQQQghBSAEIAVqIQYgBiEHQRghCCAEIAhqIQkgCSEKIAooAgAhCyAHIAs2AgAgBCEMQRAhDSAEIA1qIQ4gDiEPIA8oAgAhECAMIBA2AgAgBCgCCCERIAQoAgAhEiARIBIQ5QZBICETIAQgE2ohFCAUJAAPC1wBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCACEFQQghBiAEIAZqIQcgByEIIAggBRD2BhogBCgCCCEJQRAhCiAEIApqIQsgCyQAIAkPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD3BiEFQRAhBiADIAZqIQcgByQAIAUPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEPgGIQdBECEIIAMgCGohCSAJJAAgBw8LRAEJfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgQhBSAEKAIAIQYgBSAGayEHQQwhCCAHIAhtIQkgCQ8LrgIBIH8jACEEQSAhBSAEIAVrIQYgBiQAIAYgADYCGCAGIAE2AhQgBiACNgIQIAYgAzYCDCAGKAIYIQcgBiAHNgIcQQwhCCAHIAhqIQlBACEKIAYgCjYCCCAGKAIMIQtBCCEMIAYgDGohDSANIQ4gCSAOIAsQ+QYaIAYoAhQhDwJAAkAgD0UNACAHEPoGIRAgBigCFCERIBAgERD7BiESIBIhEwwBC0EAIRQgFCETCyATIRUgByAVNgIAIAcoAgAhFiAGKAIQIRdBDCEYIBcgGGwhGSAWIBlqIRogByAaNgIIIAcgGjYCBCAHKAIAIRsgBigCFCEcQQwhHSAcIB1sIR4gGyAeaiEfIAcQ/AYhICAgIB82AgAgBigCHCEhQSAhIiAGICJqISMgIyQAICEPC/sBARt/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEMUGIAUQ0wYhBiAFKAIAIQcgBSgCBCEIIAQoAgghCUEEIQogCSAKaiELIAYgByAIIAsQ/QYgBCgCCCEMQQQhDSAMIA1qIQ4gBSAOEP4GQQQhDyAFIA9qIRAgBCgCCCERQQghEiARIBJqIRMgECATEP4GIAUQ2AYhFCAEKAIIIRUgFRD8BiEWIBQgFhD+BiAEKAIIIRcgFygCBCEYIAQoAgghGSAZIBg2AgAgBRDUBiEaIAUgGhD/BiAFEIAHQRAhGyAEIBtqIRwgHCQADwuVAQERfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIIIAMoAgghBCADIAQ2AgwgBBCBByAEKAIAIQVBACEGIAUhByAGIQggByAIRyEJQQEhCiAJIApxIQsCQCALRQ0AIAQQ+gYhDCAEKAIAIQ0gBBCCByEOIAwgDSAOEIMHCyADKAIMIQ9BECEQIAMgEGohESARJAAgDw8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQkwchB0EQIQggAyAIaiEJIAkkACAHDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LswEBFX8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFQQghBiAEIAZqIQcgByEIQQEhCSAIIAUgCRCdBxogBRDTBiEKIAQoAgwhCyALEJQHIQwgBCgCGCENIA0QngchDiAKIAwgDhCfByAEKAIMIQ9BDCEQIA8gEGohESAEIBE2AgxBCCESIAQgEmohEyATIRQgFBCgBxpBICEVIAQgFWohFiAWJAAPC90BARh/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAFENMGIQYgBCAGNgIUIAUQ1AYhB0EBIQggByAIaiEJIAUgCRChByEKIAUQ1AYhCyAEKAIUIQwgBCENIA0gCiALIAwQ1QYaIAQoAhQhDiAEKAIIIQ8gDxCUByEQIAQoAhghESAREJ4HIRIgDiAQIBIQnwcgBCgCCCETQQwhFCATIBRqIRUgBCAVNgIIIAQhFiAFIBYQ1gYgBCEXIBcQ1wYaQSAhGCAEIBhqIRkgGSQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LigECDX8BfiMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHEJ0DIQggCCgCACEJIAYgCTYCAEEEIQogBiAKaiELIAUoAgQhDCAMENwGIQ0gDSkCACEQIAsgEDcCAEEQIQ4gBSAOaiEPIA8kACAGDwuBAQEOfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQ9gMhByAHKAIAIQggBSAINgIAIAQoAgghCUEEIQogCSAKaiELIAsQ9gMhDCAMKAIAIQ0gBSANNgIEQRAhDiAEIA5qIQ8gDyQAIAUPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ5gYhBiAEKAIIIQcgBxDmBiEIIAYhCSAIIQogCSAKRiELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC4oBAg1/AX4jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxCdAyEIIAgoAgAhCSAGIAk2AgBBBCEKIAYgCmohCyAFKAIEIQwgDBDgBiENIA0pAgAhECALIBA3AgBBECEOIAUgDmohDyAPJAAgBg8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSgCHCEGIAUoAhghByAFKAIUIQggCBDcBiEJIAYgByAJEOMGQSAhCiAFIApqIQsgCyQADwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhQgBSABNgIQIAUgAjYCDCAFKAIUIQYgBSgCECEHIAUoAgwhCCAIENwGIQkgBiAHIAkQ5AZBICEKIAUgCmohCyALJAAPC2ECCH8BfiMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAUoAgQhByAHENwGIQggCCkCACELIAYgCzcCAEEQIQkgBSAJaiEKIAokAA8LXQELfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIIIAQgATYCAEEIIQUgBCAFaiEGIAYhByAHEOYGIQggBCEJIAkQ5gYhCiAIIAoQ5wZBECELIAQgC2ohDCAMJAAPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBQ8LSgEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhDoBkEQIQcgBCAHaiEIIAgkAA8LWwEKfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBCgCACEGQQghByAEIAdqIQggCCEJIAUgBiAJEOkGQRAhCiAEIApqIQsgCyQADwvnGgHZAn8jACEDQTAhBCADIARrIQUgBSQAIAUgADYCLCAFIAE2AiggBSACNgIkQQYhBiAFIAY2AiADQAJAAkADQCAFKAIoIQcgBSgCLCEIIAcgCGshCUEIIQogCSAKbSELIAUgCzYCHCAFKAIcIQxBBSENIAwgDUsaAkACQAJAAkACQAJAIAwOBgAAAQIDBAULDAcLIAUoAiQhDiAFKAIoIQ9BeCEQIA8gEGohESAFIBE2AiggBSgCLCESIA4gESASEOoGIRNBASEUIBMgFHEhFQJAIBVFDQAgBSgCLCEWIAUoAighFyAWIBcQ6wYLDAYLIAUoAiwhGCAFKAIsIRlBCCEaIBkgGmohGyAFKAIoIRxBeCEdIBwgHWohHiAFIB42AiggBSgCJCEfIBggGyAeIB8Q7AYaDAULIAUoAiwhICAFKAIsISFBCCEiICEgImohIyAFKAIsISRBECElICQgJWohJiAFKAIoISdBeCEoICcgKGohKSAFICk2AiggBSgCJCEqICAgIyAmICkgKhDtBhoMBAsgBSgCLCErIAUoAiwhLEEIIS0gLCAtaiEuIAUoAiwhL0EQITAgLyAwaiExIAUoAiwhMkEYITMgMiAzaiE0IAUoAighNUF4ITYgNSA2aiE3IAUgNzYCKCAFKAIkITggKyAuIDEgNCA3IDgQ7gYaDAMLIAUoAhwhOUEGITogOSE7IDohPCA7IDxMIT1BASE+ID0gPnEhPwJAID9FDQAgBSgCLCFAIAUoAighQSAFKAIkIUIgQCBBIEIQ7wYMAwsgBSgCLCFDIAUgQzYCGCAFKAIoIUQgBSBENgIUIAUoAhQhRUF4IUYgRSBGaiFHIAUgRzYCFCAFKAIcIUhB6AchSSBIIUogSSFLIEogS04hTEEBIU0gTCBNcSFOAkACQCBORQ0AIAUoAhwhT0ECIVAgTyBQbSFRIAUgUTYCDCAFKAIMIVIgBSgCGCFTQQMhVCBSIFR0IVUgUyBVaiFWIAUgVjYCGCAFKAIMIVdBAiFYIFcgWG0hWSAFIFk2AgwgBSgCLCFaIAUoAiwhWyAFKAIMIVxBAyFdIFwgXXQhXiBbIF5qIV8gBSgCGCFgIAUoAhghYSAFKAIMIWJBAyFjIGIgY3QhZCBhIGRqIWUgBSgCFCFmIAUoAiQhZyBaIF8gYCBlIGYgZxDuBiFoIAUgaDYCEAwBCyAFKAIcIWlBAiFqIGkgam0hayAFIGs2AgwgBSgCDCFsIAUoAhghbUEDIW4gbCBudCFvIG0gb2ohcCAFIHA2AhggBSgCLCFxIAUoAhghciAFKAIUIXMgBSgCJCF0IHEgciBzIHQQ7AYhdSAFIHU2AhALIAUoAiwhdiAFIHY2AgggBSgCFCF3IAUgdzYCBCAFKAIkIXggBSgCCCF5IAUoAhgheiB4IHkgehDqBiF7QQEhfCB7IHxxIX0gfQ0BA0AgBSgCCCF+IAUoAgQhf0F4IYABIH8ggAFqIYEBIAUggQE2AgQgfiGCASCBASGDASCCASCDAUYhhAFBASGFASCEASCFAXEhhgECQCCGAUUNACAFKAIIIYcBQQghiAEghwEgiAFqIYkBIAUgiQE2AgggBSgCKCGKASAFIIoBNgIEIAUoAiQhiwEgBSgCLCGMASAFKAIEIY0BQXghjgEgjQEgjgFqIY8BIAUgjwE2AgQgiwEgjAEgjwEQ6gYhkAFBASGRASCQASCRAXEhkgECQCCSAQ0AA0AgBSgCCCGTASAFKAIEIZQBIJMBIZUBIJQBIZYBIJUBIJYBRiGXAUEBIZgBIJcBIJgBcSGZAQJAIJkBRQ0ADAcLIAUoAiQhmgEgBSgCLCGbASAFKAIIIZwBIJoBIJsBIJwBEOoGIZ0BQQEhngEgnQEgngFxIZ8BAkACQCCfAUUNACAFKAIIIaABIAUoAgQhoQEgoAEgoQEQ6wYgBSgCECGiAUEBIaMBIKIBIKMBaiGkASAFIKQBNgIQIAUoAgghpQFBCCGmASClASCmAWohpwEgBSCnATYCCAwBCyAFKAIIIagBQQghqQEgqAEgqQFqIaoBIAUgqgE2AggMAQsLCyAFKAIIIasBIAUoAgQhrAEgqwEhrQEgrAEhrgEgrQEgrgFGIa8BQQEhsAEgrwEgsAFxIbEBAkAgsQFFDQAMBQsDQAJAA0AgBSgCJCGyASAFKAIsIbMBIAUoAgghtAEgsgEgswEgtAEQ6gYhtQFBfyG2ASC1ASC2AXMhtwFBASG4ASC3ASC4AXEhuQEguQFFDQEgBSgCCCG6AUEIIbsBILoBILsBaiG8ASAFILwBNgIIDAALAAsCQANAIAUoAiQhvQEgBSgCLCG+ASAFKAIEIb8BQXghwAEgvwEgwAFqIcEBIAUgwQE2AgQgvQEgvgEgwQEQ6gYhwgFBASHDASDCASDDAXEhxAEgxAFFDQEMAAsACyAFKAIIIcUBIAUoAgQhxgEgxQEhxwEgxgEhyAEgxwEgyAFPIckBQQEhygEgyQEgygFxIcsBAkACQCDLAUUNAAwBCyAFKAIIIcwBIAUoAgQhzQEgzAEgzQEQ6wYgBSgCECHOAUEBIc8BIM4BIM8BaiHQASAFINABNgIQIAUoAggh0QFBCCHSASDRASDSAWoh0wEgBSDTATYCCAwBCwsgBSgCCCHUASAFINQBNgIsDAILIAUoAiQh1QEgBSgCBCHWASAFKAIYIdcBINUBINYBINcBEOoGIdgBQQEh2QEg2AEg2QFxIdoBAkACQCDaAUUNACAFKAIIIdsBIAUoAgQh3AEg2wEg3AEQ6wYgBSgCECHdAUEBId4BIN0BIN4BaiHfASAFIN8BNgIQDAELDAELCwsLIAUoAggh4AFBCCHhASDgASDhAWoh4gEgBSDiATYCCCAFKAIIIeMBIAUoAgQh5AEg4wEh5QEg5AEh5gEg5QEg5gFJIecBQQEh6AEg5wEg6AFxIekBAkAg6QFFDQADQAJAA0AgBSgCJCHqASAFKAIIIesBIAUoAhgh7AEg6gEg6wEg7AEQ6gYh7QFBASHuASDtASDuAXEh7wEg7wFFDQEgBSgCCCHwAUEIIfEBIPABIPEBaiHyASAFIPIBNgIIDAALAAsCQANAIAUoAiQh8wEgBSgCBCH0AUF4IfUBIPQBIPUBaiH2ASAFIPYBNgIEIAUoAhgh9wEg8wEg9gEg9wEQ6gYh+AFBfyH5ASD4ASD5AXMh+gFBASH7ASD6ASD7AXEh/AEg/AFFDQEMAAsACyAFKAIIIf0BIAUoAgQh/gEg/QEh/wEg/gEhgAIg/wEggAJLIYECQQEhggIggQIgggJxIYMCAkACQCCDAkUNAAwBCyAFKAIIIYQCIAUoAgQhhQIghAIghQIQ6wYgBSgCECGGAkEBIYcCIIYCIIcCaiGIAiAFIIgCNgIQIAUoAhghiQIgBSgCCCGKAiCJAiGLAiCKAiGMAiCLAiCMAkYhjQJBASGOAiCNAiCOAnEhjwICQCCPAkUNACAFKAIEIZACIAUgkAI2AhgLIAUoAgghkQJBCCGSAiCRAiCSAmohkwIgBSCTAjYCCAwBCwsLIAUoAgghlAIgBSgCGCGVAiCUAiGWAiCVAiGXAiCWAiCXAkchmAJBASGZAiCYAiCZAnEhmgICQCCaAkUNACAFKAIkIZsCIAUoAhghnAIgBSgCCCGdAiCbAiCcAiCdAhDqBiGeAkEBIZ8CIJ4CIJ8CcSGgAiCgAkUNACAFKAIIIaECIAUoAhghogIgoQIgogIQ6wYgBSgCECGjAkEBIaQCIKMCIKQCaiGlAiAFIKUCNgIQCyAFKAIQIaYCAkAgpgINACAFKAIsIacCIAUoAgghqAIgBSgCJCGpAiCnAiCoAiCpAhDwBiGqAkEBIasCIKoCIKsCcSGsAiAFIKwCOgADIAUoAgghrQJBCCGuAiCtAiCuAmohrwIgBSgCKCGwAiAFKAIkIbECIK8CILACILECEPAGIbICQQEhswIgsgIgswJxIbQCAkAgtAJFDQAgBS0AAyG1AkEBIbYCILUCILYCcSG3AgJAILcCRQ0ADAMLIAUoAgghuAIgBSC4AjYCKAwDCyAFLQADIbkCQQEhugIguQIgugJxIbsCAkAguwJFDQAgBSgCCCG8AkEIIb0CILwCIL0CaiG+AiAFIL4CNgIIIAUgvgI2AiwMAwsLIAUoAgghvwIgBSgCLCHAAiC/AiDAAmshwQJBAyHCAiDBAiDCAnUhwwIgBSgCKCHEAiAFKAIIIcUCIMQCIMUCayHGAkEDIccCIMYCIMcCdSHIAiDDAiHJAiDIAiHKAiDJAiDKAkghywJBASHMAiDLAiDMAnEhzQICQAJAIM0CRQ0AIAUoAiwhzgIgBSgCCCHPAiAFKAIkIdACIM4CIM8CINACEOkGIAUoAggh0QJBCCHSAiDRAiDSAmoh0wIgBSDTAjYCCCAFINMCNgIsDAELIAUoAggh1AJBCCHVAiDUAiDVAmoh1gIgBSgCKCHXAiAFKAIkIdgCINYCINcCINgCEOkGIAUoAggh2QIgBSDZAjYCKAsMAQsLQTAh2gIgBSDaAmoh2wIg2wIkAA8LYAEKfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAUoAgQhByAGIAcQ8QYhCEEBIQkgCCAJcSEKQRAhCyAFIAtqIQwgDCQAIAoPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQ8gZBECEHIAQgB2ohCCAIJAAPC7UEATh/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhggBiABNgIUIAYgAjYCECAGIAM2AgxBACEHIAYgBzYCCCAGKAIMIQggBigCFCEJIAYoAhghCiAIIAkgChDqBiELQQEhDCALIAxxIQ0CQAJAIA0NACAGKAIMIQ4gBigCECEPIAYoAhQhECAOIA8gEBDqBiERQQEhEiARIBJxIRMCQCATDQAgBigCCCEUIAYgFDYCHAwCCyAGKAIUIRUgBigCECEWIBUgFhDrBkEBIRcgBiAXNgIIIAYoAgwhGCAGKAIUIRkgBigCGCEaIBggGSAaEOoGIRtBASEcIBsgHHEhHQJAIB1FDQAgBigCGCEeIAYoAhQhHyAeIB8Q6wZBAiEgIAYgIDYCCAsgBigCCCEhIAYgITYCHAwBCyAGKAIMISIgBigCECEjIAYoAhQhJCAiICMgJBDqBiElQQEhJiAlICZxIScCQCAnRQ0AIAYoAhghKCAGKAIQISkgKCApEOsGQQEhKiAGICo2AgggBigCCCErIAYgKzYCHAwBCyAGKAIYISwgBigCFCEtICwgLRDrBkEBIS4gBiAuNgIIIAYoAgwhLyAGKAIQITAgBigCFCExIC8gMCAxEOoGITJBASEzIDIgM3EhNAJAIDRFDQAgBigCFCE1IAYoAhAhNiA1IDYQ6wZBAiE3IAYgNzYCCAsgBigCCCE4IAYgODYCHAsgBigCHCE5QSAhOiAGIDpqITsgOyQAIDkPC6YDASx/IwAhBUEgIQYgBSAGayEHIAckACAHIAA2AhwgByABNgIYIAcgAjYCFCAHIAM2AhAgByAENgIMIAcoAhwhCCAHKAIYIQkgBygCFCEKIAcoAgwhCyAIIAkgCiALEOwGIQwgByAMNgIIIAcoAgwhDSAHKAIQIQ4gBygCFCEPIA0gDiAPEOoGIRBBASERIBAgEXEhEgJAIBJFDQAgBygCFCETIAcoAhAhFCATIBQQ6wYgBygCCCEVQQEhFiAVIBZqIRcgByAXNgIIIAcoAgwhGCAHKAIUIRkgBygCGCEaIBggGSAaEOoGIRtBASEcIBsgHHEhHQJAIB1FDQAgBygCGCEeIAcoAhQhHyAeIB8Q6wYgBygCCCEgQQEhISAgICFqISIgByAiNgIIIAcoAgwhIyAHKAIYISQgBygCHCElICMgJCAlEOoGISZBASEnICYgJ3EhKAJAIChFDQAgBygCHCEpIAcoAhghKiApICoQ6wYgBygCCCErQQEhLCArICxqIS0gByAtNgIICwsLIAcoAgghLkEgIS8gByAvaiEwIDAkACAuDwuXBAE4fyMAIQZBICEHIAYgB2shCCAIJAAgCCAANgIcIAggATYCGCAIIAI2AhQgCCADNgIQIAggBDYCDCAIIAU2AgggCCgCHCEJIAgoAhghCiAIKAIUIQsgCCgCECEMIAgoAgghDSAJIAogCyAMIA0Q7QYhDiAIIA42AgQgCCgCCCEPIAgoAgwhECAIKAIQIREgDyAQIBEQ6gYhEkEBIRMgEiATcSEUAkAgFEUNACAIKAIQIRUgCCgCDCEWIBUgFhDrBiAIKAIEIRdBASEYIBcgGGohGSAIIBk2AgQgCCgCCCEaIAgoAhAhGyAIKAIUIRwgGiAbIBwQ6gYhHUEBIR4gHSAecSEfAkAgH0UNACAIKAIUISAgCCgCECEhICAgIRDrBiAIKAIEISJBASEjICIgI2ohJCAIICQ2AgQgCCgCCCElIAgoAhQhJiAIKAIYIScgJSAmICcQ6gYhKEEBISkgKCApcSEqAkAgKkUNACAIKAIYISsgCCgCFCEsICsgLBDrBiAIKAIEIS1BASEuIC0gLmohLyAIIC82AgQgCCgCCCEwIAgoAhghMSAIKAIcITIgMCAxIDIQ6gYhM0EBITQgMyA0cSE1AkAgNUUNACAIKAIcITYgCCgCGCE3IDYgNxDrBiAIKAIEIThBASE5IDggOWohOiAIIDo2AgQLCwsLIAgoAgQhO0EgITwgCCA8aiE9ID0kACA7DwvWBAJGfwF+IwAhA0EwIQQgAyAEayEFIAUkACAFIAA2AiwgBSABNgIoIAUgAjYCJCAFKAIsIQZBECEHIAYgB2ohCCAFIAg2AiAgBSgCLCEJIAUoAiwhCkEIIQsgCiALaiEMIAUoAiAhDSAFKAIkIQ4gCSAMIA0gDhDsBhogBSgCICEPQQghECAPIBBqIREgBSARNgIcAkADQCAFKAIcIRIgBSgCKCETIBIhFCATIRUgFCAVRyEWQQEhFyAWIBdxIRggGEUNASAFKAIkIRkgBSgCHCEaIAUoAiAhGyAZIBogGxDqBiEcQQEhHSAcIB1xIR4CQCAeRQ0AIAUoAhwhHyAfEMsGISBBECEhIAUgIWohIiAiISMgICkCACFJICMgSTcCACAFKAIgISQgBSAkNgIMIAUoAhwhJSAFICU2AiADQCAFKAIMISYgJhDLBiEnIAUoAiAhKCAoICcQ8wYaIAUoAgwhKSAFICk2AiAgBSgCICEqIAUoAiwhKyAqISwgKyEtICwgLUchLkEAIS9BASEwIC4gMHEhMSAvITICQCAxRQ0AIAUoAiQhMyAFKAIMITRBeCE1IDQgNWohNiAFIDY2AgxBECE3IAUgN2ohOCA4ITkgMyA5IDYQ6gYhOiA6ITILIDIhO0EBITwgOyA8cSE9ID0NAAtBECE+IAUgPmohPyA/IUAgQBDLBiFBIAUoAiAhQiBCIEEQ8wYaCyAFKAIcIUMgBSBDNgIgIAUoAhwhREEIIUUgRCBFaiFGIAUgRjYCHAwACwALQTAhRyAFIEdqIUggSCQADwuKCwKgAX8BfiMAIQNBMCEEIAMgBGshBSAFJAAgBSAANgIoIAUgATYCJCAFIAI2AiAgBSgCJCEGIAUoAighByAGIAdrIQhBCCEJIAggCW0hCkEFIQsgCiALSxoCQAJAAkACQAJAAkACQCAKDgYAAAECAwQFC0EBIQxBASENIAwgDXEhDiAFIA46AC8MBQsgBSgCICEPIAUoAiQhEEF4IREgECARaiESIAUgEjYCJCAFKAIoIRMgDyASIBMQ6gYhFEEBIRUgFCAVcSEWAkAgFkUNACAFKAIoIRcgBSgCJCEYIBcgGBDrBgtBASEZQQEhGiAZIBpxIRsgBSAbOgAvDAQLIAUoAighHCAFKAIoIR1BCCEeIB0gHmohHyAFKAIkISBBeCEhICAgIWohIiAFICI2AiQgBSgCICEjIBwgHyAiICMQ7AYaQQEhJEEBISUgJCAlcSEmIAUgJjoALwwDCyAFKAIoIScgBSgCKCEoQQghKSAoIClqISogBSgCKCErQRAhLCArICxqIS0gBSgCJCEuQXghLyAuIC9qITAgBSAwNgIkIAUoAiAhMSAnICogLSAwIDEQ7QYaQQEhMkEBITMgMiAzcSE0IAUgNDoALwwCCyAFKAIoITUgBSgCKCE2QQghNyA2IDdqITggBSgCKCE5QRAhOiA5IDpqITsgBSgCKCE8QRghPSA8ID1qIT4gBSgCJCE/QXghQCA/IEBqIUEgBSBBNgIkIAUoAiAhQiA1IDggOyA+IEEgQhDuBhpBASFDQQEhRCBDIERxIUUgBSBFOgAvDAELIAUoAighRkEQIUcgRiBHaiFIIAUgSDYCHCAFKAIoIUkgBSgCKCFKQQghSyBKIEtqIUwgBSgCHCFNIAUoAiAhTiBJIEwgTSBOEOwGGkEIIU8gBSBPNgIYQQAhUCAFIFA2AhQgBSgCHCFRQQghUiBRIFJqIVMgBSBTNgIQAkADQCAFKAIQIVQgBSgCJCFVIFQhViBVIVcgViBXRyFYQQEhWSBYIFlxIVogWkUNASAFKAIgIVsgBSgCECFcIAUoAhwhXSBbIFwgXRDqBiFeQQEhXyBeIF9xIWACQCBgRQ0AIAUoAhAhYSBhEMsGIWJBCCFjIAUgY2ohZCBkIWUgYikCACGjASBlIKMBNwIAIAUoAhwhZiAFIGY2AgQgBSgCECFnIAUgZzYCHANAIAUoAgQhaCBoEMsGIWkgBSgCHCFqIGogaRDzBhogBSgCBCFrIAUgazYCHCAFKAIcIWwgBSgCKCFtIGwhbiBtIW8gbiBvRyFwQQAhcUEBIXIgcCBycSFzIHEhdAJAIHNFDQAgBSgCICF1IAUoAgQhdkF4IXcgdiB3aiF4IAUgeDYCBEEIIXkgBSB5aiF6IHoheyB1IHsgeBDqBiF8IHwhdAsgdCF9QQEhfiB9IH5xIX8gfw0AC0EIIYABIAUggAFqIYEBIIEBIYIBIIIBEMsGIYMBIAUoAhwhhAEghAEggwEQ8wYaIAUoAhQhhQFBASGGASCFASCGAWohhwEgBSCHATYCFEEIIYgBIIcBIYkBIIgBIYoBIIkBIIoBRiGLAUEBIYwBIIsBIIwBcSGNAQJAII0BRQ0AIAUoAhAhjgFBCCGPASCOASCPAWohkAEgBSCQATYCECAFKAIkIZEBIJABIZIBIJEBIZMBIJIBIJMBRiGUAUEBIZUBIJQBIJUBcSGWASAFIJYBOgAvDAQLCyAFKAIQIZcBIAUglwE2AhwgBSgCECGYAUEIIZkBIJgBIJkBaiGaASAFIJoBNgIQDAALAAtBASGbAUEBIZwBIJsBIJwBcSGdASAFIJ0BOgAvCyAFLQAvIZ4BQQEhnwEgngEgnwFxIaABQTAhoQEgBSChAWohogEgogEkACCgAQ8L9AEBJH8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCACEGIAQoAgghByAHKAIAIQggBiEJIAghCiAJIApIIQtBASEMQQEhDSALIA1xIQ4gDCEPAkAgDg0AIAQoAgghECAQKAIAIREgBCgCDCESIBIoAgAhEyARIRQgEyEVIBQgFUghFkEAIRdBASEYIBYgGHEhGSAXIRoCQCAZDQAgBCgCDCEbIBsoAgQhHCAEKAIIIR0gHSgCBCEeIBwhHyAeISAgHyAgSCEhICEhGgsgGiEiICIhDwsgDyEjQQEhJCAjICRxISUgJQ8LbgEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhD0BkEEIQcgBSAHaiEIIAQoAgghCUEEIQogCSAKaiELIAggCxD0BkEQIQwgBCAMaiENIA0kAA8LgQEBDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEPYDIQcgBygCACEIIAUgCDYCACAEKAIIIQlBBCEKIAkgCmohCyALEPYDIQwgDCgCACENIAUgDTYCBEEQIQ4gBCAOaiEPIA8kACAFDwufAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRD1BiEGIAYoAgAhByAEIAc2AgQgBCgCCCEIIAgQ9QYhCSAJKAIAIQogBCgCDCELIAsgCjYCAEEEIQwgBCAMaiENIA0hDiAOEPUGIQ8gDygCACEQIAQoAgghESARIBA2AgBBECESIAQgEmohEyATJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDws5AQV/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAY2AgAgBQ8LXgEMfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEIQHIQUgBSgCACEGIAQoAgAhByAGIAdrIQhBDCEJIAggCW0hCkEQIQsgAyALaiEMIAwkACAKDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQhwchBUEQIQYgAyAGaiEHIAckACAFDwt7AQx/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQMyEIIAYgCBDIBhpBBCEJIAYgCWohCiAFKAIEIQsgCxCIByEMIAogDBCJBxpBECENIAUgDWohDiAOJAAgBg8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQiwchB0EQIQggAyAIaiEJIAkkACAHDwtUAQl/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQZBACEHIAUgBiAHEIoHIQhBECEJIAQgCWohCiAKJAAgCA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQjAchB0EQIQggAyAIaiEJIAkkACAHDwuBAgEffyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIcIAYgATYCGCAGIAI2AhQgBiADNgIQIAYoAhQhByAGKAIYIQggByAIayEJQQwhCiAJIAptIQsgBiALNgIMIAYoAgwhDCAGKAIQIQ0gDSgCACEOQQAhDyAPIAxrIRBBDCERIBAgEWwhEiAOIBJqIRMgDSATNgIAIAYoAgwhFEEAIRUgFCEWIBUhFyAWIBdKIRhBASEZIBggGXEhGgJAIBpFDQAgBigCECEbIBsoAgAhHCAGKAIYIR0gBigCDCEeQQwhHyAeIB9sISAgHCAdICAQ4xoaC0EgISEgBiAhaiEiICIkAA8LnwEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQkgchBiAGKAIAIQcgBCAHNgIEIAQoAgghCCAIEJIHIQkgCSgCACEKIAQoAgwhCyALIAo2AgBBBCEMIAQgDGohDSANIQ4gDhCSByEPIA8oAgAhECAEKAIIIREgESAQNgIAQRAhEiAEIBJqIRMgEyQADwuwAQEWfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCQByEGIAUQkAchByAFENIGIQhBDCEJIAggCWwhCiAHIApqIQsgBRCQByEMIAUQ0gYhDUEMIQ4gDSAObCEPIAwgD2ohECAFEJAHIREgBCgCCCESQQwhEyASIBNsIRQgESAUaiEVIAUgBiALIBAgFRCRB0EQIRYgBCAWaiEXIBckAA8LGwEDfyMAIQFBECECIAEgAmshAyADIAA2AgwPC0MBB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCBCEFIAQgBRCVB0EQIQYgAyAGaiEHIAckAA8LXgEMfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEJcHIQUgBSgCACEGIAQoAgAhByAGIAdrIQhBDCEJIAggCW0hCkEQIQsgAyALaiEMIAwkACAKDwtaAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAUoAgQhCCAGIAcgCBCWB0EQIQkgBSAJaiEKIAokAA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQhQchB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQhgchBUEQIQYgAyAGaiEHIAckACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtTAQh/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBhCIByEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDwufAQETfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAGEI0HIQggByEJIAghCiAJIApLIQtBASEMIAsgDHEhDQJAIA1FDQBB5AghDiAOEIMBAAsgBSgCCCEPQQwhECAPIBBsIRFBBCESIBEgEhCEASETQRAhFCAFIBRqIRUgFSQAIBMPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBBCEFIAQgBWohBiAGEI4HIQdBECEIIAMgCGohCSAJJAAgBw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEI8HIQVBECEGIAMgBmohByAHJAAgBQ8LJQEEfyMAIQFBECECIAEgAmshAyADIAA2AgxB1arVqgEhBCAEDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgAhBSAFEJQHIQZBECEHIAMgB2ohCCAIJAAgBg8LNwEDfyMAIQVBICEGIAUgBmshByAHIAA2AhwgByABNgIYIAcgAjYCFCAHIAM2AhAgByAENgIMDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEI8HIQVBECEGIAMgBmohByAHJAAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQmAdBECEHIAQgB2ohCCAIJAAPC2EBCn8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQdBDCEIIAcgCGwhCUEEIQogBiAJIAoQSUEQIQsgBSALaiEMIAwkAA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQnAchB0EQIQggAyAIaiEJIAkkACAHDwugAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUCQANAIAQoAgAhBiAFKAIIIQcgBiEIIAchCSAIIAlHIQpBASELIAogC3EhDCAMRQ0BIAUQ+gYhDSAFKAIIIQ5BdCEPIA4gD2ohECAFIBA2AgggEBCUByERIA0gERCZBwwACwALQRAhEiAEIBJqIRMgEyQADwtKAQd/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAEKAIYIQYgBSAGEJoHQSAhByAEIAdqIQggCCQADwtKAQd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgQhBSAEKAIAIQYgBSAGEJsHQRAhByAEIAdqIQggCCQADwsiAQN/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AggPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCGByEFQRAhBiADIAZqIQcgByQAIAUPC4MBAQ1/IwAhA0EQIQQgAyAEayEFIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBiAHNgIAIAUoAgghCCAIKAIEIQkgBiAJNgIEIAUoAgghCiAKKAIEIQsgBSgCBCEMQQwhDSAMIA1sIQ4gCyAOaiEPIAYgDzYCCCAGDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSgCHCEGIAUoAhghByAFKAIUIQggCBCeByEJIAYgByAJEKIHQSAhCiAFIApqIQsgCyQADws5AQZ/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFIAQoAgAhBiAGIAU2AgQgBA8LsgIBJX8jACECQSAhAyACIANrIQQgBCQAIAQgADYCGCAEIAE2AhQgBCgCGCEFIAUQpAchBiAEIAY2AhAgBCgCFCEHIAQoAhAhCCAHIQkgCCEKIAkgCkshC0EBIQwgCyAMcSENAkAgDUUNACAFELUaAAsgBRDSBiEOIAQgDjYCDCAEKAIMIQ8gBCgCECEQQQEhESAQIBF2IRIgDyETIBIhFCATIBRPIRVBASEWIBUgFnEhFwJAAkAgF0UNACAEKAIQIRggBCAYNgIcDAELIAQoAgwhGUEBIRogGSAadCEbIAQgGzYCCEEIIRwgBCAcaiEdIB0hHkEUIR8gBCAfaiEgICAhISAeICEQZyEiICIoAgAhIyAEICM2AhwLIAQoAhwhJEEgISUgBCAlaiEmICYkACAkDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhQgBSABNgIQIAUgAjYCDCAFKAIUIQYgBSgCECEHIAUoAgwhCCAIEJ4HIQkgBiAHIAkQowdBICEKIAUgCmohCyALJAAPC4EBAgx/AX4jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQcgBxCeByEIIAgpAgAhDyAGIA83AgBBCCEJIAYgCWohCiAIIAlqIQsgCygCACEMIAogDDYCAEEQIQ0gBSANaiEOIA4kAA8LhAEBEX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBClByEFIAUQpgchBiADIAY2AggQdCEHIAMgBzYCBEEIIQggAyAIaiEJIAkhCkEEIQsgAyALaiEMIAwhDSAKIA0QdSEOIA4oAgAhD0EQIRAgAyAQaiERIBEkACAPDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhCoByEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCnByEFQRAhBiADIAZqIQcgByQAIAUPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBCNByEFQRAhBiADIAZqIQcgByQAIAUPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCpByEFQRAhBiADIAZqIQcgByQAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtsAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQMyEIIAYgCBCrBxogBSgCBCEJIAkQNRogBhCsBxpBECEKIAUgCmohCyALJAAgBg8LVQEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQMxpBACEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQrQcaQRAhBSADIAVqIQYgBiQAIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC14BDH8jACECQSAhAyACIANrIQQgBCQAIAQgADYCGCAEIAE2AhBBECEFIAQgBWohBiAGIQdBGCEIIAQgCGohCSAJIQogByAKELMHIQtBICEMIAQgDGohDSANJAAgCw8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQtAchB0EQIQggAyAIaiEJIAkkACAHDwuzAQEVfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQVBCCEGIAQgBmohByAHIQhBASEJIAggBSAJELUHGiAFELYHIQogBCgCDCELIAsQtwchDCAEKAIYIQ0gDRC4ByEOIAogDCAOELkHIAQoAgwhD0EEIRAgDyAQaiERIAQgETYCDEEIIRIgBCASaiETIBMhFCAUELoHGkEgIRUgBCAVaiEWIBYkAA8L3QEBGH8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAUQtgchBiAEIAY2AhQgBRC7ByEHQQEhCCAHIAhqIQkgBSAJELwHIQogBRC7ByELIAQoAhQhDCAEIQ0gDSAKIAsgDBC9BxogBCgCFCEOIAQoAgghDyAPELcHIRAgBCgCGCERIBEQuAchEiAOIBAgEhC5ByAEKAIIIRNBBCEUIBMgFGohFSAEIBU2AgggBCEWIAUgFhC+ByAEIRcgFxC/BxpBICEYIAQgGGohGSAZJAAPC2UBDH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQrgchBiAEKAIIIQcgBxCuByEIIAYgCGshCUEMIQogCSAKbSELQRAhDCAEIAxqIQ0gDSQAIAsPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDAByEFQRAhBiADIAZqIQcgByQAIAUPC4MBAQ1/IwAhA0EQIQQgAyAEayEFIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBiAHNgIAIAUoAgghCCAIKAIEIQkgBiAJNgIEIAUoAgghCiAKKAIEIQsgBSgCBCEMQQIhDSAMIA10IQ4gCyAOaiEPIAYgDzYCCCAGDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhDCByEHQRAhCCADIAhqIQkgCSQAIAcPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSgCHCEGIAUoAhghByAFKAIUIQggCBC4ByEJIAYgByAJEMEHQSAhCiAFIApqIQsgCyQADws5AQZ/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFIAQoAgAhBiAGIAU2AgQgBA8LRAEJfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgQhBSAEKAIAIQYgBSAGayEHQQIhCCAHIAh1IQkgCQ8LsgIBJX8jACECQSAhAyACIANrIQQgBCQAIAQgADYCGCAEIAE2AhQgBCgCGCEFIAUQxQchBiAEIAY2AhAgBCgCFCEHIAQoAhAhCCAHIQkgCCEKIAkgCkshC0EBIQwgCyAMcSENAkAgDUUNACAFELUaAAsgBRDGByEOIAQgDjYCDCAEKAIMIQ8gBCgCECEQQQEhESAQIBF2IRIgDyETIBIhFCATIBRPIRVBASEWIBUgFnEhFwJAAkAgF0UNACAEKAIQIRggBCAYNgIcDAELIAQoAgwhGUEBIRogGSAadCEbIAQgGzYCCEEIIRwgBCAcaiEdIB0hHkEUIR8gBCAfaiEgICAhISAeICEQZyEiICIoAgAhIyAEICM2AhwLIAQoAhwhJEEgISUgBCAlaiEmICYkACAkDwuuAgEgfyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIYIAYgATYCFCAGIAI2AhAgBiADNgIMIAYoAhghByAGIAc2AhxBDCEIIAcgCGohCUEAIQogBiAKNgIIIAYoAgwhC0EIIQwgBiAMaiENIA0hDiAJIA4gCxDHBxogBigCFCEPAkACQCAPRQ0AIAcQyAchECAGKAIUIREgECAREMkHIRIgEiETDAELQQAhFCAUIRMLIBMhFSAHIBU2AgAgBygCACEWIAYoAhAhF0ECIRggFyAYdCEZIBYgGWohGiAHIBo2AgggByAaNgIEIAcoAgAhGyAGKAIUIRxBAiEdIBwgHXQhHiAbIB5qIR8gBxDKByEgICAgHzYCACAGKAIcISFBICEiIAYgImohIyAjJAAgIQ8L+wEBG38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQwwYgBRC2ByEGIAUoAgAhByAFKAIEIQggBCgCCCEJQQQhCiAJIApqIQsgBiAHIAggCxDLByAEKAIIIQxBBCENIAwgDWohDiAFIA4QzAdBBCEPIAUgD2ohECAEKAIIIRFBCCESIBEgEmohEyAQIBMQzAcgBRCwByEUIAQoAgghFSAVEMoHIRYgFCAWEMwHIAQoAgghFyAXKAIEIRggBCgCCCEZIBkgGDYCACAFELsHIRogBSAaEM0HIAUQzgdBECEbIAQgG2ohHCAcJAAPC5UBARF/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgggAygCCCEEIAMgBDYCDCAEEM8HIAQoAgAhBUEAIQYgBSEHIAYhCCAHIAhHIQlBASEKIAkgCnEhCwJAIAtFDQAgBBDIByEMIAQoAgAhDSAEENAHIQ4gDCANIA4Q0QcLIAMoAgwhD0EQIRAgAyAQaiERIBEkACAPDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIUIAUgATYCECAFIAI2AgwgBSgCFCEGIAUoAhAhByAFKAIMIQggCBC4ByEJIAYgByAJEMMHQSAhCiAFIApqIQsgCyQADws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQxAchBUEQIQYgAyAGaiEHIAckACAFDwtfAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHIAcQuAchCCAIKAIAIQkgBiAJNgIAQRAhCiAFIApqIQsgCyQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LhAEBEX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDSByEFIAUQ0wchBiADIAY2AggQdCEHIAMgBzYCBEEIIQggAyAIaiEJIAkhCkEEIQsgAyALaiEMIAwhDSAKIA0QdSEOIA4oAgAhD0EQIRAgAyAQaiERIBEkACAPDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ1AchBUEQIQYgAyAGaiEHIAckACAFDwt7AQx/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQMyEIIAYgCBCrBxpBBCEJIAYgCWohCiAFKAIEIQsgCxDcByEMIAogDBDdBxpBECENIAUgDWohDiAOJAAgBg8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQ3wchB0EQIQggAyAIaiEJIAkkACAHDwtUAQl/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQZBACEHIAUgBiAHEN4HIQhBECEJIAQgCWohCiAKJAAgCA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQ4AchB0EQIQggAyAIaiEJIAkkACAHDwuBAgEffyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIcIAYgATYCGCAGIAI2AhQgBiADNgIQIAYoAhQhByAGKAIYIQggByAIayEJQQIhCiAJIAp1IQsgBiALNgIMIAYoAgwhDCAGKAIQIQ0gDSgCACEOQQAhDyAPIAxrIRBBAiERIBAgEXQhEiAOIBJqIRMgDSATNgIAIAYoAgwhFEEAIRUgFCEWIBUhFyAWIBdKIRhBASEZIBggGXEhGgJAIBpFDQAgBigCECEbIBsoAgAhHCAGKAIYIR0gBigCDCEeQQIhHyAeIB90ISAgHCAdICAQ4xoaC0EgISEgBiAhaiEiICIkAA8LnwEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ5AchBiAGKAIAIQcgBCAHNgIEIAQoAgghCCAIEOQHIQkgCSgCACEKIAQoAgwhCyALIAo2AgBBBCEMIAQgDGohDSANIQ4gDhDkByEPIA8oAgAhECAEKAIIIREgESAQNgIAQRAhEiAEIBJqIRMgEyQADwuwAQEWfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRDiByEGIAUQ4gchByAFEMYHIQhBAiEJIAggCXQhCiAHIApqIQsgBRDiByEMIAUQxgchDUECIQ4gDSAOdCEPIAwgD2ohECAFEOIHIREgBCgCCCESQQIhEyASIBN0IRQgESAUaiEVIAUgBiALIBAgFRDjB0EQIRYgBCAWaiEXIBckAA8LGwEDfyMAIQFBECECIAEgAmshAyADIAA2AgwPC0MBB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCBCEFIAQgBRDlB0EQIQYgAyAGaiEHIAckAA8LXgEMfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOcHIQUgBSgCACEGIAQoAgAhByAGIAdrIQhBAiEJIAggCXUhCkEQIQsgAyALaiEMIAwkACAKDwtaAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAUoAgQhCCAGIAcgCBDmB0EQIQkgBSAJaiEKIAokAA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQ1gchB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ1QchBUEQIQYgAyAGaiEHIAckACAFDwteAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ2QchBSAFKAIAIQYgBCgCACEHIAYgB2shCEECIQkgCCAJdSEKQRAhCyADIAtqIQwgDCQAIAoPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBDXByEFQRAhBiADIAZqIQcgByQAIAUPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDYByEFQRAhBiADIAZqIQcgByQAIAUPCyUBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMQf////8DIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGENoHIQdBECEIIAMgCGohCSAJJAAgBw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEENsHIQVBECEGIAMgBmohByAHJAAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtTAQh/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBhDcByEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDwufAQETfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAGENcHIQggByEJIAghCiAJIApLIQtBASEMIAsgDHEhDQJAIA1FDQBB5AghDiAOEIMBAAsgBSgCCCEPQQIhECAPIBB0IRFBBCESIBEgEhCEASETQRAhFCAFIBRqIRUgFSQAIBMPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBBCEFIAQgBWohBiAGEOEHIQdBECEIIAMgCGohCSAJJAAgBw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMAHIQVBECEGIAMgBmohByAHJAAgBQ8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgAhBSAFELcHIQZBECEHIAMgB2ohCCAIJAAgBg8LNwEDfyMAIQVBICEGIAUgBmshByAHIAA2AhwgByABNgIYIAcgAjYCFCAHIAM2AhAgByAENgIMDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LSgEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhDoB0EQIQcgBCAHaiEIIAgkAA8LYQEKfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAUoAgQhB0ECIQggByAIdCEJQQQhCiAGIAkgChBJQRAhCyAFIAtqIQwgDCQADwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhDsByEHQRAhCCADIAhqIQkgCSQAIAcPC6ABARJ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgQhBQJAA0AgBCgCACEGIAUoAgghByAGIQggByEJIAggCUchCkEBIQsgCiALcSEMIAxFDQEgBRDIByENIAUoAgghDkF8IQ8gDiAPaiEQIAUgEDYCCCAQELcHIREgDSAREOkHDAALAAtBECESIAQgEmohEyATJAAPC0oBB38jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAQoAhghBiAFIAYQ6gdBICEHIAQgB2ohCCAIJAAPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCBCEFIAQoAgAhBiAFIAYQ6wdBECEHIAQgB2ohCCAIJAAPCyIBA38jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEENsHIQVBECEGIAMgBmohByAHJAAgBQ8LOQEFfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGNgIAIAUPC0MBBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDxBRogBBDyBxpBECEFIAMgBWohBiAGJAAgBA8LcQEKfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHEPYDIQggBiAIEPMFGiAFKAIEIQkgCRDzByEKIAYgChD0BxpBECELIAUgC2ohDCAMJAAgBg8LUAEKfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEEIQUgBCAFaiEGIAYQ9QchByAHEPcFIQhBECEJIAMgCWohCiAKJAAgCA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBD2BxpBECEFIAMgBWohBiAGJAAgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC0sBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEPMHGkEQIQcgBCAHaiEIIAgkACAFDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ+wUhBUEQIQYgAyAGaiEHIAckACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LoAUBSn8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCGCAFIAE2AhQgBSACNgIQIAUoAhghBiAGEIUIIQcgBSAHNgIMIAYQhgghCCAFIAg2AgggBSgCDCEJQQAhCiAJIQsgCiEMIAsgDEchDUEBIQ4gDSAOcSEPAkACQCAPRQ0AA0AgBhCHCCEQIAUoAhAhESAFKAIMIRJBECETIBIgE2ohFCAQIBEgFBCICCEVQQEhFiAVIBZxIRcCQAJAIBdFDQAgBSgCDCEYIBgoAgAhGUEAIRogGSEbIBohHCAbIBxHIR1BASEeIB0gHnEhHwJAAkAgH0UNACAFKAIMISAgIBCJCCEhIAUgITYCCCAFKAIMISIgIigCACEjIAUgIzYCDAwBCyAFKAIMISQgBSgCFCElICUgJDYCACAFKAIUISYgJigCACEnIAUgJzYCHAwFCwwBCyAGEIcIISggBSgCDCEpQRAhKiApICpqISsgBSgCECEsICggKyAsEIoIIS1BASEuIC0gLnEhLwJAAkAgL0UNACAFKAIMITAgMCgCBCExQQAhMiAxITMgMiE0IDMgNEchNUEBITYgNSA2cSE3AkACQCA3RQ0AIAUoAgwhOEEEITkgOCA5aiE6IDoQiQghOyAFIDs2AgggBSgCDCE8IDwoAgQhPSAFID02AgwMAQsgBSgCDCE+IAUoAhQhPyA/ID42AgAgBSgCDCFAQQQhQSBAIEFqIUIgBSBCNgIcDAYLDAELIAUoAgwhQyAFKAIUIUQgRCBDNgIAIAUoAgghRSAFIEU2AhwMBAsLDAALAAsgBhDwByFGIAUoAhQhRyBHIEY2AgAgBSgCFCFIIEgoAgAhSSAFIEk2AhwLIAUoAhwhSkEgIUsgBSBLaiFMIEwkACBKDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwvvAgEqfyMAIQVBMCEGIAUgBmshByAHJAAgByAANgIsIAcgATYCKCAHIAI2AiQgByADNgIgIAcgBDYCHCAHKAIoIQggCBCLCCEJIAcgCTYCGEEAIQpBASELIAogC3EhDCAHIAw6ABcgBygCGCENQQEhDiANIA4QjAghDyAHKAIYIRBBCCERIAcgEWohEiASIRNBACEUQQEhFSAUIBVxIRYgEyAQIBYQjQgaQQghFyAHIBdqIRggGCEZIAAgDyAZEI4IGiAHKAIYIRogABCPCCEbQRAhHCAbIBxqIR0gHRCQCCEeIAcoAiQhHyAfEPgHISAgBygCICEhICEQ+QchIiAHKAIcISMgIxD6ByEkIBogHiAgICIgJBCRCCAAEJIIISVBASEmICUgJjoABEEBISdBASEoICcgKHEhKSAHICk6ABcgBy0AFyEqQQEhKyAqICtxISwCQCAsDQAgABD/BxoLQTAhLSAHIC1qIS4gLiQADwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQlQghBSAFKAIAIQZBECEHIAMgB2ohCCAIJAAgBg8LuQIBI38jACEEQRAhBSAEIAVrIQYgBiQAIAYgADYCDCAGIAE2AgggBiACNgIEIAYgAzYCACAGKAIMIQcgBigCACEIQQAhCSAIIAk2AgAgBigCACEKQQAhCyAKIAs2AgQgBigCCCEMIAYoAgAhDSANIAw2AgggBigCACEOIAYoAgQhDyAPIA42AgAgBxDxByEQIBAoAgAhESARKAIAIRJBACETIBIhFCATIRUgFCAVRyEWQQEhFyAWIBdxIRgCQCAYRQ0AIAcQ8QchGSAZKAIAIRogGigCACEbIAcQ8QchHCAcIBs2AgALIAcQ8AchHSAdKAIAIR4gBigCBCEfIB8oAgAhICAeICAQkwggBxCUCCEhICEoAgAhIkEBISMgIiAjaiEkICEgJDYCAEEQISUgBiAlaiEmICYkAA8LZQELfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEJYIIQUgBSgCACEGIAMgBjYCCCAEEJYIIQdBACEIIAcgCDYCACADKAIIIQlBECEKIAMgCmohCyALJAAgCQ8LQgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEAIQUgBCAFEJcIQRAhBiADIAZqIQcgByQAIAQPCzkBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCACAFDwuIAQEOfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHEJgIIQggCCgCACEJIAYgCTYCACAFKAIEIQogChCZCCELIAstAAAhDEEBIQ0gDCANcSEOIAYgDjoABEEQIQ8gBSAPaiEQIBAkACAGDwtNAQd/IwAhAkEwIQMgAiADayEEIAQkACAEIAA2AiwgBCABNgIoIAQoAiwhBSAEKAIoIQYgBSAGEMMIGkEwIQcgBCAHaiEIIAgkACAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDFCCEFQRAhBiADIAZqIQcgByQAIAUPC0UBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCaCCEFIAUoAgAhBkEQIQcgAyAHaiEIIAgkACAGDwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQmgghBSAFEIkIIQZBECEHIAMgB2ohCCAIJAAgBg8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQmwghB0EQIQggAyAIaiEJIAkkACAHDwtwAQx/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAUoAgQhCCAIEJwIIQkgBiAHIAkQnQghCkEBIQsgCiALcSEMQRAhDSAFIA1qIQ4gDiQAIAwPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtwAQx/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQnAghCCAFKAIEIQkgBiAIIAkQnQghCkEBIQsgCiALcSEMQRAhDSAFIA1qIQ4gDiQAIAwPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBBCEFIAQgBWohBiAGEKEIIQdBECEIIAMgCGohCSAJJAAgBw8LVAEJfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGQQAhByAFIAYgBxCiCCEIQRAhCSAEIAlqIQogCiQAIAgPC10BCX8jACEDQRAhBCADIARrIQUgBSAANgIMIAUgATYCCCACIQYgBSAGOgAHIAUoAgwhByAFKAIIIQggByAINgIAIAUtAAchCUEBIQogCSAKcSELIAcgCzoABCAHDwtsAQt/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCBCEHIAcQowghCEEIIQkgBSAJaiEKIAohCyAGIAsgCBCkCBpBECEMIAUgDGohDSANJAAgBg8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEJUIIQUgBSgCACEGQRAhByADIAdqIQggCCQAIAYPC0UBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCcBiEFIAUQpgghBkEQIQcgAyAHaiEIIAgkACAGDwuPAQENfyMAIQVBICEGIAUgBmshByAHJAAgByAANgIcIAcgATYCGCAHIAI2AhQgByADNgIQIAcgBDYCDCAHKAIcIQggBygCGCEJIAcoAhQhCiAKEPgHIQsgBygCECEMIAwQ+QchDSAHKAIMIQ4gDhD6ByEPIAggCSALIA0gDxClCEEgIRAgByAQaiERIBEkAA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEKcIIQVBECEGIAMgBmohByAHJAAgBQ8LvggBgQF/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgghBSAEKAIMIQYgBSEHIAYhCCAHIAhGIQkgBCgCCCEKQQEhCyAJIAtxIQwgCiAMOgAMA0AgBCgCCCENIAQoAgwhDiANIQ8gDiEQIA8gEEchEUEAIRJBASETIBEgE3EhFCASIRUCQCAURQ0AIAQoAgghFiAWELUIIRcgFy0ADCEYQX8hGSAYIBlzIRogGiEVCyAVIRtBASEcIBsgHHEhHQJAIB1FDQAgBCgCCCEeIB4QtQghHyAfELYIISBBASEhICAgIXEhIgJAAkAgIkUNACAEKAIIISMgIxC1CCEkICQQtQghJSAlKAIEISYgBCAmNgIEIAQoAgQhJ0EAISggJyEpICghKiApICpHIStBASEsICsgLHEhLQJAAkAgLUUNACAEKAIEIS4gLi0ADCEvQQEhMCAvIDBxITEgMQ0AIAQoAgghMiAyELUIITMgBCAzNgIIIAQoAgghNEEBITUgNCA1OgAMIAQoAgghNiA2ELUIITcgBCA3NgIIIAQoAgghOCAEKAIMITkgOCE6IDkhOyA6IDtGITwgBCgCCCE9QQEhPiA8ID5xIT8gPSA/OgAMIAQoAgQhQEEBIUEgQCBBOgAMDAELIAQoAgghQiBCELYIIUNBASFEIEMgRHEhRQJAIEUNACAEKAIIIUYgRhC1CCFHIAQgRzYCCCAEKAIIIUggSBC3CAsgBCgCCCFJIEkQtQghSiAEIEo2AgggBCgCCCFLQQEhTCBLIEw6AAwgBCgCCCFNIE0QtQghTiAEIE42AgggBCgCCCFPQQAhUCBPIFA6AAwgBCgCCCFRIFEQuAgMAwsMAQsgBCgCCCFSIFIQtQghUyBTKAIIIVQgVCgCACFVIAQgVTYCACAEKAIAIVZBACFXIFYhWCBXIVkgWCBZRyFaQQEhWyBaIFtxIVwCQAJAIFxFDQAgBCgCACFdIF0tAAwhXkEBIV8gXiBfcSFgIGANACAEKAIIIWEgYRC1CCFiIAQgYjYCCCAEKAIIIWNBASFkIGMgZDoADCAEKAIIIWUgZRC1CCFmIAQgZjYCCCAEKAIIIWcgBCgCDCFoIGchaSBoIWogaSBqRiFrIAQoAgghbEEBIW0gayBtcSFuIGwgbjoADCAEKAIAIW9BASFwIG8gcDoADAwBCyAEKAIIIXEgcRC2CCFyQQEhcyByIHNxIXQCQCB0RQ0AIAQoAgghdSB1ELUIIXYgBCB2NgIIIAQoAgghdyB3ELgICyAEKAIIIXggeBC1CCF5IAQgeTYCCCAEKAIIIXpBASF7IHogezoADCAEKAIIIXwgfBC1CCF9IAQgfTYCCCAEKAIIIX5BACF/IH4gfzoADCAEKAIIIYABIIABELcIDAILCwwBCwtBECGBASAEIIEBaiGCASCCASQADwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhC5CCEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCzCCEFQRAhBiADIAZqIQcgByQAIAUPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBC8CCEFQRAhBiADIAZqIQcgByQAIAUPC6gBARN/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEJYIIQYgBigCACEHIAQgBzYCBCAEKAIIIQggBRCWCCEJIAkgCDYCACAEKAIEIQpBACELIAohDCALIQ0gDCANRyEOQQEhDyAOIA9xIRACQCAQRQ0AIAUQpwghESAEKAIEIRIgESASEL0IC0EQIRMgBCATaiEUIBQkAA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtQAQp/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQQhBSAEIAVqIQYgBhCeCCEHIAcQ9wUhCEEQIQkgAyAJaiEKIAokACAIDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQoAghBUEQIQYgAyAGaiEHIAckACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LYQEMfyMAIQNBECEEIAMgBGshBSAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBigCACEHIAUoAgQhCCAIKAIAIQkgByEKIAkhCyAKIAtIIQxBASENIAwgDXEhDiAODws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQnwghBUEQIQYgAyAGaiEHIAckACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCoCCEFQRAhBiADIAZqIQcgByQAIAUPC58BARN/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAYQqQghCCAHIQkgCCEKIAkgCkshC0EBIQwgCyAMcSENAkAgDUUNAEHkCCEOIA4QgwEACyAFKAIIIQ9BBSEQIA8gEHQhEUEEIRIgESASEIQBIRNBECEUIAUgFGohFSAVJAAgEw8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC3wBDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxCqCCEIIAYgCBCrCBpBBCEJIAYgCWohCiAFKAIEIQsgCxCsCCEMIAogDBCtCBpBECENIAUgDWohDiAOJAAgBg8LjwEBDX8jACEFQSAhBiAFIAZrIQcgByQAIAcgADYCFCAHIAE2AhAgByACNgIMIAcgAzYCCCAHIAQ2AgQgBygCFCEIIAcoAhAhCSAHKAIMIQogChD4ByELIAcoAgghDCAMEPkHIQ0gBygCBCEOIA4Q+gchDyAIIAkgCyANIA8QrghBICEQIAcgEGohESARJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQQhBSAEIAVqIQYgBhC0CCEHQRAhCCADIAhqIQkgCSQAIAcPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDEH///8/IQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC1oBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEKoIIQcgBygCACEIIAUgCDYCAEEQIQkgBCAJaiEKIAokACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LXAIIfwF+IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBhCsCCEHIAcpAgAhCiAFIAo3AgBBECEIIAQgCGohCSAJJAAgBQ8LpQEBD38jACEFQTAhBiAFIAZrIQcgByQAIAcgADYCLCAHIAE2AiggByACNgIkIAcgAzYCICAHIAQ2AhwgBygCKCEIIAcoAiQhCSAJEPgHGiAHKAIgIQogChD5ByELQRAhDCAHIAxqIQ0gDSEOIAsoAgAhDyAOIA82AgAgBygCHCEQIBAQ+gcaIAcoAhAhESAIIBEQrwgaQTAhEiAHIBJqIRMgEyQADwtmAQx/IwAhAkEwIQMgAiADayEEIAQkACAEIAE2AiAgBCAANgIUIAQoAhQhBUEgIQYgBCAGaiEHIAchCEEYIQkgBCAJaiEKIAohCyAFIAggCxCwCBpBMCEMIAQgDGohDSANJAAgBQ8LeQEMfyMAIQNBMCEEIAMgBGshBSAFJAAgBSAANgIUIAUgATYCECAFIAI2AgwgBSgCFCEGIAUoAhAhByAHELEIIQggCBC4ByEJIAkoAgAhCiAGIAo2AgBBBCELIAYgC2ohDCAMEKADGkEwIQ0gBSANaiEOIA4kACAGDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQsgghBUEQIQYgAyAGaiEHIAckACAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgghBSAFDwtTAQx/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgAygCDCEFIAUoAgghBiAGKAIAIQcgBCEIIAchCSAIIAlGIQpBASELIAogC3EhDCAMDwvTAgEmfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIEIQUgAyAFNgIIIAMoAgghBiAGKAIAIQcgAygCDCEIIAggBzYCBCADKAIMIQkgCSgCBCEKQQAhCyAKIQwgCyENIAwgDUchDkEBIQ8gDiAPcSEQAkAgEEUNACADKAIMIREgESgCBCESIAMoAgwhEyASIBMQuggLIAMoAgwhFCAUKAIIIRUgAygCCCEWIBYgFTYCCCADKAIMIRcgFxC2CCEYQQEhGSAYIBlxIRoCQAJAIBpFDQAgAygCCCEbIAMoAgwhHCAcKAIIIR0gHSAbNgIADAELIAMoAgghHiADKAIMIR8gHxC1CCEgICAgHjYCBAsgAygCDCEhIAMoAgghIiAiICE2AgAgAygCDCEjIAMoAgghJCAjICQQughBECElIAMgJWohJiAmJAAPC9MCASZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgAhBSADIAU2AgggAygCCCEGIAYoAgQhByADKAIMIQggCCAHNgIAIAMoAgwhCSAJKAIAIQpBACELIAohDCALIQ0gDCANRyEOQQEhDyAOIA9xIRACQCAQRQ0AIAMoAgwhESARKAIAIRIgAygCDCETIBIgExC6CAsgAygCDCEUIBQoAgghFSADKAIIIRYgFiAVNgIIIAMoAgwhFyAXELYIIRhBASEZIBggGXEhGgJAAkAgGkUNACADKAIIIRsgAygCDCEcIBwoAgghHSAdIBs2AgAMAQsgAygCCCEeIAMoAgwhHyAfELUIISAgICAeNgIECyADKAIMISEgAygCCCEiICIgITYCBCADKAIMISMgAygCCCEkICMgJBC6CEEQISUgAyAlaiEmICYkAA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEELsIIQVBECEGIAMgBmohByAHJAAgBQ8LNwEFfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGNgIIDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC8UBARh/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFLQAEIQZBASEHIAYgB3EhCAJAIAhFDQAgBSgCACEJIAQoAgghCkEQIQsgCiALaiEMIAwQkAghDSAJIA0QvggLIAQoAgghDkEAIQ8gDiEQIA8hESAQIBFHIRJBASETIBIgE3EhFAJAIBRFDQAgBSgCACEVIAQoAgghFkEBIRcgFSAWIBcQvwgLQRAhGCAEIBhqIRkgGSQADwtKAQd/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAEKAIYIQYgBSAGEMAIQSAhByAEIAdqIQggCCQADwtaAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAUoAgQhCCAGIAcgCBDBCEEQIQkgBSAJaiEKIAokAA8LQgEGfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIAIQUgBRDCCBpBECEGIAQgBmohByAHJAAPC2EBCn8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQdBBSEIIAcgCHQhCUEEIQogBiAJIAoQSUEQIQsgBSALaiEMIAwkAA8LSAEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEEIQUgBCAFaiEGIAYQsAMaQRAhByADIAdqIQggCCQAIAQPC1QBCH8jACECQTAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGELgHIQcgBSAHEMQIGkEwIQggBCAIaiEJIAkkACAFDwtTAQh/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBhC4ByEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LrQEBFH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFQQAhBiAFIQcgBiEIIAcgCEchCUEBIQogCSAKcSELAkAgC0UNACAEEMgIIAQQ2QQhDCAEKAIAIQ0gBBDpBCEOIAwgDSAOEPQEIAQQggQhD0EAIRAgDyAQNgIAQQAhESAEIBE2AgRBACESIAQgEjYCAAtBECETIAMgE2ohFCAUJAAPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQyQhBECEHIAQgB2ohCCAIJAAPC1sBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCnAyEFIAMgBTYCCCAEEMoIIAMoAgghBiAEIAYQywggBBDxBEEQIQcgAyAHaiEIIAgkAA8LVgEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBCgCACEGIAYQ2QQhByAHEM0IGiAFENkEGkEQIQggBCAIaiEJIAkkAA8LQwEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIAIQUgBCAFEMwIQRAhBiADIAZqIQcgByQADwuwAQEWfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCFBSEGIAUQhQUhByAFEOkEIQhBFCEJIAggCWwhCiAHIApqIQsgBRCFBSEMIAQoAgghDUEUIQ4gDSAObCEPIAwgD2ohECAFEIUFIREgBRCnAyESQRQhEyASIBNsIRQgESAUaiEVIAUgBiALIBAgFRCGBUEQIRYgBCAWaiEXIBckAA8LvAEBFH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAEIAY2AgQCQANAIAQoAgghByAEKAIEIQggByEJIAghCiAJIApHIQtBASEMIAsgDHEhDSANRQ0BIAUQ2QQhDiAEKAIEIQ9BbCEQIA8gEGohESAEIBE2AgQgERDaBCESIA4gEhCSBQwACwALIAQoAgghEyAFIBM2AgRBECEUIAQgFGohFSAVJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDws5AQV/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAY2AgAgBQ8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwueAgEffyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIUIAYgATYCECAGIAI2AgwgBiADNgIIIAYoAhQhBwJAA0AgBigCDCEIQQAhCSAIIQogCSELIAogC0chDEEBIQ0gDCANcSEOIA5FDQEgBxCHCCEPIAYoAgwhEEEQIREgECARaiESIAYoAhAhEyAPIBIgExCKCCEUQQEhFSAUIBVxIRYCQAJAIBYNACAGKAIMIRcgBiAXNgIIIAYoAgwhGCAYKAIAIRkgBiAZNgIMDAELIAYoAgwhGiAaKAIEIRsgBiAbNgIMCwwACwALIAYoAgghHEEYIR0gBiAdaiEeIB4hHyAfIBwQ0QgaIAYoAhghIEEgISEgBiAhaiEiICIkACAgDws5AQV/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAY2AgAgBQ8LYQEMfyMAIQNBECEEIAMgBGshBSAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBigCACEHIAUoAgQhCCAIKAIAIQkgByEKIAkhCyAKIAtIIQxBASENIAwgDXEhDiAODwtaAQx/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgAhBiAEKAIIIQcgBygCACEIIAYhCSAIIQogCSAKRiELQQEhDCALIAxxIQ0gDQ8L6wEBGn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCCCADKAIIIQQgBCgCACEFQQAhBiAFIQcgBiEIIAcgCEchCUEBIQogCSAKcSELAkACQCALRQ0AIAMoAgghDCAMKAIAIQ0gDRDVCCEOIAMgDjYCDAwBCyADKAIIIQ8gAyAPNgIEAkADQCADKAIEIRAgEBC2CCERQQEhEiARIBJxIRMgE0UNASADKAIEIRQgFBC1CCEVIAMgFTYCBAwACwALIAMoAgQhFiAWELUIIRcgAyAXNgIMCyADKAIMIRhBECEZIAMgGWohGiAaJAAgGA8LcwEOfyMAIQFBECECIAEgAmshAyADIAA2AgwCQANAIAMoAgwhBCAEKAIEIQVBACEGIAUhByAGIQggByAIRyEJQQEhCiAJIApxIQsgC0UNASADKAIMIQwgDCgCBCENIAMgDTYCDAwACwALIAMoAgwhDiAODwufAgEffyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIUIAYgATYCECAGIAI2AgwgBiADNgIIIAYoAhQhBwJAA0AgBigCDCEIQQAhCSAIIQogCSELIAogC0chDEEBIQ0gDCANcSEOIA5FDQEgBxCHCCEPIAYoAhAhECAGKAIMIRFBECESIBEgEmohEyAPIBAgExCICCEUQQEhFSAUIBVxIRYCQAJAIBZFDQAgBigCDCEXIAYgFzYCCCAGKAIMIRggGCgCACEZIAYgGTYCDAwBCyAGKAIMIRogGigCBCEbIAYgGzYCDAsMAAsACyAGKAIIIRxBGCEdIAYgHWohHiAeIR8gHyAcENEIGiAGKAIYISBBICEhIAYgIWohIiAiJAAgIA8L6AEBG38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCCCADKAIIIQQgBCgCBCEFQQAhBiAFIQcgBiEIIAcgCEchCUEBIQogCSAKcSELAkACQCALRQ0AIAMoAgghDCAMKAIEIQ0gDRDYCCEOIAMgDjYCDAwBCwJAA0AgAygCCCEPIA8QtgghEEF/IREgECARcyESQQEhEyASIBNxIRQgFEUNASADKAIIIRUgFRC1CCEWIAMgFjYCCAwACwALIAMoAgghFyAXKAIIIRggAyAYNgIMCyADKAIMIRlBECEaIAMgGmohGyAbJAAgGQ8LcwEOfyMAIQFBECECIAEgAmshAyADIAA2AgwCQANAIAMoAgwhBCAEKAIAIQVBACEGIAUhByAGIQggByAIRyEJQQEhCiAJIApxIQsgC0UNASADKAIMIQwgDCgCACENIAMgDTYCDAwACwALIAMoAgwhDiAODwsPAQF/QYCAgIB4IQAgAA8L0AEBF38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFEOgEIQcgBiEIIAchCSAIIAlLIQpBASELIAogC3EhDAJAIAxFDQAgBRC1GgALIAUQ2QQhDSAEKAIIIQ4gDSAOEOwEIQ8gBSAPNgIEIAUgDzYCACAFKAIAIRAgBCgCCCERQRQhEiARIBJsIRMgECATaiEUIAUQggQhFSAVIBQ2AgBBACEWIAUgFhDwBEEQIRcgBCAXaiEYIBgkAA8LkwIBI38jACEEQcAAIQUgBCAFayEGIAYkACAGIAE2AjggBiACNgIwIAYgADYCLCAGIAM2AiggBigCLCEHIAYoAighCEEYIQkgBiAJaiEKIAohCyALIAcgCBDYBBogBxDZBCEMQRAhDSAGIA1qIQ4gDiEPQTghECAGIBBqIREgESESIBIoAgAhEyAPIBM2AgBBCCEUIAYgFGohFSAVIRZBMCEXIAYgF2ohGCAYIRkgGSgCACEaIBYgGjYCAEEYIRsgBiAbaiEcIBwhHUEEIR4gHSAeaiEfIAYoAhAhICAGKAIIISEgDCAgICEgHxD2CEEYISIgBiAiaiEjICMhJCAkEN0EGkHAACElIAYgJWohJiAmJAAPC5cBARN/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhggBCABNgIQQQghBSAEIAVqIQYgBiEHQRghCCAEIAhqIQkgCSEKIAooAgAhCyAHIAs2AgAgBCEMQRAhDSAEIA1qIQ4gDiEPIA8oAgAhECAMIBA2AgAgBCgCCCERIAQoAgAhEiARIBIQ+whBICETIAQgE2ohFCAUJAAPC7IBARV/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBUEIIQYgBCAGaiEHIAchCEEBIQkgCCAFIAkQnwEaIAUQWyEKIAQoAgwhCyALEJYBIQwgBCgCGCENIA0QxAEhDiAKIAwgDhDCASAEKAIMIQ9BCCEQIA8gEGohESAEIBE2AgxBCCESIAQgEmohEyATIRQgFBCiARpBICEVIAQgFWohFiAWJAAPC9oBARh/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAFEFshBiAEIAY2AhQgBRALIQdBASEIIAcgCGohCSAFIAkQowEhCiAFEAshCyAEKAIUIQwgBCENIA0gCiALIAwQpAEaIAQoAhQhDiAEKAIIIQ8gDxCWASEQIAQoAhghESAREMQBIRIgDiAQIBIQwgEgBCgCCCETQQghFCATIBRqIRUgBCAVNgIIIAQhFiAFIBYQpQEgBCEXIBcQpgEaQSAhGCAEIBhqIRkgGSQADwtjAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQ8AUhBSAFKAIAIQZBCCEHIAMgB2ohCCAIIQkgCSAGEI0JGiADKAIIIQpBECELIAMgC2ohDCAMJAAgCg8LOQEFfyMAIQJBECEDIAIgA2shBCAEIAE2AgggBCAANgIEIAQoAgQhBSAEKAIIIQYgBSAGNgIAIAUPC1oBDH8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCACEGIAQoAgghByAHKAIAIQggBiEJIAghCiAJIApGIQtBASEMIAsgDHEhDSANDwtcAQt/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQ7wUhBUEIIQYgAyAGaiEHIAchCCAIIAUQjQkaIAMoAgghCUEQIQogAyAKaiELIAskACAJDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC6AuAaEFfyMAIQJBsAMhAyACIANrIQQgBCQAIAQgADYCqAMgBCABNgKkA0GQAyEFIAQgBWohBiAGIQcgBxDuCBpBgAMhCCAEIAhqIQkgCSEKIAoQ7ggaIAQoAqgDIQsgBCgCqAMhDEEIIQ0gDCANaiEOQZADIQ8gBCAPaiEQIBAhESARIAsgDhDvCBogBCgCpAMhEiAEKAKkAyETQQghFCATIBRqIRVBgAMhFiAEIBZqIRcgFyEYIBggEiAVEO8IGkGQAyEZIAQgGWohGiAaIRtBgAMhHCAEIBxqIR0gHSEeQQAhH0EBISAgHyAgcSEhIBsgHiAhEI4JISJBASEjICIgI3EhJAJAAkAgJEUNACAEKAKoAyElIAQoAqQDISYgJSAmEOQBISdBASEoICcgKHEhKQJAIClFDQAgBCgCqAMhKkEIISsgKiAraiEsIAQoAqQDIS1BCCEuIC0gLmohLyAsIC8Q0gIhMEEAITFBASEyIDAgMnEhMyAxITQCQCAzRQ0AIAQoAqgDITVB+AIhNiAEIDZqITcgNyE4QQAhOSA4IDkQDxpB+AIhOiAEIDpqITsgOyE8IDUgPBAvIT0gBCA9NgL8AiAEKAKoAyE+QfACIT8gBCA/aiFAIEAhQUEBIUIgQSBCEA8aQfACIUMgBCBDaiFEIEQhRSA+IEUQLyFGIAQgRjYC9AIgBCgCqAMhR0EIIUggRyBIaiFJIAQoAqQDIUpBCCFLIEogS2ohTEH8AiFNIAQgTWohTiBOIU9B9AIhUCAEIFBqIVEgUSFSIE8gUiBJIEwQ8gghUyBTITQLIDQhVEEBIVUgVCBVcSFWAkAgVkUNAEEBIVdBASFYIFcgWHEhWSAEIFk6AK8DDAMLQQAhWkEBIVsgWiBbcSFcIAQgXDoArwMMAgsgBCgCqAMhXSAEKAKkAyFeQQghXyBeIF9qIWAgXSBgEOQBIWFBASFiIGEgYnEhYwJAIGNFDQAgBCgCqAMhZEEIIWUgZCBlaiFmIAQoAqQDIWcgZiBnENICIWhBACFpQQEhaiBoIGpxIWsgaSFsAkAga0UNACAEKAKoAyFtQegCIW4gBCBuaiFvIG8hcEEAIXEgcCBxEA8aQegCIXIgBCByaiFzIHMhdCBtIHQQLyF1IAQgdTYC7AIgBCgCqAMhdkHgAiF3IAQgd2oheCB4IXlBASF6IHkgehAPGkHgAiF7IAQge2ohfCB8IX0gdiB9EC8hfiAEIH42AuQCIAQoAqgDIX9BCCGAASB/IIABaiGBASAEKAKkAyGCAUHsAiGDASAEIIMBaiGEASCEASGFAUHkAiGGASAEIIYBaiGHASCHASGIASCFASCIASCBASCCARDyCCGJASCJASFsCyBsIYoBQQEhiwEgigEgiwFxIYwBAkAgjAFFDQBBASGNAUEBIY4BII0BII4BcSGPASAEII8BOgCvAwwDC0EAIZABQQEhkQEgkAEgkQFxIZIBIAQgkgE6AK8DDAILIAQoAqgDIZMBQQghlAEgkwEglAFqIZUBIAQoAqQDIZYBIJUBIJYBEOQBIZcBQQEhmAEglwEgmAFxIZkBAkAgmQFFDQAgBCgCqAMhmgEgBCgCpAMhmwFBCCGcASCbASCcAWohnQEgmgEgnQEQ0gIhngFBACGfAUEBIaABIJ4BIKABcSGhASCfASGiAQJAIKEBRQ0AIAQoAqgDIaMBQQghpAEgowEgpAFqIaUBQdgCIaYBIAQgpgFqIacBIKcBIagBQQAhqQEgqAEgqQEQDxpB2AIhqgEgBCCqAWohqwEgqwEhrAEgpQEgrAEQLyGtASAEIK0BNgLcAiAEKAKoAyGuAUEIIa8BIK4BIK8BaiGwAUHQAiGxASAEILEBaiGyASCyASGzAUEBIbQBILMBILQBEA8aQdACIbUBIAQgtQFqIbYBILYBIbcBILABILcBEC8huAEgBCC4ATYC1AIgBCgCqAMhuQEgBCgCpAMhugFBCCG7ASC6ASC7AWohvAFB3AIhvQEgBCC9AWohvgEgvgEhvwFB1AIhwAEgBCDAAWohwQEgwQEhwgEgvwEgwgEguQEgvAEQ8gghwwEgwwEhogELIKIBIcQBQQEhxQEgxAEgxQFxIcYBAkAgxgFFDQBBASHHAUEBIcgBIMcBIMgBcSHJASAEIMkBOgCvAwwDC0EAIcoBQQEhywEgygEgywFxIcwBIAQgzAE6AK8DDAILIAQoAqgDIc0BQQghzgEgzQEgzgFqIc8BIAQoAqQDIdABQQgh0QEg0AEg0QFqIdIBIM8BINIBEOQBIdMBQQEh1AEg0wEg1AFxIdUBAkAg1QFFDQAgBCgCqAMh1gEgBCgCpAMh1wEg1gEg1wEQ0gIh2AFBACHZAUEBIdoBINgBINoBcSHbASDZASHcAQJAINsBRQ0AIAQoAqgDId0BQQgh3gEg3QEg3gFqId8BQcgCIeABIAQg4AFqIeEBIOEBIeIBQQAh4wEg4gEg4wEQDxpByAIh5AEgBCDkAWoh5QEg5QEh5gEg3wEg5gEQLyHnASAEIOcBNgLMAiAEKAKoAyHoAUEIIekBIOgBIOkBaiHqAUHAAiHrASAEIOsBaiHsASDsASHtAUEBIe4BIO0BIO4BEA8aQcACIe8BIAQg7wFqIfABIPABIfEBIOoBIPEBEC8h8gEgBCDyATYCxAIgBCgCqAMh8wEgBCgCpAMh9AFBzAIh9QEgBCD1AWoh9gEg9gEh9wFBxAIh+AEgBCD4AWoh+QEg+QEh+gEg9wEg+gEg8wEg9AEQ8ggh+wEg+wEh3AELINwBIfwBQQEh/QEg/AEg/QFxIf4BAkAg/gFFDQBBASH/AUEBIYACIP8BIIACcSGBAiAEIIECOgCvAwwDC0EAIYICQQEhgwIgggIggwJxIYQCIAQghAI6AK8DDAILIAQoAqgDIYUCQbACIYYCIAQghgJqIYcCIIcCIYgCIIgCIIUCEOIBGiAEKAKkAyGJAkGwAiGKAiAEIIoCaiGLAiCLAiGMAiCMAiCJAhD1CCGNAiAEII0CNgK8AiAEKAK8AiGOAgJAII4CDQAgBCgCqAMhjwJBqAIhkAIgBCCQAmohkQIgkQIhkgIgkgIgjwIQ4gEaIAQoAqQDIZMCQaACIZQCIAQglAJqIZUCIJUCIZYCIJYCIJMCEOIBGiAEKAKkAyGXAkEIIZgCIJcCIJgCaiGZAkGYAiGaAiAEIJoCaiGbAiCbAiGcAiCcAiCZAhDiARpBqAIhnQIgBCCdAmohngIgngIhnwJBoAIhoAIgBCCgAmohoQIgoQIhogJBmAIhowIgBCCjAmohpAIgpAIhpQIgnwIgogIgpQIQ8wghpgJBASGnAiCmAiCnAnEhqAIgqAJFDQBBASGpAkEBIaoCIKkCIKoCcSGrAiAEIKsCOgCvAwwCCyAEKAKoAyGsAkEIIa0CIKwCIK0CaiGuAkGIAiGvAiAEIK8CaiGwAiCwAiGxAiCxAiCuAhDiARogBCgCpAMhsgJBiAIhswIgBCCzAmohtAIgtAIhtQIgtQIgsgIQ9QghtgIgBCC2AjYClAIgBCgClAIhtwICQCC3Ag0AIAQoAqgDIbgCQQghuQIguAIguQJqIboCQYACIbsCIAQguwJqIbwCILwCIb0CIL0CILoCEOIBGiAEKAKkAyG+AkH4ASG/AiAEIL8CaiHAAiDAAiHBAiDBAiC+AhDiARogBCgCpAMhwgJBCCHDAiDCAiDDAmohxAJB8AEhxQIgBCDFAmohxgIgxgIhxwIgxwIgxAIQ4gEaQYACIcgCIAQgyAJqIckCIMkCIcoCQfgBIcsCIAQgywJqIcwCIMwCIc0CQfABIc4CIAQgzgJqIc8CIM8CIdACIMoCIM0CINACEPMIIdECQQEh0gIg0QIg0gJxIdMCINMCRQ0AQQEh1AJBASHVAiDUAiDVAnEh1gIgBCDWAjoArwMMAgsgBCgCvAIh1wIgBCgClAIh2AIg1wIh2QIg2AIh2gIg2QIg2gJGIdsCQQEh3AIg2wIg3AJxId0CAkAg3QJFDQAgBCgCvAIh3gIg3gJFDQBBACHfAkEBIeACIN8CIOACcSHhAiAEIOECOgCvAwwCCyAEKAKkAyHiAkHgASHjAiAEIOMCaiHkAiDkAiHlAiDlAiDiAhDiARogBCgCqAMh5gJB4AEh5wIgBCDnAmoh6AIg6AIh6QIg6QIg5gIQ9Qgh6gIgBCDqAjYC7AEgBCgC7AEh6wICQCDrAg0AIAQoAqQDIewCQdgBIe0CIAQg7QJqIe4CIO4CIe8CIO8CIOwCEOIBGiAEKAKoAyHwAkHQASHxAiAEIPECaiHyAiDyAiHzAiDzAiDwAhDiARogBCgCqAMh9AJBCCH1AiD0AiD1Amoh9gJByAEh9wIgBCD3Amoh+AIg+AIh+QIg+QIg9gIQ4gEaQdgBIfoCIAQg+gJqIfsCIPsCIfwCQdABIf0CIAQg/QJqIf4CIP4CIf8CQcgBIYADIAQggANqIYEDIIEDIYIDIPwCIP8CIIIDEPMIIYMDQQEhhAMggwMghANxIYUDIIUDRQ0AQQEhhgNBASGHAyCGAyCHA3EhiAMgBCCIAzoArwMMAgsgBCgCpAMhiQNBCCGKAyCJAyCKA2ohiwNBuAEhjAMgBCCMA2ohjQMgjQMhjgMgjgMgiwMQ4gEaIAQoAqgDIY8DQbgBIZADIAQgkANqIZEDIJEDIZIDIJIDII8DEPUIIZMDIAQgkwM2AsQBIAQoAsQBIZQDAkAglAMNACAEKAKkAyGVA0EIIZYDIJUDIJYDaiGXA0GwASGYAyAEIJgDaiGZAyCZAyGaAyCaAyCXAxDiARogBCgCqAMhmwNBqAEhnAMgBCCcA2ohnQMgnQMhngMgngMgmwMQ4gEaIAQoAqgDIZ8DQQghoAMgnwMgoANqIaEDQaABIaIDIAQgogNqIaMDIKMDIaQDIKQDIKEDEOIBGkGwASGlAyAEIKUDaiGmAyCmAyGnA0GoASGoAyAEIKgDaiGpAyCpAyGqA0GgASGrAyAEIKsDaiGsAyCsAyGtAyCnAyCqAyCtAxDzCCGuA0EBIa8DIK4DIK8DcSGwAyCwA0UNAEEBIbEDQQEhsgMgsQMgsgNxIbMDIAQgswM6AK8DDAILIAQoAuwBIbQDIAQoAsQBIbUDILQDIbYDILUDIbcDILYDILcDRiG4A0EBIbkDILgDILkDcSG6AwJAILoDRQ0AQQAhuwNBASG8AyC7AyC8A3EhvQMgBCC9AzoArwMMAgtBASG+A0EBIb8DIL4DIL8DcSHAAyAEIMADOgCvAwwBCyAEKAKoAyHBAyDBAxCvAyHCA0EAIcMDQQEhxAMgwgMgxANxIcUDIMMDIcYDAkAgxQNFDQAgBCgCpAMhxwMgxwMQrwMhyANBACHJA0EBIcoDIMgDIMoDcSHLAyDJAyHGAyDLA0UNACAEKAKoAyHMA0GYASHNAyAEIM0DaiHOAyDOAyHPA0EAIdADIM8DINADEA8aQZgBIdEDIAQg0QNqIdIDINIDIdMDIMwDINMDEC8h1AMgBCgCpAMh1QNBkAEh1gMgBCDWA2oh1wMg1wMh2ANBACHZAyDYAyDZAxAPGkGQASHaAyAEINoDaiHbAyDbAyHcAyDVAyDcAxAvId0DINQDId4DIN0DId8DIN4DIN8DRiHgAyDgAyHGAwsgxgMh4QNBASHiAyDhAyDiA3Eh4wMCQCDjA0UNAEGAASHkAyAEIOQDaiHlAyDlAyHmA0EBIecDIOYDIOcDEA8aQYgBIegDIAQg6ANqIekDIOkDIeoDQZADIesDIAQg6wNqIewDIOwDIe0DQYABIe4DIAQg7gNqIe8DIO8DIfADIOoDIO0DIPADEI8JQfAAIfEDIAQg8QNqIfIDIPIDIfMDQQEh9AMg8wMg9AMQDxpB+AAh9QMgBCD1A2oh9gMg9gMh9wNBgAMh+AMgBCD4A2oh+QMg+QMh+gNB8AAh+wMgBCD7A2oh/AMg/AMh/QMg9wMg+gMg/QMQjwlBiAEh/gMgBCD+A2oh/wMg/wMhgARB+AAhgQQgBCCBBGohggQgggQhgwRBACGEBEEBIYUEIIQEIIUEcSGGBCCABCCDBCCGBBCQCSGHBEEAIYgEQQEhiQQghwQgiQRxIYoEIIgEIYsEAkAgigRFDQBB4AAhjAQgBCCMBGohjQQgjQQhjgRBASGPBCCOBCCPBBAPGkHoACGQBCAEIJAEaiGRBCCRBCGSBEGQAyGTBCAEIJMEaiGUBCCUBCGVBEHgACGWBCAEIJYEaiGXBCCXBCGYBCCSBCCVBCCYBBCPCUHQACGZBCAEIJkEaiGaBCCaBCGbBEEBIZwEIJsEIJwEEA8aQdgAIZ0EIAQgnQRqIZ4EIJ4EIZ8EQYADIaAEIAQgoARqIaEEIKEEIaIEQdAAIaMEIAQgowRqIaQEIKQEIaUEIJ8EIKIEIKUEEI8JQegAIaYEIAQgpgRqIacEIKcEIagEQdgAIakEIAQgqQRqIaoEIKoEIasEIKgEIKsEEJEJIawEIKwEIYsECyCLBCGtBEEBIa4EIK0EIK4EcSGvBCAEIK8EOgCvAwwBCyAEKAKoAyGwBCCwBBDxCCGxBEEAIbIEQQEhswQgsQQgswRxIbQEILIEIbUEAkAgtARFDQAgBCgCpAMhtgQgtgQQ8QghtwRBACG4BEEBIbkEILcEILkEcSG6BCC4BCG1BCC6BEUNACAEKAKoAyG7BEHIACG8BCAEILwEaiG9BCC9BCG+BEEBIb8EIL4EIL8EEA8aQcgAIcAEIAQgwARqIcEEIMEEIcIEILsEIMIEEC8hwwQgBCgCpAMhxARBwAAhxQQgBCDFBGohxgQgxgQhxwRBASHIBCDHBCDIBBAPGkHAACHJBCAEIMkEaiHKBCDKBCHLBCDEBCDLBBAvIcwEIMMEIc0EIMwEIc4EIM0EIM4ERiHPBCDPBCG1BAsgtQQh0ARBASHRBCDQBCDRBHEh0gQCQCDSBEUNAEEwIdMEIAQg0wRqIdQEINQEIdUEQQAh1gQg1QQg1gQQDxpBOCHXBCAEINcEaiHYBCDYBCHZBEGQAyHaBCAEINoEaiHbBCDbBCHcBEEwId0EIAQg3QRqId4EIN4EId8EINkEINwEIN8EEI8JQSAh4AQgBCDgBGoh4QQg4QQh4gRBACHjBCDiBCDjBBAPGkEoIeQEIAQg5ARqIeUEIOUEIeYEQYADIecEIAQg5wRqIegEIOgEIekEQSAh6gQgBCDqBGoh6wQg6wQh7AQg5gQg6QQg7AQQjwlBOCHtBCAEIO0EaiHuBCDuBCHvBEEoIfAEIAQg8ARqIfEEIPEEIfIEQQAh8wRBASH0BCDzBCD0BHEh9QQg7wQg8gQg9QQQkAkh9gRBACH3BEEBIfgEIPYEIPgEcSH5BCD3BCH6BAJAIPkERQ0AQRAh+wQgBCD7BGoh/AQg/AQh/QRBACH+BCD9BCD+BBAPGkEYIf8EIAQg/wRqIYAFIIAFIYEFQZADIYIFIAQgggVqIYMFIIMFIYQFQRAhhQUgBCCFBWohhgUghgUhhwUggQUghAUghwUQjwkgBCGIBUEAIYkFIIgFIIkFEA8aQQghigUgBCCKBWohiwUgiwUhjAVBgAMhjQUgBCCNBWohjgUgjgUhjwUgBCGQBSCMBSCPBSCQBRCPCUEYIZEFIAQgkQVqIZIFIJIFIZMFQQghlAUgBCCUBWohlQUglQUhlgUgkwUglgUQkQkhlwUglwUh+gQLIPoEIZgFQQEhmQUgmAUgmQVxIZoFIAQgmgU6AK8DDAELQQAhmwVBASGcBSCbBSCcBXEhnQUgBCCdBToArwMLIAQtAK8DIZ4FQQEhnwUgngUgnwVxIaAFQbADIaEFIAQgoQVqIaIFIKIFJAAgoAUPC49GAscFf7kBfiMAIQVB0AshBiAFIAZrIQcgByQAIAcgADYCyAsgByABNgLECyAHIAI2AsALIAMhCCAHIAg6AL8LIAQhCSAHIAk6AL4LQbAJIQogByAKaiELIAshDCAMEO4IGkGgCSENIAcgDWohDiAOIQ8gDxDuCBogBygCxAshECAHKALECyERQQghEiARIBJqIRNBsAkhFCAHIBRqIRUgFSEWIBYgECATEO8IGiAHKALACyEXIAcoAsALIRhBCCEZIBggGWohGkGgCSEbIAcgG2ohHCAcIR0gHSAXIBoQ7wgaIActAL8LIR5BASEfIB4gH3EhIAJAAkAgIA0AQbAJISEgByAhaiEiICIhI0GgCSEkIAcgJGohJSAlISZBASEnQQEhKCAnIChxISkgIyAmICkQjgkhKkEBISsgKiArcSEsICwNAEEAIS1BASEuIC0gLnEhLyAHIC86AM8LDAELIAcoAsQLITAgMBCvAyExQQEhMiAxIDJxITMCQCAzRQ0AIAcoAsALITQgNBCvAyE1QQEhNiA1IDZxITcCQCA3RQ0AQQAhOEEBITkgOCA5cSE6IAcgOjoAzwsMAgsgBygCxAshO0EAITxBmAkhPSAHID1qIT4gPiA8EA8aQZgJIT8gByA/aiFAIDsgQBAvIUEgBygCwAshQkGQCSFDIAcgQ2ohRCBEIEIQ4gEaIAcoAsALIUVBCCFGIEUgRmohR0GICSFIIAcgSGohSSBJIEcQ4gEaQZAJIUogByBKaiFLQYgJIUwgByBMaiFNIEEgSyBNEJIJIU5BECFPIAcgT2ohUCBQIE4QsRpBECFRIAcgUWohUiBSIEZqIVMgUykDACHMBSAHKQMQIc0FIAcgzAU3A6gLIAcgzQU3A6ALIAcpA6gLIc4FIAcpA6ALIc8FIM8FIM4FEK0aIVQgByBUNgKECSAHKQOoCyHQBSAHKQOgCyHRBSAHKAKECSFVIAcgVRCxGiAHIEZqIVYgVikDACHSBSAHKQMAIdMFINEFINAFINMFINIFEKUaIVcgVyA8SCFYQQEhWSBYIFlxIVoCQCBaRQ0AIAcoAoQJIVtBfyFcIFsgXGohXSAHIF02AoQJCyAHLQC/CyFeQQEhX0EBIWAgXiBgcSFhIF8hYgJAIGENAEHwCCFjIAcgY2ohZCBkIWVBASFmIGUgZhAPGkH4CCFnIAcgZ2ohaCBoIWlBsAkhaiAHIGpqIWsgayFsQfAIIW0gByBtaiFuIG4hbyBpIGwgbxCPCSAHKAKECSFwQfgIIXEgByBxaiFyIHIhc0EBIXRBASF1IHQgdXEhdiBzIHAgdhCTCSF3IHchYgsgYiF4QQEheSB4IHlxIXoCQCB6RQ0AIAcoAsQLIXtB4AghfCAHIHxqIX0gfSF+QQAhfyB+IH8QDxpB4AghgAEgByCAAWohgQEggQEhggEgeyCCARAvIYMBIAcoAoQJIYQBQegIIYUBIAcghQFqIYYBIIYBIYcBIIcBIIMBIIQBEBwaIAcoAsgLIYgBQegIIYkBIAcgiQFqIYoBIIoBIYsBIIgBIIsBEOgBGkEBIYwBQQEhjQEgjAEgjQFxIY4BIAcgjgE6AM8LDAILQQAhjwFBASGQASCPASCQAXEhkQEgByCRAToAzwsMAQsgBygCwAshkgEgkgEQrwMhkwFBASGUASCTASCUAXEhlQECQCCVAUUNACAHKALACyGWAUEAIZcBQdgIIZgBIAcgmAFqIZkBIJkBIJcBEA8aQdgIIZoBIAcgmgFqIZsBIJYBIJsBEC8hnAEgBygCxAshnQFB0AghngEgByCeAWohnwEgnwEgnQEQ4gEaIAcoAsQLIaABQQghoQEgoAEgoQFqIaIBQcgIIaMBIAcgowFqIaQBIKQBIKIBEOIBGkHQCCGlASAHIKUBaiGmAUHICCGnASAHIKcBaiGoASCcASCmASCoARCSCSGpAUEwIaoBIAcgqgFqIasBIKsBIKkBELEaQTAhrAEgByCsAWohrQEgrQEgoQFqIa4BIK4BKQMAIdQFIAcpAzAh1QUgByDUBTcDqAsgByDVBTcDoAsgBykDqAsh1gUgBykDoAsh1wUg1wUg1gUQrRohrwEgByCvATYCxAggBykDqAsh2AUgBykDoAsh2QUgBygCxAghsAFBICGxASAHILEBaiGyASCyASCwARCxGkEgIbMBIAcgswFqIbQBILQBIKEBaiG1ASC1ASkDACHaBSAHKQMgIdsFINkFINgFINsFINoFEKUaIbYBILYBIJcBSCG3AUEBIbgBILcBILgBcSG5AQJAILkBRQ0AIAcoAsQIIboBQX8huwEgugEguwFqIbwBIAcgvAE2AsQICyAHLQC/CyG9AUEBIb4BQQEhvwEgvQEgvwFxIcABIL4BIcEBAkAgwAENAEGwCCHCASAHIMIBaiHDASDDASHEAUEBIcUBIMQBIMUBEA8aQbgIIcYBIAcgxgFqIccBIMcBIcgBQaAJIckBIAcgyQFqIcoBIMoBIcsBQbAIIcwBIAcgzAFqIc0BIM0BIc4BIMgBIMsBIM4BEI8JIAcoAsQIIc8BQbgIIdABIAcg0AFqIdEBINEBIdIBQQEh0wFBASHUASDTASDUAXEh1QEg0gEgzwEg1QEQkwkh1gEg1gEhwQELIMEBIdcBQQEh2AEg1wEg2AFxIdkBAkAg2QFFDQAgBygCwAsh2gFBoAgh2wEgByDbAWoh3AEg3AEh3QFBACHeASDdASDeARAPGkGgCCHfASAHIN8BaiHgASDgASHhASDaASDhARAvIeIBIAcoAsQIIeMBQagIIeQBIAcg5AFqIeUBIOUBIeYBIOYBIOIBIOMBEBwaIAcoAsgLIecBQagIIegBIAcg6AFqIekBIOkBIeoBIOcBIOoBEOgBGkEBIesBQQEh7AEg6wEg7AFxIe0BIAcg7QE6AM8LDAILQQAh7gFBASHvASDuASDvAXEh8AEgByDwAToAzwsMAQsgBygCwAsh8QFBCCHyASDxASDyAWoh8wFBASH0AUGYCCH1ASAHIPUBaiH2ASD2ASD0ARAPGkGYCCH3ASAHIPcBaiH4ASDzASD4ARAvIfkBIAcoAsALIfoBQZAIIfsBIAcg+wFqIfwBIPwBIPQBEA8aQZAIIf0BIAcg/QFqIf4BIPoBIP4BEC8h/wEg+QEg/wFrIYACQZAGIYECIAcggQJqIYICIIICIIACELEaQZAGIYMCIAcggwJqIYQCIIQCIPIBaiGFAiCFAikDACHcBSAHKQOQBiHdBSAHINwFNwPoCiAHIN0FNwPgCiAHKALECyGGAiCGAiDyAWohhwJBiAghiAIgByCIAmohiQIgiQIg9AEQDxpBiAghigIgByCKAmohiwIghwIgiwIQLyGMAiAHKALECyGNAkGACCGOAiAHII4CaiGPAiCPAiD0ARAPGkGACCGQAiAHIJACaiGRAiCNAiCRAhAvIZICIIwCIJICayGTAkGABiGUAiAHIJQCaiGVAiCVAiCTAhCxGkGABiGWAiAHIJYCaiGXAiCXAiDyAWohmAIgmAIpAwAh3gUgBykDgAYh3wUgByDeBTcDiAsgByDfBTcDgAsgBygCwAshmQIgmQIg8gFqIZoCQQAhmwJB+AchnAIgByCcAmohnQIgnQIgmwIQDxpB+AchngIgByCeAmohnwIgmgIgnwIQLyGgAiAHKALACyGhAkHwByGiAiAHIKICaiGjAiCjAiCbAhAPGkHwByGkAiAHIKQCaiGlAiChAiClAhAvIaYCIKACIKYCayGnAkHwBSGoAiAHIKgCaiGpAiCpAiCnAhCxGkHwBSGqAiAHIKoCaiGrAiCrAiDyAWohrAIgrAIpAwAh4AUgBykD8AUh4QUgByDgBTcD+AogByDhBTcD8AogBygCxAshrQIgrQIg8gFqIa4CQegHIa8CIAcgrwJqIbACILACIJsCEA8aQegHIbECIAcgsQJqIbICIK4CILICEC8hswIgBygCxAshtAJB4AchtQIgByC1AmohtgIgtgIgmwIQDxpB4AchtwIgByC3AmohuAIgtAIguAIQLyG5AiCzAiC5AmshugJB4AUhuwIgByC7AmohvAIgvAIgugIQsRpB4AUhvQIgByC9AmohvgIgvgIg8gFqIb8CIL8CKQMAIeIFIAcpA+AFIeMFIAcg4gU3A5gLIAcg4wU3A5ALQZALIcACIAcgwAJqIcECIMECIcICQYALIcMCIAcgwwJqIcQCIMQCIcUCQfAKIcYCIAcgxgJqIccCIMcCIcgCQeAKIckCIAcgyQJqIcoCIMoCIcsCIMICIMUCIMgCIMsCEJQJIcwCQQEhzQIgzAIgzQJxIc4CAkAgzgJFDQBBACHPAkEBIdACIM8CINACcSHRAiAHINECOgDPCwwBCyAHKALECyHSAkEAIdMCQdgHIdQCIAcg1AJqIdUCINUCINMCEA8aQdgHIdYCIAcg1gJqIdcCINICINcCEC8h2AJB0AUh2QIgByDZAmoh2gIg2gIg2AIQsRpBCCHbAkHQBSHcAiAHINwCaiHdAiDdAiDbAmoh3gIg3gIpAwAh5AUgBykD0AUh5QUgByDkBTcD2AogByDlBTcD0AogBygCwAsh3wJB0Ach4AIgByDgAmoh4QIg4QIg0wIQDxpB0Ach4gIgByDiAmoh4wIg3wIg4wIQLyHkAkHABSHlAiAHIOUCaiHmAiDmAiDkAhCxGkHABSHnAiAHIOcCaiHoAiDoAiDbAmoh6QIg6QIpAwAh5gUgBykDwAUh5wUgByDmBTcDyAogByDnBTcDwAogBygCxAsh6gJBASHrAkHIByHsAiAHIOwCaiHtAiDtAiDrAhAPGkHIByHuAiAHIO4CaiHvAiDqAiDvAhAvIfACQbAFIfECIAcg8QJqIfICIPICIPACELEaQbAFIfMCIAcg8wJqIfQCIPQCINsCaiH1AiD1AikDACHoBSAHKQOwBSHpBSAHIOgFNwO4CiAHIOkFNwOwCiAHKALACyH2AkHAByH3AiAHIPcCaiH4AiD4AiDrAhAPGkHAByH5AiAHIPkCaiH6AiD2AiD6AhAvIfsCQaAFIfwCIAcg/AJqIf0CIP0CIPsCELEaQaAFIf4CIAcg/gJqIf8CIP8CINsCaiGAAyCAAykDACHqBSAHKQOgBSHrBSAHIOoFNwOoCiAHIOsFNwOgCiAHKQPYCiHsBSAHKQPQCiHtBSAHKQOICyHuBSAHKQOACyHvBUGQBSGBAyAHIIEDaiGCAyCCAyDtBSDsBSDvBSDuBRCvGkGQBSGDAyAHIIMDaiGEAyCEAyDbAmohhQMghQMpAwAh8AUgBykDkAUh8QUgBykD+Aoh8gUgBykD8Aoh8wVBgAUhhgMgByCGA2ohhwMghwMg8QUg8AUg8wUg8gUQrxpBgAUhiAMgByCIA2ohiQMgiQMg2wJqIYoDIIoDKQMAIfQFIAcpA4AFIfUFIAcpA8gKIfYFIAcpA8AKIfcFIAcpA+gKIfgFIAcpA+AKIfkFQfAEIYsDIAcgiwNqIYwDIIwDIPcFIPYFIPkFIPgFEK8aQfAEIY0DIAcgjQNqIY4DII4DINsCaiGPAyCPAykDACH6BSAHKQPwBCH7BSAHKQOYCyH8BSAHKQOQCyH9BUHgBCGQAyAHIJADaiGRAyCRAyD7BSD6BSD9BSD8BRCvGkHgBCGSAyAHIJIDaiGTAyCTAyDbAmohlAMglAMpAwAh/gUgBykD4AQh/wVB0AQhlQMgByCVA2ohlgMglgMg9QUg9AUg/wUg/gUQsBpB0AQhlwMgByCXA2ohmAMgmAMg2wJqIZkDIJkDKQMAIYAGIAcpA9AEIYEGIAcpA6gKIYIGIAcpA6AKIYMGQcAEIZoDIAcgmgNqIZsDIJsDIIMGIIIGIP0FIPwFEK8aQcAEIZwDIAcgnANqIZ0DIJ0DINsCaiGeAyCeAykDACGEBiAHKQPABCGFBkGwBCGfAyAHIJ8DaiGgAyCgAyCFBiCEBiDzBSDyBRCvGkGwBCGhAyAHIKEDaiGiAyCiAyDbAmohowMgowMpAwAhhgYgBykDsAQhhwZBoAQhpAMgByCkA2ohpQMgpQMggQYggAYghwYghgYQqxpBoAQhpgMgByCmA2ohpwMgpwMg2wJqIagDIKgDKQMAIYgGIAcpA6AEIYkGIAcpA7gKIYoGIAcpA7AKIYsGQZAEIakDIAcgqQNqIaoDIKoDIIsGIIoGIP0FIPwFEK8aQZAEIasDIAcgqwNqIawDIKwDINsCaiGtAyCtAykDACGMBiAHKQOQBCGNBkGABCGuAyAHIK4DaiGvAyCvAyCNBiCMBiDzBSDyBRCvGkGABCGwAyAHILADaiGxAyCxAyDbAmohsgMgsgMpAwAhjgYgBykDgAQhjwZB8AMhswMgByCzA2ohtAMgtAMgiQYgiAYgjwYgjgYQsBpB8AMhtQMgByC1A2ohtgMgtgMg2wJqIbcDILcDKQMAIZAGIAcpA/ADIZEGIAcgkAY3A5gKIAcgkQY3A5AKIAcpA4gLIZIGIAcpA4ALIZMGIAcpA/gKIZQGIAcpA/AKIZUGQeADIbgDIAcguANqIbkDILkDIJMGIJIGIJUGIJQGEK8aQeADIboDIAcgugNqIbsDILsDINsCaiG8AyC8AykDACGWBiAHKQPgAyGXBiAHKQPoCiGYBiAHKQPgCiGZBiAHKQOYCyGaBiAHKQOQCyGbBkHQAyG9AyAHIL0DaiG+AyC+AyCZBiCYBiCbBiCaBhCvGkHQAyG/AyAHIL8DaiHAAyDAAyDbAmohwQMgwQMpAwAhnAYgBykD0AMhnQZBwAMhwgMgByDCA2ohwwMgwwMglwYglgYgnQYgnAYQsBpBwAMhxAMgByDEA2ohxQMgxQMg2wJqIcYDIMYDKQMAIZ4GIAcpA8ADIZ8GIAcgngY3A/gJIAcgnwY3A/AJIAcpA7gKIaAGIAcpA7AKIaEGIAcpA5gLIaIGIAcpA5ALIaMGQbADIccDIAcgxwNqIcgDIMgDIKEGIKAGIKMGIKIGEK8aQbADIckDIAcgyQNqIcoDIMoDINsCaiHLAyDLAykDACGkBiAHKQOwAyGlBiAHKQPoCiGmBiAHKQPgCiGnBkGgAyHMAyAHIMwDaiHNAyDNAyClBiCkBiCnBiCmBhCvGkGgAyHOAyAHIM4DaiHPAyDPAyDbAmoh0AMg0AMpAwAhqAYgBykDoAMhqQYgBykDqAohqgYgBykDoAohqwYgBykD+AohrAYgBykD8AohrQZBkAMh0QMgByDRA2oh0gMg0gMgqwYgqgYgrQYgrAYQrxpBkAMh0wMgByDTA2oh1AMg1AMg2wJqIdUDINUDKQMAIa4GIAcpA5ADIa8GIAcpA4gLIbAGIAcpA4ALIbEGQYADIdYDIAcg1gNqIdcDINcDIK8GIK4GILEGILAGEK8aQYADIdgDIAcg2ANqIdkDINkDINsCaiHaAyDaAykDACGyBiAHKQOAAyGzBkHwAiHbAyAHINsDaiHcAyDcAyCpBiCoBiCzBiCyBhCwGkHwAiHdAyAHIN0DaiHeAyDeAyDbAmoh3wMg3wMpAwAhtAYgBykD8AIhtQYgBykDyAohtgYgBykDwAohtwZB4AIh4AMgByDgA2oh4QMg4QMgtwYgtgYgsQYgsAYQrxpB4AIh4gMgByDiA2oh4wMg4wMg2wJqIeQDIOQDKQMAIbgGIAcpA+ACIbkGQdACIeUDIAcg5QNqIeYDIOYDILkGILgGIKcGIKYGEK8aQdACIecDIAcg5wNqIegDIOgDINsCaiHpAyDpAykDACG6BiAHKQPQAiG7BkHAAiHqAyAHIOoDaiHrAyDrAyC1BiC0BiC7BiC6BhCrGkHAAiHsAyAHIOwDaiHtAyDtAyDbAmoh7gMg7gMpAwAhvAYgBykDwAIhvQYgBykD2AohvgYgBykD0AohvwZBsAIh7wMgByDvA2oh8AMg8AMgvwYgvgYgsQYgsAYQrxpBsAIh8QMgByDxA2oh8gMg8gMg2wJqIfMDIPMDKQMAIcAGIAcpA7ACIcEGQaACIfQDIAcg9ANqIfUDIPUDIMEGIMAGIKcGIKYGEK8aQaACIfYDIAcg9gNqIfcDIPcDINsCaiH4AyD4AykDACHCBiAHKQOgAiHDBkGQAiH5AyAHIPkDaiH6AyD6AyC9BiC8BiDDBiDCBhCwGkGQAiH7AyAHIPsDaiH8AyD8AyDbAmoh/QMg/QMpAwAhxAYgBykDkAIhxQYgByDEBjcDiAogByDFBjcDgAogBykDmAshxgYgBykDkAshxwYgBykD6AohyAYgBykD4AohyQZBgAIh/gMgByD+A2oh/wMg/wMgxwYgxgYgyQYgyAYQrxpBgAIhgAQgByCABGohgQQggQQg2wJqIYIEIIIEKQMAIcoGIAcpA4ACIcsGIAcpA/gKIcwGIAcpA/AKIc0GIAcpA4gLIc4GIAcpA4ALIc8GQfABIYMEIAcggwRqIYQEIIQEIM0GIMwGIM8GIM4GEK8aQfABIYUEIAcghQRqIYYEIIYEINsCaiGHBCCHBCkDACHQBiAHKQPwASHRBkHgASGIBCAHIIgEaiGJBCCJBCDLBiDKBiDRBiDQBhCwGkHgASGKBCAHIIoEaiGLBCCLBCDbAmohjAQgjAQpAwAh0gYgBykD4AEh0wYgByDSBjcD6AkgByDTBjcD4AkgBykDmAoh1AYgBykDkAoh1QYgBykD+Akh1gYgBykD8Akh1wZB0AEhjQQgByCNBGohjgQgjgQg1QYg1AYg1wYg1gYQsxpB0AEhjwQgByCPBGohkAQgkAQg2wJqIZEEIJEEKQMAIdgGIAcpA9ABIdkGIAcg2AY3A9gJIAcg2QY3A9AJIAcpA4gKIdoGIAcpA4AKIdsGIAcpA+gJIdwGIAcpA+AJId0GQcABIZIEIAcgkgRqIZMEIJMEINsGINoGIN0GINwGELMaQcABIZQEIAcglARqIZUEIJUEINsCaiGWBCCWBCkDACHeBiAHKQPAASHfBiAHIN4GNwPICSAHIN8GNwPACSAHLQC+CyGXBEEBIZgEIJcEIJgEcSGZBAJAIJkERQ0AIAcpA9gJIeAGIAcpA9AJIeEGQoCAgICAgID/PyHiBkIAIeMGQbABIZoEIAcgmgRqIZsEIJsEIOEGIOAGIOMGIOIGEKsaQQghnARBsAEhnQQgByCdBGohngQgngQgnARqIZ8EIJ8EKQMAIeQGIAcpA7ABIeUGIAcg5AY3A9gJIAcg5QY3A9AJIAcpA8gJIeYGIAcpA8AJIecGQaABIaAEIAcgoARqIaEEIKEEIOcGIOYGIOMGIOIGEKsaQaABIaIEIAcgogRqIaMEIKMEIJwEaiGkBCCkBCkDACHoBiAHKQOgASHpBiAHIOgGNwPICSAHIOkGNwPACQsgBykD2Akh6gYgBykD0Akh6wYg6wYg6gYQrRohpQQgByClBDYCvAcgBykDyAkh7AYgBykDwAkh7QYg7QYg7AYQrRohpgQgByCmBDYCuAcgBykD2Akh7gYgBykD0Akh7wYgBygCvAchpwRBkAEhqAQgByCoBGohqQQgqQQgpwQQsRpBmAEhqgQgByCqBGohqwQgqwQpAwAh8AYgBykDkAEh8QYg7wYg7gYg8QYg8AYQpRohrARBACGtBCCsBCCtBEghrgRBASGvBCCuBCCvBHEhsAQCQCCwBEUNACAHKAK8ByGxBEF/IbIEILEEILIEaiGzBCAHILMENgK8BwsgBykDyAkh8gYgBykDwAkh8wYgBygCuAchtARBgAEhtQQgByC1BGohtgQgtgQgtAQQsRpBiAEhtwQgByC3BGohuAQguAQpAwAh9AYgBykDgAEh9QYg8wYg8gYg9QYg9AYQpRohuQRBACG6BCC5BCC6BEghuwRBASG8BCC7BCC8BHEhvQQCQCC9BEUNACAHKAK4ByG+BEF/Ib8EIL4EIL8EaiHABCAHIMAENgK4BwsgBygCxAshwQQgwQQQ8QghwgRBASHDBCDCBCDDBHEhxAQCQCDEBEUNACAHKALECyHFBCDFBBCvAiHGBCAHIMYENgK4BwsgBygCwAshxwQgxwQQ8QghyARBASHJBCDIBCDJBHEhygQCQCDKBEUNACAHKALACyHLBCDLBBCvAiHMBCAHIMwENgK4BwsgBygCvAchzQQgBygCuAchzgRBsAchzwQgByDPBGoh0AQg0AQh0QQg0QQgzQQgzgQQHBogBy0Avwsh0gRBASHTBCDSBCDTBHEh1AQCQCDUBA0AQagHIdUEIAcg1QRqIdYEINYEIdcEQbAHIdgEIAcg2ARqIdkEINkEIdoEINcEINoEEOIBGkGwCSHbBCAHINsEaiHcBCDcBCHdBEGoByHeBCAHIN4EaiHfBCDfBCHgBEEBIeEEQQEh4gQg4QQg4gRxIeMEIN0EIOAEIOMEEPAIIeQEQQEh5QQg5AQg5QRxIeYEIOYEDQBBACHnBEEBIegEIOcEIOgEcSHpBCAHIOkEOgDPCwwBCyAHLQC/CyHqBEEBIesEIOoEIOsEcSHsBAJAIOwEDQBBoAch7QQgByDtBGoh7gQg7gQh7wRBsAch8AQgByDwBGoh8QQg8QQh8gQg7wQg8gQQ4gEaQaAJIfMEIAcg8wRqIfQEIPQEIfUEQaAHIfYEIAcg9gRqIfcEIPcEIfgEQQEh+QRBASH6BCD5BCD6BHEh+wQg9QQg+AQg+wQQ8Agh/ARBASH9BCD8BCD9BHEh/gQg/gQNAEEAIf8EQQEhgAUg/wQggAVxIYEFIAcggQU6AM8LDAELIActAL8LIYIFQQEhgwUgggUggwVxIYQFAkAghAVFDQAQowIhhQVB8AAhhgUgByCGBWohhwUghwUghQUQsRpBCCGIBUHwACGJBSAHIIkFaiGKBSCKBSCIBWohiwUgiwUpAwAh9gYgBykDcCH3BhCjAiGMBUHgACGNBSAHII0FaiGOBSCOBSCMBRCxGkHgACGPBSAHII8FaiGQBSCQBSCIBWohkQUgkQUpAwAh+AYgBykDYCH5BhCjAiGSBUHQACGTBSAHIJMFaiGUBSCUBSCSBRCxGkHQACGVBSAHIJUFaiGWBSCWBSCIBWohlwUglwUpAwAh+gYgBykDUCH7BhCjAiGYBUHAACGZBSAHIJkFaiGaBSCaBSCYBRCxGkHAACGbBSAHIJsFaiGcBSCcBSCIBWohnQUgnQUpAwAh/AYgBykDQCH9BkKAgICAgICAgIB/If4GIPYGIP4GhSH/BiD4BiD+BoUhgAdB4AYhngUgByCeBWohnwUgnwUg9wYg/wYg+QYggAcg+wYg+gYg/QYg/AYQlQkaIAcpA9gJIYEHIAcpA9AJIYIHIAcpA8gJIYMHIAcpA8AJIYQHQaAGIaAFIAcgoAVqIaEFIKEFGkGgBiGiBSAHIKIFaiGjBSCjBSCCByCBByCEByCDBxCWCRpBwAYhpAUgByCkBWohpQUgpQUhpgVBoAYhpwUgByCnBWohqAUgqAUhqQUgpgUgqQUQlwkaQeAGIaoFIAcgqgVqIasFIKsFIawFQcAGIa0FIAcgrQVqIa4FIK4FIa8FQQEhsAVBASGxBSCwBSCxBXEhsgUgrAUgrwUgsgUQmAkhswVBASG0BSCzBSC0BXEhtQUCQCC1BUUNACAHKALICyG2BUGwByG3BSAHILcFaiG4BSC4BSG5BSC2BSC5BRDoARpBASG6BUEBIbsFILoFILsFcSG8BSAHILwFOgDPCwwCC0EAIb0FQQEhvgUgvQUgvgVxIb8FIAcgvwU6AM8LDAELIAcoAsgLIcAFQbAHIcEFIAcgwQVqIcIFIMIFIcMFIMAFIMMFEOgBGkEBIcQFQQEhxQUgxAUgxQVxIcYFIAcgxgU6AM8LCyAHLQDPCyHHBUEBIcgFIMcFIMgFcSHJBUHQCyHKBSAHIMoFaiHLBSDLBSQAIMkFDwuxSgL5BX/GAX4jACEGQeAJIQcgBiAHayEIIAgkACAIIAA2AtgJIAggATYC1AkgCCACNgLQCSAIIAM2AswJIAQhCSAIIAk6AMsJIAUhCiAIIAo6AMoJIAgoAtgJIQsgCC0AywkhDEEBIQ0gDCANcSEOAkACQCAODQAgCCgC0AkhDyAIKALMCSEQIA8gEBDkCCERQQEhEiARIBJxIRMgEw0AQQAhFEEBIRUgFCAVcSEWIAggFjoA3wkMAQtBuAkhFyAIIBdqIRggGCEZIBkQ7ggaQagJIRogCCAaaiEbIBshHCAcEO4IGiAIKALQCSEdIAgoAtAJIR5BCCEfIB4gH2ohIEG4CSEhIAggIWohIiAiISMgIyAdICAQ7wgaIAgoAswJISQgCCgCzAkhJUEIISYgJSAmaiEnQagJISggCCAoaiEpICkhKiAqICQgJxDvCBpBuAkhKyAIICtqISwgLCEtQagJIS4gCCAuaiEvIC8hMEEBITFBASEyIDEgMnEhMyAtIDAgMxCOCSE0QQEhNSA0IDVxITYCQCA2DQBBACE3QQEhOCA3IDhxITkgCCA5OgDfCQwBCyAIKALQCSE6IDoQrwMhO0EBITwgOyA8cSE9AkAgPUUNACAIKALMCSE+ID4QrwMhP0EBIUAgPyBAcSFBAkAgQUUNAEEAIUJBASFDIEIgQ3EhRCAIIEQ6AN8JDAILIAgoAtAJIUVBACFGQaAJIUcgCCBHaiFIIEggRhAPGkGgCSFJIAggSWohSiBFIEoQLyFLIAgoAswJIUxBmAkhTSAIIE1qIU4gTiBMEOIBGiAIKALMCSFPQQghUCBPIFBqIVFBkAkhUiAIIFJqIVMgUyBREOIBGkEQIVQgCCBUaiFVQZgJIVYgCCBWaiFXQZAJIVggCCBYaiFZIFUgSyBXIFkQmQkgCCkDECH/BSAIKQMYIYAGIAsgUGohWiBaIIAGNwMAIAsg/wU3AwAgCxCaCSFbIAggWzYCjAkgWikDACGBBiALKQMAIYIGIAgoAowJIVwgCCBcELEaIAggUGohXSBdKQMAIYMGIAgpAwAhhAYgggYggQYghAYggwYQpRohXiBeIEZIIV9BASFgIF8gYHEhYQJAIGFFDQAgCCgCjAkhYkF/IWMgYiBjaiFkIAggZDYCjAkLQfgIIWUgCCBlaiFmIGYhZ0EBIWggZyBoEA8aQYAJIWkgCCBpaiFqIGoha0G4CSFsIAggbGohbSBtIW5B+AghbyAIIG9qIXAgcCFxIGsgbiBxEI8JIAgoAowJIXJBgAkhcyAIIHNqIXQgdCF1QQEhdkEBIXcgdiB3cSF4IHUgciB4EJMJIXlBASF6IHkgenEhewJAIHtFDQAgCCgC0AkhfEHoCCF9IAggfWohfiB+IX9BACGAASB/IIABEA8aQegIIYEBIAgggQFqIYIBIIIBIYMBIHwggwEQLyGEASAIKAKMCSGFAUHwCCGGASAIIIYBaiGHASCHASGIASCIASCEASCFARAcGiAIKALUCSGJAUHwCCGKASAIIIoBaiGLASCLASGMASCJASCMARDoARpBASGNAUEBIY4BII0BII4BcSGPASAIII8BOgDfCQwCC0EAIZABQQEhkQEgkAEgkQFxIZIBIAggkgE6AN8JDAELIAgoAswJIZMBIJMBEK8DIZQBQQEhlQEglAEglQFxIZYBAkAglgFFDQAgCCgCzAkhlwFBACGYAUHgCCGZASAIIJkBaiGaASCaASCYARAPGkHgCCGbASAIIJsBaiGcASCXASCcARAvIZ0BIAgoAtAJIZ4BQdgIIZ8BIAggnwFqIaABIKABIJ4BEOIBGiAIKALQCSGhAUEIIaIBIKEBIKIBaiGjAUHQCCGkASAIIKQBaiGlASClASCjARDiARpBMCGmASAIIKYBaiGnAUHYCCGoASAIIKgBaiGpAUHQCCGqASAIIKoBaiGrASCnASCdASCpASCrARCZCSAIKQMwIYUGIAgpAzghhgYgCyCiAWohrAEgrAEghgY3AwAgCyCFBjcDACALEJoJIa0BIAggrQE2AswIIKwBKQMAIYcGIAspAwAhiAYgCCgCzAghrgFBICGvASAIIK8BaiGwASCwASCuARCxGkEgIbEBIAggsQFqIbIBILIBIKIBaiGzASCzASkDACGJBiAIKQMgIYoGIIgGIIcGIIoGIIkGEKUaIbQBILQBIJgBSCG1AUEBIbYBILUBILYBcSG3AQJAILcBRQ0AIAgoAswIIbgBQX8huQEguAEguQFqIboBIAggugE2AswIC0G4CCG7ASAIILsBaiG8ASC8ASG9AUEBIb4BIL0BIL4BEA8aQcAIIb8BIAggvwFqIcABIMABIcEBQagJIcIBIAggwgFqIcMBIMMBIcQBQbgIIcUBIAggxQFqIcYBIMYBIccBIMEBIMQBIMcBEI8JIAgoAswIIcgBQcAIIckBIAggyQFqIcoBIMoBIcsBQQEhzAFBASHNASDMASDNAXEhzgEgywEgyAEgzgEQkwkhzwFBASHQASDPASDQAXEh0QECQCDRAUUNACAIKALMCSHSAUGoCCHTASAIINMBaiHUASDUASHVAUEAIdYBINUBINYBEA8aQagIIdcBIAgg1wFqIdgBINgBIdkBINIBINkBEC8h2gEgCCgCzAgh2wFBsAgh3AEgCCDcAWoh3QEg3QEh3gEg3gEg2gEg2wEQHBogCCgC1Akh3wFBsAgh4AEgCCDgAWoh4QEg4QEh4gEg3wEg4gEQ6AEaQQEh4wFBASHkASDjASDkAXEh5QEgCCDlAToA3wkMAgtBACHmAUEBIecBIOYBIOcBcSHoASAIIOgBOgDfCQwBCyAIKALMCSHpAUEIIeoBIOkBIOoBaiHrAUEBIewBQaAIIe0BIAgg7QFqIe4BIO4BIOwBEA8aQaAIIe8BIAgg7wFqIfABIOsBIPABEC8h8QFB8AYh8gEgCCDyAWoh8wEg8wEg8QEQsRpB8AYh9AEgCCD0AWoh9QEg9QEg6gFqIfYBIPYBKQMAIYsGIAgpA/AGIYwGIAgoAswJIfcBQZgIIfgBIAgg+AFqIfkBIPkBIOwBEA8aQZgIIfoBIAgg+gFqIfsBIPcBIPsBEC8h/AFB4AYh/QEgCCD9AWoh/gEg/gEg/AEQsRpB4AYh/wEgCCD/AWohgAIggAIg6gFqIYECIIECKQMAIY0GIAgpA+AGIY4GQdAGIYICIAggggJqIYMCIIMCIIwGIIsGII4GII0GELAaQdAGIYQCIAgghAJqIYUCIIUCIOoBaiGGAiCGAikDACGPBiAIKQPQBiGQBkHIACGHAiALIIcCaiGIAiCIAiCPBjcDACALIJAGNwNAIAgoAtAJIYkCIIkCIOoBaiGKAkGQCCGLAiAIIIsCaiGMAiCMAiDsARAPGkGQCCGNAiAIII0CaiGOAiCKAiCOAhAvIY8CQcAGIZACIAggkAJqIZECIJECII8CELEaQcAGIZICIAggkgJqIZMCIJMCIOoBaiGUAiCUAikDACGRBiAIKQPABiGSBiAIKALQCSGVAkGICCGWAiAIIJYCaiGXAiCXAiDsARAPGkGICCGYAiAIIJgCaiGZAiCVAiCZAhAvIZoCQbAGIZsCIAggmwJqIZwCIJwCIJoCELEaQbAGIZ0CIAggnQJqIZ4CIJ4CIOoBaiGfAiCfAikDACGTBiAIKQOwBiGUBkGgBiGgAiAIIKACaiGhAiChAiCSBiCRBiCUBiCTBhCwGkGgBiGiAiAIIKICaiGjAiCjAiDqAWohpAIgpAIpAwAhlQYgCCkDoAYhlgZBKCGlAiALIKUCaiGmAiCmAiCVBjcDACALIJYGNwMgIAgoAswJIacCIKcCIOoBaiGoAkEAIakCQYAIIaoCIAggqgJqIasCIKsCIKkCEA8aQYAIIawCIAggrAJqIa0CIKgCIK0CEC8hrgJBkAYhrwIgCCCvAmohsAIgsAIgrgIQsRpBkAYhsQIgCCCxAmohsgIgsgIg6gFqIbMCILMCKQMAIZcGIAgpA5AGIZgGIAgoAswJIbQCQfgHIbUCIAggtQJqIbYCILYCIKkCEA8aQfgHIbcCIAggtwJqIbgCILQCILgCEC8huQJBgAYhugIgCCC6AmohuwIguwIguQIQsRpBgAYhvAIgCCC8AmohvQIgvQIg6gFqIb4CIL4CKQMAIZkGIAgpA4AGIZoGQfAFIb8CIAggvwJqIcACIMACIJgGIJcGIJoGIJkGELAaQfAFIcECIAggwQJqIcICIMICIOoBaiHDAiDDAikDACGbBiAIKQPwBSGcBkE4IcQCIAsgxAJqIcUCIMUCIJsGNwMAIAsgnAY3AzAgCCgC0AkhxgIgxgIg6gFqIccCQfAHIcgCIAggyAJqIckCIMkCIKkCEA8aQfAHIcoCIAggygJqIcsCIMcCIMsCEC8hzAJB4AUhzQIgCCDNAmohzgIgzgIgzAIQsRpB4AUhzwIgCCDPAmoh0AIg0AIg6gFqIdECINECKQMAIZ0GIAgpA+AFIZ4GIAgoAtAJIdICQegHIdMCIAgg0wJqIdQCINQCIKkCEA8aQegHIdUCIAgg1QJqIdYCINICINYCEC8h1wJB0AUh2AIgCCDYAmoh2QIg2QIg1wIQsRpB0AUh2gIgCCDaAmoh2wIg2wIg6gFqIdwCINwCKQMAIZ8GIAgpA9AFIaAGQcAFId0CIAgg3QJqId4CIN4CIJ4GIJ0GIKAGIJ8GELAaQcAFId8CIAgg3wJqIeACIOACIOoBaiHhAiDhAikDACGhBiAIKQPABSGiBkEYIeICIAsg4gJqIeMCIOMCIKEGNwMAIAsgogY3AxBBECHkAiALIOQCaiHlAkEgIeYCIAsg5gJqIecCQTAh6AIgCyDoAmoh6QJBwAAh6gIgCyDqAmoh6wIg5QIg5wIg6QIg6wIQlAkh7AJBASHtAiDsAiDtAnEh7gICQCDuAkUNAEEAIe8CQQEh8AIg7wIg8AJxIfECIAgg8QI6AN8JDAELIAgoAtAJIfICQQAh8wJB4Ach9AIgCCD0Amoh9QIg9QIg8wIQDxpB4Ach9gIgCCD2Amoh9wIg8gIg9wIQLyH4AkGwBSH5AiAIIPkCaiH6AiD6AiD4AhCxGkEIIfsCQbAFIfwCIAgg/AJqIf0CIP0CIPsCaiH+AiD+AikDACGjBiAIKQOwBSGkBkHYACH/AiALIP8CaiGAAyCAAyCjBjcDACALIKQGNwNQIAgoAswJIYEDQdgHIYIDIAggggNqIYMDIIMDIPMCEA8aQdgHIYQDIAgghANqIYUDIIEDIIUDEC8hhgNBoAUhhwMgCCCHA2ohiAMgiAMghgMQsRpBoAUhiQMgCCCJA2ohigMgigMg+wJqIYsDIIsDKQMAIaUGIAgpA6AFIaYGQegAIYwDIAsgjANqIY0DII0DIKUGNwMAIAsgpgY3A2AgCCgC0AkhjgNBASGPA0HQByGQAyAIIJADaiGRAyCRAyCPAxAPGkHQByGSAyAIIJIDaiGTAyCOAyCTAxAvIZQDQZAFIZUDIAgglQNqIZYDIJYDIJQDELEaQZAFIZcDIAgglwNqIZgDIJgDIPsCaiGZAyCZAykDACGnBiAIKQOQBSGoBkH4ACGaAyALIJoDaiGbAyCbAyCnBjcDACALIKgGNwNwIAgoAswJIZwDQcgHIZ0DIAggnQNqIZ4DIJ4DII8DEA8aQcgHIZ8DIAggnwNqIaADIJwDIKADEC8hoQNBgAUhogMgCCCiA2ohowMgowMgoQMQsRpBgAUhpAMgCCCkA2ohpQMgpQMg+wJqIaYDIKYDKQMAIakGIAgpA4AFIaoGQYgBIacDIAsgpwNqIagDIKgDIKkGNwMAIAsgqgY3A4ABIIADKQMAIasGIAspA1AhrAZBKCGpAyALIKkDaiGqAyCqAykDACGtBiALKQMgIa4GQfAEIasDIAggqwNqIawDIKwDIKwGIKsGIK4GIK0GEK8aQfAEIa0DIAggrQNqIa4DIK4DIPsCaiGvAyCvAykDACGvBiAIKQPwBCGwBkE4IbADIAsgsANqIbEDILEDKQMAIbEGIAspAzAhsgZB4AQhsgMgCCCyA2ohswMgswMgsAYgrwYgsgYgsQYQrxpB4AQhtAMgCCC0A2ohtQMgtQMg+wJqIbYDILYDKQMAIbMGIAgpA+AEIbQGII0DKQMAIbUGIAspA2AhtgZByAAhtwMgCyC3A2ohuAMguAMpAwAhtwYgCykDQCG4BkHQBCG5AyAIILkDaiG6AyC6AyC2BiC1BiC4BiC3BhCvGkHQBCG7AyAIILsDaiG8AyC8AyD7AmohvQMgvQMpAwAhuQYgCCkD0AQhugZBGCG+AyALIL4DaiG/AyC/AykDACG7BiALKQMQIbwGQcAEIcADIAggwANqIcEDIMEDILoGILkGILwGILsGEK8aQcAEIcIDIAggwgNqIcMDIMMDIPsCaiHEAyDEAykDACG9BiAIKQPABCG+BkGwBCHFAyAIIMUDaiHGAyDGAyC0BiCzBiC+BiC9BhCwGkGwBCHHAyAIIMcDaiHIAyDIAyD7AmohyQMgyQMpAwAhvwYgCCkDsAQhwAYgqAMpAwAhwQYgCykDgAEhwgZBoAQhygMgCCDKA2ohywMgywMgwgYgwQYgvAYguwYQrxpBoAQhzAMgCCDMA2ohzQMgzQMg+wJqIc4DIM4DKQMAIcMGIAgpA6AEIcQGQZAEIc8DIAggzwNqIdADINADIMQGIMMGILIGILEGEK8aQZAEIdEDIAgg0QNqIdIDINIDIPsCaiHTAyDTAykDACHFBiAIKQOQBCHGBkGABCHUAyAIINQDaiHVAyDVAyDABiC/BiDGBiDFBhCrGkGABCHWAyAIINYDaiHXAyDXAyD7Amoh2AMg2AMpAwAhxwYgCCkDgAQhyAYgmwMpAwAhyQYgCykDcCHKBkHwAyHZAyAIINkDaiHaAyDaAyDKBiDJBiC8BiC7BhCvGkHwAyHbAyAIINsDaiHcAyDcAyD7Amoh3QMg3QMpAwAhywYgCCkD8AMhzAZB4AMh3gMgCCDeA2oh3wMg3wMgzAYgywYgsgYgsQYQrxpB4AMh4AMgCCDgA2oh4QMg4QMg+wJqIeIDIOIDKQMAIc0GIAgpA+ADIc4GQdADIeMDIAgg4wNqIeQDIOQDIMgGIMcGIM4GIM0GELAaQdADIeUDIAgg5QNqIeYDIOYDIPsCaiHnAyDnAykDACHPBiAIKQPQAyHQBkGYASHoAyALIOgDaiHpAyDpAyDPBjcDACALINAGNwOQASCqAykDACHRBiALKQMgIdIGILEDKQMAIdMGIAspAzAh1AZBwAMh6gMgCCDqA2oh6wMg6wMg0gYg0QYg1AYg0wYQrxpBwAMh7AMgCCDsA2oh7QMg7QMg+wJqIe4DIO4DKQMAIdUGIAgpA8ADIdYGILgDKQMAIdcGIAspA0Ah2AYgvwMpAwAh2QYgCykDECHaBkGwAyHvAyAIIO8DaiHwAyDwAyDYBiDXBiDaBiDZBhCvGkGwAyHxAyAIIPEDaiHyAyDyAyD7Amoh8wMg8wMpAwAh2wYgCCkDsAMh3AZBoAMh9AMgCCD0A2oh9QMg9QMg1gYg1QYg3AYg2wYQsBpBoAMh9gMgCCD2A2oh9wMg9wMg+wJqIfgDIPgDKQMAId0GIAgpA6ADId4GQbgBIfkDIAsg+QNqIfoDIPoDIN0GNwMAIAsg3gY3A7ABIJsDKQMAId8GIAspA3Ah4AYgvwMpAwAh4QYgCykDECHiBkGQAyH7AyAIIPsDaiH8AyD8AyDgBiDfBiDiBiDhBhCvGkGQAyH9AyAIIP0DaiH+AyD+AyD7Amoh/wMg/wMpAwAh4wYgCCkDkAMh5AYguAMpAwAh5QYgCykDQCHmBkGAAyGABCAIIIAEaiGBBCCBBCDkBiDjBiDmBiDlBhCvGkGAAyGCBCAIIIIEaiGDBCCDBCD7AmohhAQghAQpAwAh5wYgCCkDgAMh6AYgqAMpAwAh6QYgCykDgAEh6gYgsQMpAwAh6wYgCykDMCHsBkHwAiGFBCAIIIUEaiGGBCCGBCDqBiDpBiDsBiDrBhCvGkHwAiGHBCAIIIcEaiGIBCCIBCD7AmohiQQgiQQpAwAh7QYgCCkD8AIh7gYgqgMpAwAh7wYgCykDICHwBkHgAiGKBCAIIIoEaiGLBCCLBCDuBiDtBiDwBiDvBhCvGkHgAiGMBCAIIIwEaiGNBCCNBCD7AmohjgQgjgQpAwAh8QYgCCkD4AIh8gZB0AIhjwQgCCCPBGohkAQgkAQg6AYg5wYg8gYg8QYQsBpB0AIhkQQgCCCRBGohkgQgkgQg+wJqIZMEIJMEKQMAIfMGIAgpA9ACIfQGII0DKQMAIfUGIAspA2Ah9gZBwAIhlAQgCCCUBGohlQQglQQg9gYg9QYg8AYg7wYQrxpBwAIhlgQgCCCWBGohlwQglwQg+wJqIZgEIJgEKQMAIfcGIAgpA8ACIfgGQbACIZkEIAggmQRqIZoEIJoEIPgGIPcGIOYGIOUGEK8aQbACIZsEIAggmwRqIZwEIJwEIPsCaiGdBCCdBCkDACH5BiAIKQOwAiH6BkGgAiGeBCAIIJ4EaiGfBCCfBCD0BiDzBiD6BiD5BhCrGkGgAiGgBCAIIKAEaiGhBCChBCD7AmohogQgogQpAwAh+wYgCCkDoAIh/AYggAMpAwAh/QYgCykDUCH+BkGQAiGjBCAIIKMEaiGkBCCkBCD+BiD9BiDwBiDvBhCvGkGQAiGlBCAIIKUEaiGmBCCmBCD7AmohpwQgpwQpAwAh/wYgCCkDkAIhgAdBgAIhqAQgCCCoBGohqQQgqQQggAcg/wYg5gYg5QYQrxpBgAIhqgQgCCCqBGohqwQgqwQg+wJqIawEIKwEKQMAIYEHIAgpA4ACIYIHQfABIa0EIAggrQRqIa4EIK4EIPwGIPsGIIIHIIEHELAaQfABIa8EIAggrwRqIbAEILAEIPsCaiGxBCCxBCkDACGDByAIKQPwASGEB0GoASGyBCALILIEaiGzBCCzBCCDBzcDACALIIQHNwOgASC/AykDACGFByALKQMQIYYHILgDKQMAIYcHIAspA0AhiAdB4AEhtAQgCCC0BGohtQQgtQQghgcghQcgiAcghwcQrxpB4AEhtgQgCCC2BGohtwQgtwQg+wJqIbgEILgEKQMAIYkHIAgpA+ABIYoHILEDKQMAIYsHIAspAzAhjAcgqgMpAwAhjQcgCykDICGOB0HQASG5BCAIILkEaiG6BCC6BCCMByCLByCOByCNBxCvGkHQASG7BCAIILsEaiG8BCC8BCD7AmohvQQgvQQpAwAhjwcgCCkD0AEhkAdBwAEhvgQgCCC+BGohvwQgvwQgigcgiQcgkAcgjwcQsBpBwAEhwAQgCCDABGohwQQgwQQg+wJqIcIEIMIEKQMAIZEHIAgpA8ABIZIHQcgBIcMEIAsgwwRqIcQEIMQEIJEHNwMAIAsgkgc3A8ABIOkDKQMAIZMHIAspA5ABIZQHIPoDKQMAIZUHIAspA7ABIZYHQbABIcUEIAggxQRqIcYEIMYEIJQHIJMHIJYHIJUHELMaQbABIccEIAggxwRqIcgEIMgEIPsCaiHJBCDJBCkDACGXByAIKQOwASGYB0HYASHKBCALIMoEaiHLBCDLBCCXBzcDACALIJgHNwPQASCzBCkDACGZByALKQOgASGaByDEBCkDACGbByALKQPAASGcB0GgASHMBCAIIMwEaiHNBCDNBCCaByCZByCcByCbBxCzGkGgASHOBCAIIM4EaiHPBCDPBCD7Amoh0AQg0AQpAwAhnQcgCCkDoAEhngdB6AEh0QQgCyDRBGoh0gQg0gQgnQc3AwAgCyCeBzcD4AEgCC0Aygkh0wRBASHUBCDTBCDUBHEh1QQCQCDVBEUNAEHYASHWBCALINYEaiHXBCDXBCkDACGfByALKQPQASGgB0KAgICAgICA/z8hoQdCACGiB0GQASHYBCAIINgEaiHZBCDZBCCgByCfByCiByChBxCrGkEIIdoEQZABIdsEIAgg2wRqIdwEINwEINoEaiHdBCDdBCkDACGjByAIKQOQASGkByDXBCCjBzcDACALIKQHNwPQAUHoASHeBCALIN4EaiHfBCDfBCkDACGlByALKQPgASGmB0GAASHgBCAIIOAEaiHhBCDhBCCmByClByCiByChBxCrGkGAASHiBCAIIOIEaiHjBCDjBCDaBGoh5AQg5AQpAwAhpwcgCCkDgAEhqAcg3wQgpwc3AwAgCyCoBzcD4AELQdABIeUEIAsg5QRqIeYEIOYEEJoJIecEIAgg5wQ2AsQHQeABIegEIAsg6ARqIekEIOkEEJoJIeoEIAgg6gQ2AsAHQdgBIesEIAsg6wRqIewEIOwEKQMAIakHIAspA9ABIaoHIAgoAsQHIe0EQfAAIe4EIAgg7gRqIe8EIO8EIO0EELEaQfgAIfAEIAgg8ARqIfEEIPEEKQMAIasHIAgpA3AhrAcgqgcgqQcgrAcgqwcQpRoh8gRBACHzBCDyBCDzBEgh9ARBASH1BCD0BCD1BHEh9gQCQCD2BEUNACAIKALEByH3BEF/IfgEIPcEIPgEaiH5BCAIIPkENgLEBwtB6AEh+gQgCyD6BGoh+wQg+wQpAwAhrQcgCykD4AEhrgcgCCgCwAch/ARB4AAh/QQgCCD9BGoh/gQg/gQg/AQQsRpB6AAh/wQgCCD/BGohgAUggAUpAwAhrwcgCCkDYCGwByCuByCtByCwByCvBxClGiGBBUEAIYIFIIEFIIIFSCGDBUEBIYQFIIMFIIQFcSGFBQJAIIUFRQ0AIAgoAsAHIYYFQX8hhwUghgUghwVqIYgFIAggiAU2AsAHCyAIKALQCSGJBSCJBRDxCCGKBUEBIYsFIIoFIIsFcSGMBQJAIIwFRQ0AIAgoAtAJIY0FII0FEK8CIY4FIAggjgU2AsAHCyAIKALMCSGPBSCPBRDxCCGQBUEBIZEFIJAFIJEFcSGSBQJAIJIFRQ0AIAgoAswJIZMFIJMFEK8CIZQFIAgglAU2AsAHCyAIKALEByGVBSAIKALAByGWBUG4ByGXBSAIIJcFaiGYBSCYBSGZBSCZBSCVBSCWBRAcGkGwByGaBSAIIJoFaiGbBSCbBSGcBUG4ByGdBSAIIJ0FaiGeBSCeBSGfBSCcBSCfBRDiARpBuAkhoAUgCCCgBWohoQUgoQUhogVBsAchowUgCCCjBWohpAUgpAUhpQVBASGmBUEBIacFIKYFIKcFcSGoBSCiBSClBSCoBRDwCCGpBUEBIaoFIKkFIKoFcSGrBQJAIKsFDQBBACGsBUEBIa0FIKwFIK0FcSGuBSAIIK4FOgDfCQwBC0GoByGvBSAIIK8FaiGwBSCwBSGxBUG4ByGyBSAIILIFaiGzBSCzBSG0BSCxBSC0BRDiARpBqAkhtQUgCCC1BWohtgUgtgUhtwVBqAchuAUgCCC4BWohuQUguQUhugVBASG7BUEBIbwFILsFILwFcSG9BSC3BSC6BSC9BRDwCCG+BUEBIb8FIL4FIL8FcSHABQJAIMAFDQBBACHBBUEBIcIFIMEFIMIFcSHDBSAIIMMFOgDfCQwBCyAILQDLCSHEBUEBIcUFIMQFIMUFcSHGBQJAIMYFRQ0AEKwGIccFQdAAIcgFIAggyAVqIckFIMkFIMcFELEaQQghygVB0AAhywUgCCDLBWohzAUgzAUgygVqIc0FIM0FKQMAIbEHIAgpA1AhsgcgCCCxBzcDmAcgCCCyBzcDkAcQowIhzgVBwAAhzwUgCCDPBWoh0AUg0AUgzgUQsRpBwAAh0QUgCCDRBWoh0gUg0gUgygVqIdMFINMFKQMAIbMHIAgpA0AhtAcgCCCzBzcDiAcgCCC0BzcDgAdB2AEh1AUgCyDUBWoh1QUg1QUpAwAhtQcgCykD0AEhtgcgCCkDiAchtwcgCCkDgAchuAcgtgcgtQcguAcgtwcQphoh1gVBACHXBSDWBSDXBUoh2AVBASHZBSDYBSDZBXEh2gUCQAJAINoFDQBB6AEh2wUgCyDbBWoh3AUg3AUpAwAhuQcgCykD4AEhugcgCCkDiAchuwcgCCkDgAchvAcgugcguQcgvAcguwcQphoh3QVBACHeBSDdBSDeBUoh3wVBASHgBSDfBSDgBXEh4QUg4QUNAEHYASHiBSALIOIFaiHjBSDjBSkDACG9ByALKQPQASG+ByAIKQOYByG/ByAIKQOQByHAByC+ByC9ByDAByC/BxClGiHkBUEAIeUFIOQFIOUFSCHmBUEBIecFIOYFIOcFcSHoBSDoBQ0AQegBIekFIAsg6QVqIeoFIOoFKQMAIcEHIAspA+ABIcIHIAgpA5gHIcMHIAgpA5AHIcQHIMIHIMEHIMQHIMMHEKUaIesFQQAh7AUg6wUg7AVIIe0FQQEh7gUg7QUg7gVxIe8FIO8FRQ0BC0EAIfAFQQEh8QUg8AUg8QVxIfIFIAgg8gU6AN8JDAILCyAIKALUCSHzBUG4ByH0BSAIIPQFaiH1BSD1BSH2BSDzBSD2BRDoARpBASH3BUEBIfgFIPcFIPgFcSH5BSAIIPkFOgDfCQsgCC0A3wkh+gVBASH7BSD6BSD7BXEh/AVB4Akh/QUgCCD9BWoh/gUg/gUkACD8BQ8LXAEJfyMAIQNBECEEIAMgBGshBSAFJAAgBSABNgIMIAUgAjYCCCAFKAIMIQYgBSgCCCEHIAcQzwkhCCAFKAIIIQkgACAGIAggCRDQCUEQIQogBSAKaiELIAskAA8LnwEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGENEJIQcgBCEIIAcoAgAhCSAIIAk2AgAgBCgCACEKIAUgChDgCBogBCgCCCELQQQhDCALIAxqIQ0gDRDSCSEOIA4tAAAhD0EBIRAgDyAQcSERIAUgEToABEEQIRIgBCASaiETIBMkACAFDwuXAQETfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIYIAQgATYCEEEIIQUgBCAFaiEGIAYhB0EYIQggBCAIaiEJIAkhCiAKKAIAIQsgByALNgIAIAQhDEEQIQ0gBCANaiEOIA4hDyAPKAIAIRAgDCAQNgIAIAQoAgghESAEKAIAIRIgESASEIYKQSAhEyAEIBNqIRQgFCQADwvYBAFWfyMAIQJBwAAhAyACIANrIQQgBCQAIAQgADYCMCAEIAE2AihBECEFIAQgBWohBiAGIQdBMCEIIAQgCGohCSAJIQogCigCACELIAcgCzYCAEEIIQwgBCAMaiENIA0hDkEoIQ8gBCAPaiEQIBAhESARKAIAIRIgDiASNgIAIAQoAhAhEyAEKAIIIRRBICEVIAQgFWohFiAWIRcgEyAUIBcQkAohGCAEIBg2AhhBMCEZIAQgGWohGiAaIRtBGCEcIAQgHGohHSAdIR4gHigCACEfIBsgHzYCAEEwISAgBCAgaiEhICEhIkEoISMgBCAjaiEkICQhJSAiICUQvgYhJkEBIScgJiAncSEoAkAgKEUNACAEISlBMCEqIAQgKmohKyArISwgLCgCACEtICkgLTYCACAEIS4gLhDABhoCQANAIAQhLyAvEMAGITBBKCExIAQgMWohMiAyITMgMCAzEL4GITRBASE1IDQgNXEhNiA2RQ0BQTAhNyAEIDdqITggOCE5IDkQvwYhOiAEITsgOxC/BiE8QSAhPSAEID1qIT4gPiE/ID8gOiA8EJEKIUBBASFBIEAgQXEhQgJAIEINACAEIUMgQxC/BiFEIEQQKCFFQTAhRiAEIEZqIUcgRyFIIEgQwAYhSSBJEL8GIUogSiBFEOgBGgsMAAsAC0EwIUsgBCBLaiFMIEwhTSBNEMAGGgtBOCFOIAQgTmohTyBPIVBBMCFRIAQgUWohUiBSIVMgUygCACFUIFAgVDYCACAEKAI4IVVBwAAhViAEIFZqIVcgVyQAIFUPC5EBARF/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgAhBSAEKAIEIQZBCCEHIAQgB2ohCCAIIQkgCSAFIAYQigohCkEBIQsgCiALcSEMAkACQCAMRQ0AIAQoAgAhDSANIQ4MAQsgBCgCBCEPIA8hDgsgDiEQQRAhESAEIBFqIRIgEiQAIBAPC5EBARF/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgQhBSAEKAIAIQZBCCEHIAQgB2ohCCAIIQkgCSAFIAYQigohCkEBIQsgCiALcSEMAkACQCAMRQ0AIAQoAgAhDSANIQ4MAQsgBCgCBCEPIA8hDgsgDiEQQRAhESAEIBFqIRIgEiQAIBAPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ1wIhBiAEKAIIIQcgBxDXAiEIIAYhCSAIIQogCSAKRiELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LjwEBEn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCCCADKAIIIQQgAyAENgIMQRAhBSAEIAVqIQYgBCEHA0AgByEIIAgQmwkaQQghCSAIIAlqIQogCiELIAYhDCALIAxGIQ1BASEOIA0gDnEhDyAKIQcgD0UNAAsgAygCDCEQQRAhESADIBFqIRIgEiQAIBAPC4UCARx/IwAhA0EwIQQgAyAEayEFIAUkACAFIAA2AiwgBSABNgIoIAUgAjYCJCAFKAIoIQYgBhANIQcgBSAHNgIgIAUoAiQhCCAIEA0hCSAFIAk2AhwgBSgCKCEKIAoQDiELIAUgCzYCGCAFKAIkIQwgDBAOIQ0gBSANNgIUIAUoAiwhDiAFKAIgIQ8gBSgCHCEQQQghESAFIBFqIRIgEiETIBMgDyAQEJwJQQghFCAFIBRqIRUgFSEWIA4gFhCdCSAFKAIsIRcgBSgCGCEYIAUoAhQhGSAFIRogGiAYIBkQnAkgBSEbIBcgGxCeCSAFKAIsIRxBMCEdIAUgHWohHiAeJAAgHA8LhwIBJX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCHCACIQYgBSAGOgAbIAUoAhwhB0EQIQggBSAIaiEJIAkhCiAKIAcQnwkgARANIQsgBS0AGyEMQRAhDSAFIA1qIQ4gDiEPQQEhECAMIBBxIREgDyALIBEQkwkhEkEAIRNBASEUIBIgFHEhFSATIRYCQCAVRQ0AIAUoAhwhF0EIIRggBSAYaiEZIBkhGiAaIBcQoAkgARAOIRsgBS0AGyEcQQghHSAFIB1qIR4gHiEfQQEhICAcICBxISEgHyAbICEQkwkhIiAiIRYLIBYhI0EBISQgIyAkcSElQSAhJiAFICZqIScgJyQAICUPC68BARp/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSADIAVqIQYgBiEHQQEhCCAHIAgQDxpBCCEJIAMgCWohCiAKIQsgBCALEC8hDCADKAIMIQ1BCCEOIA0gDmohDyADIRBBASERIBAgERAPGiADIRIgDyASEC8hEyAMIRQgEyEVIBQgFUYhFkEBIRcgFiAXcSEYQRAhGSADIBlqIRogGiQAIBgPC7EEAj5/EH4jACEEQeAAIQUgBCAFayEGIAYkACAGIAA2AlwgBiABNgJYIAYgAjYCVCAGIAM2AlAgBigCVCEHIAYgBzYCSCAGKAJQIQggBiAINgJMIAYoAkwhCUE4IQogBiAKaiELIAshDEEBIQ0gDCANEA8aQTghDiAGIA5qIQ8gDyEQIAkgEBAvIREgESESIBKsIUIgBigCWCETIBMoAgAhFCAUIRUgFawhQyBCIEN9IUQgBiBENwNAIAYoAkghFkEoIRcgBiAXaiEYIBghGUEBIRogGSAaEA8aQSghGyAGIBtqIRwgHCEdIBYgHRAvIR4gHiEfIB+sIUUgBigCWCEgICAoAgAhISAhISIgIqwhRiBFIEZ9IUcgBiBHNwMwIAYoAkwhI0EYISQgBiAkaiElICUhJkEAIScgJiAnEA8aQRghKCAGIChqISkgKSEqICMgKhAvISsgKyEsICysIUggBigCXCEtIC0oAgAhLiAuIS8gL6whSSBIIEl9IUogBiBKNwMgIAYoAkghMEEIITEgBiAxaiEyIDIhM0EAITQgMyA0EA8aQQghNSAGIDVqITYgNiE3IDAgNxAvITggOCE5IDmsIUsgBigCXCE6IDooAgAhOyA7ITwgPKwhTCBLIEx9IU0gBiBNNwMQIAYpAxAhTiAGKQMwIU8gBikDICFQIAYpA0AhUSBOIE8gUCBREKEJIT1BASE+ID0gPnEhP0HgACFAIAYgQGohQSBBJAAgPw8L1AIBL38jACEDQRAhBCADIARrIQUgBSQAQQghBiAFIAZqIQcgByEIIAgQrAMaQQghCSAFIAlqIQogCiELIAsgASACEK4DIQxBASENIAwgDXEhDgJAAkAgDkUNAEEIIQ8gBSAPaiEQIBAhESARIAAgAhCuAyESQQAhE0EBIRQgEiAUcSEVIBMhFgJAIBVFDQBBCCEXIAUgF2ohGCAYIRkgGSABIAAQrgMhGiAaIRYLIBYhG0EBIRwgGyAccSEdIAUgHToADwwBC0EIIR4gBSAeaiEfIB8hICAgIAAgARCuAyEhQQAhIkEBISMgISAjcSEkICIhJQJAICRFDQBBCCEmIAUgJmohJyAnISggKCACIAAQrgMhKSApISULICUhKkEBISsgKiArcSEsIAUgLDoADwsgBS0ADyEtQQEhLiAtIC5xIS9BECEwIAUgMGohMSAxJAAgLw8LfAEMfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHELECIQggBiAIEKkBGkEIIQkgBiAJaiEKIAUoAgQhCyALELECIQwgCiAMEKkBGkEQIQ0gBSANaiEOIA4kACAGDwuNBwF7fyMAIQJB0AAhAyACIANrIQQgBCQAIAQgATYCSCAEKAJIIQUgACAFEOQBIQZBASEHIAYgB3EhCAJAAkACQCAIDQAgBCgCSCEJQQghCiAJIApqIQsgACALEOQBIQxBASENIAwgDXEhDiAORQ0BC0EAIQ8gBCAPNgJMDAELQcAAIRAgBCAQaiERIBEhEkEAIRMgEiATEA8aQcAAIRQgBCAUaiEVIBUhFiAAIBYQLyEXIAQgFzYCREE4IRggBCAYaiEZIBkhGkEBIRsgGiAbEA8aQTghHCAEIBxqIR0gHSEeIAAgHhAvIR8gBCAfNgI8IAQoAkghICAEKAJIISFBCCEiICEgImohI0HEACEkIAQgJGohJSAlISZBPCEnIAQgJ2ohKCAoISkgJiApICAgIxDyCCEqQQEhKyAqICtxISwCQCAsRQ0AQQAhLSAEIC02AkwMAQtBKCEuIAQgLmohLyAvITBBACExIDAgMRAPGkEoITIgBCAyaiEzIDMhNCAAIDQQLyE1IAQgNTYCMEEgITYgBCA2aiE3IDchOEEBITkgOCA5EA8aQSAhOiAEIDpqITsgOyE8IAAgPBAvIT0gBCA9NgIkIAQoAkghPiAEKAJIIT9BCCFAID8gQGohQUEwIUIgBCBCaiFDIEMhREEkIUUgBCBFaiFGIEYhRyBEIEcgPiBBELsFIUhBASFJIEggSXEhSiAEIEo6ADcgBC0ANyFLQX8hTEEBIU1BASFOIEsgTnEhTyBMIE0gTxshUCAEIFA2AhxBGCFRIAQgUWohUiBSIVMgUxCsAxogBCgCSCFUQQghVSBUIFVqIVYgBCgCSCFXQRghWCAEIFhqIVkgWSFaIFogViBXEK4DIVtBASFcIFsgXHEhXQJAIF1FDQAgBCgCHCFeQX8hXyBeIF9sIWAgBCBgNgIcC0EQIWEgBCBhaiFiIGIhYyBjIAAQ4gEaIAQoAkghZEEIIWUgBCBlaiFmIGYhZyBnIGQQ4gEaIAQoAkghaEEIIWkgaCBpaiFqIAQhayBrIGoQ4gEaQRAhbCAEIGxqIW0gbSFuQQghbyAEIG9qIXAgcCFxIAQhciBuIHEgchDzCCFzQQEhdCBzIHRxIXUCQCB1DQAgBCgCHCF2QX8hdyB2IHdsIXggBCB4NgIcCyAEKAIcIXkgBCB5NgJMCyAEKAJMIXpB0AAheyAEIHtqIXwgfCQAIHoPC/MBAR1/IwAhBEEgIQUgBCAFayEGIAYkACAGIAE2AhggBiACNgIQIAYgADYCDCAGIAM2AggCQANAQRghByAGIAdqIQggCCEJQRAhCiAGIApqIQsgCyEMIAkgDBCpBSENQQEhDiANIA5xIQ8gD0UNASAGKAIMIRAgBigCCCERIBEoAgAhEiASENoEIRNBGCEUIAYgFGohFSAVIRYgFhCqBSEXIBAgEyAXEPcIQRghGCAGIBhqIRkgGSEaIBoQtAUaIAYoAgghGyAbKAIAIRxBFCEdIBwgHWohHiAbIB42AgAMAAsAC0EgIR8gBiAfaiEgICAkAA8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSgCHCEGIAUoAhghByAFKAIUIQggCBD4CCEJIAYgByAJEPkIQSAhCiAFIApqIQsgCyQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIUIAUgATYCECAFIAI2AgwgBSgCFCEGIAUoAhAhByAFKAIMIQggCBD4CCEJIAYgByAJEPoIQSAhCiAFIApqIQsgCyQADwtZAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHIAcQ+AghCCAGIAgQjQUaQRAhCSAFIAlqIQogCiQADwtdAQt/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgggBCABNgIAQQghBSAEIAVqIQYgBiEHIAcQyQUhCCAEIQkgCRDJBSEKIAggChD8CEEQIQsgBCALaiEMIAwkAA8LSgEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhD9CEEQIQcgBCAHaiEIIAgkAA8LWwEKfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBCgCACEGQQghByAEIAdqIQggCCEJIAUgBiAJEP4IQRAhCiAEIApqIQsgCyQADwvnGgHZAn8jACEDQTAhBCADIARrIQUgBSQAIAUgADYCLCAFIAE2AiggBSACNgIkQQYhBiAFIAY2AiADQAJAAkADQCAFKAIoIQcgBSgCLCEIIAcgCGshCUEUIQogCSAKbSELIAUgCzYCHCAFKAIcIQxBBSENIAwgDUsaAkACQAJAAkACQAJAIAwOBgAAAQIDBAULDAcLIAUoAiQhDiAFKAIoIQ9BbCEQIA8gEGohESAFIBE2AiggBSgCLCESIA4gESASEP8IIRNBASEUIBMgFHEhFQJAIBVFDQAgBSgCLCEWIAUoAighFyAWIBcQgAkLDAYLIAUoAiwhGCAFKAIsIRlBFCEaIBkgGmohGyAFKAIoIRxBbCEdIBwgHWohHiAFIB42AiggBSgCJCEfIBggGyAeIB8QgQkaDAULIAUoAiwhICAFKAIsISFBFCEiICEgImohIyAFKAIsISRBKCElICQgJWohJiAFKAIoISdBbCEoICcgKGohKSAFICk2AiggBSgCJCEqICAgIyAmICkgKhCCCRoMBAsgBSgCLCErIAUoAiwhLEEUIS0gLCAtaiEuIAUoAiwhL0EoITAgLyAwaiExIAUoAiwhMkE8ITMgMiAzaiE0IAUoAighNUFsITYgNSA2aiE3IAUgNzYCKCAFKAIkITggKyAuIDEgNCA3IDgQgwkaDAMLIAUoAhwhOUEGITogOSE7IDohPCA7IDxMIT1BASE+ID0gPnEhPwJAID9FDQAgBSgCLCFAIAUoAighQSAFKAIkIUIgQCBBIEIQhAkMAwsgBSgCLCFDIAUgQzYCGCAFKAIoIUQgBSBENgIUIAUoAhQhRUFsIUYgRSBGaiFHIAUgRzYCFCAFKAIcIUhB6AchSSBIIUogSSFLIEogS04hTEEBIU0gTCBNcSFOAkACQCBORQ0AIAUoAhwhT0ECIVAgTyBQbSFRIAUgUTYCDCAFKAIMIVIgBSgCGCFTQRQhVCBSIFRsIVUgUyBVaiFWIAUgVjYCGCAFKAIMIVdBAiFYIFcgWG0hWSAFIFk2AgwgBSgCLCFaIAUoAiwhWyAFKAIMIVxBFCFdIFwgXWwhXiBbIF5qIV8gBSgCGCFgIAUoAhghYSAFKAIMIWJBFCFjIGIgY2whZCBhIGRqIWUgBSgCFCFmIAUoAiQhZyBaIF8gYCBlIGYgZxCDCSFoIAUgaDYCEAwBCyAFKAIcIWlBAiFqIGkgam0hayAFIGs2AgwgBSgCDCFsIAUoAhghbUEUIW4gbCBubCFvIG0gb2ohcCAFIHA2AhggBSgCLCFxIAUoAhghciAFKAIUIXMgBSgCJCF0IHEgciBzIHQQgQkhdSAFIHU2AhALIAUoAiwhdiAFIHY2AgggBSgCFCF3IAUgdzYCBCAFKAIkIXggBSgCCCF5IAUoAhgheiB4IHkgehD/CCF7QQEhfCB7IHxxIX0gfQ0BA0AgBSgCCCF+IAUoAgQhf0FsIYABIH8ggAFqIYEBIAUggQE2AgQgfiGCASCBASGDASCCASCDAUYhhAFBASGFASCEASCFAXEhhgECQCCGAUUNACAFKAIIIYcBQRQhiAEghwEgiAFqIYkBIAUgiQE2AgggBSgCKCGKASAFIIoBNgIEIAUoAiQhiwEgBSgCLCGMASAFKAIEIY0BQWwhjgEgjQEgjgFqIY8BIAUgjwE2AgQgiwEgjAEgjwEQ/wghkAFBASGRASCQASCRAXEhkgECQCCSAQ0AA0AgBSgCCCGTASAFKAIEIZQBIJMBIZUBIJQBIZYBIJUBIJYBRiGXAUEBIZgBIJcBIJgBcSGZAQJAIJkBRQ0ADAcLIAUoAiQhmgEgBSgCLCGbASAFKAIIIZwBIJoBIJsBIJwBEP8IIZ0BQQEhngEgnQEgngFxIZ8BAkACQCCfAUUNACAFKAIIIaABIAUoAgQhoQEgoAEgoQEQgAkgBSgCECGiAUEBIaMBIKIBIKMBaiGkASAFIKQBNgIQIAUoAgghpQFBFCGmASClASCmAWohpwEgBSCnATYCCAwBCyAFKAIIIagBQRQhqQEgqAEgqQFqIaoBIAUgqgE2AggMAQsLCyAFKAIIIasBIAUoAgQhrAEgqwEhrQEgrAEhrgEgrQEgrgFGIa8BQQEhsAEgrwEgsAFxIbEBAkAgsQFFDQAMBQsDQAJAA0AgBSgCJCGyASAFKAIsIbMBIAUoAgghtAEgsgEgswEgtAEQ/wghtQFBfyG2ASC1ASC2AXMhtwFBASG4ASC3ASC4AXEhuQEguQFFDQEgBSgCCCG6AUEUIbsBILoBILsBaiG8ASAFILwBNgIIDAALAAsCQANAIAUoAiQhvQEgBSgCLCG+ASAFKAIEIb8BQWwhwAEgvwEgwAFqIcEBIAUgwQE2AgQgvQEgvgEgwQEQ/wghwgFBASHDASDCASDDAXEhxAEgxAFFDQEMAAsACyAFKAIIIcUBIAUoAgQhxgEgxQEhxwEgxgEhyAEgxwEgyAFPIckBQQEhygEgyQEgygFxIcsBAkACQCDLAUUNAAwBCyAFKAIIIcwBIAUoAgQhzQEgzAEgzQEQgAkgBSgCECHOAUEBIc8BIM4BIM8BaiHQASAFINABNgIQIAUoAggh0QFBFCHSASDRASDSAWoh0wEgBSDTATYCCAwBCwsgBSgCCCHUASAFINQBNgIsDAILIAUoAiQh1QEgBSgCBCHWASAFKAIYIdcBINUBINYBINcBEP8IIdgBQQEh2QEg2AEg2QFxIdoBAkACQCDaAUUNACAFKAIIIdsBIAUoAgQh3AEg2wEg3AEQgAkgBSgCECHdAUEBId4BIN0BIN4BaiHfASAFIN8BNgIQDAELDAELCwsLIAUoAggh4AFBFCHhASDgASDhAWoh4gEgBSDiATYCCCAFKAIIIeMBIAUoAgQh5AEg4wEh5QEg5AEh5gEg5QEg5gFJIecBQQEh6AEg5wEg6AFxIekBAkAg6QFFDQADQAJAA0AgBSgCJCHqASAFKAIIIesBIAUoAhgh7AEg6gEg6wEg7AEQ/wgh7QFBASHuASDtASDuAXEh7wEg7wFFDQEgBSgCCCHwAUEUIfEBIPABIPEBaiHyASAFIPIBNgIIDAALAAsCQANAIAUoAiQh8wEgBSgCBCH0AUFsIfUBIPQBIPUBaiH2ASAFIPYBNgIEIAUoAhgh9wEg8wEg9gEg9wEQ/wgh+AFBfyH5ASD4ASD5AXMh+gFBASH7ASD6ASD7AXEh/AEg/AFFDQEMAAsACyAFKAIIIf0BIAUoAgQh/gEg/QEh/wEg/gEhgAIg/wEggAJLIYECQQEhggIggQIgggJxIYMCAkACQCCDAkUNAAwBCyAFKAIIIYQCIAUoAgQhhQIghAIghQIQgAkgBSgCECGGAkEBIYcCIIYCIIcCaiGIAiAFIIgCNgIQIAUoAhghiQIgBSgCCCGKAiCJAiGLAiCKAiGMAiCLAiCMAkYhjQJBASGOAiCNAiCOAnEhjwICQCCPAkUNACAFKAIEIZACIAUgkAI2AhgLIAUoAgghkQJBFCGSAiCRAiCSAmohkwIgBSCTAjYCCAwBCwsLIAUoAgghlAIgBSgCGCGVAiCUAiGWAiCVAiGXAiCWAiCXAkchmAJBASGZAiCYAiCZAnEhmgICQCCaAkUNACAFKAIkIZsCIAUoAhghnAIgBSgCCCGdAiCbAiCcAiCdAhD/CCGeAkEBIZ8CIJ4CIJ8CcSGgAiCgAkUNACAFKAIIIaECIAUoAhghogIgoQIgogIQgAkgBSgCECGjAkEBIaQCIKMCIKQCaiGlAiAFIKUCNgIQCyAFKAIQIaYCAkAgpgINACAFKAIsIacCIAUoAgghqAIgBSgCJCGpAiCnAiCoAiCpAhCFCSGqAkEBIasCIKoCIKsCcSGsAiAFIKwCOgADIAUoAgghrQJBFCGuAiCtAiCuAmohrwIgBSgCKCGwAiAFKAIkIbECIK8CILACILECEIUJIbICQQEhswIgsgIgswJxIbQCAkAgtAJFDQAgBS0AAyG1AkEBIbYCILUCILYCcSG3AgJAILcCRQ0ADAMLIAUoAgghuAIgBSC4AjYCKAwDCyAFLQADIbkCQQEhugIguQIgugJxIbsCAkAguwJFDQAgBSgCCCG8AkEUIb0CILwCIL0CaiG+AiAFIL4CNgIIIAUgvgI2AiwMAwsLIAUoAgghvwIgBSgCLCHAAiC/AiDAAmshwQJBFCHCAiDBAiDCAm0hwwIgBSgCKCHEAiAFKAIIIcUCIMQCIMUCayHGAkEUIccCIMYCIMcCbSHIAiDDAiHJAiDIAiHKAiDJAiDKAkghywJBASHMAiDLAiDMAnEhzQICQAJAIM0CRQ0AIAUoAiwhzgIgBSgCCCHPAiAFKAIkIdACIM4CIM8CINACEP4IIAUoAggh0QJBFCHSAiDRAiDSAmoh0wIgBSDTAjYCCCAFINMCNgIsDAELIAUoAggh1AJBFCHVAiDUAiDVAmoh1gIgBSgCKCHXAiAFKAIkIdgCINYCINcCINgCEP4IIAUoAggh2QIgBSDZAjYCKAsMAQsLQTAh2gIgBSDaAmoh2wIg2wIkAA8LYAEKfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAUoAgQhByAGIAcQhgkhCEEBIQkgCCAJcSEKQRAhCyAFIAtqIQwgDCQAIAoPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQhwlBECEHIAQgB2ohCCAIJAAPC7UEATh/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhggBiABNgIUIAYgAjYCECAGIAM2AgxBACEHIAYgBzYCCCAGKAIMIQggBigCFCEJIAYoAhghCiAIIAkgChD/CCELQQEhDCALIAxxIQ0CQAJAIA0NACAGKAIMIQ4gBigCECEPIAYoAhQhECAOIA8gEBD/CCERQQEhEiARIBJxIRMCQCATDQAgBigCCCEUIAYgFDYCHAwCCyAGKAIUIRUgBigCECEWIBUgFhCACUEBIRcgBiAXNgIIIAYoAgwhGCAGKAIUIRkgBigCGCEaIBggGSAaEP8IIRtBASEcIBsgHHEhHQJAIB1FDQAgBigCGCEeIAYoAhQhHyAeIB8QgAlBAiEgIAYgIDYCCAsgBigCCCEhIAYgITYCHAwBCyAGKAIMISIgBigCECEjIAYoAhQhJCAiICMgJBD/CCElQQEhJiAlICZxIScCQCAnRQ0AIAYoAhghKCAGKAIQISkgKCApEIAJQQEhKiAGICo2AgggBigCCCErIAYgKzYCHAwBCyAGKAIYISwgBigCFCEtICwgLRCACUEBIS4gBiAuNgIIIAYoAgwhLyAGKAIQITAgBigCFCExIC8gMCAxEP8IITJBASEzIDIgM3EhNAJAIDRFDQAgBigCFCE1IAYoAhAhNiA1IDYQgAlBAiE3IAYgNzYCCAsgBigCCCE4IAYgODYCHAsgBigCHCE5QSAhOiAGIDpqITsgOyQAIDkPC6YDASx/IwAhBUEgIQYgBSAGayEHIAckACAHIAA2AhwgByABNgIYIAcgAjYCFCAHIAM2AhAgByAENgIMIAcoAhwhCCAHKAIYIQkgBygCFCEKIAcoAgwhCyAIIAkgCiALEIEJIQwgByAMNgIIIAcoAgwhDSAHKAIQIQ4gBygCFCEPIA0gDiAPEP8IIRBBASERIBAgEXEhEgJAIBJFDQAgBygCFCETIAcoAhAhFCATIBQQgAkgBygCCCEVQQEhFiAVIBZqIRcgByAXNgIIIAcoAgwhGCAHKAIUIRkgBygCGCEaIBggGSAaEP8IIRtBASEcIBsgHHEhHQJAIB1FDQAgBygCGCEeIAcoAhQhHyAeIB8QgAkgBygCCCEgQQEhISAgICFqISIgByAiNgIIIAcoAgwhIyAHKAIYISQgBygCHCElICMgJCAlEP8IISZBASEnICYgJ3EhKAJAIChFDQAgBygCHCEpIAcoAhghKiApICoQgAkgBygCCCErQQEhLCArICxqIS0gByAtNgIICwsLIAcoAgghLkEgIS8gByAvaiEwIDAkACAuDwuXBAE4fyMAIQZBICEHIAYgB2shCCAIJAAgCCAANgIcIAggATYCGCAIIAI2AhQgCCADNgIQIAggBDYCDCAIIAU2AgggCCgCHCEJIAgoAhghCiAIKAIUIQsgCCgCECEMIAgoAgghDSAJIAogCyAMIA0QggkhDiAIIA42AgQgCCgCCCEPIAgoAgwhECAIKAIQIREgDyAQIBEQ/wghEkEBIRMgEiATcSEUAkAgFEUNACAIKAIQIRUgCCgCDCEWIBUgFhCACSAIKAIEIRdBASEYIBcgGGohGSAIIBk2AgQgCCgCCCEaIAgoAhAhGyAIKAIUIRwgGiAbIBwQ/wghHUEBIR4gHSAecSEfAkAgH0UNACAIKAIUISAgCCgCECEhICAgIRCACSAIKAIEISJBASEjICIgI2ohJCAIICQ2AgQgCCgCCCElIAgoAhQhJiAIKAIYIScgJSAmICcQ/wghKEEBISkgKCApcSEqAkAgKkUNACAIKAIYISsgCCgCFCEsICsgLBCACSAIKAIEIS1BASEuIC0gLmohLyAIIC82AgQgCCgCCCEwIAgoAhghMSAIKAIcITIgMCAxIDIQ/wghM0EBITQgMyA0cSE1AkAgNUUNACAIKAIcITYgCCgCGCE3IDYgNxCACSAIKAIEIThBASE5IDggOWohOiAIIDo2AgQLCwsLIAgoAgQhO0EgITwgCCA8aiE9ID0kACA7DwvOBAFGfyMAIQNBMCEEIAMgBGshBSAFJAAgBSAANgIsIAUgATYCKCAFIAI2AiQgBSgCLCEGQSghByAGIAdqIQggBSAINgIgIAUoAiwhCSAFKAIsIQpBFCELIAogC2ohDCAFKAIgIQ0gBSgCJCEOIAkgDCANIA4QgQkaIAUoAiAhD0EUIRAgDyAQaiERIAUgETYCHAJAA0AgBSgCHCESIAUoAighEyASIRQgEyEVIBQgFUchFkEBIRcgFiAXcSEYIBhFDQEgBSgCJCEZIAUoAhwhGiAFKAIgIRsgGSAaIBsQ/wghHEEBIR0gHCAdcSEeAkAgHkUNACAFKAIcIR8gHxCDBCEgQQghISAFICFqISIgIiEjICMgIBDmBBogBSgCICEkIAUgJDYCBCAFKAIcISUgBSAlNgIgA0AgBSgCBCEmICYQgwQhJyAFKAIgISggKCAnEIgJGiAFKAIEISkgBSApNgIgIAUoAiAhKiAFKAIsISsgKiEsICshLSAsIC1HIS5BACEvQQEhMCAuIDBxITEgLyEyAkAgMUUNACAFKAIkITMgBSgCBCE0QWwhNSA0IDVqITYgBSA2NgIEQQghNyAFIDdqITggOCE5IDMgOSA2EP8IITogOiEyCyAyITtBASE8IDsgPHEhPSA9DQALQQghPiAFID5qIT8gPyFAIEAQgwQhQSAFKAIgIUIgQiBBEIgJGgsgBSgCHCFDIAUgQzYCICAFKAIcIURBFCFFIEQgRWohRiAFIEY2AhwMAAsAC0EwIUcgBSBHaiFIIEgkAA8LggsBoAF/IwAhA0HAACEEIAMgBGshBSAFJAAgBSAANgI4IAUgATYCNCAFIAI2AjAgBSgCNCEGIAUoAjghByAGIAdrIQhBFCEJIAggCW0hCkEFIQsgCiALSxoCQAJAAkACQAJAAkACQCAKDgYAAAECAwQFC0EBIQxBASENIAwgDXEhDiAFIA46AD8MBQsgBSgCMCEPIAUoAjQhEEFsIREgECARaiESIAUgEjYCNCAFKAI4IRMgDyASIBMQ/wghFEEBIRUgFCAVcSEWAkAgFkUNACAFKAI4IRcgBSgCNCEYIBcgGBCACQtBASEZQQEhGiAZIBpxIRsgBSAbOgA/DAQLIAUoAjghHCAFKAI4IR1BFCEeIB0gHmohHyAFKAI0ISBBbCEhICAgIWohIiAFICI2AjQgBSgCMCEjIBwgHyAiICMQgQkaQQEhJEEBISUgJCAlcSEmIAUgJjoAPwwDCyAFKAI4IScgBSgCOCEoQRQhKSAoIClqISogBSgCOCErQSghLCArICxqIS0gBSgCNCEuQWwhLyAuIC9qITAgBSAwNgI0IAUoAjAhMSAnICogLSAwIDEQggkaQQEhMkEBITMgMiAzcSE0IAUgNDoAPwwCCyAFKAI4ITUgBSgCOCE2QRQhNyA2IDdqITggBSgCOCE5QSghOiA5IDpqITsgBSgCOCE8QTwhPSA8ID1qIT4gBSgCNCE/QWwhQCA/IEBqIUEgBSBBNgI0IAUoAjAhQiA1IDggOyA+IEEgQhCDCRpBASFDQQEhRCBDIERxIUUgBSBFOgA/DAELIAUoAjghRkEoIUcgRiBHaiFIIAUgSDYCLCAFKAI4IUkgBSgCOCFKQRQhSyBKIEtqIUwgBSgCLCFNIAUoAjAhTiBJIEwgTSBOEIEJGkEIIU8gBSBPNgIoQQAhUCAFIFA2AiQgBSgCLCFRQRQhUiBRIFJqIVMgBSBTNgIgAkADQCAFKAIgIVQgBSgCNCFVIFQhViBVIVcgViBXRyFYQQEhWSBYIFlxIVogWkUNASAFKAIwIVsgBSgCICFcIAUoAiwhXSBbIFwgXRD/CCFeQQEhXyBeIF9xIWACQCBgRQ0AIAUoAiAhYSBhEIMEIWJBCCFjIAUgY2ohZCBkIWUgZSBiEOYEGiAFKAIsIWYgBSBmNgIEIAUoAiAhZyAFIGc2AiwDQCAFKAIEIWggaBCDBCFpIAUoAiwhaiBqIGkQiAkaIAUoAgQhayAFIGs2AiwgBSgCLCFsIAUoAjghbSBsIW4gbSFvIG4gb0chcEEAIXFBASFyIHAgcnEhcyBxIXQCQCBzRQ0AIAUoAjAhdSAFKAIEIXZBbCF3IHYgd2oheCAFIHg2AgRBCCF5IAUgeWoheiB6IXsgdSB7IHgQ/wghfCB8IXQLIHQhfUEBIX4gfSB+cSF/IH8NAAtBCCGAASAFIIABaiGBASCBASGCASCCARCDBCGDASAFKAIsIYQBIIQBIIMBEIgJGiAFKAIkIYUBQQEhhgEghQEghgFqIYcBIAUghwE2AiRBCCGIASCHASGJASCIASGKASCJASCKAUYhiwFBASGMASCLASCMAXEhjQECQCCNAUUNACAFKAIgIY4BQRQhjwEgjgEgjwFqIZABIAUgkAE2AiAgBSgCNCGRASCQASGSASCRASGTASCSASCTAUYhlAFBASGVASCUASCVAXEhlgEgBSCWAToAPwwECwsgBSgCICGXASAFIJcBNgIsIAUoAiAhmAFBFCGZASCYASCZAWohmgEgBSCaATYCIAwACwALQQEhmwFBASGcASCbASCcAXEhnQEgBSCdAToAPwsgBS0APyGeAUEBIZ8BIJ4BIJ8BcSGgAUHAACGhASAFIKEBaiGiASCiASQAIKABDwvfAQEefyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhCJCSEHQQEhCEEBIQkgByAJcSEKIAghCwJAIAoNACAEKAIIIQwgBCgCDCENIAwgDRCJCSEOQQAhD0EBIRAgDiAQcSERIA8hEgJAIBENACAEKAIMIRMgEygCECEUIAQoAgghFSAVKAIQIRYgFCEXIBYhGCAXIBhIIRkgGSESCyASIRogGiELCyALIRtBASEcIBsgHHEhHUEQIR4gBCAeaiEfIB8kACAdDwtuAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEIoJQRAhByAFIAdqIQggBCgCCCEJQRAhCiAJIApqIQsgCCALEPQGQRAhDCAEIAxqIQ0gDSQADwt7AQ1/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBhCYAyEHIAUgBxCMCRogBCgCCCEIQRAhCSAIIAlqIQogChD2AyELIAsoAgAhDCAFIAw2AhBBECENIAQgDWohDiAOJAAgBQ8L4QEBHn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQrgYhB0EBIQhBASEJIAcgCXEhCiAIIQsCQCAKDQAgBCgCCCEMIAQoAgwhDSAMIA0QrgYhDkEAIQ9BASEQIA4gEHEhESAPIRICQCARDQAgBCgCDCETQQghFCATIBRqIRUgBCgCCCEWQQghFyAWIBdqIRggFSAYEK4GIRkgGSESCyASIRogGiELCyALIRtBASEcIBsgHHEhHUEQIR4gBCAeaiEfIB8kACAdDwtKAQd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEIsJQRAhByAEIAdqIQggCCQADwtuAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEN4BQQghByAFIAdqIQggBCgCCCEJQQghCiAJIApqIQsgCCALEN4BQRAhDCAEIAxqIQ0gDSQADwuAAQEOfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQoAEhByAFIAcQ6AEaIAQoAgghCEEIIQkgCCAJaiEKIAoQoAEhC0EIIQwgBSAMaiENIA0gCxDoARpBECEOIAQgDmohDyAPJAAgBQ8LOQEFfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGNgIAIAUPC8QCAS1/IwAhA0EwIQQgAyAEayEFIAUkACAFIAA2AiwgBSABNgIoIAIhBiAFIAY6ACcgBSgCLCEHQRghCCAFIAhqIQkgCSEKIAogBxCfCSAFKAIoIQtBECEMIAUgDGohDSANIQ4gDiALEJ8JIAUtACchD0EYIRAgBSAQaiERIBEhEkEQIRMgBSATaiEUIBQhFUEBIRYgDyAWcSEXIBIgFSAXEJAJIRhBACEZQQEhGiAYIBpxIRsgGSEcAkAgG0UNACAFKAIsIR1BCCEeIAUgHmohHyAfISAgICAdEKAJIAUoAighISAFISIgIiAhEKAJIAUtACchI0EIISQgBSAkaiElICUhJiAFISdBASEoICMgKHEhKSAmICcgKRCQCSEqICohHAsgHCErQQEhLCArICxxIS1BMCEuIAUgLmohLyAvJAAgLQ8LXAEKfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFKAIIIQYgAhAwIQdBAyEIIAcgCHQhCSAGIAlqIQogACAKEKQJGkEQIQsgBSALaiEMIAwkAA8L6gIBM38jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggAiEGIAUgBjoAByAFLQAHIQdBASEIIAcgCHEhCQJAAkAgCUUNACAFKAIMIQogChCiCSELIAUoAgghDCAMEKMJIQ0gCyEOIA0hDyAOIA9MIRBBACERQQEhEiAQIBJxIRMgESEUAkAgE0UNACAFKAIMIRUgFRCjCSEWIAUoAgghFyAXEKIJIRggFiEZIBghGiAZIBpOIRsgGyEUCyAUIRwgHCEdDAELIAUoAgwhHiAeEKIJIR8gBSgCCCEgICAQowkhISAfISIgISEjICIgI0ghJEEAISVBASEmICQgJnEhJyAlISgCQCAnRQ0AIAUoAgwhKSApEKMJISogBSgCCCErICsQogkhLCAqIS0gLCEuIC0gLkohLyAvISgLICghMCAwIR0LIB0hMUEBITIgMSAycSEzQRAhNCAFIDRqITUgNSQAIDMPC7MBARl/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEKUJIQYgBCgCCCEHIAcQpQkhCCAGIQkgCCEKIAkgCkchC0EBIQxBASENIAsgDXEhDiAMIQ8CQCAODQAgBRCmCSEQIAQoAgghESAREKYJIRIgECETIBIhFCATIBRHIRUgFSEPCyAPIRZBASEXIBYgF3EhGEEQIRkgBCAZaiEaIBokACAYDwv/CgJifzN+IwAhA0GAAyEEIAMgBGshBSAFJAAgBSAANgL4AiABEK8CIQYgAhCvAiEHIAYhCCAHIQkgCCAJRiEKQQEhCyAKIAtxIQwCQAJAIAxFDQAgARCvAiENIAUgDTYC/AIMAQsgBSgC+AIhDkGgASEPIAUgD2ohECAQIA4QsRpBCCERQaABIRIgBSASaiETIBMgEWohFCAUKQMAIWUgBSkDoAEhZiAFIGU3A9gCIAUgZjcD0AJBACEVQcgBIRYgBSAWaiEXIBcgFRAPGkHIASEYIAUgGGohGSABIBkQLyEaQZABIRsgBSAbaiEcIBwgGhCxGkGQASEdIAUgHWohHiAeIBFqIR8gHykDACFnIAUpA5ABIWggBSBnNwPIAiAFIGg3A8ACQQEhIEHAASEhIAUgIWohIiAiICAQDxpBwAEhIyAFICNqISQgASAkEC8hJUGAASEmIAUgJmohJyAnICUQsRpBgAEhKCAFIChqISkgKSARaiEqICopAwAhaSAFKQOAASFqIAUgaTcDuAIgBSBqNwOwAiAFKQPYAiFrIAUpA9ACIWwgBSkDyAIhbSAFKQPAAiFuQfAAISsgBSAraiEsICwgbCBrIG4gbRCwGkHwACEtIAUgLWohLiAuIBFqIS8gLykDACFvIAUpA3AhcCAFIG83A6gCIAUgcDcDoAJCACFxIAUgcTcD2AEgBSBxNwPQASAFKQOoAiFyIAUpA6ACIXMgBSkD2AEhdCAFKQPQASF1IHMgciB1IHQQpRohMCAwRSExQQEhMiAxIDJxITMCQCAzRQ0AIAUpA7gCIXYgBSkDsAIhdyB3IHYQrRohNCAFIDQ2AvwCDAELQQAhNUG4ASE2IAUgNmohNyA3IDUQDxpBuAEhOCAFIDhqITkgAiA5EC8hOkHgACE7IAUgO2ohPCA8IDoQsRpBCCE9QeAAIT4gBSA+aiE/ID8gPWohQCBAKQMAIXggBSkDYCF5IAUgeDcD+AEgBSB5NwPwAUEBIUFBsAEhQiAFIEJqIUMgQyBBEA8aQbABIUQgBSBEaiFFIAIgRRAvIUZB0AAhRyAFIEdqIUggSCBGELEaQdAAIUkgBSBJaiFKIEogPWohSyBLKQMAIXogBSkDUCF7IAUgejcD6AEgBSB7NwPgASAFKQP4ASF8IAUpA/ABIX0gBSkDyAIhfiAFKQPAAiF/QcAAIUwgBSBMaiFNIE0gfSB8IH8gfhCwGkHAACFOIAUgTmohTyBPID1qIVAgUCkDACGAASAFKQNAIYEBIAUggAE3A5gCIAUggQE3A5ACIAUpA+gBIYIBIAUpA+ABIYMBIAUpA7gCIYQBIAUpA7ACIYUBQTAhUSAFIFFqIVIgUiCDASCCASCFASCEARCwGkEwIVMgBSBTaiFUIFQgPWohVSBVKQMAIYYBIAUpAzAhhwEgBSCGATcDiAIgBSCHATcDgAIgBSkDqAIhiAEgBSkDoAIhiQEgBSkDiAIhigEgBSkDgAIhiwFBICFWIAUgVmohVyBXIIkBIIgBIIsBIIoBEK8aQSAhWCAFIFhqIVkgWSA9aiFaIFopAwAhjAEgBSkDICGNASAFKQOYAiGOASAFKQOQAiGPAUEQIVsgBSBbaiFcIFwgjQEgjAEgjwEgjgEQsxpBECFdIAUgXWohXiBeID1qIV8gXykDACGQASAFKQMQIZEBIAUpA7gCIZIBIAUpA7ACIZMBIAUgkQEgkAEgkwEgkgEQqxogBSA9aiFgIGApAwAhlAEgBSkDACGVASAFIJQBNwPoAiAFIJUBNwPgAiAFKQPoAiGWASAFKQPgAiGXASCXASCWARCtGiFhIAUgYTYC/AILIAUoAvwCIWJBgAMhYyAFIGNqIWQgZCQAIGIPC+0CATJ/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgggBSABNgIEIAIhBiAFIAY6AAMgBS0AAyEHQQEhCCAHIAhxIQkCQAJAIAlFDQAgBSgCBCEKIAUoAgghCyALEKMJIQwgCiENIAwhDiANIA5MIQ9BACEQQQEhESAPIBFxIRIgECETAkAgEkUNACAFKAIEIRQgBSgCCCEVIBUQogkhFiAUIRcgFiEYIBcgGE4hGSAZIRMLIBMhGkEBIRsgGiAbcSEcIAUgHDoADwwBCyAFKAIEIR0gBSgCCCEeIB4QowkhHyAdISAgHyEhICAgIUghIkEAISNBASEkICIgJHEhJSAjISYCQCAlRQ0AIAUoAgQhJyAFKAIIISggKBCiCSEpICchKiApISsgKiArSiEsICwhJgsgJiEtQQEhLiAtIC5xIS8gBSAvOgAPCyAFLQAPITBBASExIDAgMXEhMkEQITMgBSAzaiE0IDQkACAyDwuyAgIYfwx+IwAhBEEwIQUgBCAFayEGIAYkACAGIAA2AiwgBiABNgIoIAYgAjYCJCAGIAM2AiAgBigCLCEHQQghCCAHIAhqIQkgCSkDACEcIAcpAwAhHSAGKAIgIQogCiAIaiELIAspAwAhHiAKKQMAIR9BECEMIAYgDGohDSANIB0gHCAfIB4QrxpBECEOIAYgDmohDyAPIAhqIRAgECkDACEgIAYpAxAhISAGKAIkIREgESAIaiESIBIpAwAhIiARKQMAISMgBigCKCETIBMgCGohFCAUKQMAISQgEykDACElIAYgIyAiICUgJBCvGiAGIAhqIRUgFSkDACEmIAYpAwAhJyAhICAgJyAmEKUaIRYgFkUhF0EBIRggFyAYcSEZQTAhGiAGIBpqIRsgGyQAIBkPC7gEAi9/EH4jACEJQZABIQogCSAKayELIAskACALIAA2AogBIAsgAjcDeCALIAE3A3AgCyAENwNoIAsgAzcDYCALIAY3A1ggCyAFNwNQIAsgCDcDSCALIAc3A0AgCygCiAEhDCALIAw2AowBQcAAIQ0gDCANaiEOIAwhDwNAIA8hECAQELgJGkEgIREgECARaiESIBIhEyAOIRQgEyAURiEVQQEhFiAVIBZxIRcgEiEPIBdFDQALIAspA3ghOCALKQNwITkgCykDWCE6IAspA1AhOyA5IDggOyA6EKYaIRhBACEZIBggGUohGkEBIRsgGiAbcSEcAkAgHEUNAEHwACEdIAsgHWohHiAeIR9B0AAhICALICBqISEgISEiIB8gIhC5CQsgCykDaCE8IAspA2AhPSALKQNIIT4gCykDQCE/ID0gPCA/ID4QphohI0EAISQgIyAkSiElQQEhJiAlICZxIScCQCAnRQ0AQeAAISggCyAoaiEpICkhKkHAACErIAsgK2ohLCAsIS0gKiAtELkJCyALKQNYIUAgCykDUCFBIAspA3ghQiALKQNwIUNBICEuIAsgLmohLyAvIEMgQiBBIEAQugkaQSAhMCALIDBqITEgDCAxELsJGiALKQNoIUQgCykDYCFFIAspA0ghRiALKQNAIUcgCxogCyBFIEQgRyBGELoJGkEgITIgDCAyaiEzIAshNCAzIDQQuwkaIAsoAowBITVBkAEhNiALIDZqITcgNyQAIDUPC4UBAgZ/BH4jACEFQTAhBiAFIAZrIQcgByAANgIsIAcgAjcDGCAHIAE3AxAgByAENwMIIAcgAzcDACAHKAIsIQggBykDECELIAcpAxghDCAIIAw3AwggCCALNwMAIAcpAwAhDSAHKQMIIQ5BGCEJIAggCWohCiAKIA43AwAgCCANNwMQIAgPC6oBAgx/BH4jACECQTAhAyACIANrIQQgBCQAIAQgADYCLCAEIAE2AiggBCgCLCEFIAQoAighBkEQIQcgBCAHaiEIIAggBhDBCSAEKQMQIQ4gBCkDGCEPIAUgDzcDCCAFIA43AwAgBCgCKCEJIAQgCRDCCSAEKQMAIRAgBCkDCCERQRghCiAFIApqIQsgCyARNwMAIAUgEDcDEEEwIQwgBCAMaiENIA0kACAFDwvPAgInfwR+IwAhA0HwACEEIAMgBGshBSAFJAAgBSAANgJsIAIhBiAFIAY6AGsgBSgCbCEHQcAAIQggBSAIaiEJIAkhCiAKIAcQvAlBECELIAUgC2ohDCAMIAEQvQkgBSkDGCEqIAUpAxAhKyAFLQBrIQ1BwAAhDiAFIA5qIQ8gDxpBASEQIA0gEHEhEUHAACESIAUgEmohEyATICsgKiAREL4JIRRBACEVQQEhFiAUIBZxIRcgFSEYAkAgF0UNACAFKAJsIRlBICEaIAUgGmohGyAbIRwgHCAZEL8JIAUgARDACSAFKQMIISwgBSkDACEtIAUtAGshHUEgIR4gBSAeaiEfIB8aQQEhICAdICBxISFBICEiIAUgImohIyAjIC0gLCAhEL4JISQgJCEYCyAYISVBASEmICUgJnEhJ0HwACEoIAUgKGohKSApJAAgJw8L8gsCZX83fiMAIQRBoAMhBSAEIAVrIQYgBiQAIAYgATYCjAMgAhCvAiEHIAMQrwIhCCAHIQkgCCEKIAkgCkYhC0EBIQwgCyAMcSENAkACQCANRQ0AIAIQrwIhDiAGIA4QsRpBCCEPIAYgD2ohECAQKQMAIWkgBikDACFqIAYgaTcDmAMgBiBqNwOQAwwBCyAGKAKMAyERQbABIRIgBiASaiETIBMgERCxGkEIIRRBsAEhFSAGIBVqIRYgFiAUaiEXIBcpAwAhayAGKQOwASFsIAYgazcD6AIgBiBsNwPgAkEAIRhB2AEhGSAGIBlqIRogGiAYEA8aQdgBIRsgBiAbaiEcIAIgHBAvIR1BoAEhHiAGIB5qIR8gHyAdELEaQaABISAgBiAgaiEhICEgFGohIiAiKQMAIW0gBikDoAEhbiAGIG03A9gCIAYgbjcD0AJBASEjQdABISQgBiAkaiElICUgIxAPGkHQASEmIAYgJmohJyACICcQLyEoQZABISkgBiApaiEqICogKBCxGkGQASErIAYgK2ohLCAsIBRqIS0gLSkDACFvIAYpA5ABIXAgBiBvNwPIAiAGIHA3A8ACIAYpA+gCIXEgBikD4AIhciAGKQPYAiFzIAYpA9ACIXRBgAEhLiAGIC5qIS8gLyByIHEgdCBzELAaQYABITAgBiAwaiExIDEgFGohMiAyKQMAIXUgBikDgAEhdiAGIHU3A7gCIAYgdjcDsAJCACF3IAYgdzcD6AEgBiB3NwPgASAGKQO4AiF4IAYpA7ACIXkgBikD6AEheiAGKQPgASF7IHkgeCB7IHoQpRohMyAzRSE0QQEhNSA0IDVxITYCQCA2RQ0AIAYpA8ACIXwgBikDyAIhfSAGIH03A/gCIAYgfDcD8AIgBiB9NwOYAyAGIHw3A5ADDAELQQAhN0HIASE4IAYgOGohOSA5IDcQDxpByAEhOiAGIDpqITsgAyA7EC8hPEHwACE9IAYgPWohPiA+IDwQsRpBCCE/QfAAIUAgBiBAaiFBIEEgP2ohQiBCKQMAIX4gBikDcCF/IAYgfjcDiAIgBiB/NwOAAkEBIUNBwAEhRCAGIERqIUUgRSBDEA8aQcABIUYgBiBGaiFHIAMgRxAvIUhB4AAhSSAGIElqIUogSiBIELEaQeAAIUsgBiBLaiFMIEwgP2ohTSBNKQMAIYABIAYpA2AhgQEgBiCAATcD+AEgBiCBATcD8AEgBikDiAIhggEgBikDgAIhgwEgBikD2AIhhAEgBikD0AIhhQFB0AAhTiAGIE5qIU8gTyCDASCCASCFASCEARCwGkHQACFQIAYgUGohUSBRID9qIVIgUikDACGGASAGKQNQIYcBIAYghgE3A6gCIAYghwE3A6ACIAYpA/gBIYgBIAYpA/ABIYkBIAYpA8gCIYoBIAYpA8ACIYsBQcAAIVMgBiBTaiFUIFQgiQEgiAEgiwEgigEQsBpBwAAhVSAGIFVqIVYgViA/aiFXIFcpAwAhjAEgBikDQCGNASAGIIwBNwOYAiAGII0BNwOQAiAGKQO4AiGOASAGKQOwAiGPASAGKQOYAiGQASAGKQOQAiGRAUEwIVggBiBYaiFZIFkgjwEgjgEgkQEgkAEQrxpBMCFaIAYgWmohWyBbID9qIVwgXCkDACGSASAGKQMwIZMBIAYpA6gCIZQBIAYpA6ACIZUBQSAhXSAGIF1qIV4gXiCTASCSASCVASCUARCzGkEgIV8gBiBfaiFgIGAgP2ohYSBhKQMAIZYBIAYpAyAhlwEgBikDyAIhmAEgBikDwAIhmQFBECFiIAYgYmohYyBjIJcBIJYBIJkBIJgBEKsaQRAhZCAGIGRqIWUgZSA/aiFmIGYpAwAhmgEgBikDECGbASAGIJoBNwP4AiAGIJsBNwPwAiAGKQPwAiGcASAGKQP4AiGdASAGIJ0BNwOYAyAGIJwBNwOQAwsgBikDkAMhngEgBikDmAMhnwEgACCfATcDCCAAIJ4BNwMAQaADIWcgBiBnaiFoIGgkAA8LWwIJfwJ+IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBikDACEKIAQpAwAhCyALIAoQrRohB0EQIQggAyAIaiEJIAkkACAHDwsxAgR/AX4jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBEIAIQUgBCAFNwIAIAQPC6gBARR/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHIAYhCCAHIQkgCCAJSiEKQQEhCyAKIAtxIQwCQCAMRQ0AQQghDSAFIA1qIQ4gDiEPQQQhECAFIBBqIREgESESIA8gEhD0BgsgBSgCCCETIAUoAgQhFCAAIBMgFBCoCUEQIRUgBSAVaiEWIBYkAA8LXwEKfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCEGQQAhByAGIAcQDxogBCgCCCEIIAQhCSAFIAkgCBCnCUEQIQogBCAKaiELIAskAA8LXwEKfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCEGQQEhByAGIAcQDxogBCgCCCEIIAQhCSAFIAkgCBCnCUEQIQogBCAKaiELIAskAA8LWAEJfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIIIQUgBCEGQQAhByAGIAcQDxogBCEIIAAgBSAIELUJQRAhCSAEIAlqIQogCiQADwtYAQl/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgghBSAEIQZBASEHIAYgBxAPGiAEIQggACAFIAgQtQlBECEJIAQgCWohCiAKJAAPC4kHAkB/Qn4jACEEQdAAIQUgBCAFayEGIAYgADcDSCAGIAE3A0AgBiACNwM4IAYgAzcDMCAGKQM4IURCACFFIEQhRiBFIUcgRiBHUyEHQQEhCCAHIAhxIQkCQAJAIAlFDQAgBikDOCFIQgAhSSBJIEh9IUogSiFLDAELIAYpAzghTCBMIUsLIEshTSAGKQNAIU5CACFPIE4hUCBPIVEgUCBRUyEKQQEhCyAKIAtxIQwCQAJAIAxFDQAgBikDQCFSQgAhUyBTIFJ9IVQgVCFVDAELIAYpA0AhViBWIVULIFUhVyBNIFd+IVggBiBYNwMoIAYpA0ghWUIAIVogWSFbIFohXCBbIFxTIQ1BASEOIA0gDnEhDwJAAkAgD0UNACAGKQNIIV1CACFeIF4gXX0hXyBfIWAMAQsgBikDSCFhIGEhYAsgYCFiIAYpAzAhY0IAIWQgYyFlIGQhZiBlIGZTIRBBASERIBAgEXEhEgJAAkAgEkUNACAGKQMwIWdCACFoIGggZ30haSBpIWoMAQsgBikDMCFrIGshagsgaiFsIGIgbH4hbSAGIG03AyAgBikDSCFuQgAhbyBuIXAgbyFxIHAgcVMhE0F/IRRBASEVQQEhFiATIBZxIRcgFCAVIBcbIRggBiAYNgIcIAYpAzghckIAIXMgciF0IHMhdSB0IHVTIRlBfyEaQQEhG0EBIRwgGSAccSEdIBogGyAdGyEeIAYgHjYCGCAGKQNAIXZCACF3IHYheCB3IXkgeCB5UyEfQX8hIEEBISFBASEiIB8gInEhIyAgICEgIxshJCAGICQ2AhQgBikDMCF6QgAheyB6IXwgeyF9IHwgfVMhJUF/ISZBASEnQQEhKCAlIChxISkgJiAnICkbISogBiAqNgIQIAYoAhghKyAGKAIUISwgKyAsbCEtIAYgLTYCDCAGKAIcIS4gBigCECEvIC4gL2whMCAGIDA2AgggBikDKCF+IAYpAyAhfyB+IYABIH8hgQEggAEggQFRITFBACEyQQEhMyAxIDNxITQgMiE1AkAgNEUNACAGKAIMITYgBigCCCE3IDYhOCA3ITkgOCA5RiE6QQEhO0EBITwgOiA8cSE9IDshPgJAID0NACAGKQMoIYIBQgAhgwEgggEhhAEggwEhhQEghAEghQFRIT8gPyE+CyA+IUAgQCE1CyA1IUFBASFCIEEgQnEhQyBDDwtqAQ5/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSADIAVqIQYgBiEHQQAhCCAHIAgQqwkaQQghCSADIAlqIQogCiELIAQgCxCsCSEMQRAhDSADIA1qIQ4gDiQAIAwPC2oBDn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAMgBWohBiAGIQdBASEIIAcgCBCrCRpBCCEJIAMgCWohCiAKIQsgBCALEKwJIQxBECENIAMgDWohDiAOJAAgDA8LVQEIfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBigCACEHIAUgBzYCACAEKAIIIQggCCgCBCEJIAUgCTYCBCAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBQ8LWwEJfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgAjYCCCAFKAIMIQYgBSEHIAcgARAtGiAFKAIIIQggBSEJIAYgCSAIEKkJQRAhCiAFIApqIQsgCyQADwtUAQd/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHIAAgBiAHELQJGkEQIQggBSAIaiEJIAkkAA8LYwELfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgAjYCCCAFKAIMIQYgARAwIQdBAyEIIAcgCHQhCSAGIAlqIQogBSgCCCELIAogCxCqCRpBECEMIAUgDGohDSANJAAPC6YCASh/IwAhAkEwIQMgAiADayEEIAQkACAEIAA2AiwgBCABNgIoIAQoAiwhBUEgIQYgBCAGaiEHIAchCEEAIQkgCCAJEKsJGiAEKAIoIQpBGCELIAQgC2ohDCAMIQ1BACEOIA0gDhCrCRpBGCEPIAQgD2ohECAQIREgCiAREKwJIRJBICETIAQgE2ohFCAUIRUgBSAVIBIQrQkgBCgCLCEWQRAhFyAEIBdqIRggGCEZQQEhGiAZIBoQqwkaIAQoAighG0EIIRwgBCAcaiEdIB0hHkEBIR8gHiAfEKsJGkEIISAgBCAgaiEhICEhIiAbICIQrAkhI0EQISQgBCAkaiElICUhJiAWICYgIxCtCSAEKAIsISdBMCEoIAQgKGohKSApJAAgJw8LOQEFfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGNgIAIAUPC2YBDX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEKAIMIQVBCCEGIAQgBmohByAHIQggCCABEK4JGkEIIQkgBCAJaiEKIAohCyAFIAsQsAkhDEEQIQ0gBCANaiEOIA4kACAMDwtcAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSACNgIIIAUoAgwhBiAFIQcgByABEK4JGiAFKAIIIQggBSEJIAYgCSAIEK8JQRAhCiAFIApqIQsgCyQADwtAAQZ/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGKAIAIQcgBSAHNgIAIAUPC1wBCX8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAI2AgggBSgCDCEGIAUhByAHIAEQrgkaIAUoAgghCCAFIQkgBiAJIAgQsQlBECEKIAUgCmohCyALJAAPC2YBDX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEKAIMIQVBCCEGIAQgBmohByAHIQggCCABEK4JGkEIIQkgBCAJaiEKIAohCyAFIAsQswkhDEEQIQ0gBCANaiEOIA4kACAMDwtjAQt/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSACNgIIIAUoAgwhBiAFKAIIIQcgARCyCSEIQQIhCSAIIAl0IQogBiAKaiELIAsgBzYCAEEQIQwgBSAMaiENIA0kAA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwtXAQt/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCgCDCEFIAEQsgkhBkECIQcgBiAHdCEIIAUgCGohCSAJKAIAIQpBECELIAQgC2ohDCAMJAAgCg8LTgEGfyMAIQNBECEEIAMgBGshBSAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAYgBzYCACAFKAIEIQggBiAINgIEIAYPC1QBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSgCCCEGIAUhByAHIAIQLRogBSEIIAAgBiAIEI8JQRAhCSAFIAlqIQogCiQADwuJDAJjf2J+IwAhBEHQACEFIAQgBWshBiAGIAA3A0AgBiABNwM4IAYgAjcDMCAGIAM3AyggBikDQCFnQgAhaCBnIWkgaCFqIGkgalMhB0EBIQggByAIcSEJAkACQAJAIAlFDQAgBikDOCFrQn8hbCBrIGx+IW0gBiBtNwM4IAYpA0AhbkJ/IW8gbiBvfiFwIAYgcDcDQAwBCyAGKQNAIXFCACFyIHEhcyByIXQgcyB0USEKQQEhCyAKIAtxIQwCQCAMRQ0AQQAhDUEBIQ4gDSAOcSEPIAYgDzoATwwCCwsgBikDMCF1QgAhdiB1IXcgdiF4IHcgeFMhEEEBIREgECARcSESAkACQCASRQ0AIAYpAygheUJ/IXogeSB6fiF7IAYgezcDKCAGKQMwIXxCfyF9IHwgfX4hfiAGIH43AzAMAQsgBikDMCF/QgAhgAEgfyGBASCAASGCASCBASCCAVEhE0EBIRQgEyAUcSEVAkAgFUUNACAGKQNAIYMBQgAhhAEggwEhhQEghAEhhgEghQEghgFSIRZBASEXIBYgF3EhGCAGIBg6AE8MAgsLIAYpAzAhhwFCACGIASCHASGJASCIASGKASCJASCKAVMhGUEBIRogGSAacSEbAkACQCAbRQ0AIAYpAzAhiwFCACGMASCMASCLAX0hjQEgjQEhjgEMAQsgBikDMCGPASCPASGOAQsgjgEhkAEgBikDOCGRAUIAIZIBIJEBIZMBIJIBIZQBIJMBIJQBUyEcQQEhHSAcIB1xIR4CQAJAIB5FDQAgBikDOCGVAUIAIZYBIJYBIJUBfSGXASCXASGYAQwBCyAGKQM4IZkBIJkBIZgBCyCYASGaASCQASCaAX4hmwEgBiCbATcDICAGKQNAIZwBQgAhnQEgnAEhngEgnQEhnwEgngEgnwFTIR9BASEgIB8gIHEhIQJAAkAgIUUNACAGKQNAIaABQgAhoQEgoQEgoAF9IaIBIKIBIaMBDAELIAYpA0AhpAEgpAEhowELIKMBIaUBIAYpAyghpgFCACGnASCmASGoASCnASGpASCoASCpAVMhIkEBISMgIiAjcSEkAkACQCAkRQ0AIAYpAyghqgFCACGrASCrASCqAX0hrAEgrAEhrQEMAQsgBikDKCGuASCuASGtAQsgrQEhrwEgpQEgrwF+IbABIAYgsAE3AxggBikDQCGxAUIAIbIBILEBIbMBILIBIbQBILMBILQBUyElQX8hJkEBISdBASEoICUgKHEhKSAmICcgKRshKiAGICo2AhQgBikDMCG1AUIAIbYBILUBIbcBILYBIbgBILcBILgBUyErQX8hLEEBIS1BASEuICsgLnEhLyAsIC0gLxshMCAGIDA2AhAgBikDOCG5AUIAIboBILkBIbsBILoBIbwBILsBILwBUyExQX8hMkEBITNBASE0IDEgNHEhNSAyIDMgNRshNiAGIDY2AgwgBikDKCG9AUIAIb4BIL0BIb8BIL4BIcABIL8BIMABUyE3QX8hOEEBITlBASE6IDcgOnEhOyA4IDkgOxshPCAGIDw2AgggBigCECE9IAYoAgwhPiA9ID5sIT8gBiA/NgIEIAYoAhQhQCAGKAIIIUEgQCBBbCFCIAYgQjYCACAGKAIEIUMgBigCACFEIEMhRSBEIUYgRSBGSCFHQQEhSCBHIEhxIUkCQCBJRQ0AQQEhSkEBIUsgSiBLcSFMIAYgTDoATwwBCyAGKAIAIU0gBigCBCFOIE0hTyBOIVAgTyBQSCFRQQEhUiBRIFJxIVMCQCBTRQ0AQQAhVEEBIVUgVCBVcSFWIAYgVjoATwwBCyAGKAIEIVdBfyFYIFchWSBYIVogWSBaRiFbQQEhXCBbIFxxIV0CQCBdRQ0AIAYpAxghwQEgBikDICHCASDBASHDASDCASHEASDDASDEAVQhXkEBIV8gXiBfcSFgIAYgYDoATwwBCyAGKQMgIcUBIAYpAxghxgEgxQEhxwEgxgEhyAEgxwEgyAFUIWFBASFiIGEgYnEhYyAGIGM6AE8LIAYtAE8hZEEBIWUgZCBlcSFmIGYPCw8BAX9B/////wchACAADwtnAgp/AX4jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBEIAIQsgBCALNwMAQRghBSAEIAVqIQYgBiALNwMAQRAhByAEIAdqIQggCCALNwMAQQghCSAEIAlqIQogCiALNwMAIAQPC9UBAhB/Bn4jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAUQwwkhBkEIIQcgBiAHaiEIIAgpAwAhEiAGKQMAIRMgBCASNwMIIAQgEzcDACAEKAIYIQkgCRDDCSEKIAogB2ohCyALKQMAIRQgCikDACEVIAQoAhwhDCAMIBQ3AwggDCAVNwMAIAQQwwkhDSANIAdqIQ4gDikDACEWIA0pAwAhFyAEKAIYIQ8gDyAWNwMIIA8gFzcDAEEgIRAgBCAQaiERIBEkAA8LhQECBn8EfiMAIQVBMCEGIAUgBmshByAHIAA2AiwgByACNwMYIAcgATcDECAHIAQ3AwggByADNwMAIAcoAiwhCCAHKQMQIQsgBykDGCEMIAggDDcDCCAIIAs3AwAgBykDACENIAcpAwghDkEYIQkgCCAJaiEKIAogDjcDACAIIA03AxAgCA8LkAECC38EfiMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQZBCCEHIAYgB2ohCCAIKQMAIQ0gBikDACEOIAUgDTcDCCAFIA43AwAgBCgCCCEJQRghCiAJIApqIQsgCykDACEPIAkpAxAhECAFIApqIQwgDCAPNwMAIAUgEDcDECAFDwtYAQl/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgghBSAEIQZBACEHIAYgBxAPGiAEIQggACAFIAgQxglBECEJIAQgCWohCiAKJAAPC30CC38CfiMAIQJBICEDIAIgA2shBCAEJAAgBCABNgIcIAQoAhwhBUEAIQZBGCEHIAQgB2ohCCAIIAYQDxpBGCEJIAQgCWohCiAEIAUgChDHCSAEKQMAIQ0gBCkDCCEOIAAgDjcDCCAAIA03AwBBICELIAQgC2ohDCAMJAAPC5EEAjB/EH4jACEEQfAAIQUgBCAFayEGIAYkACAGIAA2AmggBiACNwNYIAYgATcDUCADIQcgBiAHOgBPIAYtAE8hCEEBIQkgCCAJcSEKAkACQCAKRQ0AIAYpA1ghNCAGKQNQITUgBigCaCELQRAhDCAGIAxqIQ0gDSALEMQJIAYpAxghNiAGKQMQITcgNSA0IDcgNhClGiEOQQEhDyAOIA9IIRBBACERQQEhEiAQIBJxIRMgESEUAkAgE0UNACAGKQNYITggBikDUCE5IAYoAmghFSAGIBUQxQkgBikDCCE6IAYpAwAhOyA5IDggOyA6EKYaIRZBfyEXIBYgF0ohGCAYIRQLIBQhGUEBIRogGSAacSEbIAYgGzoAbwwBCyAGKQNYITwgBikDUCE9IAYoAmghHEEwIR0gBiAdaiEeIB4gHBDECSAGKQM4IT4gBikDMCE/ID0gPCA/ID4QpRohH0EAISAgHyAgSCEhQQAhIkEBISMgISAjcSEkICIhJQJAICRFDQAgBikDWCFAIAYpA1AhQSAGKAJoISZBICEnIAYgJ2ohKCAoICYQxQkgBikDKCFCIAYpAyAhQyBBIEAgQyBCEKYaISlBACEqICkgKkohKyArISULICUhLEEBIS0gLCAtcSEuIAYgLjoAbwsgBi0AbyEvQQEhMCAvIDBxITFB8AAhMiAGIDJqITMgMyQAIDEPC1gBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCCCEFIAQhBkEBIQcgBiAHEA8aIAQhCCAAIAUgCBDGCUEQIQkgBCAJaiEKIAokAA8LfQILfwJ+IwAhAkEgIQMgAiADayEEIAQkACAEIAE2AhwgBCgCHCEFQQEhBkEYIQcgBCAHaiEIIAggBhAPGkEYIQkgBCAJaiEKIAQgBSAKEMcJIAQpAwAhDSAEKQMIIQ4gACAONwMIIAAgDTcDAEEgIQsgBCALaiEMIAwkAA8LSwIGfwJ+IwAhAkEQIQMgAiADayEEIAQgATYCDCAEKAIMIQVBCCEGIAUgBmohByAHKQMAIQggBSkDACEJIAAgCTcDACAAIAg3AwgPC0sCBn8CfiMAIQJBECEDIAIgA2shBCAEIAE2AgwgBCgCDCEFQRghBiAFIAZqIQcgBykDACEIIAUpAxAhCSAAIAk3AwAgACAINwMIDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LfgILfwJ+IwAhAkEgIQMgAiADayEEIAQkACAEIAE2AhwgBCgCHCEFQQEhBkEYIQcgBCAHaiEIIAggBhCrCRpBGCEJIAQgCWohCiAEIAUgChDICSAEKQMAIQ0gBCkDCCEOIAAgDjcDCCAAIA03AwBBICELIAQgC2ohDCAMJAAPC34CC38CfiMAIQJBICEDIAIgA2shBCAEJAAgBCABNgIcIAQoAhwhBUEAIQZBGCEHIAQgB2ohCCAIIAYQqwkaQRghCSAEIAlqIQogBCAFIAoQyAkgBCkDACENIAQpAwghDiAAIA43AwggACANNwMAQSAhCyAEIAtqIQwgDCQADwtUAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUoAgghBiAFIQcgByACEC0aIAUhCCAAIAYgCBDLCUEQIQkgBSAJaiEKIAokAA8LeQIKfwJ+IwAhA0EgIQQgAyAEayEFIAUkACAFIAE2AhwgBSgCHCEGQRghByAFIAdqIQggCCACEC0aQRghCSAFIAlqIQogBSAGIAoQzQkgBSkDACENIAUpAwghDiAAIA43AwggACANNwMAQSAhCyAFIAtqIQwgDCQADwt6Agp/An4jACEDQSAhBCADIARrIQUgBSQAIAUgATYCHCAFKAIcIQZBGCEHIAUgB2ohCCAIIAIQrgkaQRghCSAFIAlqIQogBSAGIAoQyQkgBSkDACENIAUpAwghDiAAIA43AwggACANNwMAQSAhCyAFIAtqIQwgDCQADwt6Agp/An4jACEDQSAhBCADIARrIQUgBSQAIAUgATYCHCAFKAIcIQZBGCEHIAUgB2ohCCAIIAIQrgkaQRghCSAFIAlqIQogBSAGIAoQygkgBSkDACENIAUpAwghDiAAIA43AwggACANNwMAQSAhCyAFIAtqIQwgDCQADwt3Agx/An4jACEDQRAhBCADIARrIQUgBSQAIAUgATYCDCAFKAIMIQYgAhCyCSEHQQQhCCAHIAh0IQkgBiAJaiEKQQghCyAKIAtqIQwgDCkDACEPIAopAwAhECAAIBA3AwAgACAPNwMIQRAhDSAFIA1qIQ4gDiQADwtcAQp/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUoAgghBiACEDAhB0EFIQggByAIdCEJIAYgCWohCiAAIAoQzAkaQRAhCyAFIAtqIQwgDCQADwuQAQILfwR+IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBkEIIQcgBiAHaiEIIAgpAwAhDSAGKQMAIQ4gBSANNwMIIAUgDjcDACAEKAIIIQlBGCEKIAkgCmohCyALKQMAIQ8gCSkDECEQIAUgCmohDCAMIA83AwAgBSAQNwMQIAUPC3kCCn8CfiMAIQNBICEEIAMgBGshBSAFJAAgBSABNgIcIAUoAhwhBkEYIQcgBSAHaiEIIAggAhAtGkEYIQkgBSAJaiEKIAUgBiAKEM4JIAUpAwAhDSAFKQMIIQ4gACAONwMIIAAgDTcDAEEgIQsgBSALaiEMIAwkAA8LdgIMfwJ+IwAhA0EQIQQgAyAEayEFIAUkACAFIAE2AgwgBSgCDCEGIAIQMCEHQQQhCCAHIAh0IQkgBiAJaiEKQQghCyAKIAtqIQwgDCkDACEPIAopAwAhECAAIBA3AwAgACAPNwMIQRAhDSAFIA1qIQ4gDiQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LgQMBL38jACEEQTAhBSAEIAVrIQYgBiQAIAYgATYCLCAGIAI2AiggBiADNgIkIAYoAiwhByAGKAIoIQhBICEJIAYgCWohCiAKIQsgByALIAgQ0wkhDCAGIAw2AhwgBigCHCENIA0oAgAhDiAGIA42AhhBACEPIAYgDzoAFyAGKAIcIRAgECgCACERQQAhEiARIRMgEiEUIBMgFEYhFUEBIRYgFSAWcSEXAkAgF0UNACAGKAIkIRggGBDEASEZQQghGiAGIBpqIRsgGyEcIBwgByAZENQJIAYoAiAhHSAGKAIcIR5BCCEfIAYgH2ohICAgISEgIRDVCSEiIAcgHSAeICIQ1glBCCEjIAYgI2ohJCAkISUgJRDXCSEmIAYgJjYCGEEBIScgBiAnOgAXQQghKCAGIChqISkgKSEqICoQ2AkaCyAGKAIYISsgBiEsICwgKxDZCRogBiEtQRchLiAGIC5qIS8gLyEwIAAgLSAwENoJGkEwITEgBiAxaiEyIDIkAA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwugBQFKfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIYIAUgATYCFCAFIAI2AhAgBSgCGCEGIAYQ2wkhByAFIAc2AgwgBhDcCSEIIAUgCDYCCCAFKAIMIQlBACEKIAkhCyAKIQwgCyAMRyENQQEhDiANIA5xIQ8CQAJAIA9FDQADQCAGEN0JIRAgBSgCECERIAUoAgwhEkEQIRMgEiATaiEUIBAgESAUEN4JIRVBASEWIBUgFnEhFwJAAkAgF0UNACAFKAIMIRggGCgCACEZQQAhGiAZIRsgGiEcIBsgHEchHUEBIR4gHSAecSEfAkACQCAfRQ0AIAUoAgwhICAgEIkIISEgBSAhNgIIIAUoAgwhIiAiKAIAISMgBSAjNgIMDAELIAUoAgwhJCAFKAIUISUgJSAkNgIAIAUoAhQhJiAmKAIAIScgBSAnNgIcDAULDAELIAYQ3QkhKCAFKAIMISlBECEqICkgKmohKyAFKAIQISwgKCArICwQ3gkhLUEBIS4gLSAucSEvAkACQCAvRQ0AIAUoAgwhMCAwKAIEITFBACEyIDEhMyAyITQgMyA0RyE1QQEhNiA1IDZxITcCQAJAIDdFDQAgBSgCDCE4QQQhOSA4IDlqITogOhCJCCE7IAUgOzYCCCAFKAIMITwgPCgCBCE9IAUgPTYCDAwBCyAFKAIMIT4gBSgCFCE/ID8gPjYCACAFKAIMIUBBBCFBIEAgQWohQiAFIEI2AhwMBgsMAQsgBSgCDCFDIAUoAhQhRCBEIEM2AgAgBSgCCCFFIAUgRTYCHAwECwsMAAsACyAGEO8FIUYgBSgCFCFHIEcgRjYCACAFKAIUIUggSCgCACFJIAUgSTYCHAsgBSgCHCFKQSAhSyAFIEtqIUwgTCQAIEoPC6sCASJ/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhwgBSABNgIYIAUgAjYCFCAFKAIYIQYgBhDfCSEHIAUgBzYCEEEAIQhBASEJIAggCXEhCiAFIAo6AA8gBSgCECELQQEhDCALIAwQ4AkhDSAFKAIQIQ4gBSEPQQAhEEEBIREgECARcSESIA8gDiASEOEJGiAFIRMgACANIBMQ4gkaIAUoAhAhFCAAEOMJIRVBECEWIBUgFmohFyAXEOQJIRggBSgCFCEZIBkQxAEhGiAUIBggGhDlCSAAEOYJIRtBASEcIBsgHDoABEEBIR1BASEeIB0gHnEhHyAFIB86AA8gBS0ADyEgQQEhISAgICFxISICQCAiDQAgABDYCRoLQSAhIyAFICNqISQgJCQADwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ6AkhBSAFKAIAIQZBECEHIAMgB2ohCCAIJAAgBg8LuQIBI38jACEEQRAhBSAEIAVrIQYgBiQAIAYgADYCDCAGIAE2AgggBiACNgIEIAYgAzYCACAGKAIMIQcgBigCACEIQQAhCSAIIAk2AgAgBigCACEKQQAhCyAKIAs2AgQgBigCCCEMIAYoAgAhDSANIAw2AgggBigCACEOIAYoAgQhDyAPIA42AgAgBxDwBSEQIBAoAgAhESARKAIAIRJBACETIBIhFCATIRUgFCAVRyEWQQEhFyAWIBdxIRgCQCAYRQ0AIAcQ8AUhGSAZKAIAIRogGigCACEbIAcQ8AUhHCAcIBs2AgALIAcQ7wUhHSAdKAIAIR4gBigCBCEfIB8oAgAhICAeICAQkwggBxDnCSEhICEoAgAhIkEBISMgIiAjaiEkICEgJDYCAEEQISUgBiAlaiEmICYkAA8LZQELfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOkJIQUgBSgCACEGIAMgBjYCCCAEEOkJIQdBACEIIAcgCDYCACADKAIIIQlBECEKIAMgCmohCyALJAAgCQ8LQgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEAIQUgBCAFEOoJQRAhBiADIAZqIQcgByQAIAQPCzkBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCACAFDwuIAQEOfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHENEJIQggCCgCACEJIAYgCTYCACAFKAIEIQogChCZCCELIAstAAAhDEEBIQ0gDCANcSEOIAYgDjoABEEQIQ8gBSAPaiEQIBAkACAGDwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ6wkhBSAFKAIAIQZBECEHIAMgB2ohCCAIJAAgBg8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOsJIQUgBRCJCCEGQRAhByADIAdqIQggCCQAIAYPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEOwJIQdBECEIIAMgCGohCSAJJAAgBw8LYAEKfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAUoAgQhByAGIAcQrgYhCEEBIQkgCCAJcSEKQRAhCyAFIAtqIQwgDCQAIAoPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBBCEFIAQgBWohBiAGEO8JIQdBECEIIAMgCGohCSAJJAAgBw8LVAEJfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGQQAhByAFIAYgBxDwCSEIQRAhCSAEIAlqIQogCiQAIAgPC10BCX8jACEDQRAhBCADIARrIQUgBSAANgIMIAUgATYCCCACIQYgBSAGOgAHIAUoAgwhByAFKAIIIQggByAINgIAIAUtAAchCUEBIQogCSAKcSELIAcgCzoABCAHDwtsAQt/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCBCEHIAcQ8QkhCEEIIQkgBSAJaiEKIAohCyAGIAsgCBDyCRpBECEMIAUgDGohDSANJAAgBg8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOgJIQUgBSgCACEGQRAhByADIAdqIQggCCQAIAYPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD0CSEFQRAhBiADIAZqIQcgByQAIAUPC2EBCX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCHCAFIAE2AhggBSACNgIUIAUoAhwhBiAFKAIYIQcgBSgCFCEIIAgQxAEhCSAGIAcgCRDzCUEgIQogBSAKaiELIAskAA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPUJIQVBECEGIAMgBmohByAHJAAgBQ8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQ/wkhB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ/QkhBUEQIQYgAyAGaiEHIAckACAFDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQgAohBUEQIQYgAyAGaiEHIAckACAFDwuoAQETfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRDpCSEGIAYoAgAhByAEIAc2AgQgBCgCCCEIIAUQ6QkhCSAJIAg2AgAgBCgCBCEKQQAhCyAKIQwgCyENIAwgDUchDkEBIQ8gDiAPcSEQAkAgEEUNACAFEPUJIREgBCgCBCESIBEgEhCBCgtBECETIAQgE2ohFCAUJAAPC1ABCn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBBCEFIAQgBWohBiAGEO0JIQcgBxD3BSEIQRAhCSADIAlqIQogCiQAIAgPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDuCSEFQRAhBiADIAZqIQcgByQAIAUPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCfCCEFQRAhBiADIAZqIQcgByQAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ9gkhBUEQIQYgAyAGaiEHIAckACAFDwufAQETfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAGEPcJIQggByEJIAghCiAJIApLIQtBASEMIAsgDHEhDQJAIA1FDQBB5AghDiAOEIMBAAsgBSgCCCEPQRghECAPIBBsIRFBBCESIBEgEhCEASETQRAhFCAFIBRqIRUgFSQAIBMPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwt8AQx/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQ+AkhCCAGIAgQ+QkaQQQhCSAGIAlqIQogBSgCBCELIAsQ+gkhDCAKIAwQ+wkaQRAhDSAFIA1qIQ4gDiQAIAYPC2EBCX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCFCAFIAE2AhAgBSACNgIMIAUoAhQhBiAFKAIQIQcgBSgCDCEIIAgQxAEhCSAGIAcgCRD8CUEgIQogBSAKaiELIAskAA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBBCEFIAQgBWohBiAGEP4JIQdBECEIIAMgCGohCSAJJAAgBw8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyUBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMQarVqtUAIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC1oBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEPgJIQcgBygCACEIIAUgCDYCAEEQIQkgBCAJaiEKIAokACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LXAIIfwF+IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBhD6CSEHIAcpAgAhCiAFIAo3AgBBECEIIAQgCGohCSAJJAAgBQ8LWQEIfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAUoAgQhByAHEMQBIQggBiAIEKkBGkEQIQkgBSAJaiEKIAokAA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQuwghBUEQIQYgAyAGaiEHIAckACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LxQEBGH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUtAAQhBkEBIQcgBiAHcSEIAkAgCEUNACAFKAIAIQkgBCgCCCEKQRAhCyAKIAtqIQwgDBDkCSENIAkgDRCCCgsgBCgCCCEOQQAhDyAOIRAgDyERIBAgEUchEkEBIRMgEiATcSEUAkAgFEUNACAFKAIAIRUgBCgCCCEWQQEhFyAVIBYgFxCDCgtBECEYIAQgGGohGSAZJAAPC0oBB38jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAQoAhghBiAFIAYQhApBICEHIAQgB2ohCCAIJAAPC1oBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBSgCBCEIIAYgByAIEIUKQRAhCSAFIAlqIQogCiQADwsiAQN/IwAhAkEQIQMgAiADayEEIAQgADYCBCAEIAE2AgAPC2EBCn8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQdBGCEIIAcgCGwhCUEEIQogBiAJIAoQSUEQIQsgBSALaiEMIAwkAA8LXQELfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIIIAQgATYCAEEIIQUgBCAFaiEGIAYhByAHENcCIQggBCEJIAkQ1wIhCiAIIAoQhwpBECELIAQgC2ohDCAMJAAPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQiApBECEHIAQgB2ohCCAIJAAPC1sBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCBCEFIAQoAgAhBkEIIQcgBCAHaiEIIAghCSAFIAYgCRCJCkEQIQogBCAKaiELIAskAA8L5xoB2QJ/IwAhA0EwIQQgAyAEayEFIAUkACAFIAA2AiwgBSABNgIoIAUgAjYCJEEGIQYgBSAGNgIgA0ACQAJAA0AgBSgCKCEHIAUoAiwhCCAHIAhrIQlBCCEKIAkgCm0hCyAFIAs2AhwgBSgCHCEMQQUhDSAMIA1LGgJAAkACQAJAAkACQCAMDgYAAAECAwQFCwwHCyAFKAIkIQ4gBSgCKCEPQXghECAPIBBqIREgBSARNgIoIAUoAiwhEiAOIBEgEhCKCiETQQEhFCATIBRxIRUCQCAVRQ0AIAUoAiwhFiAFKAIoIRcgFiAXEN4BCwwGCyAFKAIsIRggBSgCLCEZQQghGiAZIBpqIRsgBSgCKCEcQXghHSAcIB1qIR4gBSAeNgIoIAUoAiQhHyAYIBsgHiAfEIsKGgwFCyAFKAIsISAgBSgCLCEhQQghIiAhICJqISMgBSgCLCEkQRAhJSAkICVqISYgBSgCKCEnQXghKCAnIChqISkgBSApNgIoIAUoAiQhKiAgICMgJiApICoQjAoaDAQLIAUoAiwhKyAFKAIsISxBCCEtICwgLWohLiAFKAIsIS9BECEwIC8gMGohMSAFKAIsITJBGCEzIDIgM2ohNCAFKAIoITVBeCE2IDUgNmohNyAFIDc2AiggBSgCJCE4ICsgLiAxIDQgNyA4EI0KGgwDCyAFKAIcITlBBiE6IDkhOyA6ITwgOyA8TCE9QQEhPiA9ID5xIT8CQCA/RQ0AIAUoAiwhQCAFKAIoIUEgBSgCJCFCIEAgQSBCEI4KDAMLIAUoAiwhQyAFIEM2AhggBSgCKCFEIAUgRDYCFCAFKAIUIUVBeCFGIEUgRmohRyAFIEc2AhQgBSgCHCFIQegHIUkgSCFKIEkhSyBKIEtOIUxBASFNIEwgTXEhTgJAAkAgTkUNACAFKAIcIU9BAiFQIE8gUG0hUSAFIFE2AgwgBSgCDCFSIAUoAhghU0EDIVQgUiBUdCFVIFMgVWohViAFIFY2AhggBSgCDCFXQQIhWCBXIFhtIVkgBSBZNgIMIAUoAiwhWiAFKAIsIVsgBSgCDCFcQQMhXSBcIF10IV4gWyBeaiFfIAUoAhghYCAFKAIYIWEgBSgCDCFiQQMhYyBiIGN0IWQgYSBkaiFlIAUoAhQhZiAFKAIkIWcgWiBfIGAgZSBmIGcQjQohaCAFIGg2AhAMAQsgBSgCHCFpQQIhaiBpIGptIWsgBSBrNgIMIAUoAgwhbCAFKAIYIW1BAyFuIGwgbnQhbyBtIG9qIXAgBSBwNgIYIAUoAiwhcSAFKAIYIXIgBSgCFCFzIAUoAiQhdCBxIHIgcyB0EIsKIXUgBSB1NgIQCyAFKAIsIXYgBSB2NgIIIAUoAhQhdyAFIHc2AgQgBSgCJCF4IAUoAggheSAFKAIYIXogeCB5IHoQigohe0EBIXwgeyB8cSF9IH0NAQNAIAUoAgghfiAFKAIEIX9BeCGAASB/IIABaiGBASAFIIEBNgIEIH4hggEggQEhgwEgggEggwFGIYQBQQEhhQEghAEghQFxIYYBAkAghgFFDQAgBSgCCCGHAUEIIYgBIIcBIIgBaiGJASAFIIkBNgIIIAUoAighigEgBSCKATYCBCAFKAIkIYsBIAUoAiwhjAEgBSgCBCGNAUF4IY4BII0BII4BaiGPASAFII8BNgIEIIsBIIwBII8BEIoKIZABQQEhkQEgkAEgkQFxIZIBAkAgkgENAANAIAUoAgghkwEgBSgCBCGUASCTASGVASCUASGWASCVASCWAUYhlwFBASGYASCXASCYAXEhmQECQCCZAUUNAAwHCyAFKAIkIZoBIAUoAiwhmwEgBSgCCCGcASCaASCbASCcARCKCiGdAUEBIZ4BIJ0BIJ4BcSGfAQJAAkAgnwFFDQAgBSgCCCGgASAFKAIEIaEBIKABIKEBEN4BIAUoAhAhogFBASGjASCiASCjAWohpAEgBSCkATYCECAFKAIIIaUBQQghpgEgpQEgpgFqIacBIAUgpwE2AggMAQsgBSgCCCGoAUEIIakBIKgBIKkBaiGqASAFIKoBNgIIDAELCwsgBSgCCCGrASAFKAIEIawBIKsBIa0BIKwBIa4BIK0BIK4BRiGvAUEBIbABIK8BILABcSGxAQJAILEBRQ0ADAULA0ACQANAIAUoAiQhsgEgBSgCLCGzASAFKAIIIbQBILIBILMBILQBEIoKIbUBQX8htgEgtQEgtgFzIbcBQQEhuAEgtwEguAFxIbkBILkBRQ0BIAUoAgghugFBCCG7ASC6ASC7AWohvAEgBSC8ATYCCAwACwALAkADQCAFKAIkIb0BIAUoAiwhvgEgBSgCBCG/AUF4IcABIL8BIMABaiHBASAFIMEBNgIEIL0BIL4BIMEBEIoKIcIBQQEhwwEgwgEgwwFxIcQBIMQBRQ0BDAALAAsgBSgCCCHFASAFKAIEIcYBIMUBIccBIMYBIcgBIMcBIMgBTyHJAUEBIcoBIMkBIMoBcSHLAQJAAkAgywFFDQAMAQsgBSgCCCHMASAFKAIEIc0BIMwBIM0BEN4BIAUoAhAhzgFBASHPASDOASDPAWoh0AEgBSDQATYCECAFKAIIIdEBQQgh0gEg0QEg0gFqIdMBIAUg0wE2AggMAQsLIAUoAggh1AEgBSDUATYCLAwCCyAFKAIkIdUBIAUoAgQh1gEgBSgCGCHXASDVASDWASDXARCKCiHYAUEBIdkBINgBINkBcSHaAQJAAkAg2gFFDQAgBSgCCCHbASAFKAIEIdwBINsBINwBEN4BIAUoAhAh3QFBASHeASDdASDeAWoh3wEgBSDfATYCEAwBCwwBCwsLCyAFKAIIIeABQQgh4QEg4AEg4QFqIeIBIAUg4gE2AgggBSgCCCHjASAFKAIEIeQBIOMBIeUBIOQBIeYBIOUBIOYBSSHnAUEBIegBIOcBIOgBcSHpAQJAIOkBRQ0AA0ACQANAIAUoAiQh6gEgBSgCCCHrASAFKAIYIewBIOoBIOsBIOwBEIoKIe0BQQEh7gEg7QEg7gFxIe8BIO8BRQ0BIAUoAggh8AFBCCHxASDwASDxAWoh8gEgBSDyATYCCAwACwALAkADQCAFKAIkIfMBIAUoAgQh9AFBeCH1ASD0ASD1AWoh9gEgBSD2ATYCBCAFKAIYIfcBIPMBIPYBIPcBEIoKIfgBQX8h+QEg+AEg+QFzIfoBQQEh+wEg+gEg+wFxIfwBIPwBRQ0BDAALAAsgBSgCCCH9ASAFKAIEIf4BIP0BIf8BIP4BIYACIP8BIIACSyGBAkEBIYICIIECIIICcSGDAgJAAkAggwJFDQAMAQsgBSgCCCGEAiAFKAIEIYUCIIQCIIUCEN4BIAUoAhAhhgJBASGHAiCGAiCHAmohiAIgBSCIAjYCECAFKAIYIYkCIAUoAgghigIgiQIhiwIgigIhjAIgiwIgjAJGIY0CQQEhjgIgjQIgjgJxIY8CAkAgjwJFDQAgBSgCBCGQAiAFIJACNgIYCyAFKAIIIZECQQghkgIgkQIgkgJqIZMCIAUgkwI2AggMAQsLCyAFKAIIIZQCIAUoAhghlQIglAIhlgIglQIhlwIglgIglwJHIZgCQQEhmQIgmAIgmQJxIZoCAkAgmgJFDQAgBSgCJCGbAiAFKAIYIZwCIAUoAgghnQIgmwIgnAIgnQIQigohngJBASGfAiCeAiCfAnEhoAIgoAJFDQAgBSgCCCGhAiAFKAIYIaICIKECIKICEN4BIAUoAhAhowJBASGkAiCjAiCkAmohpQIgBSClAjYCEAsgBSgCECGmAgJAIKYCDQAgBSgCLCGnAiAFKAIIIagCIAUoAiQhqQIgpwIgqAIgqQIQjwohqgJBASGrAiCqAiCrAnEhrAIgBSCsAjoAAyAFKAIIIa0CQQghrgIgrQIgrgJqIa8CIAUoAighsAIgBSgCJCGxAiCvAiCwAiCxAhCPCiGyAkEBIbMCILICILMCcSG0AgJAILQCRQ0AIAUtAAMhtQJBASG2AiC1AiC2AnEhtwICQCC3AkUNAAwDCyAFKAIIIbgCIAUguAI2AigMAwsgBS0AAyG5AkEBIboCILkCILoCcSG7AgJAILsCRQ0AIAUoAgghvAJBCCG9AiC8AiC9AmohvgIgBSC+AjYCCCAFIL4CNgIsDAMLCyAFKAIIIb8CIAUoAiwhwAIgvwIgwAJrIcECQQMhwgIgwQIgwgJ1IcMCIAUoAighxAIgBSgCCCHFAiDEAiDFAmshxgJBAyHHAiDGAiDHAnUhyAIgwwIhyQIgyAIhygIgyQIgygJIIcsCQQEhzAIgywIgzAJxIc0CAkACQCDNAkUNACAFKAIsIc4CIAUoAgghzwIgBSgCJCHQAiDOAiDPAiDQAhCJCiAFKAIIIdECQQgh0gIg0QIg0gJqIdMCIAUg0wI2AgggBSDTAjYCLAwBCyAFKAIIIdQCQQgh1QIg1AIg1QJqIdYCIAUoAigh1wIgBSgCJCHYAiDWAiDXAiDYAhCJCiAFKAIIIdkCIAUg2QI2AigLDAELC0EwIdoCIAUg2gJqIdsCINsCJAAPC2ABCn8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQcgBiAHEK4GIQhBASEJIAggCXEhCkEQIQsgBSALaiEMIAwkACAKDwu1BAE4fyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIYIAYgATYCFCAGIAI2AhAgBiADNgIMQQAhByAGIAc2AgggBigCDCEIIAYoAhQhCSAGKAIYIQogCCAJIAoQigohC0EBIQwgCyAMcSENAkACQCANDQAgBigCDCEOIAYoAhAhDyAGKAIUIRAgDiAPIBAQigohEUEBIRIgESAScSETAkAgEw0AIAYoAgghFCAGIBQ2AhwMAgsgBigCFCEVIAYoAhAhFiAVIBYQ3gFBASEXIAYgFzYCCCAGKAIMIRggBigCFCEZIAYoAhghGiAYIBkgGhCKCiEbQQEhHCAbIBxxIR0CQCAdRQ0AIAYoAhghHiAGKAIUIR8gHiAfEN4BQQIhICAGICA2AggLIAYoAgghISAGICE2AhwMAQsgBigCDCEiIAYoAhAhIyAGKAIUISQgIiAjICQQigohJUEBISYgJSAmcSEnAkAgJ0UNACAGKAIYISggBigCECEpICggKRDeAUEBISogBiAqNgIIIAYoAgghKyAGICs2AhwMAQsgBigCGCEsIAYoAhQhLSAsIC0Q3gFBASEuIAYgLjYCCCAGKAIMIS8gBigCECEwIAYoAhQhMSAvIDAgMRCKCiEyQQEhMyAyIDNxITQCQCA0RQ0AIAYoAhQhNSAGKAIQITYgNSA2EN4BQQIhNyAGIDc2AggLIAYoAgghOCAGIDg2AhwLIAYoAhwhOUEgITogBiA6aiE7IDskACA5DwumAwEsfyMAIQVBICEGIAUgBmshByAHJAAgByAANgIcIAcgATYCGCAHIAI2AhQgByADNgIQIAcgBDYCDCAHKAIcIQggBygCGCEJIAcoAhQhCiAHKAIMIQsgCCAJIAogCxCLCiEMIAcgDDYCCCAHKAIMIQ0gBygCECEOIAcoAhQhDyANIA4gDxCKCiEQQQEhESAQIBFxIRICQCASRQ0AIAcoAhQhEyAHKAIQIRQgEyAUEN4BIAcoAgghFUEBIRYgFSAWaiEXIAcgFzYCCCAHKAIMIRggBygCFCEZIAcoAhghGiAYIBkgGhCKCiEbQQEhHCAbIBxxIR0CQCAdRQ0AIAcoAhghHiAHKAIUIR8gHiAfEN4BIAcoAgghIEEBISEgICAhaiEiIAcgIjYCCCAHKAIMISMgBygCGCEkIAcoAhwhJSAjICQgJRCKCiEmQQEhJyAmICdxISgCQCAoRQ0AIAcoAhwhKSAHKAIYISogKSAqEN4BIAcoAgghK0EBISwgKyAsaiEtIAcgLTYCCAsLCyAHKAIIIS5BICEvIAcgL2ohMCAwJAAgLg8LlwQBOH8jACEGQSAhByAGIAdrIQggCCQAIAggADYCHCAIIAE2AhggCCACNgIUIAggAzYCECAIIAQ2AgwgCCAFNgIIIAgoAhwhCSAIKAIYIQogCCgCFCELIAgoAhAhDCAIKAIIIQ0gCSAKIAsgDCANEIwKIQ4gCCAONgIEIAgoAgghDyAIKAIMIRAgCCgCECERIA8gECAREIoKIRJBASETIBIgE3EhFAJAIBRFDQAgCCgCECEVIAgoAgwhFiAVIBYQ3gEgCCgCBCEXQQEhGCAXIBhqIRkgCCAZNgIEIAgoAgghGiAIKAIQIRsgCCgCFCEcIBogGyAcEIoKIR1BASEeIB0gHnEhHwJAIB9FDQAgCCgCFCEgIAgoAhAhISAgICEQ3gEgCCgCBCEiQQEhIyAiICNqISQgCCAkNgIEIAgoAgghJSAIKAIUISYgCCgCGCEnICUgJiAnEIoKIShBASEpICggKXEhKgJAICpFDQAgCCgCGCErIAgoAhQhLCArICwQ3gEgCCgCBCEtQQEhLiAtIC5qIS8gCCAvNgIEIAgoAgghMCAIKAIYITEgCCgCHCEyIDAgMSAyEIoKITNBASE0IDMgNHEhNQJAIDVFDQAgCCgCHCE2IAgoAhghNyA2IDcQ3gEgCCgCBCE4QQEhOSA4IDlqITogCCA6NgIECwsLCyAIKAIEITtBICE8IAggPGohPSA9JAAgOw8LywQBRn8jACEDQTAhBCADIARrIQUgBSQAIAUgADYCLCAFIAE2AiggBSACNgIkIAUoAiwhBkEQIQcgBiAHaiEIIAUgCDYCICAFKAIsIQkgBSgCLCEKQQghCyAKIAtqIQwgBSgCICENIAUoAiQhDiAJIAwgDSAOEIsKGiAFKAIgIQ9BCCEQIA8gEGohESAFIBE2AhwCQANAIAUoAhwhEiAFKAIoIRMgEiEUIBMhFSAUIBVHIRZBASEXIBYgF3EhGCAYRQ0BIAUoAiQhGSAFKAIcIRogBSgCICEbIBkgGiAbEIoKIRxBASEdIBwgHXEhHgJAIB5FDQAgBSgCHCEfIB8QKCEgQRAhISAFICFqISIgIiEjICMgIBCpARogBSgCICEkIAUgJDYCDCAFKAIcISUgBSAlNgIgA0AgBSgCDCEmICYQKCEnIAUoAiAhKCAoICcQ6AEaIAUoAgwhKSAFICk2AiAgBSgCICEqIAUoAiwhKyAqISwgKyEtICwgLUchLkEAIS9BASEwIC4gMHEhMSAvITICQCAxRQ0AIAUoAiQhMyAFKAIMITRBeCE1IDQgNWohNiAFIDY2AgxBECE3IAUgN2ohOCA4ITkgMyA5IDYQigohOiA6ITILIDIhO0EBITwgOyA8cSE9ID0NAAtBECE+IAUgPmohPyA/IUAgQBAoIUEgBSgCICFCIEIgQRDoARoLIAUoAhwhQyAFIEM2AiAgBSgCHCFEQQghRSBEIEVqIUYgBSBGNgIcDAALAAtBMCFHIAUgR2ohSCBIJAAPC/0KAaABfyMAIQNBMCEEIAMgBGshBSAFJAAgBSAANgIoIAUgATYCJCAFIAI2AiAgBSgCJCEGIAUoAighByAGIAdrIQhBCCEJIAggCW0hCkEFIQsgCiALSxoCQAJAAkACQAJAAkACQCAKDgYAAAECAwQFC0EBIQxBASENIAwgDXEhDiAFIA46AC8MBQsgBSgCICEPIAUoAiQhEEF4IREgECARaiESIAUgEjYCJCAFKAIoIRMgDyASIBMQigohFEEBIRUgFCAVcSEWAkAgFkUNACAFKAIoIRcgBSgCJCEYIBcgGBDeAQtBASEZQQEhGiAZIBpxIRsgBSAbOgAvDAQLIAUoAighHCAFKAIoIR1BCCEeIB0gHmohHyAFKAIkISBBeCEhICAgIWohIiAFICI2AiQgBSgCICEjIBwgHyAiICMQiwoaQQEhJEEBISUgJCAlcSEmIAUgJjoALwwDCyAFKAIoIScgBSgCKCEoQQghKSAoIClqISogBSgCKCErQRAhLCArICxqIS0gBSgCJCEuQXghLyAuIC9qITAgBSAwNgIkIAUoAiAhMSAnICogLSAwIDEQjAoaQQEhMkEBITMgMiAzcSE0IAUgNDoALwwCCyAFKAIoITUgBSgCKCE2QQghNyA2IDdqITggBSgCKCE5QRAhOiA5IDpqITsgBSgCKCE8QRghPSA8ID1qIT4gBSgCJCE/QXghQCA/IEBqIUEgBSBBNgIkIAUoAiAhQiA1IDggOyA+IEEgQhCNChpBASFDQQEhRCBDIERxIUUgBSBFOgAvDAELIAUoAighRkEQIUcgRiBHaiFIIAUgSDYCHCAFKAIoIUkgBSgCKCFKQQghSyBKIEtqIUwgBSgCHCFNIAUoAiAhTiBJIEwgTSBOEIsKGkEIIU8gBSBPNgIYQQAhUCAFIFA2AhQgBSgCHCFRQQghUiBRIFJqIVMgBSBTNgIQAkADQCAFKAIQIVQgBSgCJCFVIFQhViBVIVcgViBXRyFYQQEhWSBYIFlxIVogWkUNASAFKAIgIVsgBSgCECFcIAUoAhwhXSBbIFwgXRCKCiFeQQEhXyBeIF9xIWACQCBgRQ0AIAUoAhAhYSBhECghYkEIIWMgBSBjaiFkIGQhZSBlIGIQqQEaIAUoAhwhZiAFIGY2AgQgBSgCECFnIAUgZzYCHANAIAUoAgQhaCBoECghaSAFKAIcIWogaiBpEOgBGiAFKAIEIWsgBSBrNgIcIAUoAhwhbCAFKAIoIW0gbCFuIG0hbyBuIG9HIXBBACFxQQEhciBwIHJxIXMgcSF0AkAgc0UNACAFKAIgIXUgBSgCBCF2QXghdyB2IHdqIXggBSB4NgIEQQgheSAFIHlqIXogeiF7IHUgeyB4EIoKIXwgfCF0CyB0IX1BASF+IH0gfnEhfyB/DQALQQghgAEgBSCAAWohgQEggQEhggEgggEQKCGDASAFKAIcIYQBIIQBIIMBEOgBGiAFKAIUIYUBQQEhhgEghQEghgFqIYcBIAUghwE2AhRBCCGIASCHASGJASCIASGKASCJASCKAUYhiwFBASGMASCLASCMAXEhjQECQCCNAUUNACAFKAIQIY4BQQghjwEgjgEgjwFqIZABIAUgkAE2AhAgBSgCJCGRASCQASGSASCRASGTASCSASCTAUYhlAFBASGVASCUASCVAXEhlgEgBSCWAToALwwECwsgBSgCECGXASAFIJcBNgIcIAUoAhAhmAFBCCGZASCYASCZAWohmgEgBSCaATYCEAwACwALQQEhmwFBASGcASCbASCcAXEhnQEgBSCdAToALwsgBS0ALyGeAUEBIZ8BIJ4BIJ8BcSGgAUEwIaEBIAUgoQFqIaIBIKIBJAAgoAEPC6ADATl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhAgBSABNgIIIAUgAjYCBEEQIQYgBSAGaiEHIAchCEEIIQkgBSAJaiEKIAohCyAIIAsQvgYhDEEBIQ0gDCANcSEOAkACQCAORQ0AIAUhD0EQIRAgBSAQaiERIBEhEiASKAIAIRMgDyATNgIAAkADQCAFIRQgFBDABiEVQQghFiAFIBZqIRcgFyEYIBUgGBC+BiEZQQEhGiAZIBpxIRsgG0UNASAFKAIEIRxBECEdIAUgHWohHiAeIR8gHxC/BiEgIAUhISAhEL8GISIgHCAgICIQkQohI0EBISQgIyAkcSElAkAgJUUNAEEYISYgBSAmaiEnICchKEEQISkgBSApaiEqICohKyArKAIAISwgKCAsNgIADAQLQRAhLSAFIC1qIS4gLiEvIAUhMCAwKAIAITEgLyAxNgIADAALAAsLQRghMiAFIDJqITMgMyE0QQghNSAFIDVqITYgNiE3IDcoAgAhOCA0IDg2AgALIAUoAhghOUEgITogBSA6aiE7IDskACA5DwtgAQp/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHIAYgBxDkASEIQQEhCSAIIAlxIQpBECELIAUgC2ohDCAMJAAgCg8L4wEBGn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBkEAIQcgBiEIIAchCSAIIAlHIQpBASELIAogC3EhDAJAIAxFDQAgBCgCCCENIA0oAgAhDiAFIA4QkgogBCgCCCEPIA8oAgQhECAFIBAQkgogBRCLCCERIAQgETYCBCAEKAIEIRIgBCgCCCETQRAhFCATIBRqIRUgFRCQCCEWIBIgFhC+CCAEKAIEIRcgBCgCCCEYQQEhGSAXIBggGRC/CAtBECEaIAQgGmohGyAbJAAPC0MBB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAQgBRCUCkEQIQYgAyAGaiEHIAckAA8LvAEBFH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAEIAY2AgQCQANAIAQoAgghByAEKAIEIQggByEJIAghCiAJIApHIQtBASEMIAsgDHEhDSANRQ0BIAUQtgchDiAEKAIEIQ9BfCEQIA8gEGohESAEIBE2AgQgERC3ByESIA4gEhDpBwwACwALIAQoAgghEyAFIBM2AgRBECEUIAQgFGohFSAVJAAPC0MBB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAQgBRCWCkEQIQYgAyAGaiEHIAckAA8LvAEBFH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAEIAY2AgQCQANAIAQoAgghByAEKAIEIQggByEJIAghCiAJIApHIQtBASEMIAsgDHEhDSANRQ0BIAUQ0wYhDiAEKAIEIQ9BdCEQIA8gEGohESAEIBE2AgQgERCUByESIA4gEhCZBwwACwALIAQoAgghEyAFIBM2AgRBECEUIAQgFGohFSAVJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEKUKIQdBECEIIAMgCGohCSAJJAAgBw8LZQEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCnCiEGIAQoAgghByAHENcCIQggBiAIayEJQQMhCiAJIAp1IQtBECEMIAQgDGohDSANJAAgCw8LpgEBFn8jACECQTAhAyACIANrIQQgBCQAIAQgADYCKCAEIAE2AiBBGCEFIAQgBWohBiAGIQdBKCEIIAQgCGohCSAJIQogCigCACELIAcgCzYCAEEQIQwgBCAMaiENIA0hDkEgIQ8gBCAPaiEQIBAhESARKAIAIRIgDiASNgIAIAQoAhghEyAEKAIQIRQgEyAUEKgKIRVBMCEWIAQgFmohFyAXJAAgFQ8LSgEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhCpCkEQIQcgBCAHaiEIIAgkAA8LkgIBI38jACEEQcAAIQUgBCAFayEGIAYkACAGIAE2AjggBiACNgIwIAYgADYCLCAGIAM2AiggBigCLCEHIAYoAighCEEYIQkgBiAJaiEKIAohCyALIAcgCBCfARogBxBbIQxBECENIAYgDWohDiAOIQ9BOCEQIAYgEGohESARIRIgEigCACETIA8gEzYCAEEIIRQgBiAUaiEVIBUhFkEwIRcgBiAXaiEYIBghGSAZKAIAIRogFiAaNgIAQRghGyAGIBtqIRwgHCEdQQQhHiAdIB5qIR8gBigCECEgIAYoAgghISAMICAgISAfEKoKQRghIiAGICJqISMgIyEkICQQogEaQcAAISUgBiAlaiEmICYkAA8LvgMBNX8jACEEQTAhBSAEIAVrIQYgBiQAIAYgADYCLCAGIAE2AiggBiACNgIkIAYgAzYCICAGKAIsIQcgBygCBCEIIAYgCDYCHCAGKAIcIQkgBigCICEKIAkgCmshC0EDIQwgCyAMdSENIAYgDTYCGCAGKAIoIQ4gBigCGCEPQQMhECAPIBB0IREgDiARaiESIAYgEjYCFCAGKAIkIRMgBigCFCEUIBMgFGshFUEDIRYgFSAWdSEXQQghGCAGIBhqIRkgGSEaIBogByAXEJ8BGgJAA0AgBigCFCEbIAYoAiQhHCAbIR0gHCEeIB0gHkkhH0EBISAgHyAgcSEhICFFDQEgBxBbISIgBigCDCEjICMQlgEhJCAGKAIUISUgJRAoISYgIiAkICYQoQEgBigCFCEnQQghKCAnIChqISkgBiApNgIUIAYoAgwhKkEIISsgKiAraiEsIAYgLDYCDAwACwALQQghLSAGIC1qIS4gLiEvIC8QogEaIAYoAighMCAGKAIoITEgBigCGCEyQQMhMyAyIDN0ITQgMSA0aiE1IAYoAhwhNiAwIDUgNhCrChpBMCE3IAYgN2ohOCA4JAAPC9wBARp/IwAhA0EwIQQgAyAEayEFIAUkACAFIAA2AiggBSABNgIgIAUgAjYCHEEQIQYgBSAGaiEHIAchCEEoIQkgBSAJaiEKIAohCyALKAIAIQwgCCAMNgIAIAUoAhAhDSANEKwKIQ4gBSAONgIYIAUhD0EgIRAgBSAQaiERIBEhEiASKAIAIRMgDyATNgIAIAUoAgAhFCAUEKwKIRUgBSAVNgIIIAUoAhwhFiAWEK0KIRcgBSgCGCEYIAUoAgghGSAYIBkgFxCuCiEaQTAhGyAFIBtqIRwgHCQAIBoPC/gCATF/IwAhA0EwIQQgAyAEayEFIAUkACAFIAE2AiggBSACNgIgIAUgADYCHCAFKAIcIQZBCCEHIAYgB2ohCEEIIQkgBSAJaiEKIAohC0EoIQwgBSAMaiENIA0hDiAOKAIAIQ8gCyAPNgIAIAUhEEEgIREgBSARaiESIBIhEyATKAIAIRQgECAUNgIAIAUoAgghFSAFKAIAIRYgFSAWEJkKIRdBECEYIAUgGGohGSAZIRogGiAIIBcQrwoaAkADQCAFKAIQIRsgBSgCFCEcIBshHSAcIR4gHSAeRyEfQQEhICAfICBxISEgIUUNASAGEKwBISIgBSgCECEjICMQlgEhJEEoISUgBSAlaiEmICYhJyAnELQGISggIiAkICgQwgEgBSgCECEpQQghKiApICpqISsgBSArNgIQQSghLCAFICxqIS0gLSEuIC4QtQYaDAALAAtBECEvIAUgL2ohMCAwITEgMRCwChpBMCEyIAUgMmohMyAzJAAPC80CASR/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBhAlIAUoAgghByAHKAIEIQggBSAINgIAIAYQWyEJIAYoAgAhCiAFKAIEIQsgBSgCCCEMQQQhDSAMIA1qIQ4gCSAKIAsgDhCvASAGEFshDyAFKAIEIRAgBigCBCERIAUoAgghEkEIIRMgEiATaiEUIA8gECARIBQQsQogBSgCCCEVQQQhFiAVIBZqIRcgBiAXELABQQQhGCAGIBhqIRkgBSgCCCEaQQghGyAaIBtqIRwgGSAcELABIAYQJyEdIAUoAgghHiAeEK4BIR8gHSAfELABIAUoAgghICAgKAIEISEgBSgCCCEiICIgITYCACAGEAshIyAGICMQsQEgBhCyASAFKAIAISRBECElIAUgJWohJiAmJAAgJA8LYwEMfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEELUKIQUgBSgCACEGQQghByADIAdqIQggCCEJIAkgBhC2ChogAygCCCEKQRAhCyADIAtqIQwgDCQAIAoPC1wBC38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBDrCSEFQQghBiADIAZqIQcgByEIIAggBRC2ChogAygCCCEJQRAhCiADIApqIQsgCyQAIAkPC6kBARV/IwAhA0EwIQQgAyAEayEFIAUkACAFIAA2AiggBSABNgIgIAUgAjYCHEEYIQYgBSAGaiEHIAchCEEoIQkgBSAJaiEKIAohCyALKAIAIQwgCCAMNgIAQRAhDSAFIA1qIQ4gDiEPQSAhECAFIBBqIREgESESIBIoAgAhEyAPIBM2AgAgBSgCGCEUIAUoAhAhFSAUIBUQtwpBMCEWIAUgFmohFyAXJAAPC2IBCX8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAGEJgDIQcgBSgCBCEIIAgQnQMhCSAAIAcgCRDAChpBECEKIAUgCmohCyALJAAPC24BCn8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBiAHEKkBGkEIIQggBiAIaiEJIAUoAgQhCiAJIAoQqQEaQRAhCyAFIAtqIQwgDCQAIAYPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCmCiEFQRAhBiADIAZqIQcgByQAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC7cBARZ/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhggBCABNgIQQQAhBSAEIAU2AgQCQANAQRghBiAEIAZqIQcgByEIQRAhCSAEIAlqIQogCiELIAggCxCzBiEMQQEhDSAMIA1xIQ4gDkUNASAEKAIEIQ9BASEQIA8gEGohESAEIBE2AgRBGCESIAQgEmohEyATIRQgFBC1BhoMAAsACyAEKAIEIRVBICEWIAQgFmohFyAXJAAgFQ8LmQIBIn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCACEFQQAhBiAFIQcgBiEIIAcgCE4hCUEBIQogCSAKcSELAkACQCALRQ0AAkADQCAEKAIAIQxBACENIAwhDiANIQ8gDiAPSiEQQQEhESAQIBFxIRIgEkUNASAEKAIEIRMgExC1BhogBCgCACEUQX8hFSAUIBVqIRYgBCAWNgIADAALAAsMAQsCQANAIAQoAgAhF0EAIRggFyEZIBghGiAZIBpIIRtBASEcIBsgHHEhHSAdRQ0BIAQoAgQhHiAeELIKGiAEKAIAIR9BASEgIB8gIGohISAEICE2AgAMAAsACwtBECEiIAQgImohIyAjJAAPC/MBAR1/IwAhBEEgIQUgBCAFayEGIAYkACAGIAE2AhggBiACNgIQIAYgADYCDCAGIAM2AggCQANAQRghByAGIAdqIQggCCEJQRAhCiAGIApqIQsgCyEMIAkgDBCzBiENQQEhDiANIA5xIQ8gD0UNASAGKAIMIRAgBigCCCERIBEoAgAhEiASEJYBIRNBGCEUIAYgFGohFSAVIRYgFhC0BiEXIBAgEyAXEMIBQRghGCAGIBhqIRkgGSEaIBoQtQYaIAYoAgghGyAbKAIAIRxBCCEdIBwgHWohHiAbIB42AgAMAAsAC0EgIR8gBiAfaiEgICAkAA8LcwEMfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAYQrQohByAFKAIIIQggCBCtCiEJIAUoAgQhCiAKEK0KIQsgByAJIAsQswohDEEQIQ0gBSANaiEOIA4kACAMDwtFAQl/IwAhAUEQIQIgASACayEDIAMgADYCAEEIIQQgAyAEaiEFIAUhBiADIQcgBygCACEIIAYgCDYCACADKAIIIQkgCQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC6sBARV/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhggBSABNgIQIAUgAjYCDEEIIQYgBSAGaiEHIAchCEEYIQkgBSAJaiEKIAohCyALKAIAIQwgCCAMNgIAIAUhDUEQIQ4gBSAOaiEPIA8hECAQKAIAIREgDSARNgIAIAUoAgwhEiAFKAIIIRMgBSgCACEUIBMgFCASELQKIRVBICEWIAUgFmohFyAXJAAgFQ8LgwEBDX8jACEDQRAhBCADIARrIQUgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHKAIAIQggBiAINgIAIAUoAgghCSAJKAIAIQogBSgCBCELQQMhDCALIAx0IQ0gCiANaiEOIAYgDjYCBCAFKAIIIQ8gBiAPNgIIIAYPCzkBBn8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBCgCCCEGIAYgBTYCACAEDwvlAQEZfyMAIQRBECEFIAQgBWshBiAGJAAgBiAANgIMIAYgATYCCCAGIAI2AgQgBiADNgIAAkADQCAGKAIIIQcgBigCBCEIIAchCSAIIQogCSAKRyELQQEhDCALIAxxIQ0gDUUNASAGKAIMIQ4gBigCACEPIA8oAgAhECAQEJYBIREgBigCCCESIBIQwQEhEyAOIBEgExDCASAGKAIIIRRBCCEVIBQgFWohFiAGIBY2AgggBigCACEXIBcoAgAhGEEIIRkgGCAZaiEaIBcgGjYCAAwACwALQRAhGyAGIBtqIRwgHCQADwtMAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgAhBSAFENQIIQYgBCAGNgIAQRAhByADIAdqIQggCCQAIAQPC7sBARR/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBAJAA0AgBSgCDCEGIAUoAgghByAGIQggByEJIAggCUchCkEBIQsgCiALcSEMIAxFDQEgBSgCCCENQXghDiANIA5qIQ8gBSAPNgIIIA8QKCEQIAUoAgQhEUF4IRIgESASaiETIAUgEzYCBCATIBAQ6AEaDAALAAsgBSgCBCEUQRAhFSAFIBVqIRYgFiQAIBQPC9gBARp/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhggBSABNgIQIAUgAjYCDAJAA0BBGCEGIAUgBmohByAHIQhBECEJIAUgCWohCiAKIQsgCCALELMGIQxBASENIAwgDXEhDiAORQ0BQRghDyAFIA9qIRAgECERIBEQtAYhEiAFKAIMIRMgEyASEOgBGkEYIRQgBSAUaiEVIBUhFiAWELUGGiAFKAIMIRdBCCEYIBcgGGohGSAFIBk2AgwMAAsACyAFKAIMIRpBICEbIAUgG2ohHCAcJAAgGg8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCzkBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCACAFDwt5ARB/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhggBCABNgIQQRghBSAEIAVqIQYgBiEHIAcQ1wIhCEEQIQkgBCAJaiEKIAohCyALENcCIQxBCCENIAQgDWohDiAOIQ8gCCAMIA8QuApBICEQIAQgEGohESARJAAPC1oBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBSgCBCEIIAYgByAIELkKQRAhCSAFIAlqIQogCiQADwvnGgHZAn8jACEDQTAhBCADIARrIQUgBSQAIAUgADYCLCAFIAE2AiggBSACNgIkQQYhBiAFIAY2AiADQAJAAkADQCAFKAIoIQcgBSgCLCEIIAcgCGshCUEIIQogCSAKbSELIAUgCzYCHCAFKAIcIQxBBSENIAwgDUsaAkACQAJAAkACQAJAIAwOBgAAAQIDBAULDAcLIAUoAiQhDiAFKAIoIQ9BeCEQIA8gEGohESAFIBE2AiggBSgCLCESIA4gESASELoKIRNBASEUIBMgFHEhFQJAIBVFDQAgBSgCLCEWIAUoAighFyAWIBcQ3gELDAYLIAUoAiwhGCAFKAIsIRlBCCEaIBkgGmohGyAFKAIoIRxBeCEdIBwgHWohHiAFIB42AiggBSgCJCEfIBggGyAeIB8QuwoaDAULIAUoAiwhICAFKAIsISFBCCEiICEgImohIyAFKAIsISRBECElICQgJWohJiAFKAIoISdBeCEoICcgKGohKSAFICk2AiggBSgCJCEqICAgIyAmICkgKhC8ChoMBAsgBSgCLCErIAUoAiwhLEEIIS0gLCAtaiEuIAUoAiwhL0EQITAgLyAwaiExIAUoAiwhMkEYITMgMiAzaiE0IAUoAighNUF4ITYgNSA2aiE3IAUgNzYCKCAFKAIkITggKyAuIDEgNCA3IDgQvQoaDAMLIAUoAhwhOUEGITogOSE7IDohPCA7IDxMIT1BASE+ID0gPnEhPwJAID9FDQAgBSgCLCFAIAUoAighQSAFKAIkIUIgQCBBIEIQvgoMAwsgBSgCLCFDIAUgQzYCGCAFKAIoIUQgBSBENgIUIAUoAhQhRUF4IUYgRSBGaiFHIAUgRzYCFCAFKAIcIUhB6AchSSBIIUogSSFLIEogS04hTEEBIU0gTCBNcSFOAkACQCBORQ0AIAUoAhwhT0ECIVAgTyBQbSFRIAUgUTYCDCAFKAIMIVIgBSgCGCFTQQMhVCBSIFR0IVUgUyBVaiFWIAUgVjYCGCAFKAIMIVdBAiFYIFcgWG0hWSAFIFk2AgwgBSgCLCFaIAUoAiwhWyAFKAIMIVxBAyFdIFwgXXQhXiBbIF5qIV8gBSgCGCFgIAUoAhghYSAFKAIMIWJBAyFjIGIgY3QhZCBhIGRqIWUgBSgCFCFmIAUoAiQhZyBaIF8gYCBlIGYgZxC9CiFoIAUgaDYCEAwBCyAFKAIcIWlBAiFqIGkgam0hayAFIGs2AgwgBSgCDCFsIAUoAhghbUEDIW4gbCBudCFvIG0gb2ohcCAFIHA2AhggBSgCLCFxIAUoAhghciAFKAIUIXMgBSgCJCF0IHEgciBzIHQQuwohdSAFIHU2AhALIAUoAiwhdiAFIHY2AgggBSgCFCF3IAUgdzYCBCAFKAIkIXggBSgCCCF5IAUoAhgheiB4IHkgehC6CiF7QQEhfCB7IHxxIX0gfQ0BA0AgBSgCCCF+IAUoAgQhf0F4IYABIH8ggAFqIYEBIAUggQE2AgQgfiGCASCBASGDASCCASCDAUYhhAFBASGFASCEASCFAXEhhgECQCCGAUUNACAFKAIIIYcBQQghiAEghwEgiAFqIYkBIAUgiQE2AgggBSgCKCGKASAFIIoBNgIEIAUoAiQhiwEgBSgCLCGMASAFKAIEIY0BQXghjgEgjQEgjgFqIY8BIAUgjwE2AgQgiwEgjAEgjwEQugohkAFBASGRASCQASCRAXEhkgECQCCSAQ0AA0AgBSgCCCGTASAFKAIEIZQBIJMBIZUBIJQBIZYBIJUBIJYBRiGXAUEBIZgBIJcBIJgBcSGZAQJAIJkBRQ0ADAcLIAUoAiQhmgEgBSgCLCGbASAFKAIIIZwBIJoBIJsBIJwBELoKIZ0BQQEhngEgnQEgngFxIZ8BAkACQCCfAUUNACAFKAIIIaABIAUoAgQhoQEgoAEgoQEQ3gEgBSgCECGiAUEBIaMBIKIBIKMBaiGkASAFIKQBNgIQIAUoAgghpQFBCCGmASClASCmAWohpwEgBSCnATYCCAwBCyAFKAIIIagBQQghqQEgqAEgqQFqIaoBIAUgqgE2AggMAQsLCyAFKAIIIasBIAUoAgQhrAEgqwEhrQEgrAEhrgEgrQEgrgFGIa8BQQEhsAEgrwEgsAFxIbEBAkAgsQFFDQAMBQsDQAJAA0AgBSgCJCGyASAFKAIsIbMBIAUoAgghtAEgsgEgswEgtAEQugohtQFBfyG2ASC1ASC2AXMhtwFBASG4ASC3ASC4AXEhuQEguQFFDQEgBSgCCCG6AUEIIbsBILoBILsBaiG8ASAFILwBNgIIDAALAAsCQANAIAUoAiQhvQEgBSgCLCG+ASAFKAIEIb8BQXghwAEgvwEgwAFqIcEBIAUgwQE2AgQgvQEgvgEgwQEQugohwgFBASHDASDCASDDAXEhxAEgxAFFDQEMAAsACyAFKAIIIcUBIAUoAgQhxgEgxQEhxwEgxgEhyAEgxwEgyAFPIckBQQEhygEgyQEgygFxIcsBAkACQCDLAUUNAAwBCyAFKAIIIcwBIAUoAgQhzQEgzAEgzQEQ3gEgBSgCECHOAUEBIc8BIM4BIM8BaiHQASAFINABNgIQIAUoAggh0QFBCCHSASDRASDSAWoh0wEgBSDTATYCCAwBCwsgBSgCCCHUASAFINQBNgIsDAILIAUoAiQh1QEgBSgCBCHWASAFKAIYIdcBINUBINYBINcBELoKIdgBQQEh2QEg2AEg2QFxIdoBAkACQCDaAUUNACAFKAIIIdsBIAUoAgQh3AEg2wEg3AEQ3gEgBSgCECHdAUEBId4BIN0BIN4BaiHfASAFIN8BNgIQDAELDAELCwsLIAUoAggh4AFBCCHhASDgASDhAWoh4gEgBSDiATYCCCAFKAIIIeMBIAUoAgQh5AEg4wEh5QEg5AEh5gEg5QEg5gFJIecBQQEh6AEg5wEg6AFxIekBAkAg6QFFDQADQAJAA0AgBSgCJCHqASAFKAIIIesBIAUoAhgh7AEg6gEg6wEg7AEQugoh7QFBASHuASDtASDuAXEh7wEg7wFFDQEgBSgCCCHwAUEIIfEBIPABIPEBaiHyASAFIPIBNgIIDAALAAsCQANAIAUoAiQh8wEgBSgCBCH0AUF4IfUBIPQBIPUBaiH2ASAFIPYBNgIEIAUoAhgh9wEg8wEg9gEg9wEQugoh+AFBfyH5ASD4ASD5AXMh+gFBASH7ASD6ASD7AXEh/AEg/AFFDQEMAAsACyAFKAIIIf0BIAUoAgQh/gEg/QEh/wEg/gEhgAIg/wEggAJLIYECQQEhggIggQIgggJxIYMCAkACQCCDAkUNAAwBCyAFKAIIIYQCIAUoAgQhhQIghAIghQIQ3gEgBSgCECGGAkEBIYcCIIYCIIcCaiGIAiAFIIgCNgIQIAUoAhghiQIgBSgCCCGKAiCJAiGLAiCKAiGMAiCLAiCMAkYhjQJBASGOAiCNAiCOAnEhjwICQCCPAkUNACAFKAIEIZACIAUgkAI2AhgLIAUoAgghkQJBCCGSAiCRAiCSAmohkwIgBSCTAjYCCAwBCwsLIAUoAgghlAIgBSgCGCGVAiCUAiGWAiCVAiGXAiCWAiCXAkchmAJBASGZAiCYAiCZAnEhmgICQCCaAkUNACAFKAIkIZsCIAUoAhghnAIgBSgCCCGdAiCbAiCcAiCdAhC6CiGeAkEBIZ8CIJ4CIJ8CcSGgAiCgAkUNACAFKAIIIaECIAUoAhghogIgoQIgogIQ3gEgBSgCECGjAkEBIaQCIKMCIKQCaiGlAiAFIKUCNgIQCyAFKAIQIaYCAkAgpgINACAFKAIsIacCIAUoAgghqAIgBSgCJCGpAiCnAiCoAiCpAhC/CiGqAkEBIasCIKoCIKsCcSGsAiAFIKwCOgADIAUoAgghrQJBCCGuAiCtAiCuAmohrwIgBSgCKCGwAiAFKAIkIbECIK8CILACILECEL8KIbICQQEhswIgsgIgswJxIbQCAkAgtAJFDQAgBS0AAyG1AkEBIbYCILUCILYCcSG3AgJAILcCRQ0ADAMLIAUoAgghuAIgBSC4AjYCKAwDCyAFLQADIbkCQQEhugIguQIgugJxIbsCAkAguwJFDQAgBSgCCCG8AkEIIb0CILwCIL0CaiG+AiAFIL4CNgIIIAUgvgI2AiwMAwsLIAUoAgghvwIgBSgCLCHAAiC/AiDAAmshwQJBAyHCAiDBAiDCAnUhwwIgBSgCKCHEAiAFKAIIIcUCIMQCIMUCayHGAkEDIccCIMYCIMcCdSHIAiDDAiHJAiDIAiHKAiDJAiDKAkghywJBASHMAiDLAiDMAnEhzQICQAJAIM0CRQ0AIAUoAiwhzgIgBSgCCCHPAiAFKAIkIdACIM4CIM8CINACELkKIAUoAggh0QJBCCHSAiDRAiDSAmoh0wIgBSDTAjYCCCAFINMCNgIsDAELIAUoAggh1AJBCCHVAiDUAiDVAmoh1gIgBSgCKCHXAiAFKAIkIdgCINYCINcCINgCELkKIAUoAggh2QIgBSDZAjYCKAsMAQsLQTAh2gIgBSDaAmoh2wIg2wIkAA8LuwQBUn8jACEDQcAAIQQgAyAEayEFIAUkACAFIAA2AjggBSABNgI0IAUgAjYCMCAFKAI0IQZBKCEHIAUgB2ohCCAIIQlBACEKIAkgChAPGkEoIQsgBSALaiEMIAwhDSAGIA0QLyEOIAUoAjAhD0EgIRAgBSAQaiERIBEhEkEAIRMgEiATEA8aQSAhFCAFIBRqIRUgFSEWIA8gFhAvIRcgDiEYIBchGSAYIBlIIRpBASEbIBogG3EhHAJAAkAgHEUNAEEBIR1BASEeIB0gHnEhHyAFIB86AD8MAQsgBSgCNCEgQRghISAFICFqISIgIiEjQQAhJCAjICQQDxpBGCElIAUgJWohJiAmIScgICAnEC8hKCAFKAIwISlBECEqIAUgKmohKyArISxBACEtICwgLRAPGkEQIS4gBSAuaiEvIC8hMCApIDAQLyExICghMiAxITMgMiAzRiE0QQEhNSA0IDVxITYCQCA2RQ0AIAUoAjQhN0EIITggBSA4aiE5IDkhOkEBITsgOiA7EA8aQQghPCAFIDxqIT0gPSE+IDcgPhAvIT8gBSgCMCFAIAUhQUEBIUIgQSBCEA8aIAUhQyBAIEMQLyFEID8hRSBEIUYgRSBGSiFHQQEhSCBHIEhxIUkCQCBJRQ0AQQEhSkEBIUsgSiBLcSFMIAUgTDoAPwwCCwtBACFNQQEhTiBNIE5xIU8gBSBPOgA/CyAFLQA/IVBBASFRIFAgUXEhUkHAACFTIAUgU2ohVCBUJAAgUg8LtQQBOH8jACEEQSAhBSAEIAVrIQYgBiQAIAYgADYCGCAGIAE2AhQgBiACNgIQIAYgAzYCDEEAIQcgBiAHNgIIIAYoAgwhCCAGKAIUIQkgBigCGCEKIAggCSAKELoKIQtBASEMIAsgDHEhDQJAAkAgDQ0AIAYoAgwhDiAGKAIQIQ8gBigCFCEQIA4gDyAQELoKIRFBASESIBEgEnEhEwJAIBMNACAGKAIIIRQgBiAUNgIcDAILIAYoAhQhFSAGKAIQIRYgFSAWEN4BQQEhFyAGIBc2AgggBigCDCEYIAYoAhQhGSAGKAIYIRogGCAZIBoQugohG0EBIRwgGyAccSEdAkAgHUUNACAGKAIYIR4gBigCFCEfIB4gHxDeAUECISAgBiAgNgIICyAGKAIIISEgBiAhNgIcDAELIAYoAgwhIiAGKAIQISMgBigCFCEkICIgIyAkELoKISVBASEmICUgJnEhJwJAICdFDQAgBigCGCEoIAYoAhAhKSAoICkQ3gFBASEqIAYgKjYCCCAGKAIIISsgBiArNgIcDAELIAYoAhghLCAGKAIUIS0gLCAtEN4BQQEhLiAGIC42AgggBigCDCEvIAYoAhAhMCAGKAIUITEgLyAwIDEQugohMkEBITMgMiAzcSE0AkAgNEUNACAGKAIUITUgBigCECE2IDUgNhDeAUECITcgBiA3NgIICyAGKAIIITggBiA4NgIcCyAGKAIcITlBICE6IAYgOmohOyA7JAAgOQ8LpgMBLH8jACEFQSAhBiAFIAZrIQcgByQAIAcgADYCHCAHIAE2AhggByACNgIUIAcgAzYCECAHIAQ2AgwgBygCHCEIIAcoAhghCSAHKAIUIQogBygCDCELIAggCSAKIAsQuwohDCAHIAw2AgggBygCDCENIAcoAhAhDiAHKAIUIQ8gDSAOIA8QugohEEEBIREgECARcSESAkAgEkUNACAHKAIUIRMgBygCECEUIBMgFBDeASAHKAIIIRVBASEWIBUgFmohFyAHIBc2AgggBygCDCEYIAcoAhQhGSAHKAIYIRogGCAZIBoQugohG0EBIRwgGyAccSEdAkAgHUUNACAHKAIYIR4gBygCFCEfIB4gHxDeASAHKAIIISBBASEhICAgIWohIiAHICI2AgggBygCDCEjIAcoAhghJCAHKAIcISUgIyAkICUQugohJkEBIScgJiAncSEoAkAgKEUNACAHKAIcISkgBygCGCEqICkgKhDeASAHKAIIIStBASEsICsgLGohLSAHIC02AggLCwsgBygCCCEuQSAhLyAHIC9qITAgMCQAIC4PC5cEATh/IwAhBkEgIQcgBiAHayEIIAgkACAIIAA2AhwgCCABNgIYIAggAjYCFCAIIAM2AhAgCCAENgIMIAggBTYCCCAIKAIcIQkgCCgCGCEKIAgoAhQhCyAIKAIQIQwgCCgCCCENIAkgCiALIAwgDRC8CiEOIAggDjYCBCAIKAIIIQ8gCCgCDCEQIAgoAhAhESAPIBAgERC6CiESQQEhEyASIBNxIRQCQCAURQ0AIAgoAhAhFSAIKAIMIRYgFSAWEN4BIAgoAgQhF0EBIRggFyAYaiEZIAggGTYCBCAIKAIIIRogCCgCECEbIAgoAhQhHCAaIBsgHBC6CiEdQQEhHiAdIB5xIR8CQCAfRQ0AIAgoAhQhICAIKAIQISEgICAhEN4BIAgoAgQhIkEBISMgIiAjaiEkIAggJDYCBCAIKAIIISUgCCgCFCEmIAgoAhghJyAlICYgJxC6CiEoQQEhKSAoIClxISoCQCAqRQ0AIAgoAhghKyAIKAIUISwgKyAsEN4BIAgoAgQhLUEBIS4gLSAuaiEvIAggLzYCBCAIKAIIITAgCCgCGCExIAgoAhwhMiAwIDEgMhC6CiEzQQEhNCAzIDRxITUCQCA1RQ0AIAgoAhwhNiAIKAIYITcgNiA3EN4BIAgoAgQhOEEBITkgOCA5aiE6IAggOjYCBAsLCwsgCCgCBCE7QSAhPCAIIDxqIT0gPSQAIDsPC8sEAUZ/IwAhA0EwIQQgAyAEayEFIAUkACAFIAA2AiwgBSABNgIoIAUgAjYCJCAFKAIsIQZBECEHIAYgB2ohCCAFIAg2AiAgBSgCLCEJIAUoAiwhCkEIIQsgCiALaiEMIAUoAiAhDSAFKAIkIQ4gCSAMIA0gDhC7ChogBSgCICEPQQghECAPIBBqIREgBSARNgIcAkADQCAFKAIcIRIgBSgCKCETIBIhFCATIRUgFCAVRyEWQQEhFyAWIBdxIRggGEUNASAFKAIkIRkgBSgCHCEaIAUoAiAhGyAZIBogGxC6CiEcQQEhHSAcIB1xIR4CQCAeRQ0AIAUoAhwhHyAfECghIEEQISEgBSAhaiEiICIhIyAjICAQqQEaIAUoAiAhJCAFICQ2AgwgBSgCHCElIAUgJTYCIANAIAUoAgwhJiAmECghJyAFKAIgISggKCAnEOgBGiAFKAIMISkgBSApNgIgIAUoAiAhKiAFKAIsISsgKiEsICshLSAsIC1HIS5BACEvQQEhMCAuIDBxITEgLyEyAkAgMUUNACAFKAIkITMgBSgCDCE0QXghNSA0IDVqITYgBSA2NgIMQRAhNyAFIDdqITggOCE5IDMgOSA2ELoKITogOiEyCyAyITtBASE8IDsgPHEhPSA9DQALQRAhPiAFID5qIT8gPyFAIEAQKCFBIAUoAiAhQiBCIEEQ6AEaCyAFKAIcIUMgBSBDNgIgIAUoAhwhREEIIUUgRCBFaiFGIAUgRjYCHAwACwALQTAhRyAFIEdqIUggSCQADwv9CgGgAX8jACEDQTAhBCADIARrIQUgBSQAIAUgADYCKCAFIAE2AiQgBSACNgIgIAUoAiQhBiAFKAIoIQcgBiAHayEIQQghCSAIIAltIQpBBSELIAogC0saAkACQAJAAkACQAJAAkAgCg4GAAABAgMEBQtBASEMQQEhDSAMIA1xIQ4gBSAOOgAvDAULIAUoAiAhDyAFKAIkIRBBeCERIBAgEWohEiAFIBI2AiQgBSgCKCETIA8gEiATELoKIRRBASEVIBQgFXEhFgJAIBZFDQAgBSgCKCEXIAUoAiQhGCAXIBgQ3gELQQEhGUEBIRogGSAacSEbIAUgGzoALwwECyAFKAIoIRwgBSgCKCEdQQghHiAdIB5qIR8gBSgCJCEgQXghISAgICFqISIgBSAiNgIkIAUoAiAhIyAcIB8gIiAjELsKGkEBISRBASElICQgJXEhJiAFICY6AC8MAwsgBSgCKCEnIAUoAighKEEIISkgKCApaiEqIAUoAighK0EQISwgKyAsaiEtIAUoAiQhLkF4IS8gLiAvaiEwIAUgMDYCJCAFKAIgITEgJyAqIC0gMCAxELwKGkEBITJBASEzIDIgM3EhNCAFIDQ6AC8MAgsgBSgCKCE1IAUoAighNkEIITcgNiA3aiE4IAUoAighOUEQITogOSA6aiE7IAUoAighPEEYIT0gPCA9aiE+IAUoAiQhP0F4IUAgPyBAaiFBIAUgQTYCJCAFKAIgIUIgNSA4IDsgPiBBIEIQvQoaQQEhQ0EBIUQgQyBEcSFFIAUgRToALwwBCyAFKAIoIUZBECFHIEYgR2ohSCAFIEg2AhwgBSgCKCFJIAUoAighSkEIIUsgSiBLaiFMIAUoAhwhTSAFKAIgIU4gSSBMIE0gThC7ChpBCCFPIAUgTzYCGEEAIVAgBSBQNgIUIAUoAhwhUUEIIVIgUSBSaiFTIAUgUzYCEAJAA0AgBSgCECFUIAUoAiQhVSBUIVYgVSFXIFYgV0chWEEBIVkgWCBZcSFaIFpFDQEgBSgCICFbIAUoAhAhXCAFKAIcIV0gWyBcIF0QugohXkEBIV8gXiBfcSFgAkAgYEUNACAFKAIQIWEgYRAoIWJBCCFjIAUgY2ohZCBkIWUgZSBiEKkBGiAFKAIcIWYgBSBmNgIEIAUoAhAhZyAFIGc2AhwDQCAFKAIEIWggaBAoIWkgBSgCHCFqIGogaRDoARogBSgCBCFrIAUgazYCHCAFKAIcIWwgBSgCKCFtIGwhbiBtIW8gbiBvRyFwQQAhcUEBIXIgcCBycSFzIHEhdAJAIHNFDQAgBSgCICF1IAUoAgQhdkF4IXcgdiB3aiF4IAUgeDYCBEEIIXkgBSB5aiF6IHoheyB1IHsgeBC6CiF8IHwhdAsgdCF9QQEhfiB9IH5xIX8gfw0AC0EIIYABIAUggAFqIYEBIIEBIYIBIIIBECghgwEgBSgCHCGEASCEASCDARDoARogBSgCFCGFAUEBIYYBIIUBIIYBaiGHASAFIIcBNgIUQQghiAEghwEhiQEgiAEhigEgiQEgigFGIYsBQQEhjAEgiwEgjAFxIY0BAkAgjQFFDQAgBSgCECGOAUEIIY8BII4BII8BaiGQASAFIJABNgIQIAUoAiQhkQEgkAEhkgEgkQEhkwEgkgEgkwFGIZQBQQEhlQEglAEglQFxIZYBIAUglgE6AC8MBAsLIAUoAhAhlwEgBSCXATYCHCAFKAIQIZgBQQghmQEgmAEgmQFqIZoBIAUgmgE2AhAMAAsAC0EBIZsBQQEhnAEgmwEgnAFxIZ0BIAUgnQE6AC8LIAUtAC8hngFBASGfASCeASCfAXEhoAFBMCGhASAFIKEBaiGiASCiASQAIKABDwt3AQt/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQmAMhCCAGIAgQ8wMaIAUoAgQhCSAJEJ0DIQogCigCACELIAYgCzYCEEEQIQwgBSAMaiENIA0kACAGDwtEAQl/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFIAQoAgAhBiAFIAZrIQdBDCEIIAcgCG0hCSAJDwtDAQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgAhBSAEIAUQxApBECEGIAMgBmohByAHJAAPC1oBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBSgCBCEIIAYgByAIEMUKQRAhCSAFIAlqIQogCiQADwu8AQEUfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCBCEGIAQgBjYCBAJAA0AgBCgCCCEHIAQoAgQhCCAHIQkgCCEKIAkgCkchC0EBIQwgCyAMcSENIA1FDQEgBRDMBSEOIAQoAgQhD0F0IRAgDyAQaiERIAQgETYCBCARENEFIRIgDiASEMYKDAALAAsgBCgCCCETIAUgEzYCBEEQIRQgBCAUaiEVIBUkAA8LYQEKfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAUoAgQhB0EMIQggByAIbCEJQQQhCiAGIAkgChBJQRAhCyAFIAtqIQwgDCQADwtKAQd/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAEKAIYIQYgBSAGEMcKQSAhByAEIAdqIQggCCQADwtKAQd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgQhBSAEKAIAIQYgBSAGEMgKQRAhByAEIAdqIQggCCQADwtCAQZ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgghBSAFEMkKGkEQIQYgBCAGaiEHIAckAA8LPQEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMoKGkEQIQUgAyAFaiEGIAYkACAEDwtFAQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ2wkhBSAEIAUQywpBECEGIAMgBmohByAHJAAgBA8L4wEBGn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBkEAIQcgBiEIIAchCSAIIAlHIQpBASELIAogC3EhDAJAIAxFDQAgBCgCCCENIA0oAgAhDiAFIA4QywogBCgCCCEPIA8oAgQhECAFIBAQywogBRDfCSERIAQgETYCBCAEKAIEIRIgBCgCCCETQRAhFCATIBRqIRUgFRDkCSEWIBIgFhCCCiAEKAIEIRcgBCgCCCEYQQEhGSAXIBggGRCDCgtBECEaIAQgGmohGyAbJAAPCzkBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSgCHCEGIAUoAhghByAFKAIUIQggCBDNCiEJIAYgByAJEM8KQSAhCiAFIApqIQsgCyQADwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhQgBSABNgIQIAUgAjYCDCAFKAIUIQYgBSgCECEHIAUoAgwhCCAIEM0KIQkgBiAHIAkQ0ApBICEKIAUgCmohCyALJAAPC1kBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQcgBxDNCiEIIAYgCBDRChpBECEJIAUgCWohCiAKJAAPC3oCDH8BfiMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhDzAxpBECEHIAUgB2ohCCAEKAIIIQlBECEKIAkgCmohCyALKQIAIQ4gCCAONwIAQRAhDCAEIAxqIQ0gDSQAIAUPC0MBB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAQgBRDTCkEQIQYgAyAGaiEHIAckAA8LvAEBFH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAEIAY2AgQCQANAIAQoAgghByAEKAIEIQggByEJIAghCiAJIApHIQtBASEMIAsgDHEhDSANRQ0BIAUQoAQhDiAEKAIEIQ9BeCEQIA8gEGohESAEIBE2AgQgERChBCESIA4gEhDTBAwACwALIAQoAgghEyAFIBM2AgRBECEUIAQgFGohFSAVJAAPCzkBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCACAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC1sBCX8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAI2AgggBSgCDCEGIAUhByAHIAEQLRogBSgCCCEIIAUhCSAGIAkgCBDXCkEQIQogBSAKaiELIAskAA8LYgELfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgAjYCCCAFKAIMIQYgBSgCCCEHIAEQMCEIQQIhCSAIIAl0IQogBiAKaiELIAsgBzYCAEEQIQwgBSAMaiENIA0kAA8LrQEBFH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFQQAhBiAFIQcgBiEIIAcgCEchCUEBIQogCSAKcSELAkAgC0UNACAEENoKIAQQwAIhDCAEKAIAIQ0gBBC9AiEOIAwgDSAOEMICIAQQ2AIhD0EAIRAgDyAQNgIAQQAhESAEIBE2AgRBACESIAQgEjYCAAtBECETIAMgE2ohFCAUJAAPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQ2wpBECEHIAQgB2ohCCAIJAAPC1sBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDWASEFIAMgBTYCCCAEEL8CIAMoAgghBiAEIAYQ3AogBBDzAkEQIQcgAyAHaiEIIAgkAA8LVgEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBCgCACEGIAYQwAIhByAHEN0KGiAFEMACGkEQIQggBCAIaiEJIAkkAA8LsAEBFn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQvAIhBiAFELwCIQcgBRC9AiEIQQUhCSAIIAl0IQogByAKaiELIAUQvAIhDCAEKAIIIQ1BBSEOIA0gDnQhDyAMIA9qIRAgBRC8AiERIAUQ1gEhEkEFIRMgEiATdCEUIBEgFGohFSAFIAYgCyAQIBUQvgJBECEWIAQgFmohFyAXJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtDAQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgAhBSAEIAUQ3wpBECEGIAMgBmohByAHJAAPC7wBARR/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIEIQYgBCAGNgIEAkADQCAEKAIIIQcgBCgCBCEIIAchCSAIIQogCSAKRyELQQEhDCALIAxxIQ0gDUUNASAFEJADIQ4gBCgCBCEPQWghECAPIBBqIREgBCARNgIEIBEQ2QMhEiAOIBIQ6AMMAAsACyAEKAIIIRMgBSATNgIEQRAhFCAEIBRqIRUgFSQADwtaAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAUoAgQhCCAGIAcgCBDhCkEQIQkgBSAJaiEKIAokAA8LxBsB4wJ/IwAhA0EwIQQgAyAEayEFIAUkACAFIAA2AiwgBSABNgIoIAUgAjYCJEEGIQYgBSAGNgIgA0ACQAJAA0AgBSgCKCEHIAUoAiwhCCAHIAhrIQlBICEKIAkgCm0hCyAFIAs2AhwgBSgCHCEMQQUhDSAMIA1LGgJAAkACQAJAAkACQCAMDgYAAAECAwQFCwwHCyAFKAIkIQ4gDigCACEPIAUoAighEEFgIREgECARaiESIAUgEjYCKCAFKAIsIRMgEiATIA8RAQAhFEEBIRUgFCAVcSEWAkAgFkUNACAFKAIsIRcgBSgCKCEYIBcgGBDiCgsMBgsgBSgCLCEZIAUoAiwhGkEgIRsgGiAbaiEcIAUoAighHUFgIR4gHSAeaiEfIAUgHzYCKCAFKAIkISAgGSAcIB8gIBDjChoMBQsgBSgCLCEhIAUoAiwhIkEgISMgIiAjaiEkIAUoAiwhJUHAACEmICUgJmohJyAFKAIoIShBYCEpICggKWohKiAFICo2AiggBSgCJCErICEgJCAnICogKxDkChoMBAsgBSgCLCEsIAUoAiwhLUEgIS4gLSAuaiEvIAUoAiwhMEHAACExIDAgMWohMiAFKAIsITNB4AAhNCAzIDRqITUgBSgCKCE2QWAhNyA2IDdqITggBSA4NgIoIAUoAiQhOSAsIC8gMiA1IDggORDlChoMAwsgBSgCHCE6QQYhOyA6ITwgOyE9IDwgPUwhPkEBIT8gPiA/cSFAAkAgQEUNACAFKAIsIUEgBSgCKCFCIAUoAiQhQyBBIEIgQxDmCgwDCyAFKAIsIUQgBSBENgIYIAUoAighRSAFIEU2AhQgBSgCFCFGQWAhRyBGIEdqIUggBSBINgIUIAUoAhwhSUHoByFKIEkhSyBKIUwgSyBMTiFNQQEhTiBNIE5xIU8CQAJAIE9FDQAgBSgCHCFQQQIhUSBQIFFtIVIgBSBSNgIMIAUoAgwhUyAFKAIYIVRBBSFVIFMgVXQhViBUIFZqIVcgBSBXNgIYIAUoAgwhWEECIVkgWCBZbSFaIAUgWjYCDCAFKAIsIVsgBSgCLCFcIAUoAgwhXUEFIV4gXSBedCFfIFwgX2ohYCAFKAIYIWEgBSgCGCFiIAUoAgwhY0EFIWQgYyBkdCFlIGIgZWohZiAFKAIUIWcgBSgCJCFoIFsgYCBhIGYgZyBoEOUKIWkgBSBpNgIQDAELIAUoAhwhakECIWsgaiBrbSFsIAUgbDYCDCAFKAIMIW0gBSgCGCFuQQUhbyBtIG90IXAgbiBwaiFxIAUgcTYCGCAFKAIsIXIgBSgCGCFzIAUoAhQhdCAFKAIkIXUgciBzIHQgdRDjCiF2IAUgdjYCEAsgBSgCLCF3IAUgdzYCCCAFKAIUIXggBSB4NgIEIAUoAiQheSB5KAIAIXogBSgCCCF7IAUoAhghfCB7IHwgehEBACF9QQEhfiB9IH5xIX8gfw0BA0AgBSgCCCGAASAFKAIEIYEBQWAhggEggQEgggFqIYMBIAUggwE2AgQggAEhhAEggwEhhQEghAEghQFGIYYBQQEhhwEghgEghwFxIYgBAkAgiAFFDQAgBSgCCCGJAUEgIYoBIIkBIIoBaiGLASAFIIsBNgIIIAUoAighjAEgBSCMATYCBCAFKAIkIY0BII0BKAIAIY4BIAUoAiwhjwEgBSgCBCGQAUFgIZEBIJABIJEBaiGSASAFIJIBNgIEII8BIJIBII4BEQEAIZMBQQEhlAEgkwEglAFxIZUBAkAglQENAANAIAUoAgghlgEgBSgCBCGXASCWASGYASCXASGZASCYASCZAUYhmgFBASGbASCaASCbAXEhnAECQCCcAUUNAAwHCyAFKAIkIZ0BIJ0BKAIAIZ4BIAUoAiwhnwEgBSgCCCGgASCfASCgASCeAREBACGhAUEBIaIBIKEBIKIBcSGjAQJAAkAgowFFDQAgBSgCCCGkASAFKAIEIaUBIKQBIKUBEOIKIAUoAhAhpgFBASGnASCmASCnAWohqAEgBSCoATYCECAFKAIIIakBQSAhqgEgqQEgqgFqIasBIAUgqwE2AggMAQsgBSgCCCGsAUEgIa0BIKwBIK0BaiGuASAFIK4BNgIIDAELCwsgBSgCCCGvASAFKAIEIbABIK8BIbEBILABIbIBILEBILIBRiGzAUEBIbQBILMBILQBcSG1AQJAILUBRQ0ADAULA0ACQANAIAUoAiQhtgEgtgEoAgAhtwEgBSgCLCG4ASAFKAIIIbkBILgBILkBILcBEQEAIboBQX8huwEgugEguwFzIbwBQQEhvQEgvAEgvQFxIb4BIL4BRQ0BIAUoAgghvwFBICHAASC/ASDAAWohwQEgBSDBATYCCAwACwALAkADQCAFKAIkIcIBIMIBKAIAIcMBIAUoAiwhxAEgBSgCBCHFAUFgIcYBIMUBIMYBaiHHASAFIMcBNgIEIMQBIMcBIMMBEQEAIcgBQQEhyQEgyAEgyQFxIcoBIMoBRQ0BDAALAAsgBSgCCCHLASAFKAIEIcwBIMsBIc0BIMwBIc4BIM0BIM4BTyHPAUEBIdABIM8BINABcSHRAQJAAkAg0QFFDQAMAQsgBSgCCCHSASAFKAIEIdMBINIBINMBEOIKIAUoAhAh1AFBASHVASDUASDVAWoh1gEgBSDWATYCECAFKAIIIdcBQSAh2AEg1wEg2AFqIdkBIAUg2QE2AggMAQsLIAUoAggh2gEgBSDaATYCLAwCCyAFKAIkIdsBINsBKAIAIdwBIAUoAgQh3QEgBSgCGCHeASDdASDeASDcAREBACHfAUEBIeABIN8BIOABcSHhAQJAAkAg4QFFDQAgBSgCCCHiASAFKAIEIeMBIOIBIOMBEOIKIAUoAhAh5AFBASHlASDkASDlAWoh5gEgBSDmATYCEAwBCwwBCwsLCyAFKAIIIecBQSAh6AEg5wEg6AFqIekBIAUg6QE2AgggBSgCCCHqASAFKAIEIesBIOoBIewBIOsBIe0BIOwBIO0BSSHuAUEBIe8BIO4BIO8BcSHwAQJAIPABRQ0AA0ACQANAIAUoAiQh8QEg8QEoAgAh8gEgBSgCCCHzASAFKAIYIfQBIPMBIPQBIPIBEQEAIfUBQQEh9gEg9QEg9gFxIfcBIPcBRQ0BIAUoAggh+AFBICH5ASD4ASD5AWoh+gEgBSD6ATYCCAwACwALAkADQCAFKAIkIfsBIPsBKAIAIfwBIAUoAgQh/QFBYCH+ASD9ASD+AWoh/wEgBSD/ATYCBCAFKAIYIYACIP8BIIACIPwBEQEAIYECQX8hggIggQIgggJzIYMCQQEhhAIggwIghAJxIYUCIIUCRQ0BDAALAAsgBSgCCCGGAiAFKAIEIYcCIIYCIYgCIIcCIYkCIIgCIIkCSyGKAkEBIYsCIIoCIIsCcSGMAgJAAkAgjAJFDQAMAQsgBSgCCCGNAiAFKAIEIY4CII0CII4CEOIKIAUoAhAhjwJBASGQAiCPAiCQAmohkQIgBSCRAjYCECAFKAIYIZICIAUoAgghkwIgkgIhlAIgkwIhlQIglAIglQJGIZYCQQEhlwIglgIglwJxIZgCAkAgmAJFDQAgBSgCBCGZAiAFIJkCNgIYCyAFKAIIIZoCQSAhmwIgmgIgmwJqIZwCIAUgnAI2AggMAQsLCyAFKAIIIZ0CIAUoAhghngIgnQIhnwIgngIhoAIgnwIgoAJHIaECQQEhogIgoQIgogJxIaMCAkAgowJFDQAgBSgCJCGkAiCkAigCACGlAiAFKAIYIaYCIAUoAgghpwIgpgIgpwIgpQIRAQAhqAJBASGpAiCoAiCpAnEhqgIgqgJFDQAgBSgCCCGrAiAFKAIYIawCIKsCIKwCEOIKIAUoAhAhrQJBASGuAiCtAiCuAmohrwIgBSCvAjYCEAsgBSgCECGwAgJAILACDQAgBSgCLCGxAiAFKAIIIbICIAUoAiQhswIgsQIgsgIgswIQ5wohtAJBASG1AiC0AiC1AnEhtgIgBSC2AjoAAyAFKAIIIbcCQSAhuAIgtwIguAJqIbkCIAUoAighugIgBSgCJCG7AiC5AiC6AiC7AhDnCiG8AkEBIb0CILwCIL0CcSG+AgJAIL4CRQ0AIAUtAAMhvwJBASHAAiC/AiDAAnEhwQICQCDBAkUNAAwDCyAFKAIIIcICIAUgwgI2AigMAwsgBS0AAyHDAkEBIcQCIMMCIMQCcSHFAgJAIMUCRQ0AIAUoAgghxgJBICHHAiDGAiDHAmohyAIgBSDIAjYCCCAFIMgCNgIsDAMLCyAFKAIIIckCIAUoAiwhygIgyQIgygJrIcsCQQUhzAIgywIgzAJ1Ic0CIAUoAighzgIgBSgCCCHPAiDOAiDPAmsh0AJBBSHRAiDQAiDRAnUh0gIgzQIh0wIg0gIh1AIg0wIg1AJIIdUCQQEh1gIg1QIg1gJxIdcCAkACQCDXAkUNACAFKAIsIdgCIAUoAggh2QIgBSgCJCHaAiDYAiDZAiDaAhDhCiAFKAIIIdsCQSAh3AIg2wIg3AJqId0CIAUg3QI2AgggBSDdAjYCLAwBCyAFKAIIId4CQSAh3wIg3gIg3wJqIeACIAUoAigh4QIgBSgCJCHiAiDgAiDhAiDiAhDhCiAFKAIIIeMCIAUg4wI2AigLDAELC0EwIeQCIAUg5AJqIeUCIOUCJAAPC5wBARJ/IwAhAkEwIQMgAiADayEEIAQkACAEIAA2AiwgBCABNgIoIAQoAiwhBSAFENkCIQZBCCEHIAQgB2ohCCAIIQkgCSAGEOoCGiAEKAIoIQogChDZAiELIAQoAiwhDCAMIAsQ6AoaQQghDSAEIA1qIQ4gDiEPIA8Q2QIhECAEKAIoIREgESAQEOgKGkEwIRIgBCASaiETIBMkAA8L2AQBPX8jACEEQSAhBSAEIAVrIQYgBiQAIAYgADYCGCAGIAE2AhQgBiACNgIQIAYgAzYCDEEAIQcgBiAHNgIIIAYoAgwhCCAIKAIAIQkgBigCFCEKIAYoAhghCyAKIAsgCREBACEMQQEhDSAMIA1xIQ4CQAJAIA4NACAGKAIMIQ8gDygCACEQIAYoAhAhESAGKAIUIRIgESASIBARAQAhE0EBIRQgEyAUcSEVAkAgFQ0AIAYoAgghFiAGIBY2AhwMAgsgBigCFCEXIAYoAhAhGCAXIBgQ4gpBASEZIAYgGTYCCCAGKAIMIRogGigCACEbIAYoAhQhHCAGKAIYIR0gHCAdIBsRAQAhHkEBIR8gHiAfcSEgAkAgIEUNACAGKAIYISEgBigCFCEiICEgIhDiCkECISMgBiAjNgIICyAGKAIIISQgBiAkNgIcDAELIAYoAgwhJSAlKAIAISYgBigCECEnIAYoAhQhKCAnICggJhEBACEpQQEhKiApICpxISsCQCArRQ0AIAYoAhghLCAGKAIQIS0gLCAtEOIKQQEhLiAGIC42AgggBigCCCEvIAYgLzYCHAwBCyAGKAIYITAgBigCFCExIDAgMRDiCkEBITIgBiAyNgIIIAYoAgwhMyAzKAIAITQgBigCECE1IAYoAhQhNiA1IDYgNBEBACE3QQEhOCA3IDhxITkCQCA5RQ0AIAYoAhQhOiAGKAIQITsgOiA7EOIKQQIhPCAGIDw2AggLIAYoAgghPSAGID02AhwLIAYoAhwhPkEgIT8gBiA/aiFAIEAkACA+Dwu7AwEvfyMAIQVBICEGIAUgBmshByAHJAAgByAANgIcIAcgATYCGCAHIAI2AhQgByADNgIQIAcgBDYCDCAHKAIcIQggBygCGCEJIAcoAhQhCiAHKAIMIQsgCCAJIAogCxDjCiEMIAcgDDYCCCAHKAIMIQ0gDSgCACEOIAcoAhAhDyAHKAIUIRAgDyAQIA4RAQAhEUEBIRIgESAScSETAkAgE0UNACAHKAIUIRQgBygCECEVIBQgFRDiCiAHKAIIIRZBASEXIBYgF2ohGCAHIBg2AgggBygCDCEZIBkoAgAhGiAHKAIUIRsgBygCGCEcIBsgHCAaEQEAIR1BASEeIB0gHnEhHwJAIB9FDQAgBygCGCEgIAcoAhQhISAgICEQ4gogBygCCCEiQQEhIyAiICNqISQgByAkNgIIIAcoAgwhJSAlKAIAISYgBygCGCEnIAcoAhwhKCAnICggJhEBACEpQQEhKiApICpxISsCQCArRQ0AIAcoAhwhLCAHKAIYIS0gLCAtEOIKIAcoAgghLkEBIS8gLiAvaiEwIAcgMDYCCAsLCyAHKAIIITFBICEyIAcgMmohMyAzJAAgMQ8LswQBPH8jACEGQSAhByAGIAdrIQggCCQAIAggADYCHCAIIAE2AhggCCACNgIUIAggAzYCECAIIAQ2AgwgCCAFNgIIIAgoAhwhCSAIKAIYIQogCCgCFCELIAgoAhAhDCAIKAIIIQ0gCSAKIAsgDCANEOQKIQ4gCCAONgIEIAgoAgghDyAPKAIAIRAgCCgCDCERIAgoAhAhEiARIBIgEBEBACETQQEhFCATIBRxIRUCQCAVRQ0AIAgoAhAhFiAIKAIMIRcgFiAXEOIKIAgoAgQhGEEBIRkgGCAZaiEaIAggGjYCBCAIKAIIIRsgGygCACEcIAgoAhAhHSAIKAIUIR4gHSAeIBwRAQAhH0EBISAgHyAgcSEhAkAgIUUNACAIKAIUISIgCCgCECEjICIgIxDiCiAIKAIEISRBASElICQgJWohJiAIICY2AgQgCCgCCCEnICcoAgAhKCAIKAIUISkgCCgCGCEqICkgKiAoEQEAIStBASEsICsgLHEhLQJAIC1FDQAgCCgCGCEuIAgoAhQhLyAuIC8Q4gogCCgCBCEwQQEhMSAwIDFqITIgCCAyNgIEIAgoAgghMyAzKAIAITQgCCgCGCE1IAgoAhwhNiA1IDYgNBEBACE3QQEhOCA3IDhxITkCQCA5RQ0AIAgoAhwhOiAIKAIYITsgOiA7EOIKIAgoAgQhPEEBIT0gPCA9aiE+IAggPjYCBAsLCwsgCCgCBCE/QSAhQCAIIEBqIUEgQSQAID8PC98EAUh/IwAhA0HAACEEIAMgBGshBSAFJAAgBSAANgI8IAUgATYCOCAFIAI2AjQgBSgCPCEGQcAAIQcgBiAHaiEIIAUgCDYCMCAFKAI8IQkgBSgCPCEKQSAhCyAKIAtqIQwgBSgCMCENIAUoAjQhDiAJIAwgDSAOEOMKGiAFKAIwIQ9BICEQIA8gEGohESAFIBE2AiwCQANAIAUoAiwhEiAFKAI4IRMgEiEUIBMhFSAUIBVHIRZBASEXIBYgF3EhGCAYRQ0BIAUoAjQhGSAZKAIAIRogBSgCLCEbIAUoAjAhHCAbIBwgGhEBACEdQQEhHiAdIB5xIR8CQCAfRQ0AIAUoAiwhICAgENkCISFBCCEiIAUgImohIyAjISQgJCAhEOoCGiAFKAIwISUgBSAlNgIEIAUoAiwhJiAFICY2AjADQCAFKAIEIScgJxDZAiEoIAUoAjAhKSApICgQ6AoaIAUoAgQhKiAFICo2AjAgBSgCMCErIAUoAjwhLCArIS0gLCEuIC0gLkchL0EAITBBASExIC8gMXEhMiAwITMCQCAyRQ0AIAUoAjQhNCA0KAIAITUgBSgCBCE2QWAhNyA2IDdqITggBSA4NgIEQQghOSAFIDlqITogOiE7IDsgOCA1EQEAITwgPCEzCyAzIT1BASE+ID0gPnEhPyA/DQALQQghQCAFIEBqIUEgQSFCIEIQ2QIhQyAFKAIwIUQgRCBDEOgKGgsgBSgCLCFFIAUgRTYCMCAFKAIsIUZBICFHIEYgR2ohSCAFIEg2AiwMAAsAC0HAACFJIAUgSWohSiBKJAAPC6ELAaMBfyMAIQNB0AAhBCADIARrIQUgBSQAIAUgADYCSCAFIAE2AkQgBSACNgJAIAUoAkQhBiAFKAJIIQcgBiAHayEIQSAhCSAIIAltIQpBBSELIAogC0saAkACQAJAAkACQAJAAkAgCg4GAAABAgMEBQtBASEMQQEhDSAMIA1xIQ4gBSAOOgBPDAULIAUoAkAhDyAPKAIAIRAgBSgCRCERQWAhEiARIBJqIRMgBSATNgJEIAUoAkghFCATIBQgEBEBACEVQQEhFiAVIBZxIRcCQCAXRQ0AIAUoAkghGCAFKAJEIRkgGCAZEOIKC0EBIRpBASEbIBogG3EhHCAFIBw6AE8MBAsgBSgCSCEdIAUoAkghHkEgIR8gHiAfaiEgIAUoAkQhIUFgISIgISAiaiEjIAUgIzYCRCAFKAJAISQgHSAgICMgJBDjChpBASElQQEhJiAlICZxIScgBSAnOgBPDAMLIAUoAkghKCAFKAJIISlBICEqICkgKmohKyAFKAJIISxBwAAhLSAsIC1qIS4gBSgCRCEvQWAhMCAvIDBqITEgBSAxNgJEIAUoAkAhMiAoICsgLiAxIDIQ5AoaQQEhM0EBITQgMyA0cSE1IAUgNToATwwCCyAFKAJIITYgBSgCSCE3QSAhOCA3IDhqITkgBSgCSCE6QcAAITsgOiA7aiE8IAUoAkghPUHgACE+ID0gPmohPyAFKAJEIUBBYCFBIEAgQWohQiAFIEI2AkQgBSgCQCFDIDYgOSA8ID8gQiBDEOUKGkEBIURBASFFIEQgRXEhRiAFIEY6AE8MAQsgBSgCSCFHQcAAIUggRyBIaiFJIAUgSTYCPCAFKAJIIUogBSgCSCFLQSAhTCBLIExqIU0gBSgCPCFOIAUoAkAhTyBKIE0gTiBPEOMKGkEIIVAgBSBQNgI4QQAhUSAFIFE2AjQgBSgCPCFSQSAhUyBSIFNqIVQgBSBUNgIwAkADQCAFKAIwIVUgBSgCRCFWIFUhVyBWIVggVyBYRyFZQQEhWiBZIFpxIVsgW0UNASAFKAJAIVwgXCgCACFdIAUoAjAhXiAFKAI8IV8gXiBfIF0RAQAhYEEBIWEgYCBhcSFiAkAgYkUNACAFKAIwIWMgYxDZAiFkQRAhZSAFIGVqIWYgZiFnIGcgZBDqAhogBSgCPCFoIAUgaDYCDCAFKAIwIWkgBSBpNgI8A0AgBSgCDCFqIGoQ2QIhayAFKAI8IWwgbCBrEOgKGiAFKAIMIW0gBSBtNgI8IAUoAjwhbiAFKAJIIW8gbiFwIG8hcSBwIHFHIXJBACFzQQEhdCByIHRxIXUgcyF2AkAgdUUNACAFKAJAIXcgdygCACF4IAUoAgwheUFgIXogeSB6aiF7IAUgezYCDEEQIXwgBSB8aiF9IH0hfiB+IHsgeBEBACF/IH8hdgsgdiGAAUEBIYEBIIABIIEBcSGCASCCAQ0AC0EQIYMBIAUggwFqIYQBIIQBIYUBIIUBENkCIYYBIAUoAjwhhwEghwEghgEQ6AoaIAUoAjQhiAFBASGJASCIASCJAWohigEgBSCKATYCNEEIIYsBIIoBIYwBIIsBIY0BIIwBII0BRiGOAUEBIY8BII4BII8BcSGQAQJAIJABRQ0AIAUoAjAhkQFBICGSASCRASCSAWohkwEgBSCTATYCMCAFKAJEIZQBIJMBIZUBIJQBIZYBIJUBIJYBRiGXAUEBIZgBIJcBIJgBcSGZASAFIJkBOgBPDAQLCyAFKAIwIZoBIAUgmgE2AjwgBSgCMCGbAUEgIZwBIJsBIJwBaiGdASAFIJ0BNgIwDAALAAtBASGeAUEBIZ8BIJ4BIJ8BcSGgASAFIKABOgBPCyAFLQBPIaEBQQEhogEgoQEgogFxIaMBQdAAIaQBIAUgpAFqIaUBIKUBJAAgowEPC98BAhl/AX4jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGKAIAIQcgBSAHNgIAQQQhCCAFIAhqIQkgBCgCCCEKQQQhCyAKIAtqIQwgDCkCACEbIAkgGzcCAEEMIQ0gBSANaiEOIAQoAgghD0EMIRAgDyAQaiERIA4gERDoARpBFCESIAUgEmohEyAEKAIIIRRBFCEVIBQgFWohFiATIBYQ6AEaIAQoAgghFyAXKAIcIRggBSAYNgIcQRAhGSAEIBlqIRogGiQAIAUPC4UBAQ9/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQMRpBACEFIAQgBTYCAEEAIQYgBCAGNgIEQQghByAEIAdqIQhBACEJIAMgCTYCCEEIIQogAyAKaiELIAshDCADIQ0gCCAMIA0QggsaQRAhDiADIA5qIQ8gDyQAIAQPCzoBBn8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBEEAIQUgBCAFNgIAQQAhBiAEIAY2AgQgBA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQhgshB0EQIQggAyAIaiEJIAkkACAHDwuzAQEVfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQVBCCEGIAQgBmohByAHIQhBASEJIAggBSAJEIcLGiAFEIgLIQogBCgCDCELIAsQiQshDCAEKAIYIQ0gDRCKCyEOIAogDCAOEIsLIAQoAgwhD0EwIRAgDyAQaiERIAQgETYCDEEIIRIgBCASaiETIBMhFCAUEIwLGkEgIRUgBCAVaiEWIBYkAA8L3QEBGH8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAUQiAshBiAEIAY2AhQgBRCNCyEHQQEhCCAHIAhqIQkgBSAJEI4LIQogBRCNCyELIAQoAhQhDCAEIQ0gDSAKIAsgDBCPCxogBCgCFCEOIAQoAgghDyAPEIkLIRAgBCgCGCERIBEQigshEiAOIBAgEhCLCyAEKAIIIRNBMCEUIBMgFGohFSAEIBU2AgggBCEWIAUgFhCQCyAEIRcgFxCRCxpBICEYIAQgGGohGSAZJAAPC1wBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCACEFQQghBiAEIAZqIQcgByEIIAggBRC/CxogBCgCCCEJQRAhCiAEIApqIQsgCyQAIAkPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ8AohBiAEKAIIIQcgBxDwCiEIIAYhCSAIIQogCSAKRiELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwtaAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAUoAgQhCCAGIAcgCBDAC0EQIQkgBSAJaiEKIAokAA8LhAIBHn8jACEFQSAhBiAFIAZrIQcgByQAIAcgADYCHCAHIAE2AhggByACNgIUIAcgAzYCECAHIAQ2AgwgBygCFCEIIAcoAhwhCSAHKAIYIQogCCAJIAoQxwshC0EBIQxBASENIAsgDXEhDiAMIQ8CQCAODQAgBygCFCEQIAcoAhghESAHKAIcIRIgECARIBIQxwshE0EAIRRBASEVIBMgFXEhFiAUIRcCQCAWDQAgBygCHCEYIAcoAhghGSAHKAIQIRogBygCDCEbIBggGSAaIBsQyAshHCAcIRcLIBchHSAdIQ8LIA8hHkEBIR8gHiAfcSEgQSAhISAHICFqISIgIiQAICAPC1IBCX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUoAgAhB0EwIQggBiAIbCEJIAcgCWohCiAFIAo2AgAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC8UUAcgCfyMAIQZBwAAhByAGIAdrIQggCCQAIAggBDYCOCAIIAU2AjAgCCAANgIsIAggATYCKCAIIAM3AxggCCACNwMQIAgoAiwhCUEAIQogCCAKOgAPAkADQEE4IQsgCCALaiEMIAwhDUEwIQ4gCCAOaiEPIA8hECANIBAQlAIhEUEBIRIgESAScSETIBNFDQEDQEE4IRQgCCAUaiEVIBUhFkEwIRcgCCAXaiEYIBghGSAWIBkQlAIhGkEAIRtBASEcIBogHHEhHSAbIR4CQCAdRQ0AQTghHyAIIB9qISAgICEhICEQnQIhIiAiKAIIISNBDCEkICMgJGohJSAlEA0hJkE4IScgCCAnaiEoICghKSApEJ0CISogKigCCCErQRQhLCArICxqIS0gLRANIS4gJiEvIC4hMCAvIDBHITEgMSEeCyAeITJBASEzIDIgM3EhNAJAIDRFDQBBOCE1IAggNWohNiA2ITcgNxCdAiE4IDgtACEhOUEBITogOSA6cSE7AkAgO0UNACAJKAIIITxBOCE9IAggPWohPiA+IT8gPxCVAiFAIAkgQBDRCyFBIEEgPDYCAAtBAiFCIAkgQmohQ0E4IUQgCCBEaiFFIEUhRiBGEJUCIUcgQyBHENILIUhBASFJIEggSXEhSgJAIEpFDQBBOCFLIAggS2ohTCBMIU0gTRCdAiFOIE4tACEhT0EBIVAgTyBQcSFRAkAgUQ0AQTghUiAIIFJqIVMgUyFUIFQQnQIhVSBVKAIIIVYgVigCHCFXIAkoAgQhWCBYIFdqIVkgCSBZNgIEC0E4IVogCCBaaiFbIFshXCBcEJ0CIV0gXS0AIiFeQQEhXyBeIF9xIWACQCBgDQBBOCFhIAggYWohYiBiIWMgYxCdAiFkIGQoAgghZSBlKAIcIWYgCSgCCCFnIGcgZmohaCAJIGg2AggLC0E4IWkgCCBpaiFqIGohayBrEJ0CIWwgbC0AISFtQQEhbiBtIG5xIW8CQCBvRQ0AIAkoAgghcEEBIXEgCSBxaiFyQTghcyAIIHNqIXQgdCF1IHUQlQIhdiByIHYQ0wshdyB3IHA2AgALQTgheCAIIHhqIXkgeSF6IHoQlwIaDAELC0E4IXsgCCB7aiF8IHwhfSB9EJ0CIX4gfi0AISF/QQEhgAEgfyCAAXEhgQEgCCCBAToADkEIIYIBIAggggFqIYMBIIMBIYQBQTghhQEgCCCFAWohhgEghgEhhwEghwEoAgAhiAEghAEgiAE2AgADQEEIIYkBIAggiQFqIYoBIIoBIYsBQTAhjAEgCCCMAWohjQEgjQEhjgEgiwEgjgEQlAIhjwFBACGQAUEBIZEBII8BIJEBcSGSASCQASGTAQJAIJIBRQ0AQQghlAEgCCCUAWohlQEglQEhlgEglgEQnQIhlwEglwEoAgghmAFBDCGZASCYASCZAWohmgEgmgEQDSGbAUEIIZwBIAggnAFqIZ0BIJ0BIZ4BIJ4BEJ0CIZ8BIJ8BKAIIIaABQRQhoQEgoAEgoQFqIaIBIKIBEA0howEgmwEhpAEgowEhpQEgpAEgpQFGIaYBQQAhpwFBASGoASCmASCoAXEhqQEgpwEhkwEgqQFFDQBBCCGqASAIIKoBaiGrASCrASGsASCsARCdAiGtASCtAS0AISGuAUEBIa8BIK4BIK8BcSGwASAILQAOIbEBQQEhsgEgsQEgsgFxIbMBILABIbQBILMBIbUBILQBILUBRiG2ASC2ASGTAQsgkwEhtwFBASG4ASC3ASC4AXEhuQECQCC5AUUNACAJKAIEIboBQQghuwEgCCC7AWohvAEgvAEhvQEgvQEQlQIhvgEgCSC+ARDRCyG/ASC/ASC6ATYCAEECIcABIAkgwAFqIcEBQQghwgEgCCDCAWohwwEgwwEhxAEgxAEQlQIhxQEgwQEgxQEQ0gshxgFBASHHASDGASDHAXEhyAECQCDIAUUNAEEIIckBIAggyQFqIcoBIMoBIcsBIMsBEJ0CIcwBIMwBKAIIIc0BIM0BKAIcIc4BIAkoAgQhzwEgzwEgzgFqIdABIAkg0AE2AgQLIAkoAgQh0QFBASHSASAJINIBaiHTAUEIIdQBIAgg1AFqIdUBINUBIdYBINYBEJUCIdcBINMBINcBENMLIdgBINgBINEBNgIAQQgh2QEgCCDZAWoh2gEg2gEh2wEg2wEQlwIaDAELCyAIIdwBQTgh3QEgCCDdAWoh3gEg3gEh3wEg3wEoAgAh4AEg3AEg4AE2AgADQCAIIeEBQTAh4gEgCCDiAWoh4wEg4wEh5AEg4QEg5AEQlAIh5QFBACHmAUEBIecBIOUBIOcBcSHoASDmASHpAQJAIOgBRQ0AIAgh6gEg6gEQnQIh6wEg6wEoAggh7AFBDCHtASDsASDtAWoh7gEg7gEQDSHvASAIIfABIPABEJ0CIfEBIPEBKAIIIfIBQRQh8wEg8gEg8wFqIfQBIPQBEA0h9QEg7wEh9gEg9QEh9wEg9gEg9wFGIfgBQQAh+QFBASH6ASD4ASD6AXEh+wEg+QEh6QEg+wFFDQAgCCH8ASD8ARCdAiH9ASD9AS0AISH+AUEBIf8BIP4BIP8BcSGAAiAILQAOIYECQQEhggIggQIgggJxIYMCIIACIYQCIIMCIYUCIIQCIIUCRiGGAiCGAiHpAQsg6QEhhwJBASGIAiCHAiCIAnEhiQICQCCJAkUNAEECIYoCIAkgigJqIYsCIAghjAIgjAIQlQIhjQIgiwIgjQIQ0gshjgJBASGPAiCOAiCPAnEhkAICQCCQAkUNACAIIZECIJECEJ0CIZICIJICKAIIIZMCIJMCKAIcIZQCIAkoAgQhlQIglQIglAJrIZYCIAkglgI2AgQLIAghlwIglwIQlwIaDAELCwNAQTghmAIgCCCYAmohmQIgmQIhmgJBMCGbAiAIIJsCaiGcAiCcAiGdAiCaAiCdAhCUAiGeAkEAIZ8CQQEhoAIgngIgoAJxIaECIJ8CIaICAkAgoQJFDQBBOCGjAiAIIKMCaiGkAiCkAiGlAiClAhCdAiGmAiCmAigCCCGnAkEMIagCIKcCIKgCaiGpAiCpAhANIaoCQTghqwIgCCCrAmohrAIgrAIhrQIgrQIQnQIhrgIgrgIoAgghrwJBFCGwAiCvAiCwAmohsQIgsQIQDSGyAiCqAiGzAiCyAiG0AiCzAiC0AkYhtQJBACG2AkEBIbcCILUCILcCcSG4AiC2AiGiAiC4AkUNAEE4IbkCIAgguQJqIboCILoCIbsCILsCEJ0CIbwCILwCLQAhIb0CQQEhvgIgvQIgvgJxIb8CIAgtAA4hwAJBASHBAiDAAiDBAnEhwgIgvwIhwwIgwgIhxAIgwwIgxAJGIcUCIMUCIaICCyCiAiHGAkEBIccCIMYCIMcCcSHIAgJAIMgCRQ0AQTghyQIgCCDJAmohygIgygIhywIgywIQlwIaDAELCwwACwALQcAAIcwCIAggzAJqIc0CIM0CJAAPC6kCAhp/BH4jACEGQdAAIQcgBiAHayEIIAgkACAIIAM2AkggCCAENgJAIAggADYCPCAIIAI3AyggCCABNwMgIAggBTYCHCAIKAIcIQkgCCgCPCEKIAgpAyghICAIKQMgISEgCCgCSCELIAggCzYCGCAIKAJAIQwgCCAMNgIQIAgoAhghDSAIKAIQIQ4gCSAKICEgICANIA4Q1AsgCCgCPCEPIAgpAyghIiAIKQMgISNBCCEQIAggEGohESARIRJByAAhEyAIIBNqIRQgFCEVIBUoAgAhFiASIBY2AgAgCCEXQcAAIRggCCAYaiEZIBkhGiAaKAIAIRsgFyAbNgIAIAgoAgghHCAIKAIAIR0gDyAjICIgHCAdENULQdAAIR4gCCAeaiEfIB8kAA8LZQEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRDWCyEGIAQoAgghByAHEPAKIQggBiAIayEJQTAhCiAJIAptIQtBECEMIAQgDGohDSANJAAgCw8LZAEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhDXCyEHQX8hCCAHIAhzIQlBASEKIAkgCnEhC0EQIQwgBCAMaiENIA0kACALDwtlAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFENYLIQYgBCgCCCEHIAcQ1gshCCAGIAhrIQlBMCEKIAkgCm0hC0EQIQwgBCAMaiENIA0kACALDwtzAQx/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBhDaCyEHIAUoAgghCCAIENoLIQkgBSgCBCEKIAoQ2gshCyAHIAkgCxDbCyEMQRAhDSAFIA1qIQ4gDiQAIAwPC3QBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQ/AogBRCNCyEHIAQgBzYCBCAEKAIIIQggBSAIENgLIAQoAgQhCSAFIAkQ2QtBECEKIAQgCmohCyALJAAPCyIBA38jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCA8LgQIBIX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCECAFIAE2AgggBSACNgIEAkADQEEQIQYgBSAGaiEHIAchCEEIIQkgBSAJaiEKIAohCyAIIAsQlAIhDEEBIQ0gDCANcSEOIA5FDQEgBSgCBCEPQRAhECAFIBBqIREgESESIBIQlQIhEyAPIBMQ/gohFEEBIRUgFCAVcSEWAkAgFkUNAAwCC0EQIRcgBSAXaiEYIBghGSAZEJcCGgwACwALQRghGiAFIBpqIRsgGyEcQRAhHSAFIB1qIR4gHiEfIB8oAgAhICAcICA2AgAgBSgCGCEhQSAhIiAFICJqISMgIyQAICEPCz0BB38jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIIIQUgBS0AIiEGQQEhByAGIAdxIQggCA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC6kBARZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQtAshBSAEELQLIQYgBBCYCyEHQTAhCCAHIAhsIQkgBiAJaiEKIAQQtAshCyAEEI0LIQxBMCENIAwgDWwhDiALIA5qIQ8gBBC0CyEQIAQQmAshEUEwIRIgESASbCETIBAgE2ohFCAEIAUgCiAPIBQQtQtBECEVIAMgFWohFiAWJAAPC5UBARF/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgggAygCCCEEIAMgBDYCDCAEKAIAIQVBACEGIAUhByAGIQggByAIRyEJQQEhCiAJIApxIQsCQCALRQ0AIAQQ3AsgBBCICyEMIAQoAgAhDSAEEKYLIQ4gDCANIA4QowsLIAMoAgwhD0EQIRAgAyAQaiERIBEkACAPDwtsAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQMyEIIAYgCBCDCxogBSgCBCEJIAkQNRogBhCECxpBECEKIAUgCmohCyALJAAgBg8LVQEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQMxpBACEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQhQsaQRAhBSADIAVqIQYgBiQAIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQkgshBUEQIQYgAyAGaiEHIAckACAFDwuDAQENfyMAIQNBECEEIAMgBGshBSAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAYgBzYCACAFKAIIIQggCCgCBCEJIAYgCTYCBCAFKAIIIQogCigCBCELIAUoAgQhDEEwIQ0gDCANbCEOIAsgDmohDyAGIA82AgggBg8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQlAshB0EQIQggAyAIaiEJIAkkACAHDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC2EBCX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCHCAFIAE2AhggBSACNgIUIAUoAhwhBiAFKAIYIQcgBSgCFCEIIAgQigshCSAGIAcgCRCTC0EgIQogBSAKaiELIAskAA8LOQEGfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgQhBSAEKAIAIQYgBiAFNgIEIAQPC0QBCX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCgCACEGIAUgBmshB0EwIQggByAIbSEJIAkPC7ICASV/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhggBCABNgIUIAQoAhghBSAFEJcLIQYgBCAGNgIQIAQoAhQhByAEKAIQIQggByEJIAghCiAJIApLIQtBASEMIAsgDHEhDQJAIA1FDQAgBRC1GgALIAUQmAshDiAEIA42AgwgBCgCDCEPIAQoAhAhEEEBIREgECARdiESIA8hEyASIRQgEyAUTyEVQQEhFiAVIBZxIRcCQAJAIBdFDQAgBCgCECEYIAQgGDYCHAwBCyAEKAIMIRlBASEaIBkgGnQhGyAEIBs2AghBCCEcIAQgHGohHSAdIR5BFCEfIAQgH2ohICAgISEgHiAhEGchIiAiKAIAISMgBCAjNgIcCyAEKAIcISRBICElIAQgJWohJiAmJAAgJA8LrgIBIH8jACEEQSAhBSAEIAVrIQYgBiQAIAYgADYCGCAGIAE2AhQgBiACNgIQIAYgAzYCDCAGKAIYIQcgBiAHNgIcQQwhCCAHIAhqIQlBACEKIAYgCjYCCCAGKAIMIQtBCCEMIAYgDGohDSANIQ4gCSAOIAsQmQsaIAYoAhQhDwJAAkAgD0UNACAHEJoLIRAgBigCFCERIBAgERCbCyESIBIhEwwBC0EAIRQgFCETCyATIRUgByAVNgIAIAcoAgAhFiAGKAIQIRdBMCEYIBcgGGwhGSAWIBlqIRogByAaNgIIIAcgGjYCBCAHKAIAIRsgBigCFCEcQTAhHSAcIB1sIR4gGyAeaiEfIAcQnAshICAgIB82AgAgBigCHCEhQSAhIiAGICJqISMgIyQAICEPC/sBARt/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEIALIAUQiAshBiAFKAIAIQcgBSgCBCEIIAQoAgghCUEEIQogCSAKaiELIAYgByAIIAsQnQsgBCgCCCEMQQQhDSAMIA1qIQ4gBSAOEJ4LQQQhDyAFIA9qIRAgBCgCCCERQQghEiARIBJqIRMgECATEJ4LIAUQ6wohFCAEKAIIIRUgFRCcCyEWIBQgFhCeCyAEKAIIIRcgFygCBCEYIAQoAgghGSAZIBg2AgAgBRCNCyEaIAUgGhCfCyAFEKALQRAhGyAEIBtqIRwgHCQADwuVAQERfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIIIAMoAgghBCADIAQ2AgwgBBChCyAEKAIAIQVBACEGIAUhByAGIQggByAIRyEJQQEhCiAJIApxIQsCQCALRQ0AIAQQmgshDCAEKAIAIQ0gBBCiCyEOIAwgDSAOEKMLCyADKAIMIQ9BECEQIAMgEGohESARJAAgDw8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC2EBCX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCFCAFIAE2AhAgBSACNgIMIAUoAhQhBiAFKAIQIQcgBSgCDCEIIAgQigshCSAGIAcgCRCVC0EgIQogBSAKaiELIAskAA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEJYLIQVBECEGIAMgBmohByAHJAAgBQ8LgQICF38GfiMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAUoAgQhByAHEIoLIQggCCkDACEaIAYgGjcDAEEoIQkgBiAJaiEKIAggCWohCyALKQMAIRsgCiAbNwMAQSAhDCAGIAxqIQ0gCCAMaiEOIA4pAwAhHCANIBw3AwBBGCEPIAYgD2ohECAIIA9qIREgESkDACEdIBAgHTcDAEEQIRIgBiASaiETIAggEmohFCAUKQMAIR4gEyAeNwMAQQghFSAGIBVqIRYgCCAVaiEXIBcpAwAhHyAWIB83AwBBECEYIAUgGGohGSAZJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwuEAQERfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEKQLIQUgBRClCyEGIAMgBjYCCBB0IQcgAyAHNgIEQQghCCADIAhqIQkgCSEKQQQhCyADIAtqIQwgDCENIAogDRB1IQ4gDigCACEPQRAhECADIBBqIREgESQAIA8PCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCmCyEFQRAhBiADIAZqIQcgByQAIAUPC3sBDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxAzIQggBiAIEIMLGkEEIQkgBiAJaiEKIAUoAgQhCyALEK4LIQwgCiAMEK8LGkEQIQ0gBSANaiEOIA4kACAGDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhCxCyEHQRAhCCADIAhqIQkgCSQAIAcPC1QBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBkEAIQcgBSAGIAcQsAshCEEQIQkgBCAJaiEKIAokACAIDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhCyCyEHQRAhCCADIAhqIQkgCSQAIAcPC4ECAR9/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhwgBiABNgIYIAYgAjYCFCAGIAM2AhAgBigCFCEHIAYoAhghCCAHIAhrIQlBMCEKIAkgCm0hCyAGIAs2AgwgBigCDCEMIAYoAhAhDSANKAIAIQ5BACEPIA8gDGshEEEwIREgECARbCESIA4gEmohEyANIBM2AgAgBigCDCEUQQAhFSAUIRYgFSEXIBYgF0ohGEEBIRkgGCAZcSEaAkAgGkUNACAGKAIQIRsgGygCACEcIAYoAhghHSAGKAIMIR5BMCEfIB4gH2whICAcIB0gIBDjGhoLQSAhISAGICFqISIgIiQADwufAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRC2CyEGIAYoAgAhByAEIAc2AgQgBCgCCCEIIAgQtgshCSAJKAIAIQogBCgCDCELIAsgCjYCAEEEIQwgBCAMaiENIA0hDiAOELYLIQ8gDygCACEQIAQoAgghESARIBA2AgBBECESIAQgEmohEyATJAAPC7ABARZ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFELQLIQYgBRC0CyEHIAUQmAshCEEwIQkgCCAJbCEKIAcgCmohCyAFELQLIQwgBRCYCyENQTAhDiANIA5sIQ8gDCAPaiEQIAUQtAshESAEKAIIIRJBMCETIBIgE2whFCARIBRqIRUgBSAGIAsgECAVELULQRAhFiAEIBZqIRcgFyQADwsbAQN/IwAhAUEQIQIgASACayEDIAMgADYCDA8LQwEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCAFELcLQRAhBiADIAZqIQcgByQADwteAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQuQshBSAFKAIAIQYgBCgCACEHIAYgB2shCEEwIQkgCCAJbSEKQRAhCyADIAtqIQwgDCQAIAoPC1oBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBSgCBCEIIAYgByAIELgLQRAhCSAFIAlqIQogCiQADwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhCoCyEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCnCyEFQRAhBiADIAZqIQcgByQAIAUPC14BDH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCrCyEFIAUoAgAhBiAEKAIAIQcgBiAHayEIQTAhCSAIIAltIQpBECELIAMgC2ohDCAMJAAgCg8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEEKkLIQVBECEGIAMgBmohByAHJAAgBQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEKoLIQVBECEGIAMgBmohByAHJAAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgxB1arVKiEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhCsCyEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCtCyEFQRAhBiADIAZqIQcgByQAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LUwEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQrgshByAFIAc2AgBBECEIIAQgCGohCSAJJAAgBQ8LnwEBE38jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBhCpCyEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AQeQIIQ4gDhCDAQALIAUoAgghD0EwIRAgDyAQbCERQRAhEiARIBIQhAEhE0EQIRQgBSAUaiEVIBUkACATDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQQhBSAEIAVqIQYgBhCzCyEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCSCyEFQRAhBiADIAZqIQcgByQAIAUPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBQ8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIAIQUgBRCJCyEGQRAhByADIAdqIQggCCQAIAYPCzcBA38jACEFQSAhBiAFIAZrIQcgByAANgIcIAcgATYCGCAHIAI2AhQgByADNgIQIAcgBDYCDA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQugtBECEHIAQgB2ohCCAIJAAPC2EBCn8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQdBMCEIIAcgCGwhCUEQIQogBiAJIAoQSUEQIQsgBSALaiEMIAwkAA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQvgshB0EQIQggAyAIaiEJIAkkACAHDwugAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUCQANAIAQoAgAhBiAFKAIIIQcgBiEIIAchCSAIIAlHIQpBASELIAogC3EhDCAMRQ0BIAUQmgshDSAFKAIIIQ5BUCEPIA4gD2ohECAFIBA2AgggEBCJCyERIA0gERC7CwwACwALQRAhEiAEIBJqIRMgEyQADwtKAQd/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAEKAIYIQYgBSAGELwLQSAhByAEIAdqIQggCCQADwtKAQd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgQhBSAEKAIAIQYgBSAGEL0LQRAhByAEIAdqIQggCCQADwsiAQN/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AggPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCtCyEFQRAhBiADIAZqIQcgByQAIAUPCzkBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCACAFDwvEGwHjAn8jACEDQTAhBCADIARrIQUgBSQAIAUgADYCLCAFIAE2AiggBSACNgIkQR4hBiAFIAY2AiADQAJAAkADQCAFKAIoIQcgBSgCLCEIIAcgCGshCUEwIQogCSAKbSELIAUgCzYCHCAFKAIcIQxBBSENIAwgDUsaAkACQAJAAkACQAJAIAwOBgAAAQIDBAULDAcLIAUoAiQhDiAOKAIAIQ8gBSgCKCEQQVAhESAQIBFqIRIgBSASNgIoIAUoAiwhEyASIBMgDxEBACEUQQEhFSAUIBVxIRYCQCAWRQ0AIAUoAiwhFyAFKAIoIRggFyAYEMELCwwGCyAFKAIsIRkgBSgCLCEaQTAhGyAaIBtqIRwgBSgCKCEdQVAhHiAdIB5qIR8gBSAfNgIoIAUoAiQhICAZIBwgHyAgEMILGgwFCyAFKAIsISEgBSgCLCEiQTAhIyAiICNqISQgBSgCLCElQeAAISYgJSAmaiEnIAUoAighKEFQISkgKCApaiEqIAUgKjYCKCAFKAIkISsgISAkICcgKiArEMMLGgwECyAFKAIsISwgBSgCLCEtQTAhLiAtIC5qIS8gBSgCLCEwQeAAITEgMCAxaiEyIAUoAiwhM0GQASE0IDMgNGohNSAFKAIoITZBUCE3IDYgN2ohOCAFIDg2AiggBSgCJCE5ICwgLyAyIDUgOCA5EMQLGgwDCyAFKAIcITpBHiE7IDohPCA7IT0gPCA9TCE+QQEhPyA+ID9xIUACQCBARQ0AIAUoAiwhQSAFKAIoIUIgBSgCJCFDIEEgQiBDEMULDAMLIAUoAiwhRCAFIEQ2AhggBSgCKCFFIAUgRTYCFCAFKAIUIUZBUCFHIEYgR2ohSCAFIEg2AhQgBSgCHCFJQegHIUogSSFLIEohTCBLIExOIU1BASFOIE0gTnEhTwJAAkAgT0UNACAFKAIcIVBBAiFRIFAgUW0hUiAFIFI2AgwgBSgCDCFTIAUoAhghVEEwIVUgUyBVbCFWIFQgVmohVyAFIFc2AhggBSgCDCFYQQIhWSBYIFltIVogBSBaNgIMIAUoAiwhWyAFKAIsIVwgBSgCDCFdQTAhXiBdIF5sIV8gXCBfaiFgIAUoAhghYSAFKAIYIWIgBSgCDCFjQTAhZCBjIGRsIWUgYiBlaiFmIAUoAhQhZyAFKAIkIWggWyBgIGEgZiBnIGgQxAshaSAFIGk2AhAMAQsgBSgCHCFqQQIhayBqIGttIWwgBSBsNgIMIAUoAgwhbSAFKAIYIW5BMCFvIG0gb2whcCBuIHBqIXEgBSBxNgIYIAUoAiwhciAFKAIYIXMgBSgCFCF0IAUoAiQhdSByIHMgdCB1EMILIXYgBSB2NgIQCyAFKAIsIXcgBSB3NgIIIAUoAhQheCAFIHg2AgQgBSgCJCF5IHkoAgAheiAFKAIIIXsgBSgCGCF8IHsgfCB6EQEAIX1BASF+IH0gfnEhfyB/DQEDQCAFKAIIIYABIAUoAgQhgQFBUCGCASCBASCCAWohgwEgBSCDATYCBCCAASGEASCDASGFASCEASCFAUYhhgFBASGHASCGASCHAXEhiAECQCCIAUUNACAFKAIIIYkBQTAhigEgiQEgigFqIYsBIAUgiwE2AgggBSgCKCGMASAFIIwBNgIEIAUoAiQhjQEgjQEoAgAhjgEgBSgCLCGPASAFKAIEIZABQVAhkQEgkAEgkQFqIZIBIAUgkgE2AgQgjwEgkgEgjgERAQAhkwFBASGUASCTASCUAXEhlQECQCCVAQ0AA0AgBSgCCCGWASAFKAIEIZcBIJYBIZgBIJcBIZkBIJgBIJkBRiGaAUEBIZsBIJoBIJsBcSGcAQJAIJwBRQ0ADAcLIAUoAiQhnQEgnQEoAgAhngEgBSgCLCGfASAFKAIIIaABIJ8BIKABIJ4BEQEAIaEBQQEhogEgoQEgogFxIaMBAkACQCCjAUUNACAFKAIIIaQBIAUoAgQhpQEgpAEgpQEQwQsgBSgCECGmAUEBIacBIKYBIKcBaiGoASAFIKgBNgIQIAUoAgghqQFBMCGqASCpASCqAWohqwEgBSCrATYCCAwBCyAFKAIIIawBQTAhrQEgrAEgrQFqIa4BIAUgrgE2AggMAQsLCyAFKAIIIa8BIAUoAgQhsAEgrwEhsQEgsAEhsgEgsQEgsgFGIbMBQQEhtAEgswEgtAFxIbUBAkAgtQFFDQAMBQsDQAJAA0AgBSgCJCG2ASC2ASgCACG3ASAFKAIsIbgBIAUoAgghuQEguAEguQEgtwERAQAhugFBfyG7ASC6ASC7AXMhvAFBASG9ASC8ASC9AXEhvgEgvgFFDQEgBSgCCCG/AUEwIcABIL8BIMABaiHBASAFIMEBNgIIDAALAAsCQANAIAUoAiQhwgEgwgEoAgAhwwEgBSgCLCHEASAFKAIEIcUBQVAhxgEgxQEgxgFqIccBIAUgxwE2AgQgxAEgxwEgwwERAQAhyAFBASHJASDIASDJAXEhygEgygFFDQEMAAsACyAFKAIIIcsBIAUoAgQhzAEgywEhzQEgzAEhzgEgzQEgzgFPIc8BQQEh0AEgzwEg0AFxIdEBAkACQCDRAUUNAAwBCyAFKAIIIdIBIAUoAgQh0wEg0gEg0wEQwQsgBSgCECHUAUEBIdUBINQBINUBaiHWASAFINYBNgIQIAUoAggh1wFBMCHYASDXASDYAWoh2QEgBSDZATYCCAwBCwsgBSgCCCHaASAFINoBNgIsDAILIAUoAiQh2wEg2wEoAgAh3AEgBSgCBCHdASAFKAIYId4BIN0BIN4BINwBEQEAId8BQQEh4AEg3wEg4AFxIeEBAkACQCDhAUUNACAFKAIIIeIBIAUoAgQh4wEg4gEg4wEQwQsgBSgCECHkAUEBIeUBIOQBIOUBaiHmASAFIOYBNgIQDAELDAELCwsLIAUoAggh5wFBMCHoASDnASDoAWoh6QEgBSDpATYCCCAFKAIIIeoBIAUoAgQh6wEg6gEh7AEg6wEh7QEg7AEg7QFJIe4BQQEh7wEg7gEg7wFxIfABAkAg8AFFDQADQAJAA0AgBSgCJCHxASDxASgCACHyASAFKAIIIfMBIAUoAhgh9AEg8wEg9AEg8gERAQAh9QFBASH2ASD1ASD2AXEh9wEg9wFFDQEgBSgCCCH4AUEwIfkBIPgBIPkBaiH6ASAFIPoBNgIIDAALAAsCQANAIAUoAiQh+wEg+wEoAgAh/AEgBSgCBCH9AUFQIf4BIP0BIP4BaiH/ASAFIP8BNgIEIAUoAhghgAIg/wEggAIg/AERAQAhgQJBfyGCAiCBAiCCAnMhgwJBASGEAiCDAiCEAnEhhQIghQJFDQEMAAsACyAFKAIIIYYCIAUoAgQhhwIghgIhiAIghwIhiQIgiAIgiQJLIYoCQQEhiwIgigIgiwJxIYwCAkACQCCMAkUNAAwBCyAFKAIIIY0CIAUoAgQhjgIgjQIgjgIQwQsgBSgCECGPAkEBIZACII8CIJACaiGRAiAFIJECNgIQIAUoAhghkgIgBSgCCCGTAiCSAiGUAiCTAiGVAiCUAiCVAkYhlgJBASGXAiCWAiCXAnEhmAICQCCYAkUNACAFKAIEIZkCIAUgmQI2AhgLIAUoAgghmgJBMCGbAiCaAiCbAmohnAIgBSCcAjYCCAwBCwsLIAUoAgghnQIgBSgCGCGeAiCdAiGfAiCeAiGgAiCfAiCgAkchoQJBASGiAiChAiCiAnEhowICQCCjAkUNACAFKAIkIaQCIKQCKAIAIaUCIAUoAhghpgIgBSgCCCGnAiCmAiCnAiClAhEBACGoAkEBIakCIKgCIKkCcSGqAiCqAkUNACAFKAIIIasCIAUoAhghrAIgqwIgrAIQwQsgBSgCECGtAkEBIa4CIK0CIK4CaiGvAiAFIK8CNgIQCyAFKAIQIbACAkAgsAINACAFKAIsIbECIAUoAgghsgIgBSgCJCGzAiCxAiCyAiCzAhDGCyG0AkEBIbUCILQCILUCcSG2AiAFILYCOgADIAUoAgghtwJBMCG4AiC3AiC4AmohuQIgBSgCKCG6AiAFKAIkIbsCILkCILoCILsCEMYLIbwCQQEhvQIgvAIgvQJxIb4CAkAgvgJFDQAgBS0AAyG/AkEBIcACIL8CIMACcSHBAgJAIMECRQ0ADAMLIAUoAgghwgIgBSDCAjYCKAwDCyAFLQADIcMCQQEhxAIgwwIgxAJxIcUCAkAgxQJFDQAgBSgCCCHGAkEwIccCIMYCIMcCaiHIAiAFIMgCNgIIIAUgyAI2AiwMAwsLIAUoAgghyQIgBSgCLCHKAiDJAiDKAmshywJBMCHMAiDLAiDMAm0hzQIgBSgCKCHOAiAFKAIIIc8CIM4CIM8CayHQAkEwIdECINACINECbSHSAiDNAiHTAiDSAiHUAiDTAiDUAkgh1QJBASHWAiDVAiDWAnEh1wICQAJAINcCRQ0AIAUoAiwh2AIgBSgCCCHZAiAFKAIkIdoCINgCINkCINoCEMALIAUoAggh2wJBMCHcAiDbAiDcAmoh3QIgBSDdAjYCCCAFIN0CNgIsDAELIAUoAggh3gJBMCHfAiDeAiDfAmoh4AIgBSgCKCHhAiAFKAIkIeICIOACIOECIOICEMALIAUoAggh4wIgBSDjAjYCKAsMAQsLQTAh5AIgBSDkAmoh5QIg5QIkAA8LvAQCN38OfiMAIQJBwAAhAyACIANrIQQgBCQAIAQgADYCPCAEIAE2AjggBCgCPCEFIAUQ/wohBiAEIQcgBikDACE5IAcgOTcDAEEoIQggByAIaiEJIAYgCGohCiAKKQMAITogCSA6NwMAQSAhCyAHIAtqIQwgBiALaiENIA0pAwAhOyAMIDs3AwBBGCEOIAcgDmohDyAGIA5qIRAgECkDACE8IA8gPDcDAEEQIREgByARaiESIAYgEWohEyATKQMAIT0gEiA9NwMAQQghFCAHIBRqIRUgBiAUaiEWIBYpAwAhPiAVID43AwAgBCgCOCEXIBcQ/wohGCAEKAI8IRkgGCkDACE/IBkgPzcDAEEfIRogGSAaaiEbIBggGmohHCAcKAAAIR0gGyAdNgAAQRghHiAZIB5qIR8gGCAeaiEgICApAwAhQCAfIEA3AwBBECEhIBkgIWohIiAYICFqISMgIykDACFBICIgQTcDAEEIISQgGSAkaiElIBggJGohJiAmKQMAIUIgJSBCNwMAIAQhJyAnEP8KISggBCgCOCEpICgpAwAhQyApIEM3AwBBHyEqICkgKmohKyAoICpqISwgLCgAACEtICsgLTYAAEEYIS4gKSAuaiEvICggLmohMCAwKQMAIUQgLyBENwMAQRAhMSApIDFqITIgKCAxaiEzIDMpAwAhRSAyIEU3AwBBCCE0ICkgNGohNSAoIDRqITYgNikDACFGIDUgRjcDAEHAACE3IAQgN2ohOCA4JAAPC9gEAT1/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhggBiABNgIUIAYgAjYCECAGIAM2AgxBACEHIAYgBzYCCCAGKAIMIQggCCgCACEJIAYoAhQhCiAGKAIYIQsgCiALIAkRAQAhDEEBIQ0gDCANcSEOAkACQCAODQAgBigCDCEPIA8oAgAhECAGKAIQIREgBigCFCESIBEgEiAQEQEAIRNBASEUIBMgFHEhFQJAIBUNACAGKAIIIRYgBiAWNgIcDAILIAYoAhQhFyAGKAIQIRggFyAYEMELQQEhGSAGIBk2AgggBigCDCEaIBooAgAhGyAGKAIUIRwgBigCGCEdIBwgHSAbEQEAIR5BASEfIB4gH3EhIAJAICBFDQAgBigCGCEhIAYoAhQhIiAhICIQwQtBAiEjIAYgIzYCCAsgBigCCCEkIAYgJDYCHAwBCyAGKAIMISUgJSgCACEmIAYoAhAhJyAGKAIUISggJyAoICYRAQAhKUEBISogKSAqcSErAkAgK0UNACAGKAIYISwgBigCECEtICwgLRDBC0EBIS4gBiAuNgIIIAYoAgghLyAGIC82AhwMAQsgBigCGCEwIAYoAhQhMSAwIDEQwQtBASEyIAYgMjYCCCAGKAIMITMgMygCACE0IAYoAhAhNSAGKAIUITYgNSA2IDQRAQAhN0EBITggNyA4cSE5AkAgOUUNACAGKAIUITogBigCECE7IDogOxDBC0ECITwgBiA8NgIICyAGKAIIIT0gBiA9NgIcCyAGKAIcIT5BICE/IAYgP2ohQCBAJAAgPg8LuwMBL38jACEFQSAhBiAFIAZrIQcgByQAIAcgADYCHCAHIAE2AhggByACNgIUIAcgAzYCECAHIAQ2AgwgBygCHCEIIAcoAhghCSAHKAIUIQogBygCDCELIAggCSAKIAsQwgshDCAHIAw2AgggBygCDCENIA0oAgAhDiAHKAIQIQ8gBygCFCEQIA8gECAOEQEAIRFBASESIBEgEnEhEwJAIBNFDQAgBygCFCEUIAcoAhAhFSAUIBUQwQsgBygCCCEWQQEhFyAWIBdqIRggByAYNgIIIAcoAgwhGSAZKAIAIRogBygCFCEbIAcoAhghHCAbIBwgGhEBACEdQQEhHiAdIB5xIR8CQCAfRQ0AIAcoAhghICAHKAIUISEgICAhEMELIAcoAgghIkEBISMgIiAjaiEkIAcgJDYCCCAHKAIMISUgJSgCACEmIAcoAhghJyAHKAIcISggJyAoICYRAQAhKUEBISogKSAqcSErAkAgK0UNACAHKAIcISwgBygCGCEtICwgLRDBCyAHKAIIIS5BASEvIC4gL2ohMCAHIDA2AggLCwsgBygCCCExQSAhMiAHIDJqITMgMyQAIDEPC7MEATx/IwAhBkEgIQcgBiAHayEIIAgkACAIIAA2AhwgCCABNgIYIAggAjYCFCAIIAM2AhAgCCAENgIMIAggBTYCCCAIKAIcIQkgCCgCGCEKIAgoAhQhCyAIKAIQIQwgCCgCCCENIAkgCiALIAwgDRDDCyEOIAggDjYCBCAIKAIIIQ8gDygCACEQIAgoAgwhESAIKAIQIRIgESASIBARAQAhE0EBIRQgEyAUcSEVAkAgFUUNACAIKAIQIRYgCCgCDCEXIBYgFxDBCyAIKAIEIRhBASEZIBggGWohGiAIIBo2AgQgCCgCCCEbIBsoAgAhHCAIKAIQIR0gCCgCFCEeIB0gHiAcEQEAIR9BASEgIB8gIHEhIQJAICFFDQAgCCgCFCEiIAgoAhAhIyAiICMQwQsgCCgCBCEkQQEhJSAkICVqISYgCCAmNgIEIAgoAgghJyAnKAIAISggCCgCFCEpIAgoAhghKiApICogKBEBACErQQEhLCArICxxIS0CQCAtRQ0AIAgoAhghLiAIKAIUIS8gLiAvEMELIAgoAgQhMEEBITEgMCAxaiEyIAggMjYCBCAIKAIIITMgMygCACE0IAgoAhghNSAIKAIcITYgNSA2IDQRAQAhN0EBITggNyA4cSE5AkAgOUUNACAIKAIcITogCCgCGCE7IDogOxDBCyAIKAIEITxBASE9IDwgPWohPiAIID42AgQLCwsLIAgoAgQhP0EgIUAgCCBAaiFBIEEkACA/DwuXCAJxfw5+IwAhA0HgACEEIAMgBGshBSAFJAAgBSAANgJcIAUgATYCWCAFIAI2AlQgBSgCXCEGQeAAIQcgBiAHaiEIIAUgCDYCUCAFKAJcIQkgBSgCXCEKQTAhCyAKIAtqIQwgBSgCUCENIAUoAlQhDiAJIAwgDSAOEMILGiAFKAJQIQ9BMCEQIA8gEGohESAFIBE2AkwCQANAIAUoAkwhEiAFKAJYIRMgEiEUIBMhFSAUIBVHIRZBASEXIBYgF3EhGCAYRQ0BIAUoAlQhGSAZKAIAIRogBSgCTCEbIAUoAlAhHCAbIBwgGhEBACEdQQEhHiAdIB5xIR8CQCAfRQ0AIAUoAkwhICAgEP8KISFBECEiIAUgImohIyAjISQgISkDACF0ICQgdDcDAEEoISUgJCAlaiEmICEgJWohJyAnKQMAIXUgJiB1NwMAQSAhKCAkIChqISkgISAoaiEqICopAwAhdiApIHY3AwBBGCErICQgK2ohLCAhICtqIS0gLSkDACF3ICwgdzcDAEEQIS4gJCAuaiEvICEgLmohMCAwKQMAIXggLyB4NwMAQQghMSAkIDFqITIgISAxaiEzIDMpAwAheSAyIHk3AwAgBSgCUCE0IAUgNDYCDCAFKAJMITUgBSA1NgJQA0AgBSgCDCE2IDYQ/wohNyAFKAJQITggNykDACF6IDggejcDAEEfITkgOCA5aiE6IDcgOWohOyA7KAAAITwgOiA8NgAAQRghPSA4ID1qIT4gNyA9aiE/ID8pAwAheyA+IHs3AwBBECFAIDggQGohQSA3IEBqIUIgQikDACF8IEEgfDcDAEEIIUMgOCBDaiFEIDcgQ2ohRSBFKQMAIX0gRCB9NwMAIAUoAgwhRiAFIEY2AlAgBSgCUCFHIAUoAlwhSCBHIUkgSCFKIEkgSkchS0EAIUxBASFNIEsgTXEhTiBMIU8CQCBORQ0AIAUoAlQhUCBQKAIAIVEgBSgCDCFSQVAhUyBSIFNqIVQgBSBUNgIMQRAhVSAFIFVqIVYgViFXIFcgVCBREQEAIVggWCFPCyBPIVlBASFaIFkgWnEhWyBbDQALQRAhXCAFIFxqIV0gXSFeIF4Q/wohXyAFKAJQIWAgXykDACF+IGAgfjcDAEEfIWEgYCBhaiFiIF8gYWohYyBjKAAAIWQgYiBkNgAAQRghZSBgIGVqIWYgXyBlaiFnIGcpAwAhfyBmIH83AwBBECFoIGAgaGohaSBfIGhqIWogaikDACGAASBpIIABNwMAQQghayBgIGtqIWwgXyBraiFtIG0pAwAhgQEgbCCBATcDAAsgBSgCTCFuIAUgbjYCUCAFKAJMIW9BMCFwIG8gcGohcSAFIHE2AkwMAAsAC0HgACFyIAUgcmohcyBzJAAPC9QPAswBfw5+IwAhA0HgACEEIAMgBGshBSAFJAAgBSAANgJYIAUgATYCVCAFIAI2AlAgBSgCVCEGIAUoAlghByAGIAdrIQhBMCEJIAggCW0hCkEFIQsgCiALSxoCQAJAAkACQAJAAkACQCAKDgYAAAECAwQFC0EBIQxBASENIAwgDXEhDiAFIA46AF8MBQsgBSgCUCEPIA8oAgAhECAFKAJUIRFBUCESIBEgEmohEyAFIBM2AlQgBSgCWCEUIBMgFCAQEQEAIRVBASEWIBUgFnEhFwJAIBdFDQAgBSgCWCEYIAUoAlQhGSAYIBkQwQsLQQEhGkEBIRsgGiAbcSEcIAUgHDoAXwwECyAFKAJYIR0gBSgCWCEeQTAhHyAeIB9qISAgBSgCVCEhQVAhIiAhICJqISMgBSAjNgJUIAUoAlAhJCAdICAgIyAkEMILGkEBISVBASEmICUgJnEhJyAFICc6AF8MAwsgBSgCWCEoIAUoAlghKUEwISogKSAqaiErIAUoAlghLEHgACEtICwgLWohLiAFKAJUIS9BUCEwIC8gMGohMSAFIDE2AlQgBSgCUCEyICggKyAuIDEgMhDDCxpBASEzQQEhNCAzIDRxITUgBSA1OgBfDAILIAUoAlghNiAFKAJYITdBMCE4IDcgOGohOSAFKAJYITpB4AAhOyA6IDtqITwgBSgCWCE9QZABIT4gPSA+aiE/IAUoAlQhQEFQIUEgQCBBaiFCIAUgQjYCVCAFKAJQIUMgNiA5IDwgPyBCIEMQxAsaQQEhREEBIUUgRCBFcSFGIAUgRjoAXwwBCyAFKAJYIUdB4AAhSCBHIEhqIUkgBSBJNgJMIAUoAlghSiAFKAJYIUtBMCFMIEsgTGohTSAFKAJMIU4gBSgCUCFPIEogTSBOIE8QwgsaQQghUCAFIFA2AkhBACFRIAUgUTYCRCAFKAJMIVJBMCFTIFIgU2ohVCAFIFQ2AkACQANAIAUoAkAhVSAFKAJUIVYgVSFXIFYhWCBXIFhHIVlBASFaIFkgWnEhWyBbRQ0BIAUoAlAhXCBcKAIAIV0gBSgCQCFeIAUoAkwhXyBeIF8gXREBACFgQQEhYSBgIGFxIWICQCBiRQ0AIAUoAkAhYyBjEP8KIWRBECFlIAUgZWohZiBmIWcgZCkDACHPASBnIM8BNwMAQSghaCBnIGhqIWkgZCBoaiFqIGopAwAh0AEgaSDQATcDAEEgIWsgZyBraiFsIGQga2ohbSBtKQMAIdEBIGwg0QE3AwBBGCFuIGcgbmohbyBkIG5qIXAgcCkDACHSASBvINIBNwMAQRAhcSBnIHFqIXIgZCBxaiFzIHMpAwAh0wEgciDTATcDAEEIIXQgZyB0aiF1IGQgdGohdiB2KQMAIdQBIHUg1AE3AwAgBSgCTCF3IAUgdzYCDCAFKAJAIXggBSB4NgJMA0AgBSgCDCF5IHkQ/woheiAFKAJMIXsgeikDACHVASB7INUBNwMAQR8hfCB7IHxqIX0geiB8aiF+IH4oAAAhfyB9IH82AABBGCGAASB7IIABaiGBASB6IIABaiGCASCCASkDACHWASCBASDWATcDAEEQIYMBIHsggwFqIYQBIHoggwFqIYUBIIUBKQMAIdcBIIQBINcBNwMAQQghhgEgeyCGAWohhwEgeiCGAWohiAEgiAEpAwAh2AEghwEg2AE3AwAgBSgCDCGJASAFIIkBNgJMIAUoAkwhigEgBSgCWCGLASCKASGMASCLASGNASCMASCNAUchjgFBACGPAUEBIZABII4BIJABcSGRASCPASGSAQJAIJEBRQ0AIAUoAlAhkwEgkwEoAgAhlAEgBSgCDCGVAUFQIZYBIJUBIJYBaiGXASAFIJcBNgIMQRAhmAEgBSCYAWohmQEgmQEhmgEgmgEglwEglAERAQAhmwEgmwEhkgELIJIBIZwBQQEhnQEgnAEgnQFxIZ4BIJ4BDQALQRAhnwEgBSCfAWohoAEgoAEhoQEgoQEQ/wohogEgBSgCTCGjASCiASkDACHZASCjASDZATcDAEEfIaQBIKMBIKQBaiGlASCiASCkAWohpgEgpgEoAAAhpwEgpQEgpwE2AABBGCGoASCjASCoAWohqQEgogEgqAFqIaoBIKoBKQMAIdoBIKkBINoBNwMAQRAhqwEgowEgqwFqIawBIKIBIKsBaiGtASCtASkDACHbASCsASDbATcDAEEIIa4BIKMBIK4BaiGvASCiASCuAWohsAEgsAEpAwAh3AEgrwEg3AE3AwAgBSgCRCGxAUEBIbIBILEBILIBaiGzASAFILMBNgJEQQghtAEgswEhtQEgtAEhtgEgtQEgtgFGIbcBQQEhuAEgtwEguAFxIbkBAkAguQFFDQAgBSgCQCG6AUEwIbsBILoBILsBaiG8ASAFILwBNgJAIAUoAlQhvQEgvAEhvgEgvQEhvwEgvgEgvwFGIcABQQEhwQEgwAEgwQFxIcIBIAUgwgE6AF8MBAsLIAUoAkAhwwEgBSDDATYCTCAFKAJAIcQBQTAhxQEgxAEgxQFqIcYBIAUgxgE2AkAMAAsAC0EBIccBQQEhyAEgxwEgyAFxIckBIAUgyQE6AF8LIAUtAF8hygFBASHLASDKASDLAXEhzAFB4AAhzQEgBSDNAWohzgEgzgEkACDMAQ8LnwECD38EfiMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGQRghByAGIAdqIQggCCkDACESIAYpAxAhEyAFKAIEIQkgCSAHaiEKIAopAwAhFCAJKQMQIRUgEyASIBUgFBClGiELQQAhDCALIAxIIQ1BASEOIA0gDnEhD0EQIRAgBSAQaiERIBEkACAPDwv0AQEdfyMAIQRBECEFIAQgBWshBiAGJAAgBiAANgIMIAYgATYCCCAGIAI2AgQgBiADNgIAIAYoAgQhByAGKAIMIQggBigCCCEJIAcgCCAJEMkLIQpBASELQQEhDCAKIAxxIQ0gCyEOAkAgDQ0AIAYoAgQhDyAGKAIIIRAgBigCDCERIA8gECAREMkLIRJBACETQQEhFCASIBRxIRUgEyEWAkAgFQ0AIAYoAgwhFyAGKAIIIRggBigCACEZIBcgGCAZEMoLIRogGiEWCyAWIRsgGyEOCyAOIRxBASEdIBwgHXEhHkEQIR8gBiAfaiEgICAkACAeDwt3ARB/IwAhA0EQIQQgAyAEayEFIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAGLQAgIQdBASEIIAcgCHEhCSAFKAIEIQogCi0AICELQQEhDCALIAxxIQ0gCSEOIA0hDyAOIA9IIRBBASERIBAgEXEhEiASDwvkAQEcfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCBCEGIAUoAgwhByAFKAIIIQggBiAHIAgQywshCUEBIQpBASELIAkgC3EhDCAKIQ0CQCAMDQAgBSgCBCEOIAUoAgghDyAFKAIMIRAgDiAPIBAQywshEUEAIRJBASETIBEgE3EhFCASIRUCQCAUDQAgBSgCDCEWIAUoAgghFyAWIBcQzAshGCAYIRULIBUhGSAZIQ0LIA0hGkEBIRsgGiAbcSEcQRAhHSAFIB1qIR4gHiQAIBwPC3cBDX8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBygCCCEIIAUoAgQhCSAJKAIIIQogBiAIIAoQzQshC0EBIQwgCyAMcSENQRAhDiAFIA5qIQ8gDyQAIA0PCzMBBn8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCEEAIQVBASEGIAUgBnEhByAHDwuOAQEQfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAYQzgshByAFKAIIIQggCBDPCyEJIAUoAgQhCiAKEM4LIQsgBSgCBCEMIAwQzwshDSAHIAkgCyANENALIQ5BASEPIA4gD3EhEEEQIREgBSARaiESIBIkACAQDwtnAQ5/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQRQhBSAEIAVqIQYgBhANIQcgAygCDCEIQQwhCSAIIAlqIQogChANIQsgByALayEMQRAhDSADIA1qIQ4gDiQAIAwPC2cBDn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBFCEFIAQgBWohBiAGEA4hByADKAIMIQhBDCEJIAggCWohCiAKEA4hCyAHIAtrIQxBECENIAMgDWohDiAOJAAgDA8L5AsCswF/Dn4jACEEQcAAIQUgBCAFayEGIAYgADYCOCAGIAE2AjQgBiACNgIwIAYgAzYCLCAGKAI4IQdBACEIIAchCSAIIQogCSAKSCELQQEhDCALIAxxIQ0CQAJAAkAgDUUNACAGKAI0IQ5BfyEPIA4gD2whECAGIBA2AjQgBigCOCERQX8hEiARIBJsIRMgBiATNgI4DAELIAYoAjghFAJAIBQNAEEAIRVBASEWIBUgFnEhFyAGIBc6AD8MAgsLIAYoAjAhGEEAIRkgGCEaIBkhGyAaIBtIIRxBASEdIBwgHXEhHgJAAkAgHkUNACAGKAIsIR9BfyEgIB8gIGwhISAGICE2AiwgBigCMCEiQX8hIyAiICNsISQgBiAkNgIwDAELIAYoAjAhJQJAICUNACAGKAI4ISZBACEnICYhKCAnISkgKCApRyEqQQEhKyAqICtxISwgBiAsOgA/DAILCyAGKAIwIS1BACEuIC0hLyAuITAgLyAwSCExQQEhMiAxIDJxITMCQAJAIDNFDQAgBigCMCE0QQAhNSA1IDRrITYgNiE3DAELIAYoAjAhOCA4ITcLIDchOSA5ITogOqwhtwEgBigCNCE7QQAhPCA7IT0gPCE+ID0gPkghP0EBIUAgPyBAcSFBAkACQCBBRQ0AIAYoAjQhQkEAIUMgQyBCayFEIEQhRQwBCyAGKAI0IUYgRiFFCyBFIUcgRyFIIEisIbgBILcBILgBfiG5ASAGILkBNwMgIAYoAjghSUEAIUogSSFLIEohTCBLIExIIU1BASFOIE0gTnEhTwJAAkAgT0UNACAGKAI4IVBBACFRIFEgUGshUiBSIVMMAQsgBigCOCFUIFQhUwsgUyFVIFUhViBWrCG6ASAGKAIsIVdBACFYIFchWSBYIVogWSBaSCFbQQEhXCBbIFxxIV0CQAJAIF1FDQAgBigCLCFeQQAhXyBfIF5rIWAgYCFhDAELIAYoAiwhYiBiIWELIGEhYyBjIWQgZKwhuwEgugEguwF+IbwBIAYgvAE3AxggBigCOCFlQQAhZiBlIWcgZiFoIGcgaEghaUF/IWpBASFrQQEhbCBpIGxxIW0gaiBrIG0bIW4gBiBuNgIUIAYoAjAhb0EAIXAgbyFxIHAhciBxIHJIIXNBfyF0QQEhdUEBIXYgcyB2cSF3IHQgdSB3GyF4IAYgeDYCECAGKAI0IXlBACF6IHkheyB6IXwgeyB8SCF9QX8hfkEBIX9BASGAASB9IIABcSGBASB+IH8ggQEbIYIBIAYgggE2AgwgBigCLCGDAUEAIYQBIIMBIYUBIIQBIYYBIIUBIIYBSCGHAUF/IYgBQQEhiQFBASGKASCHASCKAXEhiwEgiAEgiQEgiwEbIYwBIAYgjAE2AgggBigCECGNASAGKAIMIY4BII0BII4BbCGPASAGII8BNgIEIAYoAhQhkAEgBigCCCGRASCQASCRAWwhkgEgBiCSATYCACAGKAIEIZMBIAYoAgAhlAEgkwEhlQEglAEhlgEglQEglgFIIZcBQQEhmAEglwEgmAFxIZkBAkAgmQFFDQBBASGaAUEBIZsBIJoBIJsBcSGcASAGIJwBOgA/DAELIAYoAgAhnQEgBigCBCGeASCdASGfASCeASGgASCfASCgAUghoQFBASGiASChASCiAXEhowECQCCjAUUNAEEAIaQBQQEhpQEgpAEgpQFxIaYBIAYgpgE6AD8MAQsgBigCBCGnAUF/IagBIKcBIakBIKgBIaoBIKkBIKoBRiGrAUEBIawBIKsBIKwBcSGtAQJAIK0BRQ0AIAYpAxghvQEgBikDICG+ASC9ASG/ASC+ASHAASC/ASDAAVQhrgFBASGvASCuASCvAXEhsAEgBiCwAToAPwwBCyAGKQMgIcEBIAYpAxghwgEgwQEhwwEgwgEhxAEgwwEgxAFUIbEBQQEhsgEgsQEgsgFxIbMBIAYgswE6AD8LIAYtAD8htAFBASG1ASC0ASC1AXEhtgEgtgEPCysBBH8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIIIQUgBQ8LTwEKfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgghBSAFKAIIIQYgBi0ABCEHQX8hCCAHIAhzIQlBASEKIAkgCnEhCyALDws2AQZ/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCCCEFQQQhBiAFIAZqIQcgBw8LugIBKX8jACEGQTAhByAGIAdrIQggCCQAIAggBDYCKCAIIAU2AiAgCCAANgIcIAggATYCGCAIIAM3AwggCCACNwMAAkADQEEoIQkgCCAJaiEKIAohC0EgIQwgCCAMaiENIA0hDiALIA4QlAIhD0EBIRAgDyAQcSERIBFFDQFBKCESIAggEmohEyATIRQgFBCdAiEVIBUoAgAhFkEAIRcgFyEYAkAgFkUNAEEoIRkgCCAZaiEaIBohGyAbEJ0CIRwgHCgCBCEdQQAhHiAdIR8gHiEgIB8gIEchISAhIRgLIBghIkEoISMgCCAjaiEkICQhJSAlEJ0CISYgJigCCCEnQQEhKCAiIChxISkgJyApOgAFQSghKiAIICpqISsgKyEsICwQlwIaDAALAAtBMCEtIAggLWohLiAuJAAPCzcBA38jACEFQTAhBiAFIAZrIQcgByADNgIoIAcgBDYCICAHIAA2AhwgByACNwMIIAcgATcDAA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwttAQ5/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFENYLIQYgBCgCCCEHIAcQ1gshCCAGIQkgCCEKIAkgCkYhC0EBIQwgCyAMcSENQRAhDiAEIA5qIQ8gDyQAIA0PC7wBARR/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIEIQYgBCAGNgIEAkADQCAEKAIIIQcgBCgCBCEIIAchCSAIIQogCSAKRyELQQEhDCALIAxxIQ0gDUUNASAFEIgLIQ4gBCgCBCEPQVAhECAPIBBqIREgBCARNgIEIBEQiQshEiAOIBIQuwsMAAsACyAEKAIIIRMgBSATNgIEQRAhFCAEIBRqIRUgFSQADwuwAQEWfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRC0CyEGIAUQtAshByAFEJgLIQhBMCEJIAggCWwhCiAHIApqIQsgBRC0CyEMIAQoAgghDUEwIQ4gDSAObCEPIAwgD2ohECAFELQLIREgBRCNCyESQTAhEyASIBNsIRQgESAUaiEVIAUgBiALIBAgFRC1C0EQIRYgBCAWaiEXIBckAA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC9wBARt/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCDCEHIAYgB2shCEEwIQkgCCAJbSEKIAUgCjYCACAFKAIAIQtBACEMIAshDSAMIQ4gDSAOSyEPQQEhECAPIBBxIRECQCARRQ0AIAUoAgQhEiAFKAIMIRMgBSgCACEUQTAhFSAUIBVsIRYgEiATIBYQ5RoaCyAFKAIEIRcgBSgCACEYQTAhGSAYIBlsIRogFyAaaiEbQRAhHCAFIBxqIR0gHSQAIBsPC0MBB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAQgBRDYC0EQIQYgAyAGaiEHIAckAA8L6hoB2QJ/IwAhA0EwIQQgAyAEayEFIAUkACAFIAA2AiwgBSABNgIoIAUgAjYCJEEGIQYgBSAGNgIgA0ACQAJAA0AgBSgCKCEHIAUoAiwhCCAHIAhrIQlBICEKIAkgCm0hCyAFIAs2AhwgBSgCHCEMQQUhDSAMIA1LGgJAAkACQAJAAkACQCAMDgYAAAECAwQFCwwHCyAFKAIkIQ4gBSgCKCEPQWAhECAPIBBqIREgBSARNgIoIAUoAiwhEiAOIBEgEhDeCyETQQEhFCATIBRxIRUCQCAVRQ0AIAUoAiwhFiAFKAIoIRcgFiAXEOIKCwwGCyAFKAIsIRggBSgCLCEZQSAhGiAZIBpqIRsgBSgCKCEcQWAhHSAcIB1qIR4gBSAeNgIoIAUoAiQhHyAYIBsgHiAfEN8LGgwFCyAFKAIsISAgBSgCLCEhQSAhIiAhICJqISMgBSgCLCEkQcAAISUgJCAlaiEmIAUoAighJ0FgISggJyAoaiEpIAUgKTYCKCAFKAIkISogICAjICYgKSAqEOALGgwECyAFKAIsISsgBSgCLCEsQSAhLSAsIC1qIS4gBSgCLCEvQcAAITAgLyAwaiExIAUoAiwhMkHgACEzIDIgM2ohNCAFKAIoITVBYCE2IDUgNmohNyAFIDc2AiggBSgCJCE4ICsgLiAxIDQgNyA4EOELGgwDCyAFKAIcITlBBiE6IDkhOyA6ITwgOyA8TCE9QQEhPiA9ID5xIT8CQCA/RQ0AIAUoAiwhQCAFKAIoIUEgBSgCJCFCIEAgQSBCEOILDAMLIAUoAiwhQyAFIEM2AhggBSgCKCFEIAUgRDYCFCAFKAIUIUVBYCFGIEUgRmohRyAFIEc2AhQgBSgCHCFIQegHIUkgSCFKIEkhSyBKIEtOIUxBASFNIEwgTXEhTgJAAkAgTkUNACAFKAIcIU9BAiFQIE8gUG0hUSAFIFE2AgwgBSgCDCFSIAUoAhghU0EFIVQgUiBUdCFVIFMgVWohViAFIFY2AhggBSgCDCFXQQIhWCBXIFhtIVkgBSBZNgIMIAUoAiwhWiAFKAIsIVsgBSgCDCFcQQUhXSBcIF10IV4gWyBeaiFfIAUoAhghYCAFKAIYIWEgBSgCDCFiQQUhYyBiIGN0IWQgYSBkaiFlIAUoAhQhZiAFKAIkIWcgWiBfIGAgZSBmIGcQ4QshaCAFIGg2AhAMAQsgBSgCHCFpQQIhaiBpIGptIWsgBSBrNgIMIAUoAgwhbCAFKAIYIW1BBSFuIGwgbnQhbyBtIG9qIXAgBSBwNgIYIAUoAiwhcSAFKAIYIXIgBSgCFCFzIAUoAiQhdCBxIHIgcyB0EN8LIXUgBSB1NgIQCyAFKAIsIXYgBSB2NgIIIAUoAhQhdyAFIHc2AgQgBSgCJCF4IAUoAggheSAFKAIYIXogeCB5IHoQ3gshe0EBIXwgeyB8cSF9IH0NAQNAIAUoAgghfiAFKAIEIX9BYCGAASB/IIABaiGBASAFIIEBNgIEIH4hggEggQEhgwEgggEggwFGIYQBQQEhhQEghAEghQFxIYYBAkAghgFFDQAgBSgCCCGHAUEgIYgBIIcBIIgBaiGJASAFIIkBNgIIIAUoAighigEgBSCKATYCBCAFKAIkIYsBIAUoAiwhjAEgBSgCBCGNAUFgIY4BII0BII4BaiGPASAFII8BNgIEIIsBIIwBII8BEN4LIZABQQEhkQEgkAEgkQFxIZIBAkAgkgENAANAIAUoAgghkwEgBSgCBCGUASCTASGVASCUASGWASCVASCWAUYhlwFBASGYASCXASCYAXEhmQECQCCZAUUNAAwHCyAFKAIkIZoBIAUoAiwhmwEgBSgCCCGcASCaASCbASCcARDeCyGdAUEBIZ4BIJ0BIJ4BcSGfAQJAAkAgnwFFDQAgBSgCCCGgASAFKAIEIaEBIKABIKEBEOIKIAUoAhAhogFBASGjASCiASCjAWohpAEgBSCkATYCECAFKAIIIaUBQSAhpgEgpQEgpgFqIacBIAUgpwE2AggMAQsgBSgCCCGoAUEgIakBIKgBIKkBaiGqASAFIKoBNgIIDAELCwsgBSgCCCGrASAFKAIEIawBIKsBIa0BIKwBIa4BIK0BIK4BRiGvAUEBIbABIK8BILABcSGxAQJAILEBRQ0ADAULA0ACQANAIAUoAiQhsgEgBSgCLCGzASAFKAIIIbQBILIBILMBILQBEN4LIbUBQX8htgEgtQEgtgFzIbcBQQEhuAEgtwEguAFxIbkBILkBRQ0BIAUoAgghugFBICG7ASC6ASC7AWohvAEgBSC8ATYCCAwACwALAkADQCAFKAIkIb0BIAUoAiwhvgEgBSgCBCG/AUFgIcABIL8BIMABaiHBASAFIMEBNgIEIL0BIL4BIMEBEN4LIcIBQQEhwwEgwgEgwwFxIcQBIMQBRQ0BDAALAAsgBSgCCCHFASAFKAIEIcYBIMUBIccBIMYBIcgBIMcBIMgBTyHJAUEBIcoBIMkBIMoBcSHLAQJAAkAgywFFDQAMAQsgBSgCCCHMASAFKAIEIc0BIMwBIM0BEOIKIAUoAhAhzgFBASHPASDOASDPAWoh0AEgBSDQATYCECAFKAIIIdEBQSAh0gEg0QEg0gFqIdMBIAUg0wE2AggMAQsLIAUoAggh1AEgBSDUATYCLAwCCyAFKAIkIdUBIAUoAgQh1gEgBSgCGCHXASDVASDWASDXARDeCyHYAUEBIdkBINgBINkBcSHaAQJAAkAg2gFFDQAgBSgCCCHbASAFKAIEIdwBINsBINwBEOIKIAUoAhAh3QFBASHeASDdASDeAWoh3wEgBSDfATYCEAwBCwwBCwsLCyAFKAIIIeABQSAh4QEg4AEg4QFqIeIBIAUg4gE2AgggBSgCCCHjASAFKAIEIeQBIOMBIeUBIOQBIeYBIOUBIOYBSSHnAUEBIegBIOcBIOgBcSHpAQJAIOkBRQ0AA0ACQANAIAUoAiQh6gEgBSgCCCHrASAFKAIYIewBIOoBIOsBIOwBEN4LIe0BQQEh7gEg7QEg7gFxIe8BIO8BRQ0BIAUoAggh8AFBICHxASDwASDxAWoh8gEgBSDyATYCCAwACwALAkADQCAFKAIkIfMBIAUoAgQh9AFBYCH1ASD0ASD1AWoh9gEgBSD2ATYCBCAFKAIYIfcBIPMBIPYBIPcBEN4LIfgBQX8h+QEg+AEg+QFzIfoBQQEh+wEg+gEg+wFxIfwBIPwBRQ0BDAALAAsgBSgCCCH9ASAFKAIEIf4BIP0BIf8BIP4BIYACIP8BIIACSyGBAkEBIYICIIECIIICcSGDAgJAAkAggwJFDQAMAQsgBSgCCCGEAiAFKAIEIYUCIIQCIIUCEOIKIAUoAhAhhgJBASGHAiCGAiCHAmohiAIgBSCIAjYCECAFKAIYIYkCIAUoAgghigIgiQIhiwIgigIhjAIgiwIgjAJGIY0CQQEhjgIgjQIgjgJxIY8CAkAgjwJFDQAgBSgCBCGQAiAFIJACNgIYCyAFKAIIIZECQSAhkgIgkQIgkgJqIZMCIAUgkwI2AggMAQsLCyAFKAIIIZQCIAUoAhghlQIglAIhlgIglQIhlwIglgIglwJHIZgCQQEhmQIgmAIgmQJxIZoCAkAgmgJFDQAgBSgCJCGbAiAFKAIYIZwCIAUoAgghnQIgmwIgnAIgnQIQ3gshngJBASGfAiCeAiCfAnEhoAIgoAJFDQAgBSgCCCGhAiAFKAIYIaICIKECIKICEOIKIAUoAhAhowJBASGkAiCjAiCkAmohpQIgBSClAjYCEAsgBSgCECGmAgJAIKYCDQAgBSgCLCGnAiAFKAIIIagCIAUoAiQhqQIgpwIgqAIgqQIQ4wshqgJBASGrAiCqAiCrAnEhrAIgBSCsAjoAAyAFKAIIIa0CQSAhrgIgrQIgrgJqIa8CIAUoAighsAIgBSgCJCGxAiCvAiCwAiCxAhDjCyGyAkEBIbMCILICILMCcSG0AgJAILQCRQ0AIAUtAAMhtQJBASG2AiC1AiC2AnEhtwICQCC3AkUNAAwDCyAFKAIIIbgCIAUguAI2AigMAwsgBS0AAyG5AkEBIboCILkCILoCcSG7AgJAILsCRQ0AIAUoAgghvAJBICG9AiC8AiC9AmohvgIgBSC+AjYCCCAFIL4CNgIsDAMLCyAFKAIIIb8CIAUoAiwhwAIgvwIgwAJrIcECQQUhwgIgwQIgwgJ1IcMCIAUoAighxAIgBSgCCCHFAiDEAiDFAmshxgJBBSHHAiDGAiDHAnUhyAIgwwIhyQIgyAIhygIgyQIgygJIIcsCQQEhzAIgywIgzAJxIc0CAkACQCDNAkUNACAFKAIsIc4CIAUoAgghzwIgBSgCJCHQAiDOAiDPAiDQAhDdCyAFKAIIIdECQSAh0gIg0QIg0gJqIdMCIAUg0wI2AgggBSDTAjYCLAwBCyAFKAIIIdQCQSAh1QIg1AIg1QJqIdYCIAUoAigh1wIgBSgCJCHYAiDWAiDXAiDYAhDdCyAFKAIIIdkCIAUg2QI2AigLDAELC0EwIdoCIAUg2gJqIdsCINsCJAAPC4IBARB/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhwgBSABNgIYIAUgAjYCFCAFKAIYIQYgBSgCFCEHQRAhCCAFIAhqIQkgCSEKQQghCyAFIAtqIQwgDCENIAYgByAKIA0Q5AshDkEBIQ8gDiAPcSEQQSAhESAFIBFqIRIgEiQAIBAPC7UEATh/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhggBiABNgIUIAYgAjYCECAGIAM2AgxBACEHIAYgBzYCCCAGKAIMIQggBigCFCEJIAYoAhghCiAIIAkgChDeCyELQQEhDCALIAxxIQ0CQAJAIA0NACAGKAIMIQ4gBigCECEPIAYoAhQhECAOIA8gEBDeCyERQQEhEiARIBJxIRMCQCATDQAgBigCCCEUIAYgFDYCHAwCCyAGKAIUIRUgBigCECEWIBUgFhDiCkEBIRcgBiAXNgIIIAYoAgwhGCAGKAIUIRkgBigCGCEaIBggGSAaEN4LIRtBASEcIBsgHHEhHQJAIB1FDQAgBigCGCEeIAYoAhQhHyAeIB8Q4gpBAiEgIAYgIDYCCAsgBigCCCEhIAYgITYCHAwBCyAGKAIMISIgBigCECEjIAYoAhQhJCAiICMgJBDeCyElQQEhJiAlICZxIScCQCAnRQ0AIAYoAhghKCAGKAIQISkgKCApEOIKQQEhKiAGICo2AgggBigCCCErIAYgKzYCHAwBCyAGKAIYISwgBigCFCEtICwgLRDiCkEBIS4gBiAuNgIIIAYoAgwhLyAGKAIQITAgBigCFCExIC8gMCAxEN4LITJBASEzIDIgM3EhNAJAIDRFDQAgBigCFCE1IAYoAhAhNiA1IDYQ4gpBAiE3IAYgNzYCCAsgBigCCCE4IAYgODYCHAsgBigCHCE5QSAhOiAGIDpqITsgOyQAIDkPC6YDASx/IwAhBUEgIQYgBSAGayEHIAckACAHIAA2AhwgByABNgIYIAcgAjYCFCAHIAM2AhAgByAENgIMIAcoAhwhCCAHKAIYIQkgBygCFCEKIAcoAgwhCyAIIAkgCiALEN8LIQwgByAMNgIIIAcoAgwhDSAHKAIQIQ4gBygCFCEPIA0gDiAPEN4LIRBBASERIBAgEXEhEgJAIBJFDQAgBygCFCETIAcoAhAhFCATIBQQ4gogBygCCCEVQQEhFiAVIBZqIRcgByAXNgIIIAcoAgwhGCAHKAIUIRkgBygCGCEaIBggGSAaEN4LIRtBASEcIBsgHHEhHQJAIB1FDQAgBygCGCEeIAcoAhQhHyAeIB8Q4gogBygCCCEgQQEhISAgICFqISIgByAiNgIIIAcoAgwhIyAHKAIYISQgBygCHCElICMgJCAlEN4LISZBASEnICYgJ3EhKAJAIChFDQAgBygCHCEpIAcoAhghKiApICoQ4gogBygCCCErQQEhLCArICxqIS0gByAtNgIICwsLIAcoAgghLkEgIS8gByAvaiEwIDAkACAuDwuXBAE4fyMAIQZBICEHIAYgB2shCCAIJAAgCCAANgIcIAggATYCGCAIIAI2AhQgCCADNgIQIAggBDYCDCAIIAU2AgggCCgCHCEJIAgoAhghCiAIKAIUIQsgCCgCECEMIAgoAgghDSAJIAogCyAMIA0Q4AshDiAIIA42AgQgCCgCCCEPIAgoAgwhECAIKAIQIREgDyAQIBEQ3gshEkEBIRMgEiATcSEUAkAgFEUNACAIKAIQIRUgCCgCDCEWIBUgFhDiCiAIKAIEIRdBASEYIBcgGGohGSAIIBk2AgQgCCgCCCEaIAgoAhAhGyAIKAIUIRwgGiAbIBwQ3gshHUEBIR4gHSAecSEfAkAgH0UNACAIKAIUISAgCCgCECEhICAgIRDiCiAIKAIEISJBASEjICIgI2ohJCAIICQ2AgQgCCgCCCElIAgoAhQhJiAIKAIYIScgJSAmICcQ3gshKEEBISkgKCApcSEqAkAgKkUNACAIKAIYISsgCCgCFCEsICsgLBDiCiAIKAIEIS1BASEuIC0gLmohLyAIIC82AgQgCCgCCCEwIAgoAhghMSAIKAIcITIgMCAxIDIQ3gshM0EBITQgMyA0cSE1AkAgNUUNACAIKAIcITYgCCgCGCE3IDYgNxDiCiAIKAIEIThBASE5IDggOWohOiAIIDo2AgQLCwsLIAgoAgQhO0EgITwgCCA8aiE9ID0kACA7DwvRBAFGfyMAIQNBwAAhBCADIARrIQUgBSQAIAUgADYCPCAFIAE2AjggBSACNgI0IAUoAjwhBkHAACEHIAYgB2ohCCAFIAg2AjAgBSgCPCEJIAUoAjwhCkEgIQsgCiALaiEMIAUoAjAhDSAFKAI0IQ4gCSAMIA0gDhDfCxogBSgCMCEPQSAhECAPIBBqIREgBSARNgIsAkADQCAFKAIsIRIgBSgCOCETIBIhFCATIRUgFCAVRyEWQQEhFyAWIBdxIRggGEUNASAFKAI0IRkgBSgCLCEaIAUoAjAhGyAZIBogGxDeCyEcQQEhHSAcIB1xIR4CQCAeRQ0AIAUoAiwhHyAfENkCISBBCCEhIAUgIWohIiAiISMgIyAgEOoCGiAFKAIwISQgBSAkNgIEIAUoAiwhJSAFICU2AjADQCAFKAIEISYgJhDZAiEnIAUoAjAhKCAoICcQ6AoaIAUoAgQhKSAFICk2AjAgBSgCMCEqIAUoAjwhKyAqISwgKyEtICwgLUchLkEAIS9BASEwIC4gMHEhMSAvITICQCAxRQ0AIAUoAjQhMyAFKAIEITRBYCE1IDQgNWohNiAFIDY2AgRBCCE3IAUgN2ohOCA4ITkgMyA5IDYQ3gshOiA6ITILIDIhO0EBITwgOyA8cSE9ID0NAAtBCCE+IAUgPmohPyA/IUAgQBDZAiFBIAUoAjAhQiBCIEEQ6AoaCyAFKAIsIUMgBSBDNgIwIAUoAiwhREEgIUUgRCBFaiFGIAUgRjYCLAwACwALQcAAIUcgBSBHaiFIIEgkAA8LhgsBoAF/IwAhA0HQACEEIAMgBGshBSAFJAAgBSAANgJIIAUgATYCRCAFIAI2AkAgBSgCRCEGIAUoAkghByAGIAdrIQhBICEJIAggCW0hCkEFIQsgCiALSxoCQAJAAkACQAJAAkACQCAKDgYAAAECAwQFC0EBIQxBASENIAwgDXEhDiAFIA46AE8MBQsgBSgCQCEPIAUoAkQhEEFgIREgECARaiESIAUgEjYCRCAFKAJIIRMgDyASIBMQ3gshFEEBIRUgFCAVcSEWAkAgFkUNACAFKAJIIRcgBSgCRCEYIBcgGBDiCgtBASEZQQEhGiAZIBpxIRsgBSAbOgBPDAQLIAUoAkghHCAFKAJIIR1BICEeIB0gHmohHyAFKAJEISBBYCEhICAgIWohIiAFICI2AkQgBSgCQCEjIBwgHyAiICMQ3wsaQQEhJEEBISUgJCAlcSEmIAUgJjoATwwDCyAFKAJIIScgBSgCSCEoQSAhKSAoIClqISogBSgCSCErQcAAISwgKyAsaiEtIAUoAkQhLkFgIS8gLiAvaiEwIAUgMDYCRCAFKAJAITEgJyAqIC0gMCAxEOALGkEBITJBASEzIDIgM3EhNCAFIDQ6AE8MAgsgBSgCSCE1IAUoAkghNkEgITcgNiA3aiE4IAUoAkghOUHAACE6IDkgOmohOyAFKAJIITxB4AAhPSA8ID1qIT4gBSgCRCE/QWAhQCA/IEBqIUEgBSBBNgJEIAUoAkAhQiA1IDggOyA+IEEgQhDhCxpBASFDQQEhRCBDIERxIUUgBSBFOgBPDAELIAUoAkghRkHAACFHIEYgR2ohSCAFIEg2AjwgBSgCSCFJIAUoAkghSkEgIUsgSiBLaiFMIAUoAjwhTSAFKAJAIU4gSSBMIE0gThDfCxpBCCFPIAUgTzYCOEEAIVAgBSBQNgI0IAUoAjwhUUEgIVIgUSBSaiFTIAUgUzYCMAJAA0AgBSgCMCFUIAUoAkQhVSBUIVYgVSFXIFYgV0chWEEBIVkgWCBZcSFaIFpFDQEgBSgCQCFbIAUoAjAhXCAFKAI8IV0gWyBcIF0Q3gshXkEBIV8gXiBfcSFgAkAgYEUNACAFKAIwIWEgYRDZAiFiQRAhYyAFIGNqIWQgZCFlIGUgYhDqAhogBSgCPCFmIAUgZjYCDCAFKAIwIWcgBSBnNgI8A0AgBSgCDCFoIGgQ2QIhaSAFKAI8IWogaiBpEOgKGiAFKAIMIWsgBSBrNgI8IAUoAjwhbCAFKAJIIW0gbCFuIG0hbyBuIG9HIXBBACFxQQEhciBwIHJxIXMgcSF0AkAgc0UNACAFKAJAIXUgBSgCDCF2QWAhdyB2IHdqIXggBSB4NgIMQRAheSAFIHlqIXogeiF7IHUgeyB4EN4LIXwgfCF0CyB0IX1BASF+IH0gfnEhfyB/DQALQRAhgAEgBSCAAWohgQEggQEhggEgggEQ2QIhgwEgBSgCPCGEASCEASCDARDoChogBSgCNCGFAUEBIYYBIIUBIIYBaiGHASAFIIcBNgI0QQghiAEghwEhiQEgiAEhigEgiQEgigFGIYsBQQEhjAEgiwEgjAFxIY0BAkAgjQFFDQAgBSgCMCGOAUEgIY8BII4BII8BaiGQASAFIJABNgIwIAUoAkQhkQEgkAEhkgEgkQEhkwEgkgEgkwFGIZQBQQEhlQEglAEglQFxIZYBIAUglgE6AE8MBAsLIAUoAjAhlwEgBSCXATYCPCAFKAIwIZgBQSAhmQEgmAEgmQFqIZoBIAUgmgE2AjAMAAsAC0EBIZsBQQEhnAEgmwEgnAFxIZ0BIAUgnQE6AE8LIAUtAE8hngFBASGfASCeASCfAXEhoAFB0AAhoQEgBSChAWohogEgogEkACCgAQ8L9AEBHX8jACEEQRAhBSAEIAVrIQYgBiQAIAYgADYCDCAGIAE2AgggBiACNgIEIAYgAzYCACAGKAIEIQcgBigCDCEIIAYoAgghCSAHIAggCRDlCyEKQQEhC0EBIQwgCiAMcSENIAshDgJAIA0NACAGKAIEIQ8gBigCCCEQIAYoAgwhESAPIBAgERDlCyESQQAhE0EBIRQgEiAUcSEVIBMhFgJAIBUNACAGKAIMIRcgBigCCCEYIAYoAgAhGSAXIBggGRDmCyEaIBohFgsgFiEbIBshDgsgDiEcQQEhHSAcIB1xIR5BECEfIAYgH2ohICAgJAAgHg8LjQEBFH8jACEDQRAhBCADIARrIQUgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAYtAAQhB0F/IQggByAIcyEJQQEhCiAJIApxIQsgBSgCBCEMIAwtAAQhDUF/IQ4gDSAOcyEPQQEhECAPIBBxIREgCyESIBEhEyASIBNIIRRBASEVIBQgFXEhFiAWDwvkAQEcfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCBCEGIAUoAgwhByAFKAIIIQggBiAHIAgQ5wshCUEBIQpBASELIAkgC3EhDCAKIQ0CQCAMDQAgBSgCBCEOIAUoAgghDyAFKAIMIRAgDiAPIBAQ5wshEUEAIRJBASETIBEgE3EhFCASIRUCQCAUDQAgBSgCDCEWIAUoAgghFyAWIBcQ6AshGCAYIRULIBUhGSAZIQ0LIA0hGkEBIRsgGiAbcSEcQRAhHSAFIB1qIR4gHiQAIBwPC2EBDH8jACEDQRAhBCADIARrIQUgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAYoAgghByAFKAIEIQggCCgCCCEJIAchCiAJIQsgCiALSSEMQQEhDSAMIA1xIQ4gDg8LMwEGfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIQQAhBUEBIQYgBSAGcSEHIAcPC90BARh/IwAhBEEQIQUgBCAFayEGIAYkACAGIAA2AgwgBiABNgIIIAYgAjYCBCAGIAM2AgACQANAIAYoAgghByAGKAIEIQggByEJIAghCiAJIApHIQtBASEMIAsgDHEhDSANRQ0BIAYoAgwhDiAGKAIAIQ8gDygCACEQIBAQPyERIAYoAgghEiAOIBEgEhDqCyAGKAIIIRNBDCEUIBMgFGohFSAGIBU2AgggBigCACEWIBYoAgAhF0EMIRggFyAYaiEZIBYgGTYCAAwACwALQRAhGiAGIBpqIRsgGyQADwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhwgBSABNgIYIAUgAjYCFCAFKAIcIQYgBSgCGCEHIAUoAhQhCCAIEOsLIQkgBiAHIAkQ7AtBICEKIAUgCmohCyALJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhQgBSABNgIQIAUgAjYCDCAFKAIUIQYgBSgCECEHIAUoAgwhCCAIEOsLIQkgBiAHIAkQ7QtBICEKIAUgCmohCyALJAAPC1kBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQcgBxDrCyEIIAYgCBDuCxpBECEJIAUgCWohCiAKJAAPC/IBARt/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhggBCABNgIUIAQoAhghBSAEIAU2AhwgBCgCFCEGIAYQtQEhByAHEO8LQRAhCCAEIAhqIQkgCSEKIAUgChBdGiAEKAIUIQsgCxALIQwgBCAMNgIEIAQoAgQhDUEAIQ4gDSEPIA4hECAPIBBLIRFBASESIBEgEnEhEwJAIBNFDQAgBCgCBCEUIAUgFBDwCyAEKAIUIRUgFSgCACEWIAQoAhQhFyAXKAIEIRggBCgCBCEZIAUgFiAYIBkQ8QsLIAQoAhwhGkEgIRsgBCAbaiEcIBwkACAaDws6AQZ/IwAhAUEgIQIgASACayEDIAMkACADIAA2AhwgAygCHCEEIAQQ8gtBICEFIAMgBWohBiAGJAAPC84BARd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBRCqASEHIAYhCCAHIQkgCCAJSyEKQQEhCyAKIAtxIQwCQCAMRQ0AIAUQtRoACyAFEFshDSAEKAIIIQ4gDSAOEK0BIQ8gBSAPNgIEIAUgDzYCACAFKAIAIRAgBCgCCCERQQMhEiARIBJ0IRMgECATaiEUIAUQJyEVIBUgFDYCAEEAIRYgBSAWELEBQRAhFyAEIBdqIRggGCQADwuXAQEPfyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIcIAYgATYCGCAGIAI2AhQgBiADNgIQIAYoAhwhByAGKAIQIQggBiEJIAkgByAIEJ8BGiAHEFshCiAGKAIYIQsgBigCFCEMIAYhDUEEIQ4gDSAOaiEPIAogCyAMIA8Q8wsgBiEQIBAQogEaQSAhESAGIBFqIRIgEiQADwsbAQN/IwAhAUEQIQIgASACayEDIAMgADYCBA8L3gEBGH8jACEEQRAhBSAEIAVrIQYgBiQAIAYgADYCDCAGIAE2AgggBiACNgIEIAYgAzYCAAJAA0AgBigCCCEHIAYoAgQhCCAHIQkgCCEKIAkgCkchC0EBIQwgCyAMcSENIA1FDQEgBigCDCEOIAYoAgAhDyAPKAIAIRAgEBCWASERIAYoAgghEiAOIBEgEhD0CyAGKAIIIRNBCCEUIBMgFGohFSAGIBU2AgggBigCACEWIBYoAgAhF0EIIRggFyAYaiEZIBYgGTYCAAwACwALQRAhGiAGIBpqIRsgGyQADwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhwgBSABNgIYIAUgAjYCFCAFKAIcIQYgBSgCGCEHIAUoAhQhCCAIELECIQkgBiAHIAkQ9QtBICEKIAUgCmohCyALJAAPC2EBCX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCFCAFIAE2AhAgBSACNgIMIAUoAhQhBiAFKAIQIQcgBSgCDCEIIAgQsQIhCSAGIAcgCRD2C0EgIQogBSAKaiELIAskAA8LWQEIfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAUoAgQhByAHELECIQggBiAIEKkBGkEQIQkgBSAJaiEKIAokAA8LSgEHfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGIAUgBhD4C0EgIQcgBCAHaiEIIAgkAA8LSgEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBCgCACEGIAUgBhD5C0EQIQcgBCAHaiEIIAgkAA8LQQEGfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIIIQUgBRAYGkEQIQYgBCAGaiEHIAckAA8L+wcDY38MfAN+IwAhCkHwASELIAogC2shDCAMJAAgDCAANgLsASAMIAE2AugBIAwgAjYC5AEgDCADNgLgASAMIAQ2AtwBIAwgBTkD0AEgDCAGOQPIASAMIAc2AsQBIAwgCDYCwAEgDCAJNgK8ASAMKwPQASFtRBgtRFT7IQlAIW4gbSBuoiFvRAAAAAAAgGZAIXAgbyBwoyFxIAwgcTkDsAFBACENIA23IXIgDCByOQOoASAMKwPQASFzIAwrA8gBIXQgDCsDqAEhdUEwIQ4gDCAOaiEPIA8gdTkDACAMIHQ5AyggDCBzOQMgQakJIRBBICERIAwgEWohEiAQIBIQ/hoaIAwoAuQBIRMgDCgC4AEhFCAMKALcASEVQZgBIRYgDCAWaiEXIBchGCAYIBMgFCAVEBYgDCgC7AEhGSAMKALoASEaIAwrA7ABIXZBiAEhGyAMIBtqIRwgHCEdQZgBIR4gDCAeaiEfIB8hICAdIBkgGiAgIHYQ+wtBiAEhISAMICFqISIgIiEjICMQ/AshJEEBISUgJCAlcSEmAkACQCAmRQ0AIAwoAsQBIScgDCgCwAEhKCAMKAK8ASEpQfgAISogDCAqaiErICshLCAsEP0LGkH4ACEtIAwgLWohLiAuIS8gJyAoICkgLxARQfgAITAgDCAwaiExIDEhMiAyEP4LGkEBITMgDCAzNgJ0DAELQegAITQgDCA0aiE1IDUhNiA2EP8LGkHYACE3IAwgN2ohOCA4ITkgORD9CxogDCgC7AEhOiAMKALoASE7IAwrA8gBIXcgDCB3OQNAIAwrA6gBIXggDCB4OQNIQegAITwgDCA8aiE9ID0hPiAMID42AlBB2AAhPyAMID9qIUAgQCFBIAwgQTYCVEGIASFCIAwgQmohQyBDGkEQIURBCCFFIAwgRWohRiBGIERqIUdBwAAhSCAMIEhqIUkgSSBEaiFKIEopAwAheSBHIHk3AwBBCCFLQQghTCAMIExqIU0gTSBLaiFOQcAAIU8gDCBPaiFQIFAgS2ohUSBRKQMAIXogTiB6NwMAIAwpA0AheyAMIHs3AwhBiAEhUiAMIFJqIVNBCCFUIAwgVGohVSA6IDsgUyBVEIAMQdQJIVZBACFXIFYgVxD+GhogDCgCxAEhWCAMKALAASFZIAwoArwBIVpB2AAhWyAMIFtqIVwgXCFdIFggWSBaIF0QEUEBIV4gDCBeNgJ0QdgAIV8gDCBfaiFgIGAhYSBhEP4LGkHoACFiIAwgYmohYyBjIWQgZBCBDBoLQYgBIWUgDCBlaiFmIGYhZyBnEIEMGkGYASFoIAwgaGohaSBpIWogahAeGkHwASFrIAwga2ohbCBsJAAPC6JHA5kHfyt8CX4jACEFQeAcIQYgBSAGayEHIAckACAHIAA2AtwcIAcgATYC2BwgByACNgLUHCAHIAM2AtAcIAcgBDkDyBxBuBwhCCAHIAhqIQkgCSEKIAoQggwaIAcoAtAcIQsgByALNgK0HCAHKAK0HCEMIAwQzgEhDSAHIA02ArAcIAcoArQcIQ4gDhDPASEPIAcgDzYCqBwCQANAQbAcIRAgByAQaiERIBEhEkGoHCETIAcgE2ohFCAUIRUgEiAVEIMMIRZBASEXIBYgF3EhGCAYRQ0BQbAcIRkgByAZaiEaIBohGyAbEIQMIRwgByAcNgKkHEEAIR0gByAdNgKgHAJAA0AgBygCoBwhHiAHKAKkHCEfIB8QCyEgIB4hISAgISIgISAiSSEjQQEhJCAjICRxISUgJUUNASAHKAKgHCEmQQEhJyAmICdqISggBygCpBwhKSApEAshKiAoISsgKiEsICsgLEkhLUEBIS4gLSAucSEvAkACQCAvRQ0AIAcoAqQcITAgBygCoBwhMSAwIDEQ4QEhMiAHKAKkHCEzIAcoAqAcITRBASE1IDQgNWohNiAzIDYQ4QEhN0G4HCE4IAcgOGohOSA5ITogOiAyIDcQhQwMAQsgBygCpBwhOyAHKAKgHCE8IDsgPBDhASE9IAcoAqQcIT5BACE/ID4gPxDhASFAQbgcIUEgByBBaiFCIEIhQyBDID0gQBCFDAsgBygCoBwhREEBIUUgRCBFaiFGIAcgRjYCoBwMAAsAC0GwHCFHIAcgR2ohSCBIIUkgSRDwARoMAAsAC0HeCSFKQQAhSyBKIEsQ/hoaQfgbIUwgByBMaiFNIE0hTiBOEIYMGkHoBiFPIAcgT2ohUCBQIVEgURCHDBpBuBwhUiAHIFJqIVMgUyFUIAcgVDYC5AYgBygC5AYhVSBVEIgMIVYgByBWNgLgBiAHKALkBiFXIFcQiQwhWCAHIFg2AtgGAkADQEHgBiFZIAcgWWohWiBaIVtB2AYhXCAHIFxqIV0gXSFeIFsgXhCKDCFfQQEhYCBfIGBxIWEgYUUNAUHgBiFiIAcgYmohYyBjIWQgZBCLDCFlIAcgZTYC1AYgBygC1AYhZkHIBiFnIAcgZ2ohaCBoIWkgaSBmEIwMQcgGIWogByBqaiFrIGshbCBsEA0hbSAHIG02AtAGIAcoAtQGIW5BuAYhbyAHIG9qIXAgcCFxIHEgbhCMDEG4BiFyIAcgcmohcyBzIXQgdBAOIXUgByB1NgLEBiAHKALUBiF2QagGIXcgByB3aiF4IHgheSB5IHYQjQxBqAYheiAHIHpqIXsgeyF8IHwQDSF9IAcgfTYCtAYgBygC1AYhfkGYBiF/IAcgf2ohgAEggAEhgQEggQEgfhCNDEGYBiGCASAHIIIBaiGDASCDASGEASCEARAOIYUBIAcghQE2AqQGQegGIYYBIAcghgFqIYcBIIcBIYgBQdAGIYkBIAcgiQFqIYoBIIoBIYsBQcQGIYwBIAcgjAFqIY0BII0BIY4BQbQGIY8BIAcgjwFqIZABIJABIZEBQaQGIZIBIAcgkgFqIZMBIJMBIZQBIIgBIIsBII4BIJEBIJQBEI4MGkHgBiGVASAHIJUBaiGWASCWASGXASCXARCPDBoMAAsAC0HhCSGYAUEAIZkBIJgBIJkBEP4aGkHoBiGaASAHIJoBaiGbASCbASGcAUH4GyGdASAHIJ0BaiGeASCeASGfASCcASCfARCQDEGIBiGgASAHIKABaiGhASChASGiASCiARD/CxpB5AkhowFBACGkASCjASCkARD+GhogBygC0BwhpQEgpQEQzgEhpgEgByCmATYCgAYgBygC0BwhpwEgpwEQzwEhqAEgByCoATYC+AUgBygCgAYhqQEgBygC+AUhqgFBiAYhqwEgByCrAWohrAEgrAEhrQFBASGuAUEAIa8BQQEhsAEgrgEgsAFxIbEBQQEhsgEgrwEgsgFxIbMBIK0BIKkBIKoBILEBILMBEJEMQecJIbQBQQAhtQEgtAEgtQEQ/hoaQQAhtgEgByC2ATYC9AUCQANAIAcoAvQFIbcBQYgGIbgBIAcguAFqIbkBILkBIboBILoBEJIMIbsBILcBIbwBILsBIb0BILwBIL0BSSG+AUEBIb8BIL4BIL8BcSHAASDAAUUNASAHKAL0BSHBAUGIBiHCASAHIMIBaiHDASDDASHEASDEASDBARCTDCHFAUEBIcYBIMUBIMYBOgAAIAcoAvQFIccBQQEhyAEgxwEgyAFqIckBIAcgyQE2AvQFDAALAAtB+BshygEgByDKAWohywEgywEhzAEgzAEQlAwhzQEgByDNATYC8AUgBygC8AUhzgEgzgEQlQwhzwEgByDPATYC6AUgBygC8AUh0AEg0AEQlgwh0QEgByDRATYC4AUCQANAQegFIdIBIAcg0gFqIdMBINMBIdQBQeAFIdUBIAcg1QFqIdYBINYBIdcBINQBINcBEJcMIdgBQQEh2QEg2AEg2QFxIdoBINoBRQ0BQegFIdsBIAcg2wFqIdwBINwBId0BIN0BEJgMId4BIAcg3gE2AtwFIAcoAtwFId8BQQAh4AEg3wEg4AEQmQxB6AUh4QEgByDhAWoh4gEg4gEh4wEg4wEQmgwaDAALAAtB+Bsh5AEgByDkAWoh5QEg5QEh5gEg5gEQlAwh5wEg5wEQmwwh6AEgByDoATYCoAFB6gkh6QFBoAEh6gEgByDqAWoh6wEg6QEg6wEQ/hoaQQAh7AEgByDsATYC2AUCQANAIAcoAtgFIe0BQfgbIe4BIAcg7gFqIe8BIO8BIfABIPABEJQMIfEBIPEBEJsMIfIBIO0BIfMBIPIBIfQBIPMBIPQBSSH1AUEBIfYBIPUBIPYBcSH3ASD3AUUNAUH4GyH4ASAHIPgBaiH5ASD5ASH6ASD6ARCUDCH7ASAHKALYBSH8ASD7ASD8ARCcDCH9ASAHIP0BNgLUBSAHKALUBSH+ASD+ARCdDCH/AUEBIYACIP8BIIACcSGBAgJAIIECRQ0AIAcoAtQFIYICIIICEJ4MIYMCQQEhhAIggwIghAJxIYUCIIUCRQ0AIAcoAtQFIYYCIIYCEJ8MIYcCQQEhiAIghwIgiAJxIYkCIIkCDQAgBygC1AUhigJBASGLAiCKAiCLAhCZDCAHKALUBSGMAiCMAhCgDCGNAkEBIY4CII0CII4CEJkMIAcoAtQFIY8CII8CEKEMIZACIJACEKIMIZECIJECKwMAIZ4HIJ4HEKMaIZICIAcoAtQFIZMCIJMCEKEMIZQCIJQCEKMMIZUCIJUCKwMAIZ8HIJ8HEKMaIZYCQcgFIZcCIAcglwJqIZgCIJgCIZkCIJkCIJICIJYCEBwaIAcoAtQFIZoCIJoCEKQMIZsCIJsCEKIMIZwCIJwCKwMAIaAHIKAHEKMaIZ0CIAcoAtQFIZ4CIJ4CEKQMIZ8CIJ8CEKMMIaACIKACKwMAIaEHIKEHEKMaIaECQcAFIaICIAcgogJqIaMCIKMCIaQCIKQCIJ0CIKECEBwaQQEhpQIgByClAjoAvwVBiAYhpgIgByCmAmohpwIgpwIhqAJByAUhqQIgByCpAmohqgIgqgIhqwJBwAUhrAIgByCsAmohrQIgrQIhrgJBvwUhrwIgByCvAmohsAIgsAIhsQIgqAIgqwIgrgIgsQIQpQwgBygC2AUhsgJBiAYhswIgByCzAmohtAIgtAIhtQIgtQIQpgwhtgIgtgIgsgI2AgwLIAcoAtgFIbcCQQEhuAIgtwIguAJqIbkCIAcguQI2AtgFDAALAAtBiAYhugIgByC6AmohuwIguwIhvAIgvAIQkgwhvQIgByC9AjYCYEH/CSG+AkHgACG/AiAHIL8CaiHAAiC+AiDAAhD+GhpBiAYhwQIgByDBAmohwgIgwgIhwwIgwwIQpwwhxAIgByDEAjYCuAVBiAYhxQIgByDFAmohxgIgxgIhxwIgxwIQqAwhyAIgByDIAjYCsAUgBygCuAUhyQIgBygCsAUhygJBiAYhywIgByDLAmohzAIgzAIhzQIgzQIgyQIgygIQqQxBiAYhzgIgByDOAmohzwIgzwIh0AIg0AIQkgwh0QIgByDRAjYCcEGTCiHSAkHwACHTAiAHINMCaiHUAiDSAiDUAhD+GhpBiAYh1QIgByDVAmoh1gIg1gIh1wIg1wIQpwwh2AIgByDYAjYCqAVBiAYh2QIgByDZAmoh2gIg2gIh2wIg2wIQqAwh3AIgByDcAjYCoAUgBygCqAUh3QIgBygCoAUh3gIg3QIg3gIQqgxBiAYh3wIgByDfAmoh4AIg4AIh4QIg4QIQkgwh4gIgByDiAjYCgAFBpwoh4wJBgAEh5AIgByDkAmoh5QIg4wIg5QIQ/hoaQYgGIeYCIAcg5gJqIecCIOcCIegCIOgCEKcMIekCIAcg6QI2ApgFQYgGIeoCIAcg6gJqIesCIOsCIewCIOwCEKgMIe0CIAcg7QI2ApAFQYAFIe4CIAcg7gJqIe8CIO8CIfACIPACEKsMIAcoApgFIfECIAcoApAFIfICQQgh8wJBkAEh9AIgByD0Amoh9QIg9QIg8wJqIfYCQYAFIfcCIAcg9wJqIfgCIPgCIPMCaiH5AiD5AigCACH6AiD2AiD6AjYCACAHKQOABSHJByAHIMkHNwOQAUGQASH7AiAHIPsCaiH8AiDxAiDyAiD8AhCsDEG7CiH9AkEAIf4CIP0CIP4CEP4aGkEAIf8CQQEhgAMg/wIggANxIYEDIAcggQM6AO8EIAAQ/wsaQYgGIYIDIAcgggNqIYMDIIMDIYQDIAcghAM2AugEIAcoAugEIYUDIIUDEKcMIYYDIAcghgM2AuAEIAcoAugEIYcDIIcDEKgMIYgDIAcgiAM2AtgEAkADQEHgBCGJAyAHIIkDaiGKAyCKAyGLA0HYBCGMAyAHIIwDaiGNAyCNAyGOAyCLAyCOAxCtDCGPA0EBIZADII8DIJADcSGRAyCRA0UNAUHgBCGSAyAHIJIDaiGTAyCTAyGUAyCUAxCuDCGVAyAHIJUDNgLUBCAHKALUBCGWAyCWAy0AACGXA0EBIZgDIJcDIJgDcSGZAwJAAkACQCCZAw0AIAcoAtQEIZoDIJoDLQABIZsDQQEhnAMgmwMgnANxIZ0DIJ0DDQELDAELQfgbIZ4DIAcgngNqIZ8DIJ8DIaADIKADEJQMIaEDIAcoAtQEIaIDIKIDKAIMIaMDIKEDIKMDEJwMIaQDIAcgpAM2AtAEIAcoAtAEIaUDIKUDEK8MIaYDIAcgpgM2AswEIAcoAtAEIacDIKcDEKAMIagDIKgDEK8MIakDIAcgqQM2AsgEIAcoAtAEIaoDIKoDEKEMIasDIKsDEKIMIawDIKwDKwMAIaIHIKIHEKMaIa0DIAcoAtAEIa4DIK4DEKEMIa8DIK8DEKMMIbADILADKwMAIaMHIKMHEKMaIbEDQcAEIbIDIAcgsgNqIbMDILMDIbQDILQDIK0DILEDEBwaIAcoAtAEIbUDILUDEKQMIbYDILYDEKIMIbcDILcDKwMAIaQHIKQHEKMaIbgDIAcoAtAEIbkDILkDEKQMIboDILoDEKMMIbsDILsDKwMAIaUHIKUHEKMaIbwDQbgEIb0DIAcgvQNqIb4DIL4DIb8DIL8DILgDILwDEBwaIAcoAtAEIcADIMADELAMIcEDQQEhwgMgwQMgwgNxIcMDAkACQCDDA0UNACAHKALMBCHEAyDEAxCxDCHFA0G4HCHGAyAHIMYDaiHHAyDHAyHIAyDIAyDFAxCyDCHJA0GoBCHKAyAHIMoDaiHLAyDLAyHMAyDMAyDJAxCzDBogBygCyAQhzQMgzQMQsQwhzgNBuBwhzwMgByDPA2oh0AMg0AMh0QMg0QMgzgMQsgwh0gNBmAQh0wMgByDTA2oh1AMg1AMh1QMg1QMg0gMQswwaQQEh1gMgByDWAzoAlwRBlwQh1wMgByDXA2oh2AMg2AMh2QMgByDZAzYCkAQgBygCkAQh2gNBqAQh2wMgByDbA2oh3AMg3AMh3QNBmAQh3gMgByDeA2oh3wMg3wMh4AMg3QMg4AMg2gMQtAwgBy0AlwQh4QNBASHiAyDhAyDiA3Eh4wMCQCDjAw0ADAMLIAcoAswEIeQDIOQDELUMIeUDQQEh5gMg5QMh5wMg5gMh6AMg5wMg6ANGIekDQQEh6gMg6QMg6gNxIesDAkACQAJAIOsDDQAgBygCzAQh7AMg7AMQtQwh7QNBAiHuAyDtAyHvAyDuAyHwAyDvAyDwA0Yh8QNBASHyAyDxAyDyA3Eh8wMg8wNFDQELQYAEIfQDIAcg9ANqIfUDIPUDIfYDQQAh9wMg9gMg9wMg9wMg9wMQtgwaIAcoAswEIfgDIPgDELUMIfkDQQEh+gMg+QMh+wMg+gMh/AMg+wMg/ANGIf0DQQEh/gMg/QMg/gNxIf8DAkACQCD/A0UNACAHKALMBCGABCCABBCxDCGBBEG4HCGCBCAHIIIEaiGDBCCDBCGEBCCEBCCBBBCyDCGFBEHoAyGGBCAHIIYEaiGHBCCHBCGIBCCIBCCFBBCMDEHwAyGJBCAHIIkEaiGKBCCKBCGLBEHoAyGMBCAHIIwEaiGNBCCNBCGOBCCLBCCOBBC3DBpBgAQhjwQgByCPBGohkAQgkAQhkQRB8AMhkgQgByCSBGohkwQgkwQhlAQglAQpAgAhygcgkQQgygc3AgBBCCGVBCCRBCCVBGohlgQglAQglQRqIZcEIJcEKAIAIZgEIJYEIJgENgIADAELIAcoAswEIZkEIJkEELEMIZoEQbgcIZsEIAcgmwRqIZwEIJwEIZ0EIJ0EIJoEELIMIZ4EQdADIZ8EIAcgnwRqIaAEIKAEIaEEIKEEIJ4EEI0MQdgDIaIEIAcgogRqIaMEIKMEIaQEQdADIaUEIAcgpQRqIaYEIKYEIacEIKQEIKcEELcMGkGABCGoBCAHIKgEaiGpBCCpBCGqBEHYAyGrBCAHIKsEaiGsBCCsBCGtBCCtBCkCACHLByCqBCDLBzcCAEEIIa4EIKoEIK4EaiGvBCCtBCCuBGohsAQgsAQoAgAhsQQgrwQgsQQ2AgALQRQhsgQgByCyBDYCzANBwAMhswQgByCzBGohtAQgtAQhtQRBACG2BCC1BCC2BCC2BCC2BBC2DBpBACG3BCAHILcENgK8AwJAA0AgBygCvAMhuAQgBygCzAMhuQQguAQhugQguQQhuwQgugQguwRMIbwEQQEhvQQgvAQgvQRxIb4EIL4ERQ0BQcAEIb8EIAcgvwRqIcAEIMAEIcEEIMEEEA0hwgQgwgS3IaYHIAcoArwDIcMEIMMEtyGnB0G4BCHEBCAHIMQEaiHFBCDFBCHGBCDGBBANIccEQcAEIcgEIAcgyARqIckEIMkEIcoEIMoEEA0hywQgxwQgywRrIcwEIMwEtyGoByCnByCoB6IhqQcgBygCzAMhzQQgzQS3IaoHIKkHIKoHoyGrByCmByCrB6AhrAcgrAcQoxohzgRBwAQhzwQgByDPBGoh0AQg0AQh0QQg0QQQDiHSBCDSBLchrQcgBygCvAMh0wQg0wS3Ia4HQbgEIdQEIAcg1ARqIdUEINUEIdYEINYEEA4h1wRBwAQh2AQgByDYBGoh2QQg2QQh2gQg2gQQDiHbBCDXBCDbBGsh3AQg3AS3Ia8HIK4HIK8HoiGwByAHKALMAyHdBCDdBLchsQcgsAcgsQejIbIHIK0HILIHoCGzByCzBxCjGiHeBEGwAyHfBCAHIN8EaiHgBCDgBCHhBEEAIeIEIOEEIM4EIN4EIOIEELYMGkGgAyHjBCAHIOMEaiHkBCDkBCHlBEGwAyHmBCAHIOYEaiHnBCDnBCHoBEGABCHpBCAHIOkEaiHqBCDqBCHrBCDlBCDoBCDrBBC4DEEIIewEIAcg7ARqIe0EQaADIe4EIAcg7gRqIe8EIO8EIOwEaiHwBCDwBCgCACHxBCDtBCDxBDYCACAHKQOgAyHMByAHIMwHNwMAIAcQuQwhtAcgBysDyBwhtQdEAAAAAAAAAEAhtgcgtQcgtgejIbcHILcHEJ4aIbgHILQHILgHoyG5ByC5BxCjGiHyBEEAIfMEIPMEIPIEayH0BCAHIPQENgK4AyAHKAK8AyH1BAJAIPUERQ0AQQEh9gQgByD2BDoAnwNBwAMh9wQgByD3BGoh+AQg+AQh+QRBsAMh+gQgByD6BGoh+wQg+wQh/ARBnwMh/QQgByD9BGoh/gQg/gQh/wQgACD5BCD8BCD/BBC6DAtBwAMhgAUgByCABWohgQUggQUhggVBsAMhgwUgByCDBWohhAUghAUhhQUghQUpAgAhzQcgggUgzQc3AgBBCCGGBSCCBSCGBWohhwUghQUghgVqIYgFIIgFKAIAIYkFIIcFIIkFNgIAIAcoArwDIYoFQQEhiwUgigUgiwVqIYwFIAcgjAU2ArwDDAALAAsMAQtBiAMhjQUgByCNBWohjgUgjgUhjwVBwAQhkAUgByCQBWohkQUgkQUhkgUgjwUgkgUQ4gEaIAcoAswEIZMFIJMFELEMIZQFQbgcIZUFIAcglQVqIZYFIJYFIZcFIJcFIJQFELIMIZgFQYgDIZkFIAcgmQVqIZoFIJoFIZsFIJsFIJgFELsMIboHIAcgugc5A5ADQfgCIZwFIAcgnAVqIZ0FIJ0FIZ4FQbgEIZ8FIAcgnwVqIaAFIKAFIaEFIJ4FIKEFEOIBGiAHKALMBCGiBSCiBRCxDCGjBUG4HCGkBSAHIKQFaiGlBSClBSGmBSCmBSCjBRCyDCGnBUH4AiGoBSAHIKgFaiGpBSCpBSGqBSCqBSCnBRC7DCG7ByAHILsHOQOAAyAHKwOQAyG8ByAHKwPIHCG9B0QAAAAAAAAAQCG+ByC9ByC+B6MhvwcgvwcQnhohwAcgvAcgwAejIcEHIMEHEKMaIasFQQAhrAUgrAUgqwVrIa0FIAcgrQU2AvQCIAcrA4ADIcIHIAcrA8gcIcMHRAAAAAAAAABAIcQHIMMHIMQHoyHFByDFBxCeGiHGByDCByDGB6MhxwcgxwcQoxohrgVBACGvBSCvBSCuBWshsAUgByCwBTYC8AJBwAQhsQUgByCxBWohsgUgsgUhswUgswUQDSG0BUHABCG1BSAHILUFaiG2BSC2BSG3BSC3BRAOIbgFIAcoAvQCIbkFQbACIboFIAcgugVqIbsFILsFIbwFILwFILQFILgFILkFELYMGkG4BCG9BSAHIL0FaiG+BSC+BSG/BSC/BRANIcAFQbgEIcEFIAcgwQVqIcIFIMIFIcMFIMMFEA4hxAUgBygC8AIhxQVBoAIhxgUgByDGBWohxwUgxwUhyAUgyAUgwAUgxAUgxQUQtgwaQcACIckFIAcgyQVqIcoFIMoFGkEIIcsFQSAhzAUgByDMBWohzQUgzQUgywVqIc4FQbACIc8FIAcgzwVqIdAFINAFIMsFaiHRBSDRBSgCACHSBSDOBSDSBTYCACAHKQOwAiHOByAHIM4HNwMgQRAh0wUgByDTBWoh1AUg1AUgywVqIdUFQaACIdYFIAcg1gVqIdcFINcFIMsFaiHYBSDYBSgCACHZBSDVBSDZBTYCACAHKQOgAiHPByAHIM8HNwMQQQEh2gVBwAIh2wUgByDbBWoh3AVBICHdBSAHIN0FaiHeBUEQId8FIAcg3wVqIeAFINwFIN4FIOAFINoFELwMGkHAAiHhBSAHIOEFaiHiBSDiBSHjBSAAIOMFEL0MCwwBCyAHKALQBCHkBSDkBRC+DCHlBUEBIeYFIOUFIOYFcSHnBQJAIOcFRQ0AQZgCIegFIAcg6AVqIekFIOkFIeoFIOoFELcGGkGIAiHrBSAHIOsFaiHsBSDsBSHtBSDtBRC/DBogBygCzAQh7gUg7gUQwAwh7wVBASHwBSDvBSDwBXEh8QUCQAJAIPEFRQ0AIAcoAswEIfIFIPIFELUMIfMFQQEh9AUg8wUh9QUg9AUh9gUg9QUg9gVGIfcFQQEh+AUg9wUg+AVxIfkFAkACQCD5BUUNACAHKALMBCH6BSD6BRCxDCH7BUG4HCH8BSAHIPwFaiH9BSD9BSH+BSD+BSD7BRCyDCH/BUGAAiGABiAHIIAGaiGBBiCBBiGCBiCCBiD/BRCMDEGYAiGDBiAHIIMGaiGEBiCEBiGFBkGAAiGGBiAHIIYGaiGHBiCHBiGIBiCFBiCIBhDoARoMAQsgBygCzAQhiQYgiQYQsQwhigZBuBwhiwYgByCLBmohjAYgjAYhjQYgjQYgigYQsgwhjgZB+AEhjwYgByCPBmohkAYgkAYhkQYgkQYgjgYQjQxBmAIhkgYgByCSBmohkwYgkwYhlAZB+AEhlQYgByCVBmohlgYglgYhlwYglAYglwYQ6AEaCyAHKALIBCGYBiCYBhCxDCGZBkG4HCGaBiAHIJoGaiGbBiCbBiGcBiCcBiCZBhCyDCGdBkGIAiGeBiAHIJ4GaiGfBiCfBiGgBiCgBiCdBhDBDBoMAQsgBygCyAQhoQYgoQYQtQwhogZBASGjBiCiBiGkBiCjBiGlBiCkBiClBkYhpgZBASGnBiCmBiCnBnEhqAYCQAJAIKgGRQ0AIAcoAsgEIakGIKkGELEMIaoGQbgcIasGIAcgqwZqIawGIKwGIa0GIK0GIKoGELIMIa4GQfABIa8GIAcgrwZqIbAGILAGIbEGILEGIK4GEIwMQZgCIbIGIAcgsgZqIbMGILMGIbQGQfABIbUGIAcgtQZqIbYGILYGIbcGILQGILcGEOgBGgwBCyAHKALIBCG4BiC4BhCxDCG5BkG4HCG6BiAHILoGaiG7BiC7BiG8BiC8BiC5BhCyDCG9BkHoASG+BiAHIL4GaiG/BiC/BiHABiDABiC9BhCNDEGYAiHBBiAHIMEGaiHCBiDCBiHDBkHoASHEBiAHIMQGaiHFBiDFBiHGBiDDBiDGBhDoARoLIAcoAswEIccGIMcGELEMIcgGQbgcIckGIAcgyQZqIcoGIMoGIcsGIMsGIMgGELIMIcwGQYgCIc0GIAcgzQZqIc4GIM4GIc8GIM8GIMwGEMEMGgtB4AEh0AYgByDQBmoh0QYg0QYh0gZBmAIh0wYgByDTBmoh1AYg1AYh1QYg0gYg1QYQ4gEaQdABIdYGIAcg1gZqIdcGINcGIdgGQYgCIdkGIAcg2QZqIdoGINoGIdsGINgGINsGELMMGkHAASHcBiAHINwGaiHdBiDdBiHeBkHABCHfBiAHIN8GaiHgBiDgBiHhBiDeBiDhBhC3DBpBsAEh4gYgByDiBmoh4wYg4wYh5AZBuAQh5QYgByDlBmoh5gYg5gYh5wYg5AYg5wYQtwwaIAcrA8gcIcgHQeABIegGIAcg6AZqIekGIOkGGkHQASHqBiAHIOoGaiHrBiDrBhpBCCHsBkHAACHtBiAHIO0GaiHuBiDuBiDsBmoh7wZBwAEh8AYgByDwBmoh8QYg8QYg7AZqIfIGIPIGKAIAIfMGIO8GIPMGNgIAIAcpA8ABIdAHIAcg0Ac3A0BBMCH0BiAHIPQGaiH1BiD1BiDsBmoh9gZBsAEh9wYgByD3Bmoh+AYg+AYg7AZqIfkGIPkGKAIAIfoGIPYGIPoGNgIAIAcpA7ABIdEHIAcg0Qc3AzBB4AEh+wYgByD7Bmoh/AZB0AEh/QYgByD9Bmoh/gZBwAAh/wYgByD/BmohgAdBMCGBByAHIIEHaiGCByAAIPwGIP4GIIAHIIIHIMgHEMIMCwsLQeAEIYMHIAcggwdqIYQHIIQHIYUHIIUHEMMMGgwACwALIAAQkgwhhgcgByCGBzYCUEG/CiGHB0HQACGIByAHIIgHaiGJByCHByCJBxD+GhpBASGKB0EBIYsHIIoHIIsHcSGMByAHIIwHOgDvBCAHLQDvBCGNB0EBIY4HII0HII4HcSGPBwJAII8HDQAgABCBDBoLQYgGIZAHIAcgkAdqIZEHIJEHIZIHIJIHEIEMGkHoBiGTByAHIJMHaiGUByCUByGVByCVBxDEDBpB+BshlgcgByCWB2ohlwcglwchmAcgmAcQxQwaQbgcIZkHIAcgmQdqIZoHIJoHIZsHIJsHEMYMGkHgHCGcByAHIJwHaiGdByCdByQADwtMAQt/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAQoAgQhBiAFIQcgBiEIIAcgCEYhCUEBIQogCSAKcSELIAsPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDHDBpBECEFIAMgBWohBiAGJAAgBA8LQgEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMgMIAQQyQwaQRAhBSADIAVqIQYgBiQAIAQPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDKDBpBECEFIAMgBWohBiAGJAAgBA8LrSADvwN/BH4BfCMAIQRBsAMhBSAEIAVrIQYgBiQAIAYgADYCrAMgBiABNgKoAyAGIAI2AqQDQZELIQdBACEIIAcgCBD+GhpBmAMhCSAGIAlqIQogCiELIAsQywwaIAYoAqQDIQwgDBCSDCENQQEhDiANIA50IQ9BmAMhECAGIBBqIREgESESIBIgDxDMDCAGKAKkAyETIAYgEzYClAMgBigClAMhFCAUEKcMIRUgBiAVNgKQAyAGKAKUAyEWIBYQqAwhFyAGIBc2AogDAkADQEGQAyEYIAYgGGohGSAZIRpBiAMhGyAGIBtqIRwgHCEdIBogHRCtDCEeQQEhHyAeIB9xISAgIEUNAUGQAyEhIAYgIWohIiAiISMgIxCuDCEkIAYgJDYChAMgBigChAMhJUEQISYgJSAmaiEnIAYoAoQDIShBHCEpICggKWohKkEAISsgBiArOgCDAyAGKAKEAyEsIAYgLDYC/AJBmAMhLSAGIC1qIS4gLiEvQYMDITAgBiAwaiExIDEhMkH8AiEzIAYgM2ohNCA0ITUgLyAnICogMiA1EM0MIAYoAoQDITZBHCE3IDYgN2ohOCAGKAKEAyE5QRAhOiA5IDpqITtBASE8IAYgPDoA+wIgBigChAMhPSAGID02AvQCQZgDIT4gBiA+aiE/ID8hQEH7AiFBIAYgQWohQiBCIUNB9AIhRCAGIERqIUUgRSFGIEAgOCA7IEMgRhDNDEGQAyFHIAYgR2ohSCBIIUkgSRDDDBoMAAsAC0GYAyFKIAYgSmohSyBLIUwgTBDODCFNIAYgTTYC8AJBmAMhTiAGIE5qIU8gTyFQIFAQzwwhUSAGIFE2AugCIAYoAvACIVIgBigC6AIhUyBSIFMQ0AxBmAMhVCAGIFRqIVUgVSFWIAYgVjYC5AIgBigC5AIhVyBXEM4MIVggBiBYNgLgAiAGKALkAiFZIFkQzwwhWiAGIFo2AtgCAkADQEHgAiFbIAYgW2ohXCBcIV1B2AIhXiAGIF5qIV8gXyFgIF0gYBDRDCFhQQEhYiBhIGJxIWMgY0UNAUHgAiFkIAYgZGohZSBlIWYgZhDSDCFnIAYgZzYC1AIgBigC1AIhaCBoLQAcIWlBASFqIGkganEhawJAAkAga0UNACAGKALUAiFsIAYoAtQCIW0gbSgCGCFuIG4gbDYCCAwBCyAGKALUAiFvIAYoAtQCIXAgcCgCGCFxIHEgbzYCBAtB4AIhciAGIHJqIXMgcyF0IHQQ0wwaDAALAAtBmAMhdSAGIHVqIXYgdiF3IHcQ1AwheCAGIHg2AjBBlAsheUEwIXogBiB6aiF7IHkgexD+GhpBmAMhfCAGIHxqIX0gfSF+IH4QzgwhfyAGIH82AsgCQZgDIYABIAYggAFqIYEBIIEBIYIBIIIBEM8MIYMBIAYggwE2AsACIAYoAsgCIYQBIAYoAsACIYUBIIQBIIUBENUMIYYBIAYghgE2AtACQZgDIYcBIAYghwFqIYgBIIgBIYkBIIkBEM8MIYoBIAYgigE2ArACQdACIYsBIAYgiwFqIYwBIIwBIY0BQbACIY4BIAYgjgFqIY8BII8BIZABII0BIJABENYMIZEBQQEhkgEgkQEgkgFxIZMBAkAgkwFFDQBBmAMhlAEgBiCUAWohlQEglQEhlgEglgEQzgwhlwEgBiCXATYCqAJB0AIhmAEgBiCYAWohmQEgmQEhmgFBqAIhmwEgBiCbAWohnAEgnAEhnQEgnQEoAgAhngEgmgEgngE2AgALQdACIZ8BIAYgnwFqIaABIKABIaEBIKEBENcMIaIBIKIBKAIYIaMBIKMBENgMQdACIaQBIAYgpAFqIaUBIKUBIaYBIKYBENcMIacBIKcBLQAcIagBQQEhqQEgqAEgqQFxIaoBAkAgqgFFDQBB0AIhqwEgBiCrAWohrAEgrAEhrQEgrQEQ1wwhrgEgrgEoAhghrwFBECGwASCvASCwAWohsQFB0AIhsgEgBiCyAWohswEgswEhtAEgtAEQ1wwhtQEgtQEoAhghtgFBHCG3ASC2ASC3AWohuAEgsQEguAEQ2QwLQdACIbkBIAYguQFqIboBILoBIbsBILsBENcMIbwBILwBKAIYIb0BIAYoAqQDIb4BIL4BEJIMIb8BQQEhwAEgvwEhwQEgwAEhwgEgwQEgwgFGIcMBQZgCIcQBIAYgxAFqIcUBIMUBIcYBQQEhxwEgwwEgxwFxIcgBIMYBIAMgvQEgyAEQ2gxBASHJASAGIMkBNgKUAkGYAiHKASAGIMoBaiHLASDLASHMASAGIMwBNgKQAkGoCyHNAUEAIc4BIM0BIM4BEP4aGgJAA0AgBigClAIhzwEgBigCpAMh0AEg0AEQkgwh0QEgzwEh0gEg0QEh0wEg0gEg0wFJIdQBQQEh1QEg1AEg1QFxIdYBINYBRQ0BIAYoApQCIdcBIAYoAqQDIdgBINgBEJIMIdkBIAYg2QE2AgQgBiDXATYCAEGrCyHaASDaASAGEP4aGkGYAyHbASAGINsBaiHcASDcASHdASDdARDODCHeASAGIN4BNgKAAkGYAyHfASAGIN8BaiHgASDgASHhASDhARDPDCHiASAGIOIBNgL4AUHIASHjASAGIOMBaiHkASDkASHlAUGYAiHmASAGIOYBaiHnASDnASHoASDoASkCACHDAyDlASDDAzcCAEEIIekBIOUBIOkBaiHqASDoASDpAWoh6wEg6wEoAgAh7AEg6gEg7AE2AgBBuAEh7QEgBiDtAWoh7gEg7gEh7wFBACHwASDvASDwASDwASDwARC2DBpB2AEh8QEgBiDxAWoh8gEg8gEaQQgh8wFBICH0ASAGIPQBaiH1ASD1ASDzAWoh9gFByAEh9wEgBiD3AWoh+AEg+AEg8wFqIfkBIPkBKAIAIfoBIPYBIPoBNgIAIAYpA8gBIcQDIAYgxAM3AyBBECH7ASAGIPsBaiH8ASD8ASDzAWoh/QFBuAEh/gEgBiD+AWoh/wEg/wEg8wFqIYACIIACKAIAIYECIP0BIIECNgIAIAYpA7gBIcUDIAYgxQM3AxBBACGCAkHYASGDAiAGIIMCaiGEAkEgIYUCIAYghQJqIYYCQRAhhwIgBiCHAmohiAIghAIghgIgiAIgggIgggIQ2wwaIAYoAoACIYkCIAYoAvgBIYoCQdgBIYsCIAYgiwJqIYwCIIwCIY0CIIkCIIoCII0CENwMIY4CIAYgjgI2AogCQZgDIY8CIAYgjwJqIZACIJACIZECIJECEM4MIZICIAYgkgI2ArABQQAhkwIgBiCTAjYCrAEQowIhlAIgBiCUAjYCqAEQowIhlQIgBiCVAjYCpAEQ3QwhxwMgBiDHAzkDmAFBkAIhlgIgBiCWAmohlwIglwIhmAIgBiCYAjYCeEGYAiGZAiAGIJkCaiGaAiCaAiGbAiAGIJsCNgJ8QawBIZwCIAYgnAJqIZ0CIJ0CIZ4CIAYgngI2AoABQZgBIZ8CIAYgnwJqIaACIKACIaECIAYgoQI2AoQBQagBIaICIAYgogJqIaMCIKMCIaQCIAYgpAI2AogBQaQBIaUCIAYgpQJqIaYCIKYCIacCIAYgpwI2AowBQbABIagCIAYgqAJqIakCIKkCIaoCIAYgqgI2ApABQfAAIasCIAYgqwJqIawCIKwCIa0CQYgCIa4CIAYgrgJqIa8CIK8CIbACILACKAIAIbECIK0CILECNgIAAkADQEGYAyGyAiAGILICaiGzAiCzAiG0AiC0AhDPDCG1AiAGILUCNgJoQfAAIbYCIAYgtgJqIbcCILcCIbgCQegAIbkCIAYguQJqIboCILoCIbsCILgCILsCENEMIbwCQQEhvQIgvAIgvQJxIb4CIL4CRQ0BQeAAIb8CIAYgvwJqIcACIMACIcECQfAAIcICIAYgwgJqIcMCIMMCIcQCIMQCKAIAIcUCIMECIMUCNgIAIAYoAmAhxgJB+AAhxwIgBiDHAmohyAIgyAIhyQIgyQIgxgIQ3gwhygJBASHLAiDKAiDLAnEhzAICQCDMAg0ADAILQfAAIc0CIAYgzQJqIc4CIM4CIc8CIM8CENMMGgwACwALQdgAIdACIAYg0AJqIdECINECIdICQYgCIdMCIAYg0wJqIdQCINQCIdUCINUCKAIAIdYCINICINYCNgIAAkADQEGYAyHXAiAGINcCaiHYAiDYAiHZAiDZAhDODCHaAiAGINoCNgJQQdgAIdsCIAYg2wJqIdwCINwCId0CQdAAId4CIAYg3gJqId8CIN8CIeACIN0CIOACENEMIeECQQEh4gIg4QIg4gJxIeMCIOMCRQ0BQdgAIeQCIAYg5AJqIeUCIOUCIeYCQQEh5wIg5gIg5wIQ3wwh6AIgBiDoAjYCSCAGKAJIIekCQfgAIeoCIAYg6gJqIesCIOsCIewCIOwCIOkCEN4MIe0CQX8h7gIg7QIg7gJzIe8CQQEh8AIg7wIg8AJxIfECAkAg8QJFDQAMAgtB2AAh8gIgBiDyAmoh8wIg8wIh9AIg9AIQ4AwaDAALAAsgBigCoAIh9QICQCD1Ag0AQbABIfYCIAYg9gJqIfcCIPcCIfgCIPgCENcMIfkCIPkCKAIIIfoCIPoCRQ0AQcALIfsCQQAh/AIg+wIg/AIQ/hoaCyAGKAKgAiH9AgJAIP0CRQ0AQbABIf4CIAYg/gJqIf8CIP8CIYADIIADENcMIYEDIIEDKAIIIYIDIIIDDQBBxgshgwNBACGEAyCDAyCEAxD+GhoLQbABIYUDIAYghQNqIYYDIIYDIYcDIIcDENcMIYgDIIgDKAIYIYkDIIkDENgMQbABIYoDIAYgigNqIYsDIIsDIYwDIIwDENcMIY0DII0DLQAcIY4DQQEhjwMgjgMgjwNxIZADAkAgkANFDQBBsAEhkQMgBiCRA2ohkgMgkgMhkwMgkwMQ1wwhlAMglAMoAhghlQNBECGWAyCVAyCWA2ohlwNBsAEhmAMgBiCYA2ohmQMgmQMhmgMgmgMQ1wwhmwMgmwMoAhghnANBHCGdAyCcAyCdA2ohngMglwMgngMQ2QwLQbABIZ8DIAYgnwNqIaADIKADIaEDIKEDENcMIaIDIKIDKAIYIaMDIAYoAqQDIaQDIKQDEJIMIaUDIAYoApQCIaYDQQEhpwMgpgMgpwNqIagDIKUDIakDIKgDIaoDIKkDIKoDRiGrA0E4IawDIAYgrANqIa0DIK0DIa4DQQEhrwMgqwMgrwNxIbADIK4DIAMgowMgsAMQ2gxBmAIhsQMgBiCxA2ohsgMgsgMhswNBOCG0AyAGILQDaiG1AyC1AyG2AyC2AykCACHGAyCzAyDGAzcCAEEIIbcDILMDILcDaiG4AyC2AyC3A2ohuQMguQMoAgAhugMguAMgugM2AgAgBigClAIhuwNBASG8AyC7AyC8A2ohvQMgBiC9AzYClAIMAAsAC0GYAyG+AyAGIL4DaiG/AyC/AyHAAyDAAxDhDBpBsAMhwQMgBiDBA2ohwgMgwgMkAA8LQgEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOIMIAQQ4wwaQRAhBSADIAVqIQYgBiQAIAQPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDkDBpBECEFIAMgBWohBiAGJAAgBA8LZAEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhDlDCEHQX8hCCAHIAhzIQlBASEKIAkgCnEhC0EQIQwgBCAMaiENIA0kACALDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC8kBARZ/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBigCBCEHIAYQ5gwhCCAIKAIAIQkgByEKIAkhCyAKIAtJIQxBASENIAwgDXEhDgJAAkAgDkUNACAFKAIIIQ8gDxCxAiEQIAUoAgQhESARELECIRIgBiAQIBIQ5wwMAQsgBSgCCCETIBMQsQIhFCAFKAIEIRUgFRCxAiEWIAYgFCAWEOgMC0EQIRcgBSAXaiEYIBgkAA8LXwEKfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOkMGkEMIQUgBCAFaiEGIAYQ6gwaQRghByAEIAdqIQggCBDrDBpBECEJIAMgCWohCiAKJAAgBA8LqwEBE38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBBCEFIAQgBWohBiAGEOwMGkEQIQcgBCAHaiEIIAgQ7QwaQRQhCSAEIAlqIQogChDuDBpBJCELIAQgC2ohDCAMEO8MGkHAACENIAQgDWohDiAOEPAMGkHQACEPIAQgD2ohECAQEPEMGkEAIREgBCARNgKIFUEQIRIgAyASaiETIBMkACAEDwtVAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQoAgAhBSAEIAUQ8gwhBiADIAY2AgggAygCCCEHQRAhCCADIAhqIQkgCSQAIAcPC1UBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBCgCBCEFIAQgBRDyDCEGIAMgBjYCCCADKAIIIQdBECEIIAMgCGohCSAJJAAgBw8LZAEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhDzDCEHQX8hCCAHIAhzIQlBASEKIAkgCnEhC0EQIQwgBCAMaiENIA0kACALDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC5UBARN/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhghBUEIIQYgBCAGaiEHIAchCEEAIQkgCCAJEKsJGkEQIQogBCAKaiELIAshDEEIIQ0gBCANaiEOIA4hDyAMIAUgDxD8DEEQIRAgBCAQaiERIBEhEiAAIBIQ4gEaQSAhEyAEIBNqIRQgFCQADwuVAQETfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIYIQVBCCEGIAQgBmohByAHIQhBASEJIAggCRCrCRpBECEKIAQgCmohCyALIQxBCCENIAQgDWohDiAOIQ8gDCAFIA8Q/AxBECEQIAQgEGohESARIRIgACASEOIBGkEgIRMgBCATaiEUIBQkAA8LzwYBbn8jACEFQbABIQYgBSAGayEHIAckACAHIAA2AqwBIAcgATYCqAEgByACNgKkASAHIAM2AqABIAcgBDYCnAEgBygCrAEhCCAHKAKoASEJIAkoAgAhCiAHKAKkASELIAsoAgAhDEGQASENIAcgDWohDiAOIQ8gDyAKIAwQ9AwaQQQhECAIIBBqIRFB8AAhEiAHIBJqIRMgEyEUQZABIRUgByAVaiEWIBYhFyAUIBcQ9QwaQfAAIRggByAYaiEZIBkhGiARIBoQ9gxBBCEbIAggG2ohHCAcEPcMIR0gCCgCiBUhHiAdIB4Q+AwaQQQhHyAIIB9qISAgIBD3DCEhQQEhIiAhICIQ+QwaIAcoAqABISMgIygCACEkIAcoApwBISUgJSgCACEmQegAIScgByAnaiEoICghKSApICQgJhD0DBpBBCEqIAggKmohK0HIACEsIAcgLGohLSAtIS5B6AAhLyAHIC9qITAgMCExIC4gMRD1DBpByAAhMiAHIDJqITMgMyE0ICsgNBD2DEEEITUgCCA1aiE2IDYQ9wwhNyAIKAKIFSE4IDcgOBD4DBpBBCE5IAggOWohOiA6EPcMITtBAiE8IDsgPBD5DBpBkAEhPSAHID1qIT4gPiE/QegAIUAgByBAaiFBIEEhQiAIID8gQhD6DCFDQQEhRCBDIERxIUUCQAJAIEVFDQBBBCFGIAggRmohR0EoIUggByBIaiFJIEkhSkGQASFLIAcgS2ohTCBMIU1B6AAhTiAHIE5qIU8gTyFQIEogTSBQEPsMGkEoIVEgByBRaiFSIFIhUyBHIFMQ9gxBBCFUIAggVGohVSBVEPcMIVZBCCFXIFYgVxD5DBoMAQtBBCFYIAggWGohWUEIIVogByBaaiFbIFshXEHoACFdIAcgXWohXiBeIV9BkAEhYCAHIGBqIWEgYSFiIFwgXyBiEPsMGkEIIWMgByBjaiFkIGQhZSBZIGUQ9gxBBCFmIAggZmohZyBnEPcMIWhBCSFpIGggaRD5DBoLQQQhaiAIIGpqIWsgaxD3DCFsIAgoAogVIW0gbCBtEPgMGiAIKAKIFSFuQQEhbyBuIG9qIXAgCCBwNgKIFUGwASFxIAcgcWohciByJAAgbg8LPQEHfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBUEQIQYgBSAGaiEHIAQgBzYCACAEDwuhBQFTfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGQQQhByAFIAdqIQggCBD9DCEJIAYgCRD+DCAFEP8MIAQoAhghCiAFIAoQgA0DQEEkIQsgBSALaiEMIAwQgQ0hDUEBIQ5BASEPIA0gD3EhECAOIRECQCAQRQ0AQRAhEiAFIBJqIRNBBCEUIAUgFGohFSAVEIINIRYgBCAWNgIIQQghFyAEIBdqIRggGCEZIBMgGRCDDSEaQX8hGyAaIBtzIRwgHCERCyARIR1BASEeIB0gHnEhHwJAIB9FDQBBJCEgIAUgIGohISAhEIENISJBASEjICIgI3EhJAJAAkAgJEUNACAEKAIYISUgBSAlEIQNDAELQRAhJiAFICZqISdBBCEoIAUgKGohKSApEIINISogBCAqNgIAIAQhKyAnICsQgw0hLEEBIS0gLCAtcSEuAkACQCAuRQ0AIAQoAhghLyAFIC8QhQ0MAQtBECEwIAUgMGohMSAxEIYNITJBJCEzIAUgM2ohNCA0EIcNITVBECE2IAQgNmohNyA3ITggOCAyIDUQiA0hOUEBITogOSA6cSE7AkACQCA7RQ0AIAQoAhghPCAFIDwQhA0MAQsgBCgCGCE9IAUgPRCFDQsLCwNAQSQhPiAFID5qIT8gPxCBDSFAQQAhQUEBIUIgQCBCcSFDIEEhRAJAIEMNAEEkIUUgBSBFaiFGIEYQhw0hRyBHEIkNIUhBfyFJIEggSXMhSiBKIUQLIEQhS0EBIUwgSyBMcSFNAkAgTUUNAEEkIU4gBSBOaiFPIE8Qig0MAQsLDAELC0HAACFQIAUgUGohUSBREIsNIAQoAhghUiBSEIwNQSAhUyAEIFNqIVQgVCQADwvhAgEtfyMAIQVBMCEGIAUgBmshByAHJAAgByABNgIoIAcgAjYCICAHIAA2AhwgAyEIIAcgCDoAGyAEIQkgByAJOgAaQRAhCiAHIApqIQsgCyEMQSghDSAHIA1qIQ4gDiEPIA8oAgAhECAMIBA2AgACQANAQRAhESAHIBFqIRIgEiETQSAhFCAHIBRqIRUgFSEWIBMgFhDrASEXQQEhGCAXIBhxIRkgGUUNASAHKAIcIRpBECEbIAcgG2ohHCAcIR0gHRDsASEeIB4Q7QEhHyAHIB82AghBECEgIAcgIGohISAhISIgIhDsASEjICMQ7gEhJCAHICQ2AgAgBy0AGyElIActABohJiAHKAIIIScgBygCACEoQQEhKSAlIClxISpBASErICYgK3EhLCAaICcgKCAqICwQjQ1BECEtIAcgLWohLiAuIS8gLxDwARoMAAsAC0EwITAgByAwaiExIDEkAA8LRAEJfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgQhBSAEKAIAIQYgBSAGayEHQSwhCCAHIAhtIQkgCQ8LSwEJfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIAIQYgBCgCCCEHQSwhCCAHIAhsIQkgBiAJaiEKIAoPCy8BBn8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBEEYIQUgBCAFaiEGIAYPC1UBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBCgCACEFIAQgBRCODSEGIAMgBjYCCCADKAIIIQdBECEIIAMgCGohCSAJJAAgBw8LVQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEKAIEIQUgBCAFEI4NIQYgAyAGNgIIIAMoAgghB0EQIQggAyAIaiEJIAkkACAHDwtkAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEI8NIQdBfyEIIAcgCHMhCUEBIQogCSAKcSELQRAhDCAEIAxqIQ0gDSQAIAsPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBQ8LaQEMfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIUIQZBHyEHIAYgB3EhCCAFIAg2AhQgBCgCCCEJQQUhCiAJIAp0IQsgBSgCFCEMIAwgC3IhDSAFIA02AhQPCz0BB38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQVBGCEGIAUgBmohByAEIAc2AgAgBA8LRAEJfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgQhBSAEKAIAIQYgBSAGayEHQRghCCAHIAhtIQkgCQ8LSwEJfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIAIQYgBCgCCCEHQRghCCAHIAhsIQkgBiAJaiEKIAoPC1IBDH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIUIQVBAiEGIAUgBnEhB0EBIQhBACEJIAggCSAHGyEKQQEhCyAKIAtxIQwgDA8LmQEBF38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBChDCEFQQAhBiAFIQcgBiEIIAcgCEchCUEAIQpBASELIAkgC3EhDCAKIQ0CQCAMRQ0AIAQQpAwhDkEAIQ8gDiEQIA8hESAQIBFHIRIgEiENCyANIRNBASEUIBMgFHEhFUEQIRYgAyAWaiEXIBckACAVDws2AQd/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCFCEFQQUhBiAFIAZ2IQcgBw8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgghBSAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwsvAQZ/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGDwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgghBSAFEJANIQZBECEHIAMgB2ohCCAIJAAgBg8L8AEBGn8jACEEQRAhBSAEIAVrIQYgBiQAIAYgADYCDCAGIAE2AgggBiACNgIEIAYgAzYCACAGKAIMIQcgBygCBCEIIAcQkQ0hCSAJKAIAIQogCCELIAohDCALIAxJIQ1BASEOIA0gDnEhDwJAAkAgD0UNACAGKAIIIRAgEBCxAiERIAYoAgQhEiASELECIRMgBigCACEUIBQQ0gkhFSAHIBEgEyAVEJINDAELIAYoAgghFiAWELECIRcgBigCBCEYIBgQsQIhGSAGKAIAIRogGhDSCSEbIAcgFyAZIBsQkw0LQRAhHCAGIBxqIR0gHSQADws2AQd/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFQVQhBiAFIAZqIQcgBw8LVQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEKAIAIQUgBCAFEJ0NIQYgAyAGNgIIIAMoAgghB0EQIQggAyAIaiEJIAkkACAHDwtVAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQoAgQhBSAEIAUQnQ0hBiADIAY2AgggAygCCCEHQRAhCCADIAhqIQkgCSQAIAcPC8URAv8Bfwl+IwAhA0GgAiEEIAMgBGshBSAFJAAgBSABNgKYAiAFIAI2ApACIAUgADYCjAJBgAIhBiAFIAZqIQcgByEIIAgQ9AEaQZACIQkgBSAJaiEKIAohC0GYAiEMIAUgDGohDSANIQ4gCyAOEJQNIQ8gBSAPNgL8ASAFKAL8ASEQQYACIREgBSARaiESIBIhEyATIBAQ9gFBACEUIAUgFDYC+AECQANAIAUoAvgBIRUgBSgC/AEhFiAVIRcgFiEYIBcgGEkhGUEBIRogGSAacSEbIBtFDQEgBSgC+AEhHEGYAiEdIAUgHWohHiAeIR8gHyAcEJUNISBBECEhICAgIWohIkG4ASEjIAUgI2ohJCAkISUgIikCACGCAiAlIIICNwIAQQghJiAlICZqIScgIiAmaiEoICgoAgAhKSAnICk2AgBByAEhKiAFICpqISsgKxpBCCEsQQghLSAFIC1qIS4gLiAsaiEvQbgBITAgBSAwaiExIDEgLGohMiAyKAIAITMgLyAzNgIAIAUpA7gBIYMCIAUggwI3AwhByAEhNCAFIDRqITVBCCE2IAUgNmohNyA1IDcQlg0gBSgC+AEhOEGYAiE5IAUgOWohOiA6ITsgOyA4EJUNITxBHCE9IDwgPWohPkGgASE/IAUgP2ohQCBAIUEgPikCACGEAiBBIIQCNwIAQQghQiBBIEJqIUMgPiBCaiFEIEQoAgAhRSBDIEU2AgBBsAEhRiAFIEZqIUcgRxpBCCFIQRghSSAFIElqIUogSiBIaiFLQaABIUwgBSBMaiFNIE0gSGohTiBOKAIAIU8gSyBPNgIAIAUpA6ABIYUCIAUghQI3AxhBsAEhUCAFIFBqIVFBGCFSIAUgUmohUyBRIFMQlg1B0AEhVCAFIFRqIVUgVSFWQcgBIVcgBSBXaiFYIFghWUGwASFaIAUgWmohWyBbIVwgViBZIFwQ+QEgBSgC+AEhXUGYAiFeIAUgXmohXyBfIWAgYCBdEJUNIWFBKCFiIGEgYmohY0GYASFkIAUgZGohZSBlIWZB+AEhZyAFIGdqIWggaCFpIGYgaSBjEPoBQeABIWogBSBqaiFrIGshbEHQASFtIAUgbWohbiBuIW9BmAEhcCAFIHBqIXEgcSFyIGwgbyByEPsBQYACIXMgBSBzaiF0IHQhdUHgASF2IAUgdmohdyB3IXggdSB4EPwBIAUoAvgBIXlBASF6IHkgemoheyAFIHs2AvgBDAALAAtBiAEhfCAFIHxqIX0gfSF+IH4Q9AEaIAUoAvwBIX9BiAEhgAEgBSCAAWohgQEggQEhggEgggEgfxD2AUGAAiGDASAFIIMBaiGEASCEASGFASCFARD9ASGGASAFIIYBNgKAAUGAAiGHASAFIIcBaiGIASCIASGJASCJARD+ASGKASAFIIoBNgJ4IAUoAoABIYsBIAUoAnghjAFBiAEhjQEgBSCNAWohjgEgjgEhjwEgjwEgiwEgjAEQ/wFB6AAhkAEgBSCQAWohkQEgkQEhkgEgkgEQ/wsaQYgBIZMBIAUgkwFqIZQBIJQBIZUBIJUBEIACIZYBQegAIZcBIAUglwFqIZgBIJgBIZkBIJkBIJYBEJcNQYgBIZoBIAUgmgFqIZsBIJsBIZwBIAUgnAE2AmQgBSgCZCGdASCdARD9ASGeASAFIJ4BNgJgIAUoAmQhnwEgnwEQ/gEhoAEgBSCgATYCWAJAA0BB4AAhoQEgBSChAWohogEgogEhowFB2AAhpAEgBSCkAWohpQEgpQEhpgEgowEgpgEQggIhpwFBASGoASCnASCoAXEhqQEgqQFFDQFB4AAhqgEgBSCqAWohqwEgqwEhrAEgrAEQgwIhrQEgBSCtATYCVCAFKAJUIa4BIK4BKAIQIa8BQZgCIbABIAUgsAFqIbEBILEBIbIBILIBIK8BEJUNIbMBQSghtAEgBSC0AWohtQEgtQEhtgEgswEpAgAhhgIgtgEghgI3AgBBKCG3ASC2ASC3AWohuAEgswEgtwFqIbkBILkBKAIAIboBILgBILoBNgIAQSAhuwEgtgEguwFqIbwBILMBILsBaiG9ASC9ASkCACGHAiC8ASCHAjcCAEEYIb4BILYBIL4BaiG/ASCzASC+AWohwAEgwAEpAgAhiAIgvwEgiAI3AgBBECHBASC2ASDBAWohwgEgswEgwQFqIcMBIMMBKQIAIYkCIMIBIIkCNwIAQQghxAEgtgEgxAFqIcUBILMBIMQBaiHGASDGASkCACGKAiDFASCKAjcCAEEoIccBIAUgxwFqIcgBIMgBIckBQRAhygEgyQEgygFqIcsBIAUoAlQhzAEgzAEQDSHNASDLASDNARCYDRpBKCHOASAFIM4BaiHPASDPASHQAUEQIdEBINABINEBaiHSASAFKAJUIdMBINMBEA4h1AEg0gEg1AEQmQ0aQSgh1QEgBSDVAWoh1gEg1gEh1wFBHCHYASDXASDYAWoh2QEgBSgCVCHaAUEIIdsBINoBINsBaiHcASDcARANId0BINkBIN0BEJgNGkEoId4BIAUg3gFqId8BIN8BIeABQRwh4QEg4AEg4QFqIeIBIAUoAlQh4wFBCCHkASDjASDkAWoh5QEg5QEQDiHmASDiASDmARCZDRogBSgCVCHnASDnASgCFCHoASAFIOgBNgJQQegAIekBIAUg6QFqIeoBIOoBIesBQSgh7AEgBSDsAWoh7QEg7QEh7gEg6wEg7gEQmg1B4AAh7wEgBSDvAWoh8AEg8AEh8QEg8QEQiAIaDAALAAtB6AAh8gEgBSDyAWoh8wEg8wEh9AEg9AEQmw0h9QEgBSgCjAIh9gEg9gEg9QEQnA0aQegAIfcBIAUg9wFqIfgBIPgBIfkBIPkBEIEMGkGIASH6ASAFIPoBaiH7ASD7ASH8ASD8ARCLAhpBgAIh/QEgBSD9AWoh/gEg/gEh/wEg/wEQiwIaQaACIYACIAUggAJqIYECIIECJAAPC50BARR/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhggBCABNgIQQQghBSAEIAVqIQYgBiEHQRghCCAEIAhqIQkgCSEKIAooAgAhCyAHIAs2AgAgBCEMQRAhDSAEIA1qIQ4gDiEPIA8oAgAhECAMIBA2AgAgBCgCCCERIAQoAgAhEkEEIRMgESASIBMQnw1BICEUIAQgFGohFSAVJAAPCy0BBX8jACEBQSAhAiABIAJrIQMgAyQAIAAQug0aQSAhBCADIARqIQUgBSQADwv3NQLRBX8kfiMAIQNB4AUhBCADIARrIQUgBSQAIAUgADYC2AUgBSABNgLQBUEAIQYgBSAGOgDHBUHYBSEHIAUgB2ohCCAIIQlB0AUhCiAFIApqIQsgCyEMIAkgDBCgDSENQQEhDiANIA5xIQ8CQAJAIA9FDQAMAQtB2AUhECAFIBBqIREgESESIBIQoQ0hE0EQIRQgEyAUaiEVQbAFIRYgBSAWaiEXIBchGCAVKQIAIdQFIBgg1AU3AgBBCCEZIBggGWohGiAVIBlqIRsgGygCACEcIBogHDYCAEEIIR1B4AEhHiAFIB5qIR8gHyAdaiEgQbAFISEgBSAhaiEiICIgHWohIyAjKAIAISQgICAkNgIAIAUpA7AFIdUFIAUg1QU3A+ABQeABISUgBSAlaiEmICYQog0hJyAFICc2AsAFQaAFISggBSAoaiEpICkhKiAqEKMNGgNAQdgFISsgBSAraiEsICwhLUHQBSEuIAUgLmohLyAvITAgLSAwEK0MITFBASEyQQEhMyAxIDNxITQgMiE1AkAgNA0AQaAFITYgBSA2aiE3IDchOCA4EKQNITlBfyE6IDkgOnMhOyA7ITULIDUhPEEBIT0gPCA9cSE+AkAgPkUNAANAQdgFIT8gBSA/aiFAIEAhQUHQBSFCIAUgQmohQyBDIUQgQSBEEK0MIUVBACFGQQEhRyBFIEdxIUggRiFJAkAgSEUNAEHYBSFKIAUgSmohSyBLIUwgTBChDSFNQRAhTiBNIE5qIU9BkAUhUCAFIFBqIVEgUSFSIE8pAgAh1gUgUiDWBTcCAEEIIVMgUiBTaiFUIE8gU2ohVSBVKAIAIVYgVCBWNgIAQQghV0HQASFYIAUgWGohWSBZIFdqIVpBkAUhWyAFIFtqIVwgXCBXaiFdIF0oAgAhXiBaIF42AgAgBSkDkAUh1wUgBSDXBTcD0AFB0AEhXyAFIF9qIWAgYBCiDSFhIAUoAsAFIWIgYSFjIGIhZCBjIGRGIWUgZSFJCyBJIWZBASFnIGYgZ3EhaAJAIGhFDQBB2AUhaSAFIGlqIWogaiFrIGsQrgwhbEHgBCFtIAUgbWohbiBuIW8gbyBsEKUNGkEBIXAgBSBwOgCBBUGgBSFxIAUgcWohciByIXNB4AQhdCAFIHRqIXUgdSF2IHMgdhCmDUHYBSF3IAUgd2oheCB4IXkgeRDDDBoMAQsLQaAFIXogBSB6aiF7IHshfCAFIHw2AtwEIAUoAtwEIX0gfRCnDSF+IAUgfjYC2AQgBSgC3AQhfyB/EKgNIYABIAUggAE2AtAEAkADQEHYBCGBASAFIIEBaiGCASCCASGDAUHQBCGEASAFIIQBaiGFASCFASGGASCDASCGARCpDSGHAUEBIYgBIIcBIIgBcSGJASCJAUUNAUHYBCGKASAFIIoBaiGLASCLARCqDSGMASAFIIwBNgLMBCAFKALMBCGNASCNASgCCCGOASAFII4BNgLIBCAFKALABSGPASAFKALIBCGQAUEQIZEBIAUgkQFqIZIBIJIBII8BIJABEKsNIAUpAxgh2AUgBSkDECHZBSAFKALMBCGTASCTASDZBTcDEEEYIZQBIJMBIJQBaiGVASCVASDYBTcDACAFKALABSGWASAFKALIBCGXAUEQIZgBIJcBIJgBaiGZAUG4BCGaASAFIJoBaiGbASCbASGcASCZASkCACHaBSCcASDaBTcCAEEIIZ0BIJwBIJ0BaiGeASCZASCdAWohnwEgnwEoAgAhoAEgngEgoAE2AgBBCCGhAUEgIaIBIAUgogFqIaMBIKMBIKEBaiGkAUG4BCGlASAFIKUBaiGmASCmASChAWohpwEgpwEoAgAhqAEgpAEgqAE2AgAgBSkDuAQh2wUgBSDbBTcDIEEgIakBIAUgqQFqIaoBIKoBEKINIasBIJYBIawBIKsBIa0BIKwBIK0BRiGuAUEBIa8BQQEhsAEgrgEgsAFxIbEBIK8BIbIBAkAgsQENACAFKALABSGzASAFKALIBCG0AUEcIbUBILQBILUBaiG2AUGoBCG3ASAFILcBaiG4ASC4ASG5ASC2ASkCACHcBSC5ASDcBTcCAEEIIboBILkBILoBaiG7ASC2ASC6AWohvAEgvAEoAgAhvQEguwEgvQE2AgBBCCG+ASAFIL4BaiG/AUGoBCHAASAFIMABaiHBASDBASC+AWohwgEgwgEoAgAhwwEgvwEgwwE2AgAgBSkDqAQh3QUgBSDdBTcDACAFEKINIcQBILMBIcUBIMQBIcYBIMUBIMYBRiHHASDHASGyAQsgsgEhyAEgBSgCzAQhyQFBASHKASDIASDKAXEhywEgyQEgywE6ACBB2AQhzAEgBSDMAWohzQEgzQEhzgEgzgEQrA0aDAALAAtBoAUhzwEgBSDPAWoh0AEg0AEh0QEg0QEQrQ0h0gEgBSDSATYCoARBoAUh0wEgBSDTAWoh1AEg1AEh1QEg1QEQrg0h1gEgBSDWATYCmAQgBSgCoAQh1wEgBSgCmAQh2AFBBSHZASDXASDYASDZARCwDUGgBSHaASAFINoBaiHbASDbASHcASDcARCtDSHdASAFIN0BNgKQBAJAA0BBoAUh3gEgBSDeAWoh3wEg3wEh4AEg4AEQrg0h4QEgBSDhATYCiARBkAQh4gEgBSDiAWoh4wEg4wEh5AFBiAQh5QEgBSDlAWoh5gEg5gEh5wEg5AEg5wEQqQ0h6AFBASHpASDoASDpAXEh6gEg6gFFDQFBkAQh6wEgBSDrAWoh7AEg7AEh7QFBASHuASDtASDuARCxDSHvASAFIO8BNgKABEGQBCHwASAFIPABaiHxASDxASHyASDyARCyDSHzASDzAS0AICH0AUEBIfUBIPQBIPUBcSH2AQJAIPYBRQ0AA0BBoAUh9wEgBSD3AWoh+AEg+AEh+QEg+QEQrg0h+gEgBSD6ATYC+ANBgAQh+wEgBSD7AWoh/AEg/AEh/QFB+AMh/gEgBSD+AWoh/wEg/wEhgAIg/QEggAIQqQ0hgQJBACGCAkEBIYMCIIECIIMCcSGEAiCCAiGFAgJAIIQCRQ0AQYAEIYYCIAUghgJqIYcCIIcCIYgCIIgCELINIYkCIIkCLQAgIYoCQQAhiwJBASGMAiCKAiCMAnEhjQIgiwIhhQIgjQJFDQBBgAQhjgIgBSCOAmohjwIgjwIQsg0hkAJBGCGRAiCQAiCRAmohkgIgkgIpAwAh3gUgkAIpAxAh3wVBkAQhkwIgBSCTAmohlAIglAIQsg0hlQIglQIgkQJqIZYCIJYCKQMAIeAFIJUCKQMQIeEFIN8FIN4FIOEFIOAFEKUaIZcCIJcCRSGYAiCYAiGFAgsghQIhmQJBASGaAiCZAiCaAnEhmwICQCCbAkUNAEGABCGcAiAFIJwCaiGdAiCdAiGeAiCeAhCsDRoMAQsLC0HwAyGfAiAFIJ8CaiGgAiCgAiGhAkGQBCGiAiAFIKICaiGjAiCjAiGkAiCkAigCACGlAiChAiClAjYCAAJAA0BB8AMhpgIgBSCmAmohpwIgpwIhqAJBgAQhqQIgBSCpAmohqgIgqgIhqwIgqAIgqwIQsw0hrAJBASGtAiCsAiCtAnEhrgIgrgJFDQFB8AMhrwIgBSCvAmohsAIgsAIhsQIgsQIQsg0hsgIgsgIoAgghswIgBSCzAjYC7ANB8AMhtAIgBSC0AmohtQIgtQIhtgIgtgIQsg0htwIgtwIoAgghuAJBECG5AiC4AiC5AmohugJB4AMhuwIgBSC7AmohvAIgvAIhvQIgugIpAgAh4gUgvQIg4gU3AgBBCCG+AiC9AiC+AmohvwIgugIgvgJqIcACIMACKAIAIcECIL8CIMECNgIAQQghwgJB0AAhwwIgBSDDAmohxAIgxAIgwgJqIcUCQeADIcYCIAUgxgJqIccCIMcCIMICaiHIAiDIAigCACHJAiDFAiDJAjYCACAFKQPgAyHjBSAFIOMFNwNQQdAAIcoCIAUgygJqIcsCIMsCEKINIcwCQfADIc0CIAUgzQJqIc4CIM4CIc8CIM8CELINIdACINACKAIIIdECQRwh0gIg0QIg0gJqIdMCQdADIdQCIAUg1AJqIdUCINUCIdYCINMCKQIAIeQFINYCIOQFNwIAQQgh1wIg1gIg1wJqIdgCINMCINcCaiHZAiDZAigCACHaAiDYAiDaAjYCAEEIIdsCQeAAIdwCIAUg3AJqId0CIN0CINsCaiHeAkHQAyHfAiAFIN8CaiHgAiDgAiDbAmoh4QIg4QIoAgAh4gIg3gIg4gI2AgAgBSkD0AMh5QUgBSDlBTcDYEHgACHjAiAFIOMCaiHkAiDkAhCiDSHlAiDMAiHmAiDlAiHnAiDmAiDnAkch6AJBASHpAiDoAiDpAnEh6gICQCDqAkUNACAFKALABSHrAiAFKALsAyHsAkEQIe0CIOwCIO0CaiHuAkHAAyHvAiAFIO8CaiHwAiDwAiHxAiDuAikCACHmBSDxAiDmBTcCAEEIIfICIPECIPICaiHzAiDuAiDyAmoh9AIg9AIoAgAh9QIg8wIg9QI2AgBBCCH2AkEwIfcCIAUg9wJqIfgCIPgCIPYCaiH5AkHAAyH6AiAFIPoCaiH7AiD7AiD2Amoh/AIg/AIoAgAh/QIg+QIg/QI2AgAgBSkDwAMh5wUgBSDnBTcDMEEwIf4CIAUg/gJqIf8CIP8CEKINIYADIOsCIYEDIIADIYIDIIEDIIIDRiGDA0HwAyGEAyAFIIQDaiGFAyCFAyGGAyCGAxCyDSGHA0EBIYgDIIMDIIgDcSGJAyCHAyCJAzoAISAFKALABSGKAyAFKALsAyGLA0EcIYwDIIsDIIwDaiGNA0GwAyGOAyAFII4DaiGPAyCPAyGQAyCNAykCACHoBSCQAyDoBTcCAEEIIZEDIJADIJEDaiGSAyCNAyCRA2ohkwMgkwMoAgAhlAMgkgMglAM2AgBBCCGVA0HAACGWAyAFIJYDaiGXAyCXAyCVA2ohmANBsAMhmQMgBSCZA2ohmgMgmgMglQNqIZsDIJsDKAIAIZwDIJgDIJwDNgIAIAUpA7ADIekFIAUg6QU3A0BBwAAhnQMgBSCdA2ohngMgngMQog0hnwMgigMhoAMgnwMhoQMgoAMgoQNGIaIDQfADIaMDIAUgowNqIaQDIKQDIaUDIKUDELINIaYDQQEhpwMgogMgpwNxIagDIKYDIKgDOgAiC0HwAyGpAyAFIKkDaiGqAyCqAyGrAyCrAxCsDRoMAAsACyAFKALABSGsA0GQBCGtAyAFIK0DaiGuAyCuAxCyDSGvA0EYIbADIK8DILADaiGxAyCxAykDACHqBSCvAykDECHrBUGoAyGyAyAFILIDaiGzAyCzAyG0A0GQBCG1AyAFILUDaiG2AyC2AyG3AyC3AygCACG4AyC0AyC4AzYCAEGgAyG5AyAFILkDaiG6AyC6AyG7A0GABCG8AyAFILwDaiG9AyC9AyG+AyC+AygCACG/AyC7AyC/AzYCACAFKAKoAyHAAyAFKAKgAyHBA0HIBSHCAyAFIMIDaiHDAyCsAyDrBSDqBSDAAyDBAyACIMMDELQNA0BBkAQhxAMgBSDEA2ohxQMgxQMhxgNBgAQhxwMgBSDHA2ohyAMgyAMhyQMgxgMgyQMQsw0hygNBACHLA0EBIcwDIMoDIMwDcSHNAyDLAyHOAwJAIM0DRQ0AQZAEIc8DIAUgzwNqIdADINADIdEDINEDELINIdIDINIDKAIIIdMDQRAh1AMg0wMg1ANqIdUDQZADIdYDIAUg1gNqIdcDINcDIdgDINUDKQIAIewFINgDIOwFNwIAQQgh2QMg2AMg2QNqIdoDINUDINkDaiHbAyDbAygCACHcAyDaAyDcAzYCAEEIId0DQZABId4DIAUg3gNqId8DIN8DIN0DaiHgA0GQAyHhAyAFIOEDaiHiAyDiAyDdA2oh4wMg4wMoAgAh5AMg4AMg5AM2AgAgBSkDkAMh7QUgBSDtBTcDkAFBkAEh5QMgBSDlA2oh5gMg5gMQog0h5wNBkAQh6AMgBSDoA2oh6QMg6QMh6gMg6gMQsg0h6wMg6wMoAggh7ANBHCHtAyDsAyDtA2oh7gNBgAMh7wMgBSDvA2oh8AMg8AMh8QMg7gMpAgAh7gUg8QMg7gU3AgBBCCHyAyDxAyDyA2oh8wMg7gMg8gNqIfQDIPQDKAIAIfUDIPMDIPUDNgIAQQgh9gNBoAEh9wMgBSD3A2oh+AMg+AMg9gNqIfkDQYADIfoDIAUg+gNqIfsDIPsDIPYDaiH8AyD8AygCACH9AyD5AyD9AzYCACAFKQOAAyHvBSAFIO8FNwOgAUGgASH+AyAFIP4DaiH/AyD/AxCiDSGABCDnAyGBBCCABCGCBCCBBCCCBEchgwRBASGEBEEBIYUEIIMEIIUEcSGGBCCEBCGHBAJAIIYEDQBBkAQhiAQgBSCIBGohiQQgiQQhigQgigQQsg0hiwQgiwQtACIhjAQgjAQhhwQLIIcEIY0EII0EIc4DCyDOAyGOBEEBIY8EII4EII8EcSGQBAJAIJAERQ0AQZAEIZEEIAUgkQRqIZIEIJIEIZMEIJMEEKwNGgwBCwtB+AIhlAQgBSCUBGohlQQglQQhlgRBkAQhlwQgBSCXBGohmAQgmAQhmQQgmQQoAgAhmgQglgQgmgQ2AgACQANAQfgCIZsEIAUgmwRqIZwEIJwEIZ0EQYAEIZ4EIAUgngRqIZ8EIJ8EIaAEIJ0EIKAEELMNIaEEQQEhogQgoQQgogRxIaMEIKMERQ0BQfgCIaQEIAUgpARqIaUEIKUEELINIaYEIKYEKAIIIacEQSQhqAQgpwQgqARqIakEIKkEKAIAIaoEQQghqwRB6AIhrAQgBSCsBGohrQQgrQQgqwRqIa4EIK4EIKoENgIAIKcEKQIcIfAFIAUg8AU3A+gCQYABIa8EIAUgrwRqIbAEILAEIKsEaiGxBCCuBCgCACGyBCCxBCCyBDYCACAFKQPoAiHxBSAFIPEFNwOAAUGAASGzBCAFILMEaiG0BCC0BBC1DSG1BEHwACG2BCAFILYEaiG3BCC3BCC1BBCxGkHwACG4BCAFILgEaiG5BCC5BCCrBGohugQgugQpAwAh8gUgBSkDcCHzBUH4AiG7BCAFILsEaiG8BCC8BBCyDSG9BEEYIb4EIL0EIL4EaiG/BCC/BCDyBTcDACC9BCDzBTcDEEH4AiHABCAFIMAEaiHBBCDBBCHCBCDCBBCyDSHDBEEAIcQEIMMEIMQEOgAhQfgCIcUEIAUgxQRqIcYEIMYEIccEIMcEELINIcgEQQEhyQQgyAQgyQQ6ACJB+AIhygQgBSDKBGohywQgywQhzAQgzAQQrA0aDAALAAsMAAsAC0GgBSHNBCAFIM0EaiHOBCDOBCHPBCDPBBCnDSHQBCAFINAENgLQAkGgBSHRBCAFINEEaiHSBCDSBCHTBCDTBBCoDSHUBCAFINQENgLIAiAFKALQAiHVBCAFKALIAiHWBCDVBCDWBBC2DSHXBCAFINcENgLYAkHgAiHYBCAFINgEaiHZBCDZBCHaBEHYAiHbBCAFINsEaiHcBCDcBCHdBEEAId4EINoEIN0EIN4EELcNGkGgBSHfBCAFIN8EaiHgBCDgBCHhBCDhBBCoDSHiBCAFIOIENgKwAkG4AiHjBCAFIOMEaiHkBCDkBCHlBEGwAiHmBCAFIOYEaiHnBCDnBCHoBEEAIekEIOUEIOgEIOkEELcNGiAFKALgAiHqBCAFKAK4AiHrBEGgBSHsBCAFIOwEaiHtBCDtBCHuBCDuBCDqBCDrBBC4DSHvBCAFIO8ENgKoAhCjAiHwBCAFIPAENgLABUGgBSHxBCAFIPEEaiHyBCDyBCHzBCAFIPMENgKkAiAFKAKkAiH0BCD0BBCnDSH1BCAFIPUENgKgAiAFKAKkAiH2BCD2BBCoDSH3BCAFIPcENgKYAgJAA0BBoAIh+AQgBSD4BGoh+QQg+QQh+gRBmAIh+wQgBSD7BGoh/AQg/AQh/QQg+gQg/QQQqQ0h/gRBASH/BCD+BCD/BHEhgAUggAVFDQFBoAIhgQUgBSCBBWohggUgggUhgwUggwUQqg0hhAUgBSCEBTYClAIgBSgClAIhhQUghQUoAgghhgVBHCGHBSCGBSCHBWohiAVBgAIhiQUgBSCJBWohigUgigUhiwUgiAUpAgAh9AUgiwUg9AU3AgBBCCGMBSCLBSCMBWohjQUgiAUgjAVqIY4FII4FKAIAIY8FII0FII8FNgIAQQghkAVBsAEhkQUgBSCRBWohkgUgkgUgkAVqIZMFQYACIZQFIAUglAVqIZUFIJUFIJAFaiGWBSCWBSgCACGXBSCTBSCXBTYCACAFKQOAAiH1BSAFIPUFNwOwAUGwASGYBSAFIJgFaiGZBSCZBRCiDSGaBSAFIJoFNgKQAkHABSGbBSAFIJsFaiGcBSCcBSGdBUGQAiGeBSAFIJ4FaiGfBSCfBSGgBSCdBSCgBRCkAiGhBSChBSgCACGiBSAFIKIFNgLABUGgAiGjBSAFIKMFaiGkBSCkBSGlBSClBRCsDRoMAAsAC0HYBSGmBSAFIKYFaiGnBSCnBSGoBUHQBSGpBSAFIKkFaiGqBSCqBSGrBSCoBSCrBRCtDCGsBUEBIa0FIKwFIK0FcSGuBQJAIK4FRQ0AQdgFIa8FIAUgrwVqIbAFILAFIbEFILEFEKENIbIFQRAhswUgsgUgswVqIbQFQfABIbUFIAUgtQVqIbYFILYFIbcFILQFKQIAIfYFILcFIPYFNwIAQQghuAUgtwUguAVqIbkFILQFILgFaiG6BSC6BSgCACG7BSC5BSC7BTYCAEEIIbwFQcABIb0FIAUgvQVqIb4FIL4FILwFaiG/BUHwASHABSAFIMAFaiHBBSDBBSC8BWohwgUgwgUoAgAhwwUgvwUgwwU2AgAgBSkD8AEh9wUgBSD3BTcDwAFBwAEhxAUgBSDEBWohxQUgxQUQog0hxgUgBSDGBTYC/AFBwAUhxwUgBSDHBWohyAUgyAUhyQVB/AEhygUgBSDKBWohywUgywUhzAUgyQUgzAUQpAIhzQUgzQUoAgAhzgUgBSDOBTYCwAULDAELC0GgBSHPBSAFIM8FaiHQBSDQBSHRBSDRBRC5DRoLQeAFIdIFIAUg0gVqIdMFINMFJAAPC2QBDH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQoA0hB0F/IQggByAIcyEJQQEhCiAJIApxIQtBECEMIAQgDGohDSANJAAgCw8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC1IBDH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIUIQVBASEGIAUgBnEhB0EBIQhBACEJIAggCSAHGyEKQQEhCyAKIAtxIQwgDA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwtLAQl/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgAhBiAEKAIIIQdBBCEIIAcgCHQhCSAGIAlqIQogCg8LygEBGH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCCCAEIAE2AgQgBCgCCCEFIAQgBTYCDEEQIQYgBSAGaiEHIAUhCANAIAghCSAJELcGGkEIIQogCSAKaiELIAshDCAHIQ0gDCANRiEOQQEhDyAOIA9xIRAgCyEIIBBFDQALIAQoAgQhESAFIBEQ6AEaIAQoAgQhEkEIIRMgEiATaiEUQQghFSAFIBVqIRYgFiAUEOgBGiAEKAIMIRdBECEYIAQgGGohGSAZJAAgFw8L8w4B7QF/IwAhA0GQAiEEIAMgBGshBSAFJAAgBSACNgKIAiAFIAA2AoQCIAUgATYCgAIgBSgChAIhBkH4ASEHIAUgB2ohCCAIIQkgCSAGEIwMIAUoAoACIQpB8AEhCyAFIAtqIQwgDCENIA0gChCMDEH4ASEOIAUgDmohDyAPIRBB8AEhESAFIBFqIRIgEiETIBAgExDkASEUQQEhFSAUIBVxIRYCQAJAIBZFDQAgBSgChAIhF0HgASEYIAUgGGohGSAZIRogGiAXEIwMQegBIRsgBSAbaiEcIBwhHUHgASEeIAUgHmohHyAfISAgHSAgEOIBGiAFKAKEAiEhQdABISIgBSAiaiEjICMhJCAkICEQjQxB2AEhJSAFICVqISYgJiEnQdABISggBSAoaiEpICkhKiAnICoQ4gEaIAUoAoACIStBwAEhLCAFICxqIS0gLSEuIC4gKxCNDEHIASEvIAUgL2ohMCAwITFBwAEhMiAFIDJqITMgMyE0IDEgNBDiARpBiAIhNSAFIDVqITYgNiE3QegBITggBSA4aiE5IDkhOkHYASE7IAUgO2ohPCA8IT1ByAEhPiAFID5qIT8gPyFAIDcgOiA9IEAQuw0MAQsgBSgChAIhQUG4ASFCIAUgQmohQyBDIUQgRCBBEIwMIAUoAoACIUVBsAEhRiAFIEZqIUcgRyFIIEggRRCNDEG4ASFJIAUgSWohSiBKIUtBsAEhTCAFIExqIU0gTSFOIEsgThDkASFPQQEhUCBPIFBxIVECQAJAIFFFDQAgBSgChAIhUkGgASFTIAUgU2ohVCBUIVUgVSBSEIwMQagBIVYgBSBWaiFXIFchWEGgASFZIAUgWWohWiBaIVsgWCBbEOIBGiAFKAKEAiFcQZABIV0gBSBdaiFeIF4hXyBfIFwQjQxBmAEhYCAFIGBqIWEgYSFiQZABIWMgBSBjaiFkIGQhZSBiIGUQ4gEaIAUoAoACIWZBgAEhZyAFIGdqIWggaCFpIGkgZhCMDEGIASFqIAUgamohayBrIWxBgAEhbSAFIG1qIW4gbiFvIGwgbxDiARpBiAIhcCAFIHBqIXEgcSFyQagBIXMgBSBzaiF0IHQhdUGYASF2IAUgdmohdyB3IXhBiAEheSAFIHlqIXogeiF7IHIgdSB4IHsQuw0MAQsgBSgChAIhfEH4ACF9IAUgfWohfiB+IX8gfyB8EI0MIAUoAoACIYABQfAAIYEBIAUggQFqIYIBIIIBIYMBIIMBIIABEIwMQfgAIYQBIAUghAFqIYUBIIUBIYYBQfAAIYcBIAUghwFqIYgBIIgBIYkBIIYBIIkBEOQBIYoBQQEhiwEgigEgiwFxIYwBAkACQCCMAUUNACAFKAKEAiGNAUHgACGOASAFII4BaiGPASCPASGQASCQASCNARCNDEHoACGRASAFIJEBaiGSASCSASGTAUHgACGUASAFIJQBaiGVASCVASGWASCTASCWARDiARogBSgChAIhlwFB0AAhmAEgBSCYAWohmQEgmQEhmgEgmgEglwEQjAxB2AAhmwEgBSCbAWohnAEgnAEhnQFB0AAhngEgBSCeAWohnwEgnwEhoAEgnQEgoAEQ4gEaIAUoAoACIaEBQcAAIaIBIAUgogFqIaMBIKMBIaQBIKQBIKEBEI0MQcgAIaUBIAUgpQFqIaYBIKYBIacBQcAAIagBIAUgqAFqIakBIKkBIaoBIKcBIKoBEOIBGkGIAiGrASAFIKsBaiGsASCsASGtAUHoACGuASAFIK4BaiGvASCvASGwAUHYACGxASAFILEBaiGyASCyASGzAUHIACG0ASAFILQBaiG1ASC1ASG2ASCtASCwASCzASC2ARC7DQwBCyAFKAKEAiG3AUE4IbgBIAUguAFqIbkBILkBIboBILoBILcBEI0MIAUoAoACIbsBQTAhvAEgBSC8AWohvQEgvQEhvgEgvgEguwEQjQxBOCG/ASAFIL8BaiHAASDAASHBAUEwIcIBIAUgwgFqIcMBIMMBIcQBIMEBIMQBEOQBIcUBQQEhxgEgxQEgxgFxIccBAkAgxwFFDQAgBSgChAIhyAFBICHJASAFIMkBaiHKASDKASHLASDLASDIARCNDEEoIcwBIAUgzAFqIc0BIM0BIc4BQSAhzwEgBSDPAWoh0AEg0AEh0QEgzgEg0QEQ4gEaIAUoAoQCIdIBQRAh0wEgBSDTAWoh1AEg1AEh1QEg1QEg0gEQjAxBGCHWASAFINYBaiHXASDXASHYAUEQIdkBIAUg2QFqIdoBINoBIdsBINgBINsBEOIBGiAFKAKAAiHcASAFId0BIN0BINwBEIwMQQgh3gEgBSDeAWoh3wEg3wEh4AEgBSHhASDgASDhARDiARpBiAIh4gEgBSDiAWoh4wEg4wEh5AFBKCHlASAFIOUBaiHmASDmASHnAUEYIegBIAUg6AFqIekBIOkBIeoBQQgh6wEgBSDrAWoh7AEg7AEh7QEg5AEg5wEg6gEg7QEQuw0LCwsLQZACIe4BIAUg7gFqIe8BIO8BJAAPCzYBB38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIIIQVBHyEGIAUgBnEhByAHDwtjAQd/IwAhBEEQIQUgBCAFayEGIAYgADYCDCAGIAE2AgggBiACNgIEIAYgAzYCACAGKAIMIQcgBigCCCEIIAcgCDYCACAGKAIEIQkgByAJNgIEIAYoAgAhCiAHIAo2AgggBw8LcQELfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQDSEHIAUgBzYCACAEKAIIIQggCBAOIQkgBSAJNgIEQQAhCiAFIAo2AghBECELIAQgC2ohDCAMJAAgBQ8LzQUCVH8IfiMAIQNBkAEhBCADIARrIQUgBSQAIAUgATYCjAEgBSACNgKIASAFKAKMASEGQfgAIQcgBSAHaiEIIAghCSAGKQIAIVcgCSBXNwIAQQghCiAJIApqIQsgBiAKaiEMIAwoAgAhDSALIA02AgBBCCEOQQghDyAFIA9qIRAgECAOaiERQfgAIRIgBSASaiETIBMgDmohFCAUKAIAIRUgESAVNgIAIAUpA3ghWCAFIFg3AwhBCCEWIAUgFmohFyAXEKINIRggBSgCiAEhGUHoACEaIAUgGmohGyAbIRwgGSkCACFZIBwgWTcCAEEIIR0gHCAdaiEeIBkgHWohHyAfKAIAISAgHiAgNgIAQQghIUEYISIgBSAiaiEjICMgIWohJEHoACElIAUgJWohJiAmICFqIScgJygCACEoICQgKDYCACAFKQNoIVogBSBaNwMYQRghKSAFIClqISogKhCiDSErIBggK2shLCAFKAKMASEtQdgAIS4gBSAuaiEvIC8hMCAtKQIAIVsgMCBbNwIAQQghMSAwIDFqITIgLSAxaiEzIDMoAgAhNCAyIDQ2AgBBCCE1QSghNiAFIDZqITcgNyA1aiE4QdgAITkgBSA5aiE6IDogNWohOyA7KAIAITwgOCA8NgIAIAUpA1ghXCAFIFw3AyhBKCE9IAUgPWohPiA+ELUNIT8gBSgCiAEhQEHIACFBIAUgQWohQiBCIUMgQCkCACFdIEMgXTcCAEEIIUQgQyBEaiFFIEAgRGohRiBGKAIAIUcgRSBHNgIAQQghSEE4IUkgBSBJaiFKIEogSGohS0HIACFMIAUgTGohTSBNIEhqIU4gTigCACFPIEsgTzYCACAFKQNIIV4gBSBeNwM4QTghUCAFIFBqIVEgURC1DSFSID8gUmshU0EAIVQgACAsIFMgVBC2DBpBkAEhVSAFIFVqIVYgViQADwuvAQMSfwJ+AnwjACEBQSAhAiABIAJrIQMgAyQAQRAhBCADIARqIQUgBSEGIAApAgAhEyAGIBM3AgBBCCEHIAYgB2ohCCAAIAdqIQkgCSgCACEKIAggCjYCAEEIIQsgAyALaiEMQRAhDSADIA1qIQ4gDiALaiEPIA8oAgAhECAMIBA2AgAgAykDECEUIAMgFDcDACADELwNIRUgFZ8hFkEgIREgAyARaiESIBIkACAWDwvwAQEafyMAIQRBECEFIAQgBWshBiAGJAAgBiAANgIMIAYgATYCCCAGIAI2AgQgBiADNgIAIAYoAgwhByAHKAIEIQggBxCRDSEJIAkoAgAhCiAIIQsgCiEMIAsgDEkhDUEBIQ4gDSAOcSEPAkACQCAPRQ0AIAYoAgghECAQEL0NIREgBigCBCESIBIQvQ0hEyAGKAIAIRQgFBDSCSEVIAcgESATIBUQvg0MAQsgBigCCCEWIBYQvQ0hFyAGKAIEIRggGBC9DSEZIAYoAgAhGiAaENIJIRsgByAXIBkgGxC/DQtBECEcIAYgHGohHSAdJAAPC8EGA1J/AX4hfCMAIQJBkAEhAyACIANrIQQgBCQAIAQgATYCjAEgBCgCjAEhBUH4ACEGIAQgBmohByAHIQggCCAFEIwMQYABIQkgBCAJaiEKIAohC0H4ACEMIAQgDGohDSANIQ4gCyAOEOIBGiAEKAKMASEPQeAAIRAgBCAQaiERIBEhEiASIA8QjQwgBCgCjAEhE0HYACEUIAQgFGohFSAVIRYgFiATEIwMQegAIRcgBCAXaiEYIBghGUHgACEaIAQgGmohGyAbIRxB2AAhHSAEIB1qIR4gHiEfIBkgHCAfEMANQfAAISAgBCAgaiEhICEhIkHoACEjIAQgI2ohJCAkISUgIiAlEOIBGkHAACEmIAQgJmohJyAnIShB8AAhKSAEIClqISogKiErICggKxC3DBpBCCEsIAQgLGohLUHAACEuIAQgLmohLyAvICxqITAgMCgCACExIC0gMTYCACAEKQNAIVQgBCBUNwMAIAQQuQwhVSAEIFU5A1BB8AAhMiAEIDJqITMgMyE0IDQQDSE1IDW3IVYgBCsDUCFXIFYgV6MhWCAEIFg5AzhB8AAhNiAEIDZqITcgNyE4IDgQDiE5IDm3IVkgBCsDUCFaIFkgWqMhWyAEIFs5AzBBgAEhOiAEIDpqITsgOyE8IDwQDSE9IAAQDSE+ID0gPmshPyA/tyFcIAQrAzghXSBcIF2iIV5BgAEhQCAEIEBqIUEgQSFCIEIQDiFDIAAQDiFEIEMgRGshRSBFtyFfIAQrAzAhYCBfIGCiIWEgXiBhoCFiIAQgYjkDKEGAASFGIAQgRmohRyBHIUggSBANIUkgABANIUogSSBKayFLIEu3IWMgBCsDOCFkIAQrAyghZSBkIGWiIWYgYyBmoSFnIAQgZzkDIEGAASFMIAQgTGohTSBNIU4gThAOIU8gABAOIVAgTyBQayFRIFG3IWggBCsDMCFpIAQrAyghaiBpIGqiIWsgaCBroSFsIAQgbDkDGCAEKwMgIW0gBCsDICFuIG0gbqIhbyAEKwMYIXAgBCsDGCFxIHAgcaIhciBvIHKgIXMgc58hdCAEIHQ5AxAgBCsDECF1QZABIVIgBCBSaiFTIFMkACB1Dwu/DwLWAX8SfiMAIQRBkAIhBSAEIAVrIQYgBiQAIAYgADYCiAIgAyEHIAYgBzoAhwIgBigCiAIhCCAGIAg2AowCIAgQxA0aQRAhCSAIIAlqIQogASkCACHaASAKINoBNwIAQQghCyAKIAtqIQwgASALaiENIA0oAgAhDiAMIA42AgBBHCEPIAggD2ohECACKQIAIdsBIBAg2wE3AgBBCCERIBAgEWohEiACIBFqIRMgEygCACEUIBIgFDYCAEEBIRUgCCAVNgIoIAYtAIcCIRZBASEXIBYgF3EhGAJAIBhFDQBBECEZIAggGWohGkH4ASEbIAYgG2ohHCAcIR0gGikCACHcASAdINwBNwIAQQghHiAdIB5qIR8gGiAeaiEgICAoAgAhISAfICE2AgBBCCEiQegAISMgBiAjaiEkICQgImohJUH4ASEmIAYgJmohJyAnICJqISggKCgCACEpICUgKTYCACAGKQP4ASHdASAGIN0BNwNoQegAISogBiAqaiErICsQog0hLEEcIS0gCCAtaiEuQegBIS8gBiAvaiEwIDAhMSAuKQIAId4BIDEg3gE3AgBBCCEyIDEgMmohMyAuIDJqITQgNCgCACE1IDMgNTYCAEEIITZB+AAhNyAGIDdqITggOCA2aiE5QegBITogBiA6aiE7IDsgNmohPCA8KAIAIT0gOSA9NgIAIAYpA+gBId8BIAYg3wE3A3hB+AAhPiAGID5qIT8gPxCiDSFAICwhQSBAIUIgQSBCSiFDQQEhRCBDIERxIUUCQAJAIEUNAEEQIUYgCCBGaiFHQdgBIUggBiBIaiFJIEkhSiBHKQIAIeABIEog4AE3AgBBCCFLIEogS2ohTCBHIEtqIU0gTSgCACFOIEwgTjYCAEEIIU9ByAAhUCAGIFBqIVEgUSBPaiFSQdgBIVMgBiBTaiFUIFQgT2ohVSBVKAIAIVYgUiBWNgIAIAYpA9gBIeEBIAYg4QE3A0hByAAhVyAGIFdqIVggWBCiDSFZQRwhWiAIIFpqIVtByAEhXCAGIFxqIV0gXSFeIFspAgAh4gEgXiDiATcCAEEIIV8gXiBfaiFgIFsgX2ohYSBhKAIAIWIgYCBiNgIAQQghY0HYACFkIAYgZGohZSBlIGNqIWZByAEhZyAGIGdqIWggaCBjaiFpIGkoAgAhaiBmIGo2AgAgBikDyAEh4wEgBiDjATcDWEHYACFrIAYga2ohbCBsEKINIW0gWSFuIG0hbyBuIG9GIXBBASFxIHAgcXEhciByRQ0BQRAhcyAIIHNqIXRBuAEhdSAGIHVqIXYgdiF3IHQpAgAh5AEgdyDkATcCAEEIIXggdyB4aiF5IHQgeGoheiB6KAIAIXsgeSB7NgIAQQghfEEoIX0gBiB9aiF+IH4gfGohf0G4ASGAASAGIIABaiGBASCBASB8aiGCASCCASgCACGDASB/IIMBNgIAIAYpA7gBIeUBIAYg5QE3AyhBKCGEASAGIIQBaiGFASCFARC1DSGGAUEcIYcBIAgghwFqIYgBQagBIYkBIAYgiQFqIYoBIIoBIYsBIIgBKQIAIeYBIIsBIOYBNwIAQQghjAEgiwEgjAFqIY0BIIgBIIwBaiGOASCOASgCACGPASCNASCPATYCAEEIIZABQTghkQEgBiCRAWohkgEgkgEgkAFqIZMBQagBIZQBIAYglAFqIZUBIJUBIJABaiGWASCWASgCACGXASCTASCXATYCACAGKQOoASHnASAGIOcBNwM4QTghmAEgBiCYAWohmQEgmQEQtQ0hmgEghgEhmwEgmgEhnAEgmwEgnAFKIZ0BQQEhngEgnQEgngFxIZ8BIJ8BRQ0BC0EQIaABIAggoAFqIaEBQRwhogEgCCCiAWohowEgoQEgowEQ2QwgCCgCKCGkAUF/IaUBIKQBIKUBbCGmASAIIKYBNgIoC0EQIacBIAggpwFqIagBQZgBIakBIAYgqQFqIaoBIKoBIasBIKgBKQIAIegBIKsBIOgBNwIAQQghrAEgqwEgrAFqIa0BIKgBIKwBaiGuASCuASgCACGvASCtASCvATYCAEEIIbABQQghsQEgBiCxAWohsgEgsgEgsAFqIbMBQZgBIbQBIAYgtAFqIbUBILUBILABaiG2ASC2ASgCACG3ASCzASC3ATYCACAGKQOYASHpASAGIOkBNwMIQQghuAEgBiC4AWohuQEguQEQog0hugFBHCG7ASAIILsBaiG8AUGIASG9ASAGIL0BaiG+ASC+ASG/ASC8ASkCACHqASC/ASDqATcCAEEIIcABIL8BIMABaiHBASC8ASDAAWohwgEgwgEoAgAhwwEgwQEgwwE2AgBBCCHEAUEYIcUBIAYgxQFqIcYBIMYBIMQBaiHHAUGIASHIASAGIMgBaiHJASDJASDEAWohygEgygEoAgAhywEgxwEgywE2AgAgBikDiAEh6wEgBiDrATcDGEEYIcwBIAYgzAFqIc0BIM0BEKINIc4BILoBIc8BIM4BIdABIM8BINABRiHRAUEBIdIBINEBINIBcSHTAQJAINMBRQ0AIAgoAigh1AFBfyHVASDUASDVAWwh1gEgCCDWATYCKAsLIAYoAowCIdcBQZACIdgBIAYg2AFqIdkBINkBJAAg1wEPC6IBARJ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIEIQYgBRCRDSEHIAcoAgAhCCAGIQkgCCEKIAkgCkkhC0EBIQwgCyAMcSENAkACQCANRQ0AIAQoAgghDiAOEMENIQ8gBSAPEMINDAELIAQoAgghECAQEMENIREgBSAREMMNC0EQIRIgBCASaiETIBMkAA8LUgEMfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAhQhBUEBIQYgBSAGcSEHQQAhCEEBIQkgCCAJIAcbIQpBASELIAogC3EhDCAMDwuPAQESfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIIIAMoAgghBCADIAQ2AgxBECEFIAQgBWohBiAEIQcDQCAHIQggCBC3BhpBCCEJIAggCWohCiAKIQsgBiEMIAsgDEYhDUEBIQ4gDSAOcSEPIAohByAPRQ0ACyADKAIMIRBBECERIAMgEWohEiASJAAgEA8LZAEMfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEELUMIQUgAyAFNgIIIAMoAgghBkEAIQcgBiAHEMUNIQhBASEJIAggCXEhCkEQIQsgAyALaiEMIAwkACAKDwtyAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEOgBGiAEKAIIIQdBCCEIIAcgCGohCUEIIQogBSAKaiELIAsgCRDoARpBECEMIAQgDGohDSANJAAgBQ8LhiIDhwN/G34wfCMAIQZB8AQhByAGIAdrIQggCCQAIAggADYC7AQgCCAFOQPgBEHIBCEJIAggCWohCiAKIQsgCyACEIwMQdAEIQwgCCAMaiENIA0hDkHIBCEPIAggD2ohECAQIREgDiARELcMGkGwBCESIAggEmohEyATIRQgFCACEI0MQbgEIRUgCCAVaiEWIBYhF0GwBCEYIAggGGohGSAZIRogFyAaELcMGkGgBCEbIAggG2ohHCAcIR1BuAQhHiAIIB5qIR8gHyEgICApAgAhjQMgHSCNAzcCAEEIISEgHSAhaiEiICAgIWohIyAjKAIAISQgIiAkNgIAQQghJUE4ISYgCCAmaiEnICcgJWohKEGgBCEpIAggKWohKiAqICVqISsgKygCACEsICggLDYCACAIKQOgBCGOAyAIII4DNwM4QTghLSAIIC1qIS4gLhCiDSEvQZAEITAgCCAwaiExIDEhMkHQBCEzIAggM2ohNCA0ITUgNSkCACGPAyAyII8DNwIAQQghNiAyIDZqITcgNSA2aiE4IDgoAgAhOSA3IDk2AgBBCCE6QcgAITsgCCA7aiE8IDwgOmohPUGQBCE+IAggPmohPyA/IDpqIUAgQCgCACFBID0gQTYCACAIKQOQBCGQAyAIIJADNwNIQcgAIUIgCCBCaiFDIEMQog0hRCAvIERrIUUgCCBFNgKsBEGABCFGIAggRmohRyBHIUhBuAQhSSAIIElqIUogSiFLIEspAgAhkQMgSCCRAzcCAEEIIUwgSCBMaiFNIEsgTGohTiBOKAIAIU8gTSBPNgIAQQghUEHYACFRIAggUWohUiBSIFBqIVNBgAQhVCAIIFRqIVUgVSBQaiFWIFYoAgAhVyBTIFc2AgAgCCkDgAQhkgMgCCCSAzcDWEHYACFYIAggWGohWSBZELUNIVpB8AMhWyAIIFtqIVwgXCFdQdAEIV4gCCBeaiFfIF8hYCBgKQIAIZMDIF0gkwM3AgBBCCFhIF0gYWohYiBgIGFqIWMgYygCACFkIGIgZDYCAEEIIWVB6AAhZiAIIGZqIWcgZyBlaiFoQfADIWkgCCBpaiFqIGogZWohayBrKAIAIWwgaCBsNgIAIAgpA/ADIZQDIAgglAM3A2hB6AAhbSAIIG1qIW4gbhC1DSFvIFogb2shcCAIIHA2AowEQRQhcSAIIHE2AuwDQdADIXIgCCByaiFzIHMhdEHQBCF1IAggdWohdiB2IXcgdykCACGVAyB0IJUDNwIAQQgheCB0IHhqIXkgdyB4aiF6IHooAgAheyB5IHs2AgBBwAMhfCAIIHxqIX0gfSF+QbgEIX8gCCB/aiGAASCAASGBASCBASkCACGWAyB+IJYDNwIAQQghggEgfiCCAWohgwEggQEgggFqIYQBIIQBKAIAIYUBIIMBIIUBNgIAQbADIYYBIAgghgFqIYcBIIcBIYgBIAMpAgAhlwMgiAEglwM3AgBBCCGJASCIASCJAWohigEgAyCJAWohiwEgiwEoAgAhjAEgigEgjAE2AgBBCCGNAUGYASGOASAIII4BaiGPASCPASCNAWohkAFB0AMhkQEgCCCRAWohkgEgkgEgjQFqIZMBIJMBKAIAIZQBIJABIJQBNgIAIAgpA9ADIZgDIAggmAM3A5gBQYgBIZUBIAgglQFqIZYBIJYBII0BaiGXAUHAAyGYASAIIJgBaiGZASCZASCNAWohmgEgmgEoAgAhmwEglwEgmwE2AgAgCCkDwAMhmQMgCCCZAzcDiAFB+AAhnAEgCCCcAWohnQEgnQEgjQFqIZ4BQbADIZ8BIAggnwFqIaABIKABII0BaiGhASChASgCACGiASCeASCiATYCACAIKQOwAyGaAyAIIJoDNwN4QZgBIaMBIAggowFqIaQBQYgBIaUBIAggpQFqIaYBQfgAIacBIAggpwFqIagBIKQBIKYBIKgBEMYNIagDIAggqAM5A+ADQZgDIakBIAggqQFqIaoBIKoBIasBQdAEIawBIAggrAFqIa0BIK0BIa4BIK4BKQIAIZsDIKsBIJsDNwIAQQghrwEgqwEgrwFqIbABIK4BIK8BaiGxASCxASgCACGyASCwASCyATYCAEGIAyGzASAIILMBaiG0ASC0ASG1AUG4BCG2ASAIILYBaiG3ASC3ASG4ASC4ASkCACGcAyC1ASCcAzcCAEEIIbkBILUBILkBaiG6ASC4ASC5AWohuwEguwEoAgAhvAEgugEgvAE2AgBB+AIhvQEgCCC9AWohvgEgvgEhvwEgBCkCACGdAyC/ASCdAzcCAEEIIcABIL8BIMABaiHBASAEIMABaiHCASDCASgCACHDASDBASDDATYCAEEIIcQBQcgBIcUBIAggxQFqIcYBIMYBIMQBaiHHAUGYAyHIASAIIMgBaiHJASDJASDEAWohygEgygEoAgAhywEgxwEgywE2AgAgCCkDmAMhngMgCCCeAzcDyAFBuAEhzAEgCCDMAWohzQEgzQEgxAFqIc4BQYgDIc8BIAggzwFqIdABINABIMQBaiHRASDRASgCACHSASDOASDSATYCACAIKQOIAyGfAyAIIJ8DNwO4AUGoASHTASAIINMBaiHUASDUASDEAWoh1QFB+AIh1gEgCCDWAWoh1wEg1wEgxAFqIdgBINgBKAIAIdkBINUBINkBNgIAIAgpA/gCIaADIAggoAM3A6gBQcgBIdoBIAgg2gFqIdsBQbgBIdwBIAgg3AFqId0BQagBId4BIAgg3gFqId8BINsBIN0BIN8BEMYNIakDIAggqQM5A6gDQQAh4AEgCCDgAToA9wICQANAIAgtAPcCIeEBQX8h4gEg4QEg4gFzIeMBQQEh5AEg4wEg5AFxIeUBIOUBRQ0BQQEh5gEgCCDmAToA9wJB6AIh5wEgCCDnAWoh6AEg6AEh6QEgAykCACGhAyDpASChAzcCAEEIIeoBIOkBIOoBaiHrASADIOoBaiHsASDsASgCACHtASDrASDtATYCAEEAIe4BIAgg7gE2AuQCAkADQCAIKALkAiHvASAIKALsAyHwASDvASHxASDwASHyASDxASDyAU0h8wFBASH0ASDzASD0AXEh9QEg9QFFDQEgCCsD4AMhqgMgCCsDqAMhqwMgqwMgqgOhIawDIAgoAuQCIfYBIPYBuCGtAyCsAyCtA6IhrgMgCCgC7AMh9wEg9wG4Ia8DIK4DIK8DoyGwAyCqAyCwA6AhsQMgCCCxAzkD2AJByAIh+AEgCCD4AWoh+QEg+QEh+gFB0AQh+wEgCCD7AWoh/AEg/AEh/QEg/QEpAgAhogMg+gEgogM3AgBBCCH+ASD6ASD+AWoh/wEg/QEg/gFqIYACIIACKAIAIYECIP8BIIECNgIAQQghggJBGCGDAiAIIIMCaiGEAiCEAiCCAmohhQJByAIhhgIgCCCGAmohhwIghwIgggJqIYgCIIgCKAIAIYkCIIUCIIkCNgIAIAgpA8gCIaMDIAggowM3AxhBGCGKAiAIIIoCaiGLAiCLAhCiDSGMAiAIKAKsBCGNAiCNArchsgMgCCsD2AIhswMgsgMgswOiIbQDILQDEKMaIY4CIIwCII4CaiGPAiAIII8CNgLUAkG4AiGQAiAIIJACaiGRAiCRAiGSAkHQBCGTAiAIIJMCaiGUAiCUAiGVAiCVAikCACGkAyCSAiCkAzcCAEEIIZYCIJICIJYCaiGXAiCVAiCWAmohmAIgmAIoAgAhmQIglwIgmQI2AgBBCCGaAkEoIZsCIAggmwJqIZwCIJwCIJoCaiGdAkG4AiGeAiAIIJ4CaiGfAiCfAiCaAmohoAIgoAIoAgAhoQIgnQIgoQI2AgAgCCkDuAIhpQMgCCClAzcDKEEoIaICIAggogJqIaMCIKMCELUNIaQCIAgoAowEIaUCIKUCtyG1AyAIKwPYAiG2AyC1AyC2A6IhtwMgtwMQoxohpgIgpAIgpgJqIacCIAggpwI2AsQCIAEQDSGoAiAIKALUAiGpAiCoAiCpAmshqgIgCCCqAjYCtAIgARAOIasCIAgoAsQCIawCIKsCIKwCayGtAiAIIK0CNgKwAiAIKAK0AiGuAiCuArchuAMgCCgCtAIhrwIgrwK3IbkDILgDILkDoiG6AyAIKAKwAiGwAiCwArchuwMgCCgCsAIhsQIgsQK3IbwDILsDILwDoiG9AyC6AyC9A6AhvgMgCCC+AzkDqAIgCCgCtAIhsgIgsgK3Ib8DIAgoAowEIbMCILMCtyHAAyC/AyDAA6IhwQMgCCgCsAIhtAIgtAK3IcIDIAgoAqwEIbUCILUCtyHDAyDCAyDDA6IhxAMgwQMgxAOhIcUDRAAAAAAAAABAIcYDIMYDIMUDoiHHAyAIIMcDOQOgAiAIKALUAiG2AiAIKAKMBCG3AiC3ArchyAMgCCsDqAIhyQMgyAMgyQOiIcoDIAgrA6ACIcsDIMoDIMsDoyHMAyDMAxCjGiG4AiC2AiC4AmohuQIgCCC5AjYCnAIgCCgCxAIhugIgCCgCrAQhuwIguwK3Ic0DIAgrA6gCIc4DIM0DIM4DoiHPAyAIKwOgAiHQAyDPAyDQA6Mh0QMg0QMQoxohvAIgugIgvAJrIb0CIAggvQI2ApgCIAgoAuQCIb4CIAgoAuwDIb8CIL4CIcACIL8CIcECIMACIMECRiHCAkEBIcMCIMICIMMCcSHEAgJAIMQCRQ0AIAQoAgAhxQIgCCDFAjYCnAIgBCgCBCHGAiAIIMYCNgKYAgsgCCgCnAIhxwIgCCgCmAIhyAJB+AEhyQIgCCDJAmohygIgygIhywIgywIgxwIgyAIQHBpBgAIhzAIgCCDMAmohzQIgzQIhzgJB+AEhzwIgCCDPAmoh0AIg0AIh0QIgzgIg0QIgARDADUGIAiHSAiAIINICaiHTAiDTAiHUAkGAAiHVAiAIINUCaiHWAiDWAiHXAiDUAiDXAhC3DBpBCCHYAkEIIdkCIAgg2QJqIdoCINoCINgCaiHbAkGIAiHcAiAIINwCaiHdAiDdAiDYAmoh3gIg3gIoAgAh3wIg2wIg3wI2AgAgCCkDiAIhpgMgCCCmAzcDCEEIIeACIAgg4AJqIeECIOECELkMIdIDIAgrA+AEIdMDRAAAAAAAAABAIdQDINMDINQDoyHVAyDVAxCeGiHWAyDSAyDWA6Mh1wMg1wMQoxoh4gJBACHjAiDjAiDiAmsh5AIgCCDkAjYClAIgCCgC5AIh5QICQAJAIOUCDQAgCCgClAIh5gIgCCDmAjYC8AIMAQsgCCgC7AQh5wIgCCgCnAIh6AIgCCgCmAIh6QIgCCgClAIh6gJB6AEh6wIgCCDrAmoh7AIg7AIh7QIg7QIg6AIg6QIg6gIQtgwaQQEh7gIgCCDuAjoA5wFB6AIh7wIgCCDvAmoh8AIg8AIh8QJB6AEh8gIgCCDyAmoh8wIg8wIh9AJB5wEh9QIgCCD1Amoh9gIg9gIh9wIg5wIg8QIg9AIg9wIQxw0gCCgCnAIh+AIgCCgCmAIh+QIgCCgClAIh+gJB2AEh+wIgCCD7Amoh/AIg/AIh/QIg/QIg+AIg+QIg+gIQtgwaQegCIf4CIAgg/gJqIf8CIP8CIYADQdgBIYEDIAgggQNqIYIDIIIDIYMDIIMDKQIAIacDIIADIKcDNwIAQQghhAMggAMghANqIYUDIIMDIIQDaiGGAyCGAygCACGHAyCFAyCHAzYCAAsgCCgC5AIhiANBASGJAyCIAyCJA2ohigMgCCCKAzYC5AIMAAsACwwACwALQfAEIYsDIAggiwNqIYwDIIwDJAAPCz0BB38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQVBLCEGIAUgBmohByAEIAc2AgAgBA8LfAEOfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEHAACEFIAQgBWohBiAGEMgNGkEkIQcgBCAHaiEIIAgQyQ0aQRQhCSAEIAlqIQogChDKDRpBBCELIAQgC2ohDCAMEMsNGkEQIQ0gAyANaiEOIA4kACAEDwtfAQp/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQRghBSAEIAVqIQYgBhDMDRpBDCEHIAQgB2ohCCAIEM0NGiAEEM4NGkEQIQkgAyAJaiEKIAokACAEDwtCAQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQzw0gBBDQDRpBECEFIAMgBWohBiAGJAAgBA8LhQEBD38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBAxGkEAIQUgBCAFNgIAQQAhBiAEIAY2AgRBCCEHIAQgB2ohCEEAIQkgAyAJNgIIQQghCiADIApqIQsgCyEMIAMhDSAIIAwgDRDrFxpBECEOIAMgDmohDyAPJAAgBA8LqAEBFn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDvFyEFIAQQ7xchBiAEEPAXIQdBDCEIIAcgCGwhCSAGIAlqIQogBBDvFyELIAQQEiEMQQwhDSAMIA1sIQ4gCyAOaiEPIAQQ7xchECAEEPAXIRFBDCESIBEgEmwhEyAQIBNqIRQgBCAFIAogDyAUEPEXQRAhFSADIBVqIRYgFiQADwuVAQERfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIIIAMoAgghBCADIAQ2AgwgBCgCACEFQQAhBiAFIQcgBiEIIAcgCEchCUEBIQogCSAKcSELAkAgC0UNACAEEPIXIAQQ8xchDCAEKAIAIQ0gBBD0FyEOIAwgDSAOEPUXCyADKAIMIQ9BECEQIAMgEGohESARJAAgDw8LhQEBD38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBAxGkEAIQUgBCAFNgIAQQAhBiAEIAY2AgRBCCEHIAQgB2ohCEEAIQkgAyAJNgIIQQghCiADIApqIQsgCyEMIAMhDSAIIAwgDRCWGBpBECEOIAMgDmohDyAPJAAgBA8LPQEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEJkYGkEQIQUgAyAFaiEGIAYkACAEDwu0AQEUfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGIAUQmhghByAGIQggByEJIAggCUshCkEBIQsgCiALcSEMAkAgDEUNACAFEJsYIQ0gBCANNgIUIAQoAhghDiAFENQMIQ8gBCgCFCEQIAQhESARIA4gDyAQEJwYGiAEIRIgBSASEJ0YIAQhEyATEJ4YGgtBICEUIAQgFGohFSAVJAAPC5cCAR5/IwAhBUEgIQYgBSAGayEHIAckACAHIAA2AhwgByABNgIYIAcgAjYCFCAHIAM2AhAgByAENgIMIAcoAhwhCCAIKAIEIQkgCBCfGCEKIAooAgAhCyAJIQwgCyENIAwgDUkhDkEBIQ8gDiAPcSEQAkACQCAQRQ0AIAcoAhghESAREL0NIRIgBygCFCETIBMQvQ0hFCAHKAIQIRUgFRDSCSEWIAcoAgwhFyAXEKAYIRggCCASIBQgFiAYEKEYDAELIAcoAhghGSAZEL0NIRogBygCFCEbIBsQvQ0hHCAHKAIQIR0gHRDSCSEeIAcoAgwhHyAfEKAYISAgCCAaIBwgHiAgEKIYC0EgISEgByAhaiEiICIkAA8LVQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEKAIAIQUgBCAFEKUYIQYgAyAGNgIIIAMoAgghB0EQIQggAyAIaiEJIAkkACAHDwtVAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQoAgQhBSAEIAUQpRghBiADIAY2AgggAygCCCEHQRAhCCADIAhqIQkgCSQAIAcPC10BC38jACECQRAhAyACIANrIQQgBCQAIAQgADYCCCAEIAE2AgBBCCEFIAQgBWohBiAGIQcgBxCjGCEIIAQhCSAJEKMYIQogCCAKEKQYQRAhCyAEIAtqIQwgDCQADwtkAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGENYMIQdBfyEIIAcgCHMhCUEBIQogCSAKcSELQRAhDCAEIAxqIQ0gDSQAIAsPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBQ8LPQEHfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBUEgIQYgBSAGaiEHIAQgBzYCACAEDwtEAQl/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFIAQoAgAhBiAFIAZrIQdBBSEIIAcgCHUhCSAJDwv3AQEhfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIQIAQgATYCCAJAA0BBECEFIAQgBWohBiAGIQdBCCEIIAQgCGohCSAJIQogByAKENEMIQtBASEMIAsgDHEhDSANRQ0BQRAhDiAEIA5qIQ8gDyEQIBAQ0gwhESAEIRIgEiAREKYYIRNBASEUIBMgFHEhFQJAIBVFDQAMAgtBECEWIAQgFmohFyAXIRggGBDTDBoMAAsAC0EYIRkgBCAZaiEaIBohG0EQIRwgBCAcaiEdIB0hHiAeKAIAIR8gGyAfNgIAIAQoAhghIEEgISEgBCAhaiEiICIkACAgDwttAQ5/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEKMYIQYgBCgCCCEHIAcQoxghCCAGIQkgCCEKIAkgCkYhC0EBIQwgCyAMcSENQRAhDiAEIA5qIQ8gDyQAIA0PC0UBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAUQpxghBkEQIQcgAyAHaiEIIAgkACAGDwtRAQl/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQRBASEFIAQgBToAAiAEKAIEIQZBASEHIAYgBzoAHSAEKAIIIQhBASEJIAggCToAHQ8LkAICHn8DfiMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBRDJFyEGQQghByAEIAdqIQggCCEJIAYpAgAhICAJICA3AgBBCCEKIAkgCmohCyAGIApqIQwgDCgCACENIAsgDTYCACAEKAIYIQ4gDhDJFyEPIAQoAhwhECAPKQIAISEgECAhNwIAQQghESAQIBFqIRIgDyARaiETIBMoAgAhFCASIBQ2AgBBCCEVIAQgFWohFiAWIRcgFxDJFyEYIAQoAhghGSAYKQIAISIgGSAiNwIAQQghGiAZIBpqIRsgGCAaaiEcIBwoAgAhHSAbIB02AgBBICEeIAQgHmohHyAfJAAPC4cEAzV/BHwCfiMAIQRBECEFIAQgBWshBiAGJAAgBiABNgIMIAYgAjYCCCADIQcgBiAHOgAHIAYoAgwhCCAIKAIQIQkgCRD8CyEKQQEhCyAKIAtxIQwCQCAMDQAgBigCCCENQRAhDiANIA5qIQ8gCCgCECEQIBAQpgwhEUEcIRIgESASaiETIA8gExCoGCEUQQEhFSAUIBVxIRYgFkUNACAIKwMAITkgCCsDCCE6IAgoAhQhFyAIKAIQIRggOSA6IBcgGBCpGCAIKAIQIRkgGRC/FgsgCCgCECEaIAYoAgghGyAaIBsQqhggBi0AByEcQQEhHSAcIB1xIR4CQAJAIB4NACAGKAIIIR8gHygCJCEgICANAQsgCCsDACE7IAgrAwghPCAIKAIUISEgCCgCECEiIDsgPCAhICIQqRggCCgCECEjICMQvxYLIAgoAhAhJCAkEPwLISVBASEmICUgJnEhJwJAAkAgJw0AIAgoAhAhKCAoEKYMISlBHCEqICkgKmohKyArKQIAIT0gACA9NwIAQQghLCAAICxqIS0gKyAsaiEuIC4oAgAhLyAtIC82AgAMAQsgCCgCFCEwIDAQqxghMSAxEKwYITIgMikCACE+IAAgPjcCAEEIITMgACAzaiE0IDIgM2ohNSA1KAIAITYgNCA2NgIAC0EQITcgBiA3aiE4IDgkAA8L0QECFH8CfiMAIQVBECEGIAUgBmshByAHIAA2AgwgAyEIIAcgCDoACyAHIAQ2AgQgBygCDCEJIAEpAgAhGSAJIBk3AgBBCCEKIAkgCmohCyABIApqIQwgDCgCACENIAsgDTYCAEEMIQ4gCSAOaiEPIAIpAgAhGiAPIBo3AgBBCCEQIA8gEGohESACIBBqIRIgEigCACETIBEgEzYCACAHKAIEIRQgCSAUNgIYIActAAshFUEBIRYgFSAWcSEXIAkgFzoAHEEAIRggCSAYOgAdIAkPC8QBARh/IwAhA0EwIQQgAyAEayEFIAUkACAFIAA2AiAgBSABNgIYIAUgAjYCFEEQIQYgBSAGaiEHIAchCEEgIQkgBSAJaiEKIAohCyALKAIAIQwgCCAMNgIAQQghDSAFIA1qIQ4gDiEPQRghECAFIBBqIREgESESIBIoAgAhEyAPIBM2AgAgBSgCFCEUIAUoAhAhFSAFKAIIIRYgFSAWIBQQrRghFyAFIBc2AiggBSgCKCEYQTAhGSAFIBlqIRogGiQAIBgPCwwBAXwQrhghACAADwusCwOxAX8BfgZ8IwAhAkHAACEDIAIgA2shBCAEJAAgBCABNgI4IAQgADYCNCAEKAI0IQVBOCEGIAQgBmohByAHIQggCBDXDCEJIAktAB0hCkEBIQsgCiALcSEMAkACQCAMDQAgBSgCACENQTghDiAEIA5qIQ8gDyEQIBAQ0gwhESANIBEQrxghEiAEIBI2AjAgBSgCBCETIBMoAgghFEE4IRUgBCAVaiEWIBYhFyAXENcMIRggGCgCCCEZIBQgGWshGiAaEKQaIRsgBCAbNgIsIAUoAgQhHCAcKAIIIR1BOCEeIAQgHmohHyAfISAgIBDXDCEhICEoAhQhIiAdICJrISMgIxCkGiEkIAQgJDYCKCAFKAIEISVBOCEmIAQgJmohJyAnISggKBDXDCEpQRAhKiAEICpqISsgKyEsICwgJSApELgMQQghLSAEIC1qIS5BECEvIAQgL2ohMCAwIC1qITEgMSgCACEyIC4gMjYCACAEKQMQIbMBIAQgswE3AwAgBBC8DSG0ASAEILQBOQMgIAUoAgghMyAzKAIAITRBASE1IDQhNiA1ITcgNiA3TiE4QQEhOSA4IDlxIToCQCA6RQ0AQTghOyAEIDtqITwgPCE9ID0Q1wwhPiA+KAIAIT8gBSgCBCFAIEAoAgAhQSA/IEFrIUIgQhCkGiFDIEO3IbUBIAUoAgwhRCBEKwMAIbYBILUBILYBZCFFQQEhRiBFIEZxIUcgR0UNAEEAIUhBASFJIEggSXEhSiAEIEo6AD8MAgsgBCgCMCFLIAUoAgghTCBMKAIAIU0gSyFOIE0hTyBOIE9KIVBBASFRIFAgUXEhUgJAAkAgUg0AIAQoAjAhUyAFKAIIIVQgVCgCACFVIFMhViBVIVcgViBXRiFYQQEhWSBYIFlxIVogWkUNAUE4IVsgBCBbaiFcIFwhXSBdENcMIV4gBSgCBCFfIF4gXxCwGCFgQQEhYSBgIGFxIWICQCBiRQ0AIAQoAiwhYyAFKAIQIWQgZCgCACFlIGMhZiBlIWcgZiBnSCFoQQEhaSBoIGlxIWogag0BC0E4IWsgBCBraiFsIGwhbSBtENcMIW4gBSgCBCFvIG4gbxCoGCFwQQEhcSBwIHFxIXICQCByDQAgBCgCLCFzIAUoAhAhdCB0KAIAIXUgcyF2IHUhdyB2IHdGIXhBASF5IHggeXEheiB6RQ0CC0E4IXsgBCB7aiF8IHwhfSB9ENcMIX4gBSgCBCF/IH4gfxCwGCGAAUEBIYEBIIABIIEBcSGCAQJAIIIBRQ0AIAQoAighgwEgBSgCFCGEASCEASgCACGFASCDASGGASCFASGHASCGASCHAUghiAFBASGJASCIASCJAXEhigEgigENAQtBOCGLASAEIIsBaiGMASCMASGNASCNARDXDCGOASAFKAIEIY8BII4BII8BEKgYIZABQQEhkQEgkAEgkQFxIZIBAkAgkgENACAEKAIoIZMBIAUoAhQhlAEglAEoAgAhlQEgkwEhlgEglQEhlwEglgEglwFGIZgBQQEhmQEgmAEgmQFxIZoBIJoBRQ0CCyAEKwMgIbcBIAUoAgwhmwEgmwErAwAhuAEgtwEguAFjIZwBQQEhnQEgnAEgnQFxIZ4BIJ4BRQ0BCyAFKAIYIZ8BQTghoAEgBCCgAWohoQEgoQEhogEgogEoAgAhowEgnwEgowE2AgAgBCgCLCGkASAFKAIQIaUBIKUBIKQBNgIAIAQoAighpgEgBSgCFCGnASCnASCmATYCACAEKwMgIbkBIAUoAgwhqAEgqAEguQE5AwAgBCgCMCGpASAFKAIIIaoBIKoBIKkBNgIACwtBASGrAUEBIawBIKsBIKwBcSGtASAEIK0BOgA/CyAELQA/Ia4BQQEhrwEgrgEgrwFxIbABQcAAIbEBIAQgsQFqIbIBILIBJAAgsAEPC2cBC38jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCBCEFIAQoAgAhBkEAIQcgByAGayEIIAUgCBCxGCEJIAQgCTYCCCAEKAIIIQpBECELIAQgC2ohDCAMJAAgCg8LPQEHfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBUFgIQYgBSAGaiEHIAQgBzYCACAEDwtCAQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQshggBBCzGBpBECEFIAMgBWohBiAGJAAgBA8LqQEBFn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCmFiEFIAQQphYhBiAEEIkWIQdBLCEIIAcgCGwhCSAGIAlqIQogBBCmFiELIAQQkgwhDEEsIQ0gDCANbCEOIAsgDmohDyAEEKYWIRAgBBCJFiERQSwhEiARIBJsIRMgECATaiEUIAQgBSAKIA8gFBCnFkEQIRUgAyAVaiEWIBYkAA8LlQEBEX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCCCADKAIIIQQgAyAENgIMIAQoAgAhBUEAIQYgBSEHIAYhCCAHIAhHIQlBASEKIAkgCnEhCwJAIAtFDQAgBBDBFiAEEPsVIQwgBCgCACENIAQQlxYhDiAMIA0gDhCUFgsgAygCDCEPQRAhECADIBBqIREgESQAIA8PC4UBAQ9/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQMRpBACEFIAQgBTYCAEEAIQYgBCAGNgIEQQghByAEIAdqIQhBACEJIAMgCTYCCEEIIQogAyAKaiELIAshDCADIQ0gCCAMIA0Q0Q0aQRAhDiADIA5qIQ8gDyQAIAQPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQzwIhBiAEKAIIIQcgBxDPAiEIIAYhCSAIIQogCSAKRiELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQ1Q0hB0EQIQggAyAIaiEJIAkkACAHDwvKAQEXfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSgCHCEGQQghByAFIAdqIQggCCEJQQEhCiAJIAYgChDWDRogBhDXDSELIAUoAgwhDCAMENgNIQ0gBSgCGCEOIA4QsQIhDyAFKAIUIRAgEBCxAiERIAsgDSAPIBEQ2Q0gBSgCDCESQRAhEyASIBNqIRQgBSAUNgIMQQghFSAFIBVqIRYgFiEXIBcQ2g0aQSAhGCAFIBhqIRkgGSQADwuVAgEgfyMAIQNBMCEEIAMgBGshBSAFJAAgBSAANgIsIAUgATYCKCAFIAI2AiQgBSgCLCEGIAYQ1w0hByAFIAc2AiAgBhDbDSEIQQEhCSAIIAlqIQogBiAKENwNIQsgBhDbDSEMIAUoAiAhDUEIIQ4gBSAOaiEPIA8hECAQIAsgDCANEN0NGiAFKAIgIREgBSgCECESIBIQ2A0hEyAFKAIoIRQgFBCxAiEVIAUoAiQhFiAWELECIRcgESATIBUgFxDZDSAFKAIQIRhBECEZIBggGWohGiAFIBo2AhBBCCEbIAUgG2ohHCAcIR0gBiAdEN4NQQghHiAFIB5qIR8gHyEgICAQ3w0aQTAhISAFICFqISIgIiQADws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQlA4aQRAhBSADIAVqIQYgBiQAIAQPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCVDhpBECEFIAMgBWohBiAGJAAgBA8LPQEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEJYOGkEQIQUgAyAFaiEGIAYkACAEDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQow4aQRAhBSADIAVqIQYgBiQAIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtTAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQpA4aQQwhBSAEIAVqIQZBACEHIAYgBzoAAEEQIQggAyAIaiEJIAkkACAEDwtOAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQpQ4aQRAhBSAEIAVqIQYgBhCmDhpBECEHIAMgB2ohCCAIJAAgBA8LzQEBGX8jACEBQSAhAiABIAJrIQMgAyQAIAMgADYCHCADKAIcIQRBECEFIAMgBWohBiAGIQdBACEIIAcgCDsAAEECIQkgByAJaiEKIAogCDoAAEEYIQsgAyALaiEMIAwaQQ4hDSADIA1qIQ4gAy0AEiEPIA4gDzoAACADLwEQIRAgAyAQOwEMQRghESADIBFqIRJBDCETIAMgE2ohFCASIBQQpw4aQRghFSADIBVqIRYgFiEXIAQgFxCoDhpBICEYIAMgGGohGSAZJAAgBA8LSAEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEEIQUgBCAFaiEGIAYQqQ4aQRAhByADIAdqIQggCCQAIAQPC1wBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCACEFQQghBiAEIAZqIQcgByEIIAggBRDODhogBCgCCCEJQRAhCiAEIApqIQsgCyQAIAkPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQzw4hBiAEKAIIIQcgBxDPDiEIIAYhCSAIIQogCSAKRiELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LTgEGfyMAIQNBECEEIAMgBGshBSAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAYgBzYCACAFKAIEIQggBiAINgIEIAYPC3gCCn8CfiMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBikCACEMIAUgDDcCAEEIIQcgBSAHaiEIIAQoAgghCSAJKQIAIQ0gCCANNwIAQQAhCiAFIAo2AhBBACELIAUgCzYCGCAFDwuiAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCBCEGIAUQ0A4hByAHKAIAIQggBiEJIAghCiAJIApJIQtBASEMIAsgDHEhDQJAAkAgDUUNACAEKAIIIQ4gDhDRDiEPIAUgDxDSDgwBCyAEKAIIIRAgEBDRDiERIAUgERDTDgtBECESIAQgEmohEyATJAAPCzYBB38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQVBZCEGIAUgBmohByAHDws5AQV/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAY2AhQgBQ8LRwEHfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSgCGCEHIAcgBnIhCCAFIAg2AhggBQ8LjQIBI38jACEDQRAhBCADIARrIQUgBSQAIAUgADYCCCAFIAE2AgQgBSACNgIAIAUoAgQhBiAGENQOIQcgBSgCACEIIAgQ1A4hCSAHIQogCSELIAogC0YhDEEBIQ0gDCANcSEOAkACQCAORQ0AIAUoAgQhDyAPENUOIRAgBSgCACERIBEQ1Q4hEiAQIRMgEiEUIBMgFEghFUEBIRYgFSAWcSEXIAUgFzoADwwBCyAFKAIEIRggGBDUDiEZIAUoAgAhGiAaENQOIRsgGSEcIBshHSAcIB1IIR5BASEfIB4gH3EhICAFICA6AA8LIAUtAA8hIUEBISIgISAicSEjQRAhJCAFICRqISUgJSQAICMPC38CCn8CfiMAIQNBECEEIAMgBGshBSAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcpAgAhDSAGIA03AgBBCCEIIAYgCGohCSAFKAIEIQogCikCACEOIAkgDjcCAEEAIQsgBiALNgIQQQAhDCAGIAw2AhggBg8LkQEBEn8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCHCAFIAE2AhggBSgCGCEGQQghByAFIAdqIQggCCEJIAkgAhCuCRpBECEKIAUgCmohCyALIQxBCCENIAUgDWohDiAOIQ8gDCAGIA8Qjw9BECEQIAUgEGohESARIRIgACASEOIBGkEgIRMgBSATaiEUIBQkAA8LRAEJfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgQhBSAEKAIAIQYgBSAGayEHQRwhCCAHIAhtIQkgCQ8LqwEBFX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQkQ9BDCEHIAUgB2ohCCAEKAIIIQlBASEKIAkgCnQhCyAIIAsQkg9BGCEMIAUgDGohDSAEKAIIIQ5BAiEPIA4gD3QhECAEKAIIIRFBASESIBEgEnQhEyAQIBNqIRQgDSAUEJMPQRAhFSAEIBVqIRYgFiQADwueBQFWfyMAIQFB8AAhAiABIAJrIQMgAyQAIAMgADYCbCADKAJsIQRBBCEFIAQgBWohBiAGEJQPIQcgAyAHNgJoQQQhCCAEIAhqIQkgCRCCDSEKIAMgCjYCYEHYACELIAMgC2ohDCAMIQ1BACEOIA0gDjsAACADKAJoIQ8gAygCYCEQIAMvAVghESADIBE7AQ5BDiESIAMgEmohEyAPIBAgExCVD0EEIRQgBCAUaiEVQQQhFiAEIBZqIRcgFxCUDyEYIAMgGDYCQEEEIRkgBCAZaiEaIBoQgg0hGyADIBs2AjggAygCQCEcIAMoAjghHSAcIB0Qlg8hHiADIB42AkhB0AAhHyADIB9qISAgICEhQcgAISIgAyAiaiEjICMhJEEAISUgISAkICUQlw8aQQQhJiAEICZqIScgJxCCDSEoIAMgKDYCKEEwISkgAyApaiEqICohK0EoISwgAyAsaiEtIC0hLkEAIS8gKyAuIC8Qlw8aIAMoAlAhMCADKAIwITEgFSAwIDEQmA8hMiADIDI2AiBBACEzIAMgMzYCHAJAA0AgAygCHCE0QQQhNSAEIDVqITYgNhD9DCE3IDQhOCA3ITkgOCA5SSE6QQEhOyA6IDtxITwgPEUNAUEEIT0gBCA9aiE+IAMoAhwhPyA+ID8QmQ8hQCADKAIcIUEgQCBBEJoPGiADKAIcIUJBASFDIEIgQ2ohRCADIEQ2AhwMAAsAC0EEIUUgBCBFaiFGIEYQlA8hRyADIEc2AhBBGCFIIAMgSGohSSBJIUpBECFLIAMgS2ohTCBMIU1BACFOIEogTSBOEJcPGkEQIU8gBCBPaiFQQRghUSADIFFqIVIgUiFTIFMoAgAhVCBQIFQ2AgBB8AAhVSADIFVqIVYgViQADwvaBAFOfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQVBBCEGIAUgBmohByAHEJsPIQhBASEJIAggCXEhCgJAAkAgCkUNAAwBC0EEIQsgBSALaiEMIAwQ/QwhDUEBIQ4gDSEPIA4hECAPIBBGIRFBASESIBEgEnEhEwJAIBNFDQAgBCgCGCEUQQQhFSAFIBVqIRZBACEXIBYgFxCZDyEYIBQgGBCcD0EQIRkgBSAZaiEaIBoQnQ8aDAELQQAhGyAEIBs2AhQDQEEQIRwgBSAcaiEdQQQhHiAFIB5qIR8gHxCCDSEgIAQgIDYCEEEQISEgBCAhaiEiICIhIyAdICMQng8hJEEAISVBASEmICQgJnEhJyAlISgCQCAnRQ0AQRAhKSAFIClqISogKhCfDyErICsQoA8hLEEEIS0gBSAtaiEuIC4QlA8hLyAEIC82AghBCCEwIAQgMGohMSAxITIgMhChDyEzIDMQoA8hNCAsIDQQog8hNUEAITZBASE3IDUgN3EhOCA2ISggOEUNAEEQITkgBSA5aiE6IDoQhg0hOyA7EKMPITwgPCEoCyAoIT1BASE+ID0gPnEhPwJAID9FDQBBECFAIAUgQGohQSBBEJ0PGiAEKAIUIUJBASFDIEIgQ2ohRCAEIEQ2AhQMAQsLIAQoAhQhRUEBIUYgRSFHIEYhSCBHIEhGIUlBASFKIEkgSnEhSwJAAkAgS0UNACAEKAIYIUwgBSBMEKQPDAELIAQoAhghTSAFIE0QpQ8LC0EgIU4gBCBOaiFPIE8kAA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEKYPIQVBASEGIAUgBnEhB0EQIQggAyAIaiEJIAkkACAHDwtVAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQoAgQhBSAEIAUQqQ8hBiADIAY2AgggAygCCCEHQRAhCCADIAhqIQkgCSQAIAcPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQpw8hBiAEKAIIIQcgBxCoDyEIIAYhCSAIIQogCSAKRiELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LihoC/AJ/Bn4jACECQZACIQMgAiADayEEIAQkACAEIAA2AowCIAQgATYCiAIgBCgCjAIhBUEQIQYgBSAGaiEHIAcQhg0hCEHoASEJIAQgCWohCiAKIQsgCCkCACH+AiALIP4CNwIAQRghDCALIAxqIQ0gCCAMaiEOIA4oAgAhDyANIA82AgBBECEQIAsgEGohESAIIBBqIRIgEikCACH/AiARIP8CNwIAQQghEyALIBNqIRQgCCATaiEVIBUpAgAhgAMgFCCAAzcCAEEQIRYgBSAWaiEXQQEhGCAXIBgQqg8hGSAEIBk2AuABQegBIRogBCAaaiEbIBshHCAcEKsPIR1BASEeIB0gHnEhHwJAAkAgHw0AA0BBFCEgIAUgIGohISAhEKwPISJBACEjQQEhJCAiICRxISUgIyEmAkAgJQ0AQRQhJyAFICdqISggKBCtDyEpQegBISogBCAqaiErICshLCAsEKAPIS0gKSAtEK4PIS4gLiEmCyAmIS9BASEwIC8gMHEhMQJAIDFFDQBBFCEyIAUgMmohMyAzEK0PITRBCCE1IDQgNWohNkHYASE3IAQgN2ohOCA4ITkgNigCACE6IDkgOjYCAEEUITsgBSA7aiE8IDwQrw9BwAAhPSAFID1qIT5B0AEhPyAEID9qIUAgQCFBQdgBIUIgBCBCaiFDIEMhRCBEKAIAIUUgQSBFNgIAIAQoAtABIUYgPiBGELAPIUcgBCBHNgLIAQwBCwsMAQsDQEEEIUggBSBIaiFJIEkQgg0hSiAEIEo2AsABQeABIUsgBCBLaiFMIEwhTUHAASFOIAQgTmohTyBPIVAgTSBQEJ4PIVFBACFSQQEhUyBRIFNxIVQgUiFVAkAgVEUNAEHgASFWIAQgVmohVyBXIVggWBCfDyFZIFkQqw8hWkEAIVtBASFcIFogXHEhXSBbIVUgXUUNAEHgASFeIAQgXmohXyBfIWAgYBCfDyFhIGEQoA8hYkHoASFjIAQgY2ohZCBkIWUgZRCgDyFmIGIgZhCuDyFnIGchVQsgVSFoQQEhaSBoIGlxIWoCQCBqRQ0AQeABIWsgBCBraiFsIGwhbSBtEJ0PGgwBCwsLQRAhbiAFIG5qIW8gbxCGDSFwQYgBIXEgBCBxaiFyIHIhcyBzIHAQsQ8aQcAAIXQgBSB0aiF1QYgBIXYgBCB2aiF3IHcheCB1IHgQsg8heSAEIHk2AoABAkADQEEQIXogBSB6aiF7QeABIXwgBCB8aiF9IH0hfiB7IH4Qsw8hf0EBIYABIH8ggAFxIYEBIIEBRQ0BQRAhggEgBSCCAWohgwEggwEQhg0hhAFB6AEhhQEgBCCFAWohhgEghgEhhwEghAEpAgAhgQMghwEggQM3AgBBGCGIASCHASCIAWohiQEghAEgiAFqIYoBIIoBKAIAIYsBIIkBIIsBNgIAQRAhjAEghwEgjAFqIY0BIIQBIIwBaiGOASCOASkCACGCAyCNASCCAzcCAEEIIY8BIIcBII8BaiGQASCEASCPAWohkQEgkQEpAgAhgwMgkAEggwM3AgBB+AAhkgEgBCCSAWohkwEgkwEhlAFBgAEhlQEgBCCVAWohlgEglgEhlwEglwEoAgAhmAEglAEgmAE2AgBBwAAhmQEgBSCZAWohmgEgmgEQtA8hmwEgBCCbATYCcEGAASGcASAEIJwBaiGdASCdASGeAUHwACGfASAEIJ8BaiGgASCgASGhASCeASChARC1DyGiAUEBIaMBIKIBIKMBcSGkAQJAAkAgpAFFDQBB+AAhpQEgBCClAWohpgEgpgEhpwEgpwEQtg8aQfgAIagBIAQgqAFqIakBIKkBIaoBIKoBELcPIasBIKsBELgPIawBIAQgrAE2AmwgBCgCbCGtASAEKAJsIa4BQeAAIa8BIAQgrwFqIbABILABIbEBQYABIbIBIAQgsgFqIbMBILMBIbQBILQBKAIAIbUBILEBILUBNgIAIAQoAogCIbYBIAQoAmAhtwFB6AEhuAEgBCC4AWohuQEguQEhugEgBSCtASCuASC6ASC3ASC2ARC5DyG7ASAEILsBNgJoQYABIbwBIAQgvAFqIb0BIL0BIb4BQegAIb8BIAQgvwFqIcABIMABIcEBIMEBKAIAIcIBIL4BIMIBNgIAQfgAIcMBIAQgwwFqIcQBIMQBIcUBIMUBELcPIcYBIMYBELoPIccBQfgAIcgBIAQgyAFqIckBIMkBIcoBIMoBELcPIcsBIMsBELgPIcwBQdgAIc0BIAQgzQFqIc4BIM4BIc8BQYABIdABIAQg0AFqIdEBINEBIdIBINIBKAIAIdMBIM8BINMBNgIAIAQoAlgh1AFB6AEh1QEgBCDVAWoh1gEg1gEh1wEgBSDHASDMASDXASDUARC7DwwBC0HAACHYASAFINgBaiHZASDZARC8DyHaASAEINoBNgJQQYABIdsBIAQg2wFqIdwBINwBId0BQdAAId4BIAQg3gFqId8BIN8BIeABIN0BIOABELUPIeEBQQEh4gEg4QEg4gFxIeMBAkACQCDjAUUNAEGAASHkASAEIOQBaiHlASDlASHmASDmARC3DyHnASDnARC6DyHoASAEIOgBNgJMIAQoAkwh6QEgBCgCTCHqAUHAACHrASAEIOsBaiHsASDsASHtAUGAASHuASAEIO4BaiHvASDvASHwASDwASgCACHxASDtASDxATYCACAEKAKIAiHyASAEKAJAIfMBQegBIfQBIAQg9AFqIfUBIPUBIfYBIAUg6QEg6gEg9gEg8wEg8gEQuQ8h9wEgBCD3ATYCSEH4ACH4ASAEIPgBaiH5ASD5ASH6AUHIACH7ASAEIPsBaiH8ASD8ASH9ASD9ASgCACH+ASD6ASD+ATYCAEHoASH/ASAEIP8BaiGAAiCAAiGBAiCBAhCrDyGCAkEBIYMCIIICIIMCcSGEAgJAIIQCRQ0AQegBIYUCIAQghQJqIYYCIIYCIYcCIIcCEL0PGgtBgAEhiAIgBCCIAmohiQIgiQIhigIgigIQtw8hiwIgiwIQug8hjAJBgAEhjQIgBCCNAmohjgIgjgIhjwIgjwIQtw8hkAIgkAIQuA8hkQJBOCGSAiAEIJICaiGTAiCTAiGUAkGAASGVAiAEIJUCaiGWAiCWAiGXAiCXAigCACGYAiCUAiCYAjYCACAEKAI4IZkCQegBIZoCIAQgmgJqIZsCIJsCIZwCIAUgnAIgjAIgkQIgmQIQuw9BgAEhnQIgBCCdAmohngIgngIhnwJB+AAhoAIgBCCgAmohoQIgoQIhogIgogIoAgAhowIgnwIgowI2AgAMAQtBgAEhpAIgBCCkAmohpQIgpQIhpgIgpgIQtw8hpwIgpwIQug8hqAIgBCCoAjYCNEGAASGpAiAEIKkCaiGqAiCqAiGrAiCrAhC3DyGsAiCsAhC4DyGtAiAEIK0CNgIwQYABIa4CIAQgrgJqIa8CIK8CIbACILACELcPIbECQTghsgIgsQIgsgJqIbMCIAUgswIQvg9B+AAhtAIgBCC0AmohtQIgtQIhtgIgtgIQtg8aQfgAIbcCIAQgtwJqIbgCILgCIbkCILkCELcPIboCILoCELgPIbsCIAQguwI2AixB+AAhvAIgBCC8AmohvQIgvQIhvgIgvgIQtw8hvwIgvwIQug8hwAIgBCDAAjYCKCAEKAIsIcECIAQoAjQhwgJBGCHDAiAEIMMCaiHEAiDEAiHFAkGAASHGAiAEIMYCaiHHAiDHAiHIAiDIAigCACHJAiDFAiDJAjYCACAEKAKIAiHKAiAEKAIYIcsCQegBIcwCIAQgzAJqIc0CIM0CIc4CIAUgwQIgwgIgzgIgywIgygIQuQ8hzwIgBCDPAjYCICAEKAIoIdACIAQoAiwh0QJBECHSAiAEINICaiHTAiDTAiHUAkEgIdUCIAQg1QJqIdYCINYCIdcCINcCKAIAIdgCINQCINgCNgIAIAQoAhAh2QJB6AEh2gIgBCDaAmoh2wIg2wIh3AIgBSDQAiDRAiDcAiDZAhC7D0HoASHdAiAEIN0CaiHeAiDeAiHfAiDfAhCrDyHgAkEBIeECIOACIOECcSHiAgJAIOICRQ0AQegBIeMCIAQg4wJqIeQCIOQCIeUCIOUCEL0PGgsgBCgCNCHmAiAEKAIwIecCQQgh6AIgBCDoAmoh6QIg6QIh6gJBgAEh6wIgBCDrAmoh7AIg7AIh7QIg7QIoAgAh7gIg6gIg7gI2AgAgBCgCCCHvAkHoASHwAiAEIPACaiHxAiDxAiHyAiAFIPICIOYCIOcCIO8CELsPQYABIfMCIAQg8wJqIfQCIPQCIfUCQSAh9gIgBCD2Amoh9wIg9wIh+AIg+AIoAgAh+QIg9QIg+QI2AgALC0EQIfoCIAUg+gJqIfsCIPsCEJ0PGgwACwALQZACIfwCIAQg/AJqIf0CIP0CJAAPC4EPAuYBfwZ+IwAhAkGgASEDIAIgA2shBCAEJAAgBCAANgKcASAEIAE2ApgBIAQoApwBIQVBJCEGIAUgBmohByAHEIcNIQggBCAINgKUASAEKAKUASEJIAQgCTYCkAEgBCgClAEhCkEgIQsgCiALaiEMQYgBIQ0gBCANaiEOIA4hDyAMKAIAIRAgDyAQNgIAQYABIREgBCARaiESIBIhE0GIASEUIAQgFGohFSAVIRYgFigCACEXIBMgFzYCAEGIASEYIAQgGGohGSAZIRogGhC3DyEbIBsQuA8hHEHgACEdIAQgHWohHiAeIR8gHCkCACHoASAfIOgBNwIAQRghICAfICBqISEgHCAgaiEiICIoAgAhIyAhICM2AgBBECEkIB8gJGohJSAcICRqISYgJikCACHpASAlIOkBNwIAQQghJyAfICdqISggHCAnaiEpICkpAgAh6gEgKCDqATcCAEGIASEqIAQgKmohKyArISwgLBC3DyEtQTghLiAtIC5qIS8gLxC/DyEwIAQgMDYCXEGIASExIAQgMWohMiAyITMgMxC2DxpBiAEhNCAEIDRqITUgNSE2IDYQtw8hN0E4ITggNyA4aiE5IDkQvw8hOiAEIDo2AlhBiAEhOyAEIDtqITwgPCE9ID0Qtw8hPiA+ELoPIT9BOCFAIAQgQGohQSBBIUIgPykCACHrASBCIOsBNwIAQRghQyBCIENqIUQgPyBDaiFFIEUoAgAhRiBEIEY2AgBBECFHIEIgR2ohSCA/IEdqIUkgSSkCACHsASBIIOwBNwIAQQghSiBCIEpqIUsgPyBKaiFMIEwpAgAh7QEgSyDtATcCAEE4IU0gBCBNaiFOIE4hTyBPEKsPIVBBASFRIFAgUXEhUgJAIFINAEHgACFTIAQgU2ohVCBUIVUgVRCrDyFWQQEhVyBWIFdxIVggWEUNAEHgACFZIAQgWWohWiBaIVsgWxDADyFcQTghXSAEIF1qIV4gXiFfIF8QoA8hYCBcIGAQrg8hYUEBIWIgYSBicSFjIGNFDQBB4AAhZCAEIGRqIWUgZSFmIGYQvQ8aC0GIASFnIAQgZ2ohaCBoIWkgaRC3DyFqQeAAIWsgBCBraiFsIGwhbSBqIG0QwQ8aQYgBIW4gBCBuaiFvIG8hcCBwELcPIXFBOCFyIHEgcmohcyAEKAKYASF0IAQoApABIXUgBCgCWCF2IAQoAlwhd0EwIXggBCB4aiF5IHkhekE4IXsgBCB7aiF8IHwhfUHgACF+IAQgfmohfyB/IYABIHogdCB9IIABIHUgdiB3EMIPIAQoAjAhgQEgcyCBARDDDxpBwAAhggEgBSCCAWohgwFBKCGEASAEIIQBaiGFASCFASGGAUGAASGHASAEIIcBaiGIASCIASGJASCJASgCACGKASCGASCKATYCACAEKAIoIYsBIIMBIIsBELAPIYwBIAQgjAE2AiBBgAEhjQEgBCCNAWohjgEgjgEhjwFBiAEhkAEgBCCQAWohkQEgkQEhkgEgkgEoAgAhkwEgjwEgkwE2AgBBJCGUASAFIJQBaiGVASCVARCKDUHAACGWASAFIJYBaiGXASCXARC8DyGYASAEIJgBNgIYQYgBIZkBIAQgmQFqIZoBIJoBIZsBQRghnAEgBCCcAWohnQEgnQEhngEgmwEgngEQxA8hnwFBASGgASCfASCgAXEhoQECQCChAUUNAEGIASGiASAEIKIBaiGjASCjASGkASCkARC3DyGlAUE4IaYBIKUBIKYBaiGnASAFIKcBEL4PQYgBIagBIAQgqAFqIakBIKkBIaoBIKoBELYPGkGIASGrASAEIKsBaiGsASCsASGtASCtARC3DyGuASCuARC6DyGvASAEIK8BNgIUIAQoAhQhsAFBECGxASAEILEBaiGyASCyASGzAUGAASG0ASAEILQBaiG1ASC1ASG2ASC2ASgCACG3ASCzASC3ATYCACAEKAIQIbgBQTghuQEgBCC5AWohugEgugEhuwFB4AAhvAEgBCC8AWohvQEgvQEhvgEgBSCwASC7ASC+ASC4ARC7DwtBgAEhvwEgBCC/AWohwAEgwAEhwQEgwQEQxQ8aQcAAIcIBIAUgwgFqIcMBIMMBELQPIcQBIAQgxAE2AghBgAEhxQEgBCDFAWohxgEgxgEhxwFBCCHIASAEIMgBaiHJASDJASHKASDHASDKARDEDyHLAUEBIcwBIMsBIMwBcSHNAQJAIM0BRQ0AQYABIc4BIAQgzgFqIc8BIM8BIdABINABELcPIdEBQTgh0gEg0QEg0gFqIdMBIAUg0wEQvg9BgAEh1AEgBCDUAWoh1QEg1QEh1gEg1gEQtw8h1wEg1wEQuA8h2AEgBCDYATYCBCAEKAIEIdkBIAQh2gFBgAEh2wEgBCDbAWoh3AEg3AEh3QEg3QEoAgAh3gEg2gEg3gE2AgAgBCgCACHfAUE4IeABIAQg4AFqIeEBIOEBIeIBQeAAIeMBIAQg4wFqIeQBIOQBIeUBIAUg4gEg5QEg2QEg3wEQuw8LQaABIeYBIAQg5gFqIecBIOcBJAAPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBQ8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMsPIQUgBRDMDyEGQRAhByADIAdqIQggCCQAIAYPC+oBAhp/A3wjACEDQSAhBCADIARrIQUgBSQAIAUgADYCHCAFIAE2AhggBSACNgIUIAUoAhwhBkEBIQcgBiAHaiEIIAUoAhghCSAJEMYPIQogBSAKNgIMQQwhCyAFIAtqIQwgDCENIAggDRDHDyEdQQEhDiAGIA5qIQ8gBSgCFCEQIBAQyA8hHiAFIB45AwAgBSERIA8gERDJDyEfQcAAIRIgBiAdIB8gEhDKDyETIAUgEzYCECAFKAIQIRRBfyEVIBQhFiAVIRcgFiAXRiEYQQEhGSAYIBlxIRpBICEbIAUgG2ohHCAcJAAgGg8LNgEHfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQtABghBUEBIQYgBSAGcSEHIAcPC6YBARV/IwAhAUEgIQIgASACayEDIAMkACADIAA2AhwgAygCHCEEIAQQyw8hBUEYIQYgAyAGaiEHIAchCCAFKAIAIQkgCCAJNgIAIAQQzQ9BECEKIAQgCmohC0EQIQwgAyAMaiENIA0hDkEYIQ8gAyAPaiEQIBAhESAOIBEQzg8aIAMoAhAhEiALIBIQzw8hEyADIBM2AghBICEUIAMgFGohFSAVJAAPCzoBBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDQD0EQIQUgAyAFaiEGIAYkAA8L/SACyAN/CX4jACEBQdABIQIgASACayEDIAMkACADIAA2AswBIAMoAswBIQRBGCEFIAQgBWohBiAGENEPIQcgAyAHNgLIAUEYIQggBCAIaiEJIAkQ0Q8hCiADIAo2AsABAkADQEEYIQsgBCALaiEMIAwQ0g8hDSADIA02ArgBQcABIQ4gAyAOaiEPIA8hEEG4ASERIAMgEWohEiASIRMgECATENMPIRRBASEVIBQgFXEhFiAWRQ0BQcABIRcgAyAXaiEYIBghGSAZENQPIRogGhCQDSEbIAMgGzYCtAFBwAEhHCADIBxqIR0gHSEeIB4Q1A8hHyAfENUPISAgAyAgNgKwASADKAK0ASEhQQAhIiAhISMgIiEkICMgJEchJUEBISYgJSAmcSEnAkACQCAnRQ0AIAMoArABIShBACEpICghKiApISsgKiArRyEsQQEhLSAsIC1xIS4gLkUNAEEkIS8gBCAvaiEwIAMoArQBITEgAygCsAEhMiAwIDEgMhDWDyEzQQEhNCAzIDRxITUgNUUNAEHAASE2IAMgNmohNyA3ITggOBDXDyE5IAQgORDYDwwBC0HAASE6IAMgOmohOyA7ITxByAEhPSADID1qIT4gPiE/IDwgPxDTDyFAQQEhQSBAIEFxIUICQCBCRQ0AQcABIUMgAyBDaiFEIEQhRSBFENcPIUZByAEhRyADIEdqIUggSCFJIEkQ1w8hSiBGKQIAIckDIEogyQM3AgBBECFLIEogS2ohTCBGIEtqIU0gTSkCACHKAyBMIMoDNwIAQQghTiBKIE5qIU8gRiBOaiFQIFApAgAhywMgTyDLAzcCACADIEo2AqwBQcABIVEgAyBRaiFSIFIhU0EBIVQgUyBUENkPIVUgAyBVNgKgAUGgASFWIAMgVmohVyBXIVggWBDXDyFZQcgBIVogAyBaaiFbIFshXEEBIV0gXCBdENkPIV4gAyBeNgKYAUGYASFfIAMgX2ohYCBgIWEgYRDXDyFiIFkpAgAhzAMgYiDMAzcCAEEQIWMgYiBjaiFkIFkgY2ohZSBlKQIAIc0DIGQgzQM3AgBBCCFmIGIgZmohZyBZIGZqIWggaCkCACHOAyBnIM4DNwIAIAMgYjYCqAEgAygCrAEhaSADKAKoASFqIGkgahDaDyADKAKoASFrIAMoAqwBIWwgayBsENoPIAMoAqwBIW0gbRDbDyFuQQAhbyBuIXAgbyFxIHAgcUchckEBIXMgciBzcSF0AkAgdEUNACADKAKsASF1IHUQ2w8hdiADKAKsASF3IHYgdxDcDyADKAKoASF4IHgQ3Q8heSADKAKoASF6IHkgehDeDwsgAygCqAEheyB7ENsPIXxBACF9IHwhfiB9IX8gfiB/RyGAAUEBIYEBIIABIIEBcSGCAQJAIIIBRQ0AIAMoAqwBIYMBIIMBEN0PIYQBIAMoAqwBIYUBIIQBIIUBEN4PIAMoAqgBIYYBIIYBENsPIYcBIAMoAqgBIYgBIIcBIIgBENwPCwtByAEhiQEgAyCJAWohigEgigEhiwFBAiGMASCLASCMARDfDxoLQcABIY0BIAMgjQFqIY4BII4BIY8BQQIhkAEgjwEgkAEQ3w8aDAALAAtBGCGRASAEIJEBaiGSAUGQASGTASADIJMBaiGUASCUASGVAUHIASGWASADIJYBaiGXASCXASGYAUEAIZkBIJUBIJgBIJkBEOAPGkEYIZoBIAQgmgFqIZsBIJsBENIPIZwBIAMgnAE2AoABQYgBIZ0BIAMgnQFqIZ4BIJ4BIZ8BQYABIaABIAMgoAFqIaEBIKEBIaIBQQAhowEgnwEgogEgowEQ4A8aIAMoApABIaQBIAMoAogBIaUBIJIBIKQBIKUBEOEPIaYBIAMgpgE2AnhBGCGnASAEIKcBaiGoASCoARDRDyGpASADIKkBNgJwAkADQEEYIaoBIAQgqgFqIasBIKsBENIPIawBIAMgrAE2AmhB8AAhrQEgAyCtAWohrgEgrgEhrwFB6AAhsAEgAyCwAWohsQEgsQEhsgEgrwEgsgEQ0w8hswFBASG0ASCzASC0AXEhtQEgtQFFDQFB8AAhtgEgAyC2AWohtwEgtwEhuAEguAEQ1A8huQEguQEQ4g8hugFB8AAhuwEgAyC7AWohvAEgvAEhvQEgvQEQ1w8hvgEgugEgvgEQ4w9B8AAhvwEgAyC/AWohwAEgwAEhwQEgwQEQ1A8hwgEgwgEQkA0hwwFBACHEASDDASHFASDEASHGASDFASDGAUchxwFBASHIASDHASDIAXEhyQECQCDJAUUNAEHwACHKASADIMoBaiHLASDLASHMASDMARDUDyHNASDNARCQDSHOAUHwACHPASADIM8BaiHQASDQASHRASDRARDXDyHSASDOASDSARDkDwtB8AAh0wEgAyDTAWoh1AEg1AEh1QEg1QEQ5Q8aDAALAAtBDCHWASAEINYBaiHXASDXARDmDyHYASADINgBNgJgQQwh2QEgBCDZAWoh2gEg2gEQ5g8h2wEgAyDbATYCWAJAA0BBDCHcASAEINwBaiHdASDdARDnDyHeASADIN4BNgJQQdgAId8BIAMg3wFqIeABIOABIeEBQdAAIeIBIAMg4gFqIeMBIOMBIeQBIOEBIOQBEOgPIeUBQQEh5gEg5QEg5gFxIecBIOcBRQ0BQdgAIegBIAMg6AFqIekBIOkBIeoBIOoBEOkPIesBIOsBEOoPIewBQQAh7QEg7AEh7gEg7QEh7wEg7gEg7wFHIfABQQEh8QEg8AEg8QFxIfIBAkAg8gFFDQBB2AAh8wEgAyDzAWoh9AEg9AEh9QFB4AAh9gEgAyD2AWoh9wEg9wEh+AEg9QEg+AEQ6A8h+QFBASH6ASD5ASD6AXEh+wECQCD7AUUNAEHYACH8ASADIPwBaiH9ASD9ASH+ASD+ARDrDyH/AUHgACGAAiADIIACaiGBAiCBAiGCAiCCAhDrDyGDAiD/ASkDACHPAyCDAiDPAzcDAEEQIYQCIIMCIIQCaiGFAiD/ASCEAmohhgIghgIpAwAh0AMghQIg0AM3AwBBCCGHAiCDAiCHAmohiAIg/wEghwJqIYkCIIkCKQMAIdEDIIgCINEDNwMAQeAAIYoCIAMgigJqIYsCIIsCIYwCIIwCEOsPIY0CIAMgjQI2AkwgAygCTCGOAiCOAhDqDyGPAiADII8CNgJIA0AgAygCSCGQAiADKAJMIZECIJACIJECEOwPIAMoAkghkgIgkgIQ7Q8hkwIgAyCTAjYCSCADKAJIIZQCIAMoAkwhlQIglQIQ6g8hlgIglAIhlwIglgIhmAIglwIgmAJHIZkCQQEhmgIgmQIgmgJxIZsCIJsCDQALC0HgACGcAiADIJwCaiGdAiCdAiGeAiCeAhDuDxoLQdgAIZ8CIAMgnwJqIaACIKACIaECIKECEO4PGgwACwALQQwhogIgBCCiAmohowJBwAAhpAIgAyCkAmohpQIgpQIhpgJB4AAhpwIgAyCnAmohqAIgqAIhqQJBACGqAiCmAiCpAiCqAhDvDxpBDCGrAiAEIKsCaiGsAiCsAhDnDyGtAiADIK0CNgIwQTghrgIgAyCuAmohrwIgrwIhsAJBMCGxAiADILECaiGyAiCyAiGzAkEAIbQCILACILMCILQCEO8PGiADKAJAIbUCIAMoAjghtgIgowIgtQIgtgIQ8A8htwIgAyC3AjYCKEEMIbgCIAQguAJqIbkCILkCEPEPIboCQQEhuwIgugIguwJxIbwCAkACQCC8AkUNAEEYIb0CIAQgvQJqIb4CIL4CEPIPIb8CQQEhwAIgvwIgwAJxIcECAkAgwQINAEEYIcICIAQgwgJqIcMCIMMCENEPIcQCIAMgxAI2AiBBICHFAiADIMUCaiHGAiDGAiHHAiDHAhDXDyHIAiADIMgCNgIcIAMoAhwhyQIgAygCHCHKAiDJAiDKAhDcDyADKAIcIcsCIAMoAhwhzAIgywIgzAIQ3g9BICHNAiADIM0CaiHOAiDOAiHPAiDPAhDlDxpBICHQAiADINACaiHRAiDRAiHSAiDSAhDXDyHTAiADINMCNgIcQSAh1AIgAyDUAmoh1QIg1QIh1gIg1gIQ5Q8aAkADQEEYIdcCIAQg1wJqIdgCINgCENIPIdkCIAMg2QI2AhhBICHaAiADINoCaiHbAiDbAiHcAkEYId0CIAMg3QJqId4CIN4CId8CINwCIN8CENMPIeACQQEh4QIg4AIg4QJxIeICIOICRQ0BQSAh4wIgAyDjAmoh5AIg5AIh5QIg5QIQ1w8h5gIgAyDmAjYCFEEgIecCIAMg5wJqIegCIOgCIekCIOkCEOUPGiADKAIcIeoCIAMoAhQh6wIg6gIg6wIQ3A8gAygCHCHsAiADKAIUIe0CIOwCIO0CEN4PIAMoAhQh7gIgAygCHCHvAiDuAiDvAhDcDyADKAIUIfACIAMoAhwh8QIg8AIg8QIQ3g9BICHyAiADIPICaiHzAiDzAiH0AiD0AhDXDyH1AiADIPUCNgIcQSAh9gIgAyD2Amoh9wIg9wIh+AIg+AIQ5Q8aDAALAAsgAygCHCH5AiADKAIcIfoCIPkCIPoCENwPIAMoAhwh+wIgAygCHCH8AiD7AiD8AhDeDwsMAQsgBBDzDyH9AiADIP0CNgIQAkADQCAEEPQPIf4CIAMg/gI2AghBECH/AiADIP8CaiGAAyCAAyGBA0EIIYIDIAMgggNqIYMDIIMDIYQDIIEDIIQDEPUPIYUDQQEhhgMghQMghgNxIYcDIIcDRQ0BQRAhiAMgAyCIA2ohiQMgiQMhigMgigMQ9g8hiwMgiwMQ9w8hjANBASGNAyCMAyCNA3EhjgMCQAJAII4DRQ0ADAELQRAhjwMgAyCPA2ohkAMgkAMhkQMgkQMQ9g8hkgMgkgMQ+A8hkwMgAyCTAzYCBAJAA0AgAygCBCGUAyCUAxDbDyGVA0EAIZYDIJUDIZcDIJYDIZgDIJcDIJgDRyGZA0EBIZoDIJkDIJoDcSGbAyCbA0UNASADKAIEIZwDIJwDENsPIZ0DIAMgnQM2AgQgAygCBCGeA0EQIZ8DIAMgnwNqIaADIKADIaEDIKEDEPYPIaIDIKIDEPgPIaMDIJ4DIaQDIKMDIaUDIKQDIKUDRiGmA0EBIacDIKYDIKcDcSGoAwJAIKgDRQ0ADAILDAALAAsgAygCBCGpAyCpAxDbDyGqA0EAIasDIKoDIawDIKsDIa0DIKwDIK0DRyGuA0EBIa8DIK4DIK8DcSGwAwJAILADRQ0ADAELQRAhsQMgAyCxA2ohsgMgsgMhswMgswMQ9g8htAMgtAMQ+A8htQMgAyC1AzYCAAJAA0AgAygCACG2AyC2AxDdDyG3A0EAIbgDILcDIbkDILgDIboDILkDILoDRyG7A0EBIbwDILsDILwDcSG9AyC9A0UNASADKAIAIb4DIL4DEN0PIb8DIAMgvwM2AgAMAAsACyADKAIEIcADIAMoAgAhwQMgwAMgwQMQ3g8gAygCACHCAyADKAIEIcMDIMIDIMMDENwPC0EQIcQDIAMgxANqIcUDIMUDIcYDIMYDEPkPGgwACwALC0HQASHHAyADIMcDaiHIAyDIAyQADwuwCQKNAX8EfiMAIQVB8AEhBiAFIAZrIQcgByQAIAcgATYC6AEgByACNgLgASAHIAA2AtwBIAMhCCAHIAg6ANsBIAQhCSAHIAk6ANoBQeABIQogByAKaiELIAshDEHoASENIAcgDWohDiAOIQ8gDCAPENACIRAgByAQNgLUAUEAIREgByARNgLQAQJAA0AgBygC0AEhEiAHKALUASETIBIhFCATIRUgFCAVSSEWQQEhFyAWIBdxIRggGEUNASAHKALQASEZQegBIRogByAaaiEbIBshHCAcIBkQ0QIhHSAHIB02AswBIAcoAtABIR5BASEfIB4gH2ohICAHKALUASEhICAhIiAhISMgIiAjSSEkQQEhJSAkICVxISYCQAJAICZFDQAgBygC0AEhJ0EBISggJyAoaiEpQegBISogByAqaiErICshLCAsICkQ0QIhLSAHIC02AsgBDAELIActANsBIS5BASEvIC4gL3EhMAJAAkAgMEUNAEHoASExIAcgMWohMiAyITNBACE0IDMgNBDRAiE1IAcgNTYCyAEMAQsMAwsLIActANoBITZBASE3QQEhOCA2IDhxITkgNyE6AkAgOQ0AIAcoAswBITtBsAEhPCAHIDxqIT0gPSE+ID4gOxC3DBpBwAEhPyAHID9qIUAgQBpBCCFBQSghQiAHIEJqIUMgQyBBaiFEQbABIUUgByBFaiFGIEYgQWohRyBHKAIAIUggRCBINgIAIAcpA7ABIZIBIAcgkgE3AyhBwAEhSSAHIElqIUpBKCFLIAcgS2ohTCBKIEwQlg0gBygCyAEhTUGYASFOIAcgTmohTyBPIVAgUCBNELcMGkGoASFRIAcgUWohUiBSGkEIIVNBOCFUIAcgVGohVSBVIFNqIVZBmAEhVyAHIFdqIVggWCBTaiFZIFkoAgAhWiBWIFo2AgAgBykDmAEhkwEgByCTATcDOEGoASFbIAcgW2ohXEE4IV0gByBdaiFeIFwgXhCWDUHAASFfIAcgX2ohYCBgIWFBqAEhYiAHIGJqIWMgYyFkIGEgZBDSAiFlIGUhOgsgOiFmQQEhZyBmIGdxIWgCQCBoRQ0AIAcoAtwBIWkgBygCzAEhakHYACFrIAcga2ohbCBsIW0gbSBqELcMGiAHKALIASFuQcgAIW8gByBvaiFwIHAhcSBxIG4QtwwaQegAIXIgByByaiFzIHMaQQghdEEYIXUgByB1aiF2IHYgdGohd0HYACF4IAcgeGoheSB5IHRqIXogeigCACF7IHcgezYCACAHKQNYIZQBIAcglAE3AxhBCCF8IAcgfGohfSB9IHRqIX5ByAAhfyAHIH9qIYABIIABIHRqIYEBIIEBKAIAIYIBIH4gggE2AgAgBykDSCGVASAHIJUBNwMIQQEhgwFB6AAhhAEgByCEAWohhQFBGCGGASAHIIYBaiGHAUEIIYgBIAcgiAFqIYkBIIUBIIcBIIkBIIMBELwMGkHoACGKASAHIIoBaiGLASCLASGMASBpIIwBEPYVCyAHKALQASGNAUEBIY4BII0BII4BaiGPASAHII8BNgLQAQwACwALQfABIZABIAcgkAFqIZEBIJEBJAAPC1wBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCACEFQQghBiAEIAZqIQcgByEIIAggBRCxFhogBCgCCCEJQRAhCiAEIApqIQsgCyQAIAkPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ6BUhBiAEKAIIIQcgBxDoFSEIIAYhCSAIIQogCSAKRiELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgQhBSAFDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhD5FSEHQRAhCCADIAhqIQkgCSQAIAcPC8sBARV/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhwgBiABNgIYIAYgAjYCFCAGIAM2AhAgBigCHCEHIAYhCEEBIQkgCCAHIAkQ+hUaIAcQ+xUhCiAGKAIEIQsgCxD8FSEMIAYoAhghDSANELECIQ4gBigCFCEPIA8QsQIhECAGKAIQIREgERDSCSESIAogDCAOIBAgEhCyFiAGKAIEIRNBLCEUIBMgFGohFSAGIBU2AgQgBiEWIBYQ/hUaQSAhFyAGIBdqIRggGCQADwusAgEifyMAIQRBMCEFIAQgBWshBiAGJAAgBiAANgIsIAYgATYCKCAGIAI2AiQgBiADNgIgIAYoAiwhByAHEPsVIQggBiAINgIcIAcQkgwhCUEBIQogCSAKaiELIAcgCxD/FSEMIAcQkgwhDSAGKAIcIQ5BCCEPIAYgD2ohECAQIREgESAMIA0gDhCAFhogBigCHCESIAYoAhAhEyATEPwVIRQgBigCKCEVIBUQsQIhFiAGKAIkIRcgFxCxAiEYIAYoAiAhGSAZENIJIRogEiAUIBYgGCAaELIWIAYoAhAhG0EsIRwgGyAcaiEdIAYgHTYCEEEIIR4gBiAeaiEfIB8hICAHICAQgRZBCCEhIAYgIWohIiAiISMgIxCCFhpBMCEkIAYgJGohJSAlJAAPC2UBDH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQtRYhBiAEKAIIIQcgBxC1FiEIIAYgCGshCUEsIQogCSAKbSELQRAhDCAEIAxqIQ0gDSQAIAsPC0sBCX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCACEGIAQoAgghB0EsIQggByAIbCEJIAYgCWohCiAKDwvLAgIlfwR+IwAhAkHAACEDIAIgA2shBCAEJAAgBCAANgI8QTAhBSAEIAVqIQYgBiEHIAEpAgAhJyAHICc3AgBBCCEIIAcgCGohCSABIAhqIQogCigCACELIAkgCzYCAEEIIQwgBCAMaiENQTAhDiAEIA5qIQ8gDyAMaiEQIBAoAgAhESANIBE2AgAgBCkDMCEoIAQgKDcDACAEEKINIRJBICETIAQgE2ohFCAUIRUgASkCACEpIBUgKTcCAEEIIRYgFSAWaiEXIAEgFmohGCAYKAIAIRkgFyAZNgIAQQghGkEQIRsgBCAbaiEcIBwgGmohHUEgIR4gBCAeaiEfIB8gGmohICAgKAIAISEgHSAhNgIAIAQpAyAhKiAEICo3AxBBECEiIAQgImohIyAjELUNISQgACASICQQHBpBwAAhJSAEICVqISYgJiQADwu0AQEUfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGIAUQiRYhByAGIQggByEJIAggCUshCkEBIQsgCiALcSEMAkAgDEUNACAFEPsVIQ0gBCANNgIUIAQoAhghDiAFEJIMIQ8gBCgCFCEQIAQhESARIA4gDyAQEIAWGiAEIRIgBSASEIEWIAQhEyATEIIWGgtBICEUIAQgFGohFSAVJAAPC0ABBn8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIIIQUgBCgCDCEGIAYgBTYCACAEKAIIIQcgBw8LQAEGfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgghBSAEKAIMIQYgBiAFNgIEIAQoAgghByAHDwuUAQEQfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCBCEGIAUQkQ0hByAHKAIAIQggBiEJIAghCiAJIApHIQtBASEMIAsgDHEhDQJAAkAgDUUNACAEKAIIIQ4gBSAOELYWDAELIAQoAgghDyAFIA8QtxYLQRAhECAEIBBqIREgESQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LTAEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhC4FkEQIQcgBCAHaiEIIAgkACAFDwtcAQp/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgAhBUEIIQYgBCAGaiEHIAchCCAIIAUQxRYaIAQoAgghCUEQIQogBCAKaiELIAskACAJDwufAwI0fwR+IwAhAkHQACEDIAIgA2shBCAEJAAgBCAANgJMIAQgATYCSCAEKAJMIQVBECEGIAUgBmohB0E4IQggBCAIaiEJIAkhCiAHKQIAITYgCiA2NwIAQQghCyAKIAtqIQwgByALaiENIA0oAgAhDiAMIA42AgBBCCEPQQghECAEIBBqIREgESAPaiESQTghEyAEIBNqIRQgFCAPaiEVIBUoAgAhFiASIBY2AgAgBCkDOCE3IAQgNzcDCEEIIRcgBCAXaiEYIBgQog0hGSAEKAJIIRpBECEbIBogG2ohHEEoIR0gBCAdaiEeIB4hHyAcKQIAITggHyA4NwIAQQghICAfICBqISEgHCAgaiEiICIoAgAhIyAhICM2AgBBCCEkQRghJSAEICVqISYgJiAkaiEnQSghKCAEIChqISkgKSAkaiEqICooAgAhKyAnICs2AgAgBCkDKCE5IAQgOTcDGEEYISwgBCAsaiEtIC0Qog0hLiAZIS8gLiEwIC8gMEghMUEBITIgMSAycSEzQdAAITQgBCA0aiE1IDUkACAzDwuAAQEQfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIYIAUgATYCECAFIAI2AgxBGCEGIAUgBmohByAHIQggCBC1FiEJQRAhCiAFIApqIQsgCyEMIAwQtRYhDUEMIQ4gBSAOaiEPIA8hECAJIA0gEBDGFkEgIREgBSARaiESIBIkAA8LbQEOfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRC1FiEGIAQoAgghByAHELUWIQggBiEJIAghCiAJIApGIQtBASEMIAsgDHEhDUEQIQ4gBCAOaiEPIA8kACANDwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgAhBSAFEM4WIQZBECEHIAMgB2ohCCAIJAAgBg8LDgEBfyAAKAIAIQEgAQ8LPQEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEM8WGkEQIQUgAyAFaiEGIAYkACAEDwtMAQt/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAQoAgQhBiAFIQcgBiEIIAcgCEYhCUEBIQogCSAKcSELIAsPC5IBAgx/AX4jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ0BYaIAQoAgghBiAFIAY2AghBGCEHIAUgB2ohCEIAIQ4gCCAONwMAIAUgDjcDEEEAIQkgBSAJOgAgQQAhCiAFIAo6ACFBACELIAUgCzoAIkEQIQwgBCAMaiENIA0kACAFDwuUAQEQfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCBCEGIAUQ0RYhByAHKAIAIQggBiEJIAghCiAJIApHIQtBASEMIAsgDHEhDQJAAkAgDUUNACAEKAIIIQ4gBSAOENIWDAELIAQoAgghDyAFIA8Q0xYLQRAhECAEIBBqIREgESQADwtVAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQoAgAhBSAEIAUQ1BYhBiADIAY2AgggAygCCCEHQRAhCCADIAhqIQkgCSQAIAcPC1UBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBCgCBCEFIAQgBRDUFiEGIAMgBjYCCCADKAIIIQdBECEIIAMgCGohCSAJJAAgBw8LZAEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhDVFiEHQX8hCCAHIAhzIQlBASEKIAkgCnEhC0EQIQwgBCAMaiENIA0kACALDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC9wDAjF/Bn4jACEDQYABIQQgAyAEayEFIAUkACAFIAE2AnwgBSACNgJ4IAUoAnwhBiAFKAJ4IQdBGCEIIAcgCGohCSAJKAIAIQpBCCELQdgAIQwgBSAMaiENIA0gC2ohDiAOIAo2AgAgBykCECE0IAUgNDcDWEEoIQ8gBSAPaiEQIBAgC2ohESAOKAIAIRIgESASNgIAIAUpA1ghNSAFIDU3AyhB6AAhEyAFIBNqIRRBKCEVIAUgFWohFiAUIBYQlg1B8AAhFyAFIBdqIRhB6AAhGSAFIBlqIRogGCAaEOIBGiAFKAJ4IRtBJCEcIBsgHGohHSAdKAIAIR5BOCEfIAUgH2ohICAgIAtqISEgISAeNgIAIBspAhwhNiAFIDY3AzhBGCEiIAUgImohIyAjIAtqISQgISgCACElICQgJTYCACAFKQM4ITcgBSA3NwMYQcgAISYgBSAmaiEnQRghKCAFIChqISkgJyApEJYNQdAAISogBSAqaiErQcgAISwgBSAsaiEtICsgLRDiARpB8AAhLiAFIC5qIS9B0AAhMCAFIDBqITEgBSAGIC8gMRCZCSAFKQMAITggBSkDCCE5IAAgOTcDCCAAIDg3AwBBgAEhMiAFIDJqITMgMyQADws9AQd/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFQTAhBiAFIAZqIQcgBCAHNgIAIAQPC0wBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBCnDSEFIAMgBTYCCCADKAIIIQZBECEHIAMgB2ohCCAIJAAgBg8LTAEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEEKgNIQUgAyAFNgIIIAMoAgghBkEQIQcgAyAHaiEIIAgkACAGDwuBAQERfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGQRAhByAEIAdqIQggCCEJQQghCiAEIApqIQsgCyEMIAQhDSAFIAYgCSAMIA0Q2BYhDkEBIQ8gDiAPcSEQQSAhESAEIBFqIRIgEiQAIBAPC4ABARB/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhggBSABNgIQIAUgAjYCDEEYIQYgBSAGaiEHIAchCCAIENYWIQlBECEKIAUgCmohCyALIQwgDBDWFiENQQwhDiAFIA5qIQ8gDyEQIAkgDSAQENcWQSAhESAFIBFqIRIgEiQADwuAAQEPfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQVBCCEGIAQgBmohByAHIQggBSgCACEJIAggCTYCACAEKAIAIQpBCCELIAQgC2ohDCAMIQ0gDSAKENkWGiAEKAIIIQ5BECEPIAQgD2ohECAQJAAgDg8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIAIQUgBRDaFiEGQRAhByADIAdqIQggCCQAIAYPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ1hYhBiAEKAIIIQcgBxDWFiEIIAYhCSAIIQogCSAKSSELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LxAICHX8EfiMAIQdB4AAhCCAHIAhrIQkgCSQAIAkgAzYCWCAJIAQ2AlAgCSAANgJMIAkgAjcDOCAJIAE3AzAgCSAFNgIsIAkgBjYCKCAJKAIsIQogCSgCTCELIAkpAzghJCAJKQMwISUgCSgCWCEMIAkgDDYCICAJKAJQIQ0gCSANNgIYIAkoAiAhDiAJKAIYIQ8gCiALICUgJCAOIA8Q2xYgCSgCTCEQIAkpAzghJiAJKQMwISdBECERIAkgEWohEiASIRNB2AAhFCAJIBRqIRUgFSEWIBYoAgAhFyATIBc2AgBBCCEYIAkgGGohGSAZIRpB0AAhGyAJIBtqIRwgHCEdIB0oAgAhHiAaIB42AgAgCSgCKCEfIAkoAhAhICAJKAIIISEgECAnICYgICAhIB8Q3BZB4AAhIiAJICJqISMgIyQADwsOAQF/IAAoAgQhASABDwu4BQJdfwR+IwAhAkHAACEDIAIgA2shBCAEJAAgBCAANgIwIAQgATYCKEEQIQUgBCAFaiEGIAYhB0EwIQggBCAIaiEJIAkhCiAKKAIAIQsgByALNgIAQQghDCAEIAxqIQ0gDSEOQSghDyAEIA9qIRAgECERIBEoAgAhEiAOIBI2AgAgBCgCECETIAQoAgghFEEgIRUgBCAVaiEWIBYhFyATIBQgFxDjFiEYIAQgGDYCGEEwIRkgBCAZaiEaIBohG0EYIRwgBCAcaiEdIB0hHiAeKAIAIR8gGyAfNgIAQTAhICAEICBqISEgISEiQSghIyAEICNqISQgJCElICIgJRCpDSEmQQEhJyAmICdxISgCQCAoRQ0AIAQhKUEwISogBCAqaiErICshLCAsKAIAIS0gKSAtNgIAAkADQCAEIS4gLhCsDSEvQSghMCAEIDBqITEgMSEyIC8gMhCpDSEzQQEhNCAzIDRxITUgNUUNASAEITYgNhCqDSE3QSAhOCAEIDhqITkgOSE6IDogNxDkFiE7QQEhPCA7IDxxIT0CQCA9DQAgBCE+ID4Qqg0hPyA/EOUWIUBBMCFBIAQgQWohQiBCIUMgQxCqDSFEIEApAwAhXyBEIF83AwBBHyFFIEQgRWohRiBAIEVqIUcgRygAACFIIEYgSDYAAEEYIUkgRCBJaiFKIEAgSWohSyBLKQMAIWAgSiBgNwMAQRAhTCBEIExqIU0gQCBMaiFOIE4pAwAhYSBNIGE3AwBBCCFPIEQgT2ohUCBAIE9qIVEgUSkDACFiIFAgYjcDAEEwIVIgBCBSaiFTIFMhVCBUEKwNGgsMAAsACwtBOCFVIAQgVWohViBWIVdBMCFYIAQgWGohWSBZIVogWigCACFbIFcgWzYCACAEKAI4IVxBwAAhXSAEIF1qIV4gXiQAIFwPC1oBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxDWFiEIIAYgCDYCAEEQIQkgBSAJaiEKIAokACAGDwvrAgEvfyMAIQNBMCEEIAMgBGshBSAFJAAgBSABNgIgIAUgAjYCGCAFIAA2AhQgBSgCFCEGIAYoAgAhByAGEKcNIQggBSAINgIIQSAhCSAFIAlqIQogCiELQQghDCAFIAxqIQ0gDSEOIAsgDhDdFiEPQTAhECAPIBBsIREgByARaiESIAUgEjYCEEEgIRMgBSATaiEUIBQhFUEYIRYgBSAWaiEXIBchGCAVIBgQ3hYhGUEBIRogGSAacSEbAkAgG0UNACAFKAIQIRxBGCEdIAUgHWohHiAeIR9BICEgIAUgIGohISAhISIgHyAiEN8WISNBMCEkICMgJGwhJSAcICVqISYgBigCBCEnIAUoAhAhKCAmICcgKBDgFiEpIAYgKRDhFiAFKAIQISpBUCErICogK2ohLCAGICwQ4hYLIAUoAhAhLSAGIC0Q1BYhLiAFIC42AiggBSgCKCEvQTAhMCAFIDBqITEgMSQAIC8PC0IBBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDmFiAEEOcWGkEQIQUgAyAFaiEGIAYkACAEDws6AQZ/IwAhAUEgIQIgASACayEDIAMgADYCBCADKAIEIQRBACEFIAQgBTYCBEEAIQYgBCAGNgIIIAQPC7ADAyN/C34EfCMAIQRB8AAhBSAEIAVrIQYgBiQAIAYgADYCbCAGKAJsIQdB2AAhCCAGIAhqIQkgCSACIAEQwA1B0AAhCiAGIApqIQsgCyADIAEQwA1B2AAhDCAGIAxqIQ1B0AAhDiAGIA5qIQ8gDSAPEMIXISdBICEQIAYgEGohESARICcQqBpBCCESQSAhEyAGIBNqIRQgFCASaiEVIBUpAwAhKCAGKQMgISlBwAAhFiAGIBZqIRcgFyACIAEQwxcgBikDSCEqIAYpA0AhK0EQIRggBiAYaiEZIBkgKSAoICsgKhCzGkEQIRogBiAaaiEbIBsgEmohHCAcKQMAISwgBikDECEtQTAhHSAGIB1qIR4gHiADIAEQwxcgBikDOCEuIAYpAzAhLyAGIC0gLCAvIC4QsxogBiASaiEfIB8pAwAhMCAGKQMAITEgMSAwELQaITIgBiAyOQNgIAYrA2AhM0SAXkAhz+stQCE0IDQQnRohNSAzIDVlISBBASEhICAgIXEhIgJAICJFDQAgBygCACEjQQAhJCAjICQ6AAALQfAAISUgBiAlaiEmICYkAA8LlgUDSX8Ifgd8IwAhAUGAASECIAEgAmshAyADJABB8AAhBCADIARqIQUgBSEGIAApAgAhSiAGIEo3AgBBCCEHIAYgB2ohCCAAIAdqIQkgCSgCACEKIAggCjYCAEEIIQsgAyALaiEMQfAAIQ0gAyANaiEOIA4gC2ohDyAPKAIAIRAgDCAQNgIAIAMpA3AhSyADIEs3AwAgAxCiDSERIBG3IVJB4AAhEiADIBJqIRMgEyEUIAApAgAhTCAUIEw3AgBBCCEVIBQgFWohFiAAIBVqIRcgFygCACEYIBYgGDYCAEEIIRlBECEaIAMgGmohGyAbIBlqIRxB4AAhHSADIB1qIR4gHiAZaiEfIB8oAgAhICAcICA2AgAgAykDYCFNIAMgTTcDEEEQISEgAyAhaiEiICIQog0hIyAjtyFTIFIgU6IhVEHQACEkIAMgJGohJSAlISYgACkCACFOICYgTjcCAEEIIScgJiAnaiEoIAAgJ2ohKSApKAIAISogKCAqNgIAQQghK0EgISwgAyAsaiEtIC0gK2ohLkHQACEvIAMgL2ohMCAwICtqITEgMSgCACEyIC4gMjYCACADKQNQIU8gAyBPNwMgQSAhMyADIDNqITQgNBC1DSE1IDW3IVVBwAAhNiADIDZqITcgNyE4IAApAgAhUCA4IFA3AgBBCCE5IDggOWohOiAAIDlqITsgOygCACE8IDogPDYCAEEIIT1BMCE+IAMgPmohPyA/ID1qIUBBwAAhQSADIEFqIUIgQiA9aiFDIEMoAgAhRCBAIEQ2AgAgAykDQCFRIAMgUTcDMEEwIUUgAyBFaiFGIEYQtQ0hRyBHtyFWIFUgVqIhVyBUIFegIVhBgAEhSCADIEhqIUkgSSQAIFgPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwvLAQEVfyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIcIAYgATYCGCAGIAI2AhQgBiADNgIQIAYoAhwhByAGIQhBASEJIAggByAJEPoVGiAHEPsVIQogBigCBCELIAsQ/BUhDCAGKAIYIQ0gDRC9DSEOIAYoAhQhDyAPEL0NIRAgBigCECERIBEQ0gkhEiAKIAwgDiAQIBIQxhcgBigCBCETQSwhFCATIBRqIRUgBiAVNgIEIAYhFiAWEP4VGkEgIRcgBiAXaiEYIBgkAA8LrAIBIn8jACEEQTAhBSAEIAVrIQYgBiQAIAYgADYCLCAGIAE2AiggBiACNgIkIAYgAzYCICAGKAIsIQcgBxD7FSEIIAYgCDYCHCAHEJIMIQlBASEKIAkgCmohCyAHIAsQ/xUhDCAHEJIMIQ0gBigCHCEOQQghDyAGIA9qIRAgECERIBEgDCANIA4QgBYaIAYoAhwhEiAGKAIQIRMgExD8FSEUIAYoAighFSAVEL0NIRYgBigCJCEXIBcQvQ0hGCAGKAIgIRkgGRDSCSEaIBIgFCAWIBggGhDGFyAGKAIQIRtBLCEcIBsgHGohHSAGIB02AhBBCCEeIAYgHmohHyAfISAgByAgEIEWQQghISAGICFqISIgIiEjICMQghYaQTAhJCAGICRqISUgJSQADwuHAQEPfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAYQDSEHIAUoAgQhCCAIEA0hCSAHIAlrIQogBSgCCCELIAsQDiEMIAUoAgQhDSANEA4hDiAMIA5rIQ8gACAKIA8QHBpBECEQIAUgEGohESARJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwuzAQEVfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQVBCCEGIAQgBmohByAHIQhBASEJIAggBSAJEPoVGiAFEPsVIQogBCgCDCELIAsQ/BUhDCAEKAIYIQ0gDRDBDSEOIAogDCAOEP0VIAQoAgwhD0EsIRAgDyAQaiERIAQgETYCDEEIIRIgBCASaiETIBMhFCAUEP4VGkEgIRUgBCAVaiEWIBYkAA8L3QEBGH8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAUQ+xUhBiAEIAY2AhQgBRCSDCEHQQEhCCAHIAhqIQkgBSAJEP8VIQogBRCSDCELIAQoAhQhDCAEIQ0gDSAKIAsgDBCAFhogBCgCFCEOIAQoAgghDyAPEPwVIRAgBCgCGCERIBEQwQ0hEiAOIBAgEhD9FSAEKAIIIRNBLCEUIBMgFGohFSAEIBU2AgggBCEWIAUgFhCBFiAEIRcgFxCCFhpBICEYIAQgGGohGSAZJAAPC2YBCn8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBEEAIQUgBCAFOgAAQQAhBiAEIAY6AAFBACEHIAQgBzoAAkEAIQggBCAINgIEQQAhCSAEIAk2AghBACEKIAQgCjYCDCAEDwtXAQx/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFQQMhBiAFIAZ2IQcgBCgCCCEIIAchCSAIIQogCSAKRiELQQEhDCALIAxxIQ0gDQ8L6gEDGn8CfgN8IwAhA0HAACEEIAMgBGshBSAFJABBMCEGIAUgBmohByAHIQggCCABIAAQuAxBICEJIAUgCWohCiAKIQsgCyACIAAQuAxBMCEMIAUgDGohDSANIQ5BICEPIAUgD2ohECAQIREgDiAREMoXIR0gHbkhH0EQIRIgBSASaiETIBMhFCAUIAEgABC4DEEIIRUgBSAVaiEWQRAhFyAFIBdqIRggGCAVaiEZIBkoAgAhGiAWIBo2AgAgBSkDECEeIAUgHjcDACAFELwNISAgHyAgoyEhQcAAIRsgBSAbaiEcIBwkACAhDwvwAQEafyMAIQRBECEFIAQgBWshBiAGJAAgBiAANgIMIAYgATYCCCAGIAI2AgQgBiADNgIAIAYoAgwhByAHKAIEIQggBxCRDSEJIAkoAgAhCiAIIQsgCiEMIAsgDEkhDUEBIQ4gDSAOcSEPAkACQCAPRQ0AIAYoAgghECAQEL0NIREgBigCBCESIBIQyxchEyAGKAIAIRQgFBDSCSEVIAcgESATIBUQzBcMAQsgBigCCCEWIBYQvQ0hFyAGKAIEIRggGBDLFyEZIAYoAgAhGiAaENIJIRsgByAXIBkgGxDNFwtBECEcIAYgHGohHSAdJAAPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDRFxpBECEFIAMgBWohBiAGJAAgBA8LTgEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEQIQUgBCAFaiEGIAYQ0hcaIAQQ0xcaQRAhByADIAdqIQggCCQAIAQPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDUFxpBECEFIAMgBWohBiAGJAAgBA8LQgEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOwOIAQQ1RcaQRAhBSADIAVqIQYgBiQAIAQPC0IBBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDhECAEEOIXGkEQIQUgAyAFaiEGIAYkACAEDwtCAQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQuRAgBBDjFxpBECEFIAMgBWohBiAGJAAgBA8LQgEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEJEQIAQQ5BcaQRAhBSADIAVqIQYgBiQAIAQPC6kBARZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQgw4hBSAEEIMOIQYgBBDnDSEHQQQhCCAHIAh0IQkgBiAJaiEKIAQQgw4hCyAEENsNIQxBBCENIAwgDXQhDiALIA5qIQ8gBBCDDiEQIAQQ5w0hEUEEIRIgESASdCETIBAgE2ohFCAEIAUgCiAPIBQQhA5BECEVIAMgFWohFiAWJAAPC5UBARF/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgggAygCCCEEIAMgBDYCDCAEKAIAIQVBACEGIAUhByAGIQggByAIRyEJQQEhCiAJIApxIQsCQCALRQ0AIAQQ6RcgBBDXDSEMIAQoAgAhDSAEEPUNIQ4gDCANIA4Q8g0LIAMoAgwhD0EQIRAgAyAQaiERIBEkACAPDwtsAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQMyEIIAYgCBDSDRogBSgCBCEJIAkQNRogBhDTDRpBECEKIAUgCmohCyALJAAgBg8LVQEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQMxpBACEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQ1A0aQRAhBSADIAVqIQYgBiQAIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ4A0hBUEQIQYgAyAGaiEHIAckACAFDwuDAQENfyMAIQNBECEEIAMgBGshBSAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAYgBzYCACAFKAIIIQggCCgCBCEJIAYgCTYCBCAFKAIIIQogCigCBCELIAUoAgQhDEEEIQ0gDCANdCEOIAsgDmohDyAGIA82AgggBg8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQ4g0hB0EQIQggAyAIaiEJIAkkACAHDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LeAELfyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIcIAYgATYCGCAGIAI2AhQgBiADNgIQIAYoAhwhByAGKAIYIQggBigCFCEJIAkQsQIhCiAGKAIQIQsgCxCxAiEMIAcgCCAKIAwQ4Q1BICENIAYgDWohDiAOJAAPCzkBBn8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCgCACEGIAYgBTYCBCAEDwtEAQl/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFIAQoAgAhBiAFIAZrIQdBBCEIIAcgCHUhCSAJDwuyAgElfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIYIAQgATYCFCAEKAIYIQUgBRDmDSEGIAQgBjYCECAEKAIUIQcgBCgCECEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AIAUQtRoACyAFEOcNIQ4gBCAONgIMIAQoAgwhDyAEKAIQIRBBASERIBAgEXYhEiAPIRMgEiEUIBMgFE8hFUEBIRYgFSAWcSEXAkACQCAXRQ0AIAQoAhAhGCAEIBg2AhwMAQsgBCgCDCEZQQEhGiAZIBp0IRsgBCAbNgIIQQghHCAEIBxqIR0gHSEeQRQhHyAEIB9qISAgICEhIB4gIRBnISIgIigCACEjIAQgIzYCHAsgBCgCHCEkQSAhJSAEICVqISYgJiQAICQPC64CASB/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhggBiABNgIUIAYgAjYCECAGIAM2AgwgBigCGCEHIAYgBzYCHEEMIQggByAIaiEJQQAhCiAGIAo2AgggBigCDCELQQghDCAGIAxqIQ0gDSEOIAkgDiALEOgNGiAGKAIUIQ8CQAJAIA9FDQAgBxDpDSEQIAYoAhQhESAQIBEQ6g0hEiASIRMMAQtBACEUIBQhEwsgEyEVIAcgFTYCACAHKAIAIRYgBigCECEXQQQhGCAXIBh0IRkgFiAZaiEaIAcgGjYCCCAHIBo2AgQgBygCACEbIAYoAhQhHEEEIR0gHCAddCEeIBsgHmohHyAHEOsNISAgICAfNgIAIAYoAhwhIUEgISIgBiAiaiEjICMkACAhDwv7AQEbfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRDPDSAFENcNIQYgBSgCACEHIAUoAgQhCCAEKAIIIQlBBCEKIAkgCmohCyAGIAcgCCALEOwNIAQoAgghDEEEIQ0gDCANaiEOIAUgDhDtDUEEIQ8gBSAPaiEQIAQoAgghEUEIIRIgESASaiETIBAgExDtDSAFEOYMIRQgBCgCCCEVIBUQ6w0hFiAUIBYQ7Q0gBCgCCCEXIBcoAgQhGCAEKAIIIRkgGSAYNgIAIAUQ2w0hGiAFIBoQ7g0gBRDvDUEQIRsgBCAbaiEcIBwkAA8LlQEBEX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCCCADKAIIIQQgAyAENgIMIAQQ8A0gBCgCACEFQQAhBiAFIQcgBiEIIAcgCEchCUEBIQogCSAKcSELAkAgC0UNACAEEOkNIQwgBCgCACENIAQQ8Q0hDiAMIA0gDhDyDQsgAygCDCEPQRAhECADIBBqIREgESQAIA8PCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwt4AQt/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhQgBiABNgIQIAYgAjYCDCAGIAM2AgggBigCFCEHIAYoAhAhCCAGKAIMIQkgCRCxAiEKIAYoAgghCyALELECIQwgByAIIAogDBDjDUEgIQ0gBiANaiEOIA4kAA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOUNIQVBECEGIAMgBmohByAHJAAgBQ8LcAEKfyMAIQRBECEFIAQgBWshBiAGJAAgBiAANgIMIAYgATYCCCAGIAI2AgQgBiADNgIAIAYoAgghByAGKAIEIQggCBCxAiEJIAYoAgAhCiAKELECIQsgByAJIAsQ5A0aQRAhDCAGIAxqIQ0gDSQADwvGAQEWfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIIIAUgATYCBCAFIAI2AgAgBSgCCCEGIAUgBjYCDEEQIQcgBiAHaiEIIAYhCQNAIAkhCiAKELcGGkEIIQsgCiALaiEMIAwhDSAIIQ4gDSAORiEPQQEhECAPIBBxIREgDCEJIBFFDQALIAUoAgQhEiAGIBIQ6AEaIAUoAgAhE0EIIRQgBiAUaiEVIBUgExDoARogBSgCDCEWQRAhFyAFIBdqIRggGCQAIBYPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwuEAQERfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPMNIQUgBRD0DSEGIAMgBjYCCBB0IQcgAyAHNgIEQQghCCADIAhqIQkgCSEKQQQhCyADIAtqIQwgDCENIAogDRB1IQ4gDigCACEPQRAhECADIBBqIREgESQAIA8PCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD1DSEFQRAhBiADIAZqIQcgByQAIAUPC3sBDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxAzIQggBiAIENINGkEEIQkgBiAJaiEKIAUoAgQhCyALEP0NIQwgCiAMEP4NGkEQIQ0gBSANaiEOIA4kACAGDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhCADiEHQRAhCCADIAhqIQkgCSQAIAcPC1QBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBkEAIQcgBSAGIAcQ/w0hCEEQIQkgBCAJaiEKIAokACAIDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhCBDiEHQRAhCCADIAhqIQkgCSQAIAcPC+kBARp/IwAhBEEQIQUgBCAFayEGIAYkACAGIAA2AgwgBiABNgIIIAYgAjYCBCAGIAM2AgACQANAIAYoAgQhByAGKAIIIQggByEJIAghCiAJIApHIQtBASEMIAsgDHEhDSANRQ0BIAYoAgwhDiAGKAIAIQ8gDygCACEQQXAhESAQIBFqIRIgEhDYDSETIAYoAgQhFEFwIRUgFCAVaiEWIAYgFjYCBCAWEIUOIRcgDiATIBcQhg4gBigCACEYIBgoAgAhGUFwIRogGSAaaiEbIBggGzYCAAwACwALQRAhHCAGIBxqIR0gHSQADwufAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCHDiEGIAYoAgAhByAEIAc2AgQgBCgCCCEIIAgQhw4hCSAJKAIAIQogBCgCDCELIAsgCjYCAEEEIQwgBCAMaiENIA0hDiAOEIcOIQ8gDygCACEQIAQoAgghESARIBA2AgBBECESIAQgEmohEyATJAAPC7ABARZ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEIMOIQYgBRCDDiEHIAUQ5w0hCEEEIQkgCCAJdCEKIAcgCmohCyAFEIMOIQwgBRDnDSENQQQhDiANIA50IQ8gDCAPaiEQIAUQgw4hESAEKAIIIRJBBCETIBIgE3QhFCARIBRqIRUgBSAGIAsgECAVEIQOQRAhFiAEIBZqIRcgFyQADwsbAQN/IwAhAUEQIQIgASACayEDIAMgADYCDA8LQwEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCAFEIwOQRAhBiADIAZqIQcgByQADwteAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQjg4hBSAFKAIAIQYgBCgCACEHIAYgB2shCEEEIQkgCCAJdSEKQRAhCyADIAtqIQwgDCQAIAoPC1oBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBSgCBCEIIAYgByAIEI0OQRAhCSAFIAlqIQogCiQADwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhD3DSEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD2DSEFQRAhBiADIAZqIQcgByQAIAUPC14BDH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD6DSEFIAUoAgAhBiAEKAIAIQcgBiAHayEIQQQhCSAIIAl1IQpBECELIAMgC2ohDCAMJAAgCg8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEEPgNIQVBECEGIAMgBmohByAHJAAgBQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPkNIQVBECEGIAMgBmohByAHJAAgBQ8LJQEEfyMAIQFBECECIAEgAmshAyADIAA2AgxB/////wAhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQ+w0hB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ/A0hBUEQIQYgAyAGaiEHIAckACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC1MBCH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEP0NIQcgBSAHNgIAQRAhCCAEIAhqIQkgCSQAIAUPC58BARN/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAYQ+A0hCCAHIQkgCCEKIAkgCkshC0EBIQwgCyAMcSENAkAgDUUNAEHNCiEOIA4QgwEACyAFKAIIIQ9BBCEQIA8gEHQhEUEEIRIgESASEIQBIRNBECEUIAUgFGohFSAVJAAgEw8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEEIQUgBCAFaiEGIAYQgg4hB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ4A0hBUEQIQYgAyAGaiEHIAckACAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC0UBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAUQ2A0hBkEQIQcgAyAHaiEIIAgkACAGDws3AQN/IwAhBUEgIQYgBSAGayEHIAcgADYCHCAHIAE2AhggByACNgIUIAcgAzYCECAHIAQ2AgwPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCKDiEFQRAhBiADIAZqIQcgByQAIAUPC2EBCX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCHCAFIAE2AhggBSACNgIUIAUoAhwhBiAFKAIYIQcgBSgCFCEIIAgQiA4hCSAGIAcgCRCJDkEgIQogBSAKaiELIAskAA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhQgBSABNgIQIAUgAjYCDCAFKAIUIQYgBSgCECEHIAUoAgwhCCAIEIgOIQkgBiAHIAkQiw5BICEKIAUgCmohCyALJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtZAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHIAcQiA4hCCAGIAgQswwaQRAhCSAFIAlqIQogCiQADwtKAQd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEI8OQRAhByAEIAdqIQggCCQADwthAQp/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHQQQhCCAHIAh0IQlBBCEKIAYgCSAKEElBECELIAUgC2ohDCAMJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBDCEFIAQgBWohBiAGEJMOIQdBECEIIAMgCGohCSAJJAAgBw8LoAEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCBCEFAkADQCAEKAIAIQYgBSgCCCEHIAYhCCAHIQkgCCAJRyEKQQEhCyAKIAtxIQwgDEUNASAFEOkNIQ0gBSgCCCEOQXAhDyAOIA9qIRAgBSAQNgIIIBAQ2A0hESANIBEQkA4MAAsAC0EQIRIgBCASaiETIBMkAA8LSgEHfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGIAUgBhCRDkEgIQcgBCAHaiEIIAgkAA8LSgEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBCgCACEGIAUgBhCSDkEQIQcgBCAHaiEIIAgkAA8LIgEDfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ/A0hBUEQIQYgAyAGaiEHIAckACAFDwuFAQEPfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEDEaQQAhBSAEIAU2AgBBACEGIAQgBjYCBEEIIQcgBCAHaiEIQQAhCSADIAk2AghBCCEKIAMgCmohCyALIQwgAyENIAggDCANEJcOGkEQIQ4gAyAOaiEPIA8kACAEDwuFAQEPfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEDEaQQAhBSAEIAU2AgBBACEGIAQgBjYCBEEIIQcgBCAHaiEIQQAhCSADIAk2AghBCCEKIAMgCmohCyALIQwgAyENIAggDCANEJsOGkEQIQ4gAyAOaiEPIA8kACAEDwuFAQEPfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEDEaQQAhBSAEIAU2AgBBACEGIAQgBjYCBEEIIQcgBCAHaiEIQQAhCSADIAk2AghBCCEKIAMgCmohCyALIQwgAyENIAggDCANEJ8OGkEQIQ4gAyAOaiEPIA8kACAEDwtsAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQMyEIIAYgCBCYDhogBSgCBCEJIAkQNRogBhCZDhpBECEKIAUgCmohCyALJAAgBg8LVQEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQMxpBACEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQmg4aQRAhBSADIAVqIQYgBiQAIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtsAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQMyEIIAYgCBCcDhogBSgCBCEJIAkQNRogBhCdDhpBECEKIAUgCmohCyALJAAgBg8LVQEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQMxpBACEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQng4aQRAhBSADIAVqIQYgBiQAIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtsAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQMyEIIAYgCBCgDhogBSgCBCEJIAkQNRogBhChDhpBECEKIAUgCmohCyALJAAgBg8LVQEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQMxpBACEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQog4aQRAhBSADIAVqIQYgBiQAIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwuFAQEPfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEDEaQQAhBSAEIAU2AgBBACEGIAQgBjYCBEEIIQcgBCAHaiEIQQAhCSADIAk2AghBCCEKIAMgCmohCyALIQwgAyENIAggDCANEKoOGkEQIQ4gAyAOaiEPIA8kACAEDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQrg4aQRAhBSADIAVqIQYgBiQAIAQPC1MBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCzDhpBDCEFIAQgBWohBkEAIQcgBiAHOwEAQRAhCCADIAhqIQkgCSQAIAQPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBC0DhpBECEFIAMgBWohBiAGJAAgBA8LUgEJfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCgCDCEFIAEvAAAhBiAFIAY7AABBAiEHIAUgB2ohCCABIAdqIQkgCS0AACEKIAggCjoAACAFDwuaAQERfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQVBBCEGIAUgBmohByAHEMIOGkEIIQggBSAIaiEJQQAhCiAEIAo2AgQgBCgCCCELQQQhDCAEIAxqIQ0gDSEOIAkgDiALEMMOGiAFEMQOIQ8gBRDFDiEQIBAgDzYCAEEQIREgBCARaiESIBIkACAFDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQyw4aQRAhBSADIAVqIQYgBiQAIAQPC2wBCX8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxAzIQggBiAIEKsOGiAFKAIEIQkgCRA1GiAGEKwOGkEQIQogBSAKaiELIAskACAGDwtVAQh/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBhAzGkEAIQcgBSAHNgIAQRAhCCAEIAhqIQkgCSQAIAUPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBCtDhpBECEFIAMgBWohBiAGJAAgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC4UBAQ9/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQMRpBACEFIAQgBTYCAEEAIQYgBCAGNgIEQQghByAEIAdqIQhBACEJIAMgCTYCCEEIIQogAyAKaiELIAshDCADIQ0gCCAMIA0Qrw4aQRAhDiADIA5qIQ8gDyQAIAQPC2wBCX8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxAzIQggBiAIELAOGiAFKAIEIQkgCRA1GiAGELEOGkEQIQogBSAKaiELIAskACAGDwtVAQh/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBhAzGkEAIQcgBSAHNgIAQRAhCCAEIAhqIQkgCSQAIAUPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBCyDhpBECEFIAMgBWohBiAGJAAgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBC1DhpBECEFIAMgBWohBiAGJAAgBA8LcAENfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEELoOGkEIIQUgBCAFaiEGQQAhByADIAc2AghBCCEIIAMgCGohCSAJIQogAyELIAYgCiALELsOGkEQIQwgAyAMaiENIA0kACAEDwuFAQEPfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEDEaQQAhBSAEIAU2AgBBACEGIAQgBjYCBEEIIQcgBCAHaiEIQQAhCSADIAk2AghBCCEKIAMgCmohCyALIQwgAyENIAggDCANELYOGkEQIQ4gAyAOaiEPIA8kACAEDwtsAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQMyEIIAYgCBC3DhogBSgCBCEJIAkQNRogBhC4DhpBECEKIAUgCmohCyALJAAgBg8LVQEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQMxpBACEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQuQ4aQRAhBSADIAVqIQYgBiQAIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQp/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQvA4hBSAFEL0OIQYgBCAGNgIAIAQQvA4hByAHEL0OIQggBCAINgIEQRAhCSADIAlqIQogCiQAIAQPC20BCX8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxD2AyEIIAYgCBDzBRogBSgCBCEJIAkQNRogBhC+DhpBECEKIAUgCmohCyALJAAgBg8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEL8OIQVBECEGIAMgBmohByAHJAAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBDBDhpBECEFIAMgBWohBiAGJAAgBA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMAOIQVBECEGIAMgBmohByAHJAAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtDAQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ8QUaIAQQxg4aQRAhBSADIAVqIQYgBiQAIAQPC3wBDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxD2AyEIIAYgCBDzBRpBBCEJIAYgCWohCiAFKAIEIQsgCxDHDiEMIAogDBDIDhpBECENIAUgDWohDiAOJAAgBg8LUAEKfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEEIQUgBCAFaiEGIAYQyQ4hByAHEPcFIQhBECEJIAMgCWohCiAKJAAgCA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBDKDhpBECEFIAMgBWohBiAGJAAgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC3oBDX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEMcOIQcgBy8AACEIIAUgCDsAAEECIQkgBSAJaiEKIAcgCWohCyALLQAAIQwgCiAMOgAAQRAhDSAEIA1qIQ4gDiQAIAUPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD7BSEFQRAhBiADIAZqIQcgByQAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDws9AQZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQzA4aQRAhBSADIAVqIQYgBiQAIAQPC+kBAR9/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgggAygCCCEEIAMgBDYCDEGUCiEFIAQgBWohBiAEIQcDQCAHIQggCBDNDhpBhAIhCSAIIAlqIQogCiELIAYhDCALIAxGIQ1BASEOIA0gDnEhDyAKIQcgD0UNAAtBlAohECAEIBBqIRFBlAohEiARIBJqIRMgESEUA0AgFCEVIBUQzQ4aQYQCIRYgFSAWaiEXIBchGCATIRkgGCAZRiEaQQEhGyAaIBtxIRwgFyEUIBxFDQALIAMoAgwhHUEQIR4gAyAeaiEfIB8kACAdDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LOQEFfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGNgIAIAUPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBQ8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQ1g4hB0EQIQggAyAIaiEJIAkkACAHDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LswEBFX8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFQQghBiAEIAZqIQcgByEIQQEhCSAIIAUgCRDXDhogBRDYDiEKIAQoAgwhCyALENkOIQwgBCgCGCENIA0Q2g4hDiAKIAwgDhDbDiAEKAIMIQ9BHCEQIA8gEGohESAEIBE2AgxBCCESIAQgEmohEyATIRQgFBDcDhpBICEVIAQgFWohFiAWJAAPC90BARh/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAFENgOIQYgBCAGNgIUIAUQ/QwhB0EBIQggByAIaiEJIAUgCRDdDiEKIAUQ/QwhCyAEKAIUIQwgBCENIA0gCiALIAwQ3g4aIAQoAhQhDiAEKAIIIQ8gDxDZDiEQIAQoAhghESARENoOIRIgDiAQIBIQ2w4gBCgCCCETQRwhFCATIBRqIRUgBCAVNgIIIAQhFiAFIBYQ3w4gBCEXIBcQ4A4aQSAhGCAEIBhqIRkgGSQADwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOEOIQVBECEGIAMgBmohByAHJAAgBQ8LgwEBDX8jACEDQRAhBCADIARrIQUgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAGIAc2AgAgBSgCCCEIIAgoAgQhCSAGIAk2AgQgBSgCCCEKIAooAgQhCyAFKAIEIQxBHCENIAwgDWwhDiALIA5qIQ8gBiAPNgIIIAYPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEOMOIQdBECEIIAMgCGohCSAJJAAgBw8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhwgBSABNgIYIAUgAjYCFCAFKAIcIQYgBSgCGCEHIAUoAhQhCCAIENoOIQkgBiAHIAkQ4g5BICEKIAUgCmohCyALJAAPCzkBBn8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCgCACEGIAYgBTYCBCAEDwuyAgElfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIYIAQgATYCFCAEKAIYIQUgBRDmDiEGIAQgBjYCECAEKAIUIQcgBCgCECEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AIAUQtRoACyAFEOcOIQ4gBCAONgIMIAQoAgwhDyAEKAIQIRBBASERIBAgEXYhEiAPIRMgEiEUIBMgFE8hFUEBIRYgFSAWcSEXAkACQCAXRQ0AIAQoAhAhGCAEIBg2AhwMAQsgBCgCDCEZQQEhGiAZIBp0IRsgBCAbNgIIQQghHCAEIBxqIR0gHSEeQRQhHyAEIB9qISAgICEhIB4gIRBnISIgIigCACEjIAQgIzYCHAsgBCgCHCEkQSAhJSAEICVqISYgJiQAICQPC64CASB/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhggBiABNgIUIAYgAjYCECAGIAM2AgwgBigCGCEHIAYgBzYCHEEMIQggByAIaiEJQQAhCiAGIAo2AgggBigCDCELQQghDCAGIAxqIQ0gDSEOIAkgDiALEOgOGiAGKAIUIQ8CQAJAIA9FDQAgBxDpDiEQIAYoAhQhESAQIBEQ6g4hEiASIRMMAQtBACEUIBQhEwsgEyEVIAcgFTYCACAHKAIAIRYgBigCECEXQRwhGCAXIBhsIRkgFiAZaiEaIAcgGjYCCCAHIBo2AgQgBygCACEbIAYoAhQhHEEcIR0gHCAdbCEeIBsgHmohHyAHEOsOISAgICAfNgIAIAYoAhwhIUEgISIgBiAiaiEjICMkACAhDwv7AQEbfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRDsDiAFENgOIQYgBSgCACEHIAUoAgQhCCAEKAIIIQlBBCEKIAkgCmohCyAGIAcgCCALEO0OIAQoAgghDEEEIQ0gDCANaiEOIAUgDhDuDkEEIQ8gBSAPaiEQIAQoAgghEUEIIRIgESASaiETIBAgExDuDiAFENAOIRQgBCgCCCEVIBUQ6w4hFiAUIBYQ7g4gBCgCCCEXIBcoAgQhGCAEKAIIIRkgGSAYNgIAIAUQ/QwhGiAFIBoQ7w4gBRDwDkEQIRsgBCAbaiEcIBwkAA8LlQEBEX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCCCADKAIIIQQgAyAENgIMIAQQ8Q4gBCgCACEFQQAhBiAFIQcgBiEIIAcgCEchCUEBIQogCSAKcSELAkAgC0UNACAEEOkOIQwgBCgCACENIAQQ8g4hDiAMIA0gDhDzDgsgAygCDCEPQRAhECADIBBqIREgESQAIA8PCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhQgBSABNgIQIAUgAjYCDCAFKAIUIQYgBSgCECEHIAUoAgwhCCAIENoOIQkgBiAHIAkQ5A5BICEKIAUgCmohCyALJAAPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDlDiEFQRAhBiADIAZqIQcgByQAIAUPC8EBAhJ/A34jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQcgBxDaDiEIIAgpAgAhFSAGIBU3AgBBGCEJIAYgCWohCiAIIAlqIQsgCygCACEMIAogDDYCAEEQIQ0gBiANaiEOIAggDWohDyAPKQIAIRYgDiAWNwIAQQghECAGIBBqIREgCCAQaiESIBIpAgAhFyARIBc3AgBBECETIAUgE2ohFCAUJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwuEAQERfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPQOIQUgBRD1DiEGIAMgBjYCCBB0IQcgAyAHNgIEQQghCCADIAhqIQkgCSEKQQQhCyADIAtqIQwgDCENIAogDRB1IQ4gDigCACEPQRAhECADIBBqIREgESQAIA8PCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD2DiEFQRAhBiADIAZqIQcgByQAIAUPC3sBDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxAzIQggBiAIEKsOGkEEIQkgBiAJaiEKIAUoAgQhCyALEP4OIQwgCiAMEP8OGkEQIQ0gBSANaiEOIA4kACAGDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhCBDyEHQRAhCCADIAhqIQkgCSQAIAcPC1QBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBkEAIQcgBSAGIAcQgA8hCEEQIQkgBCAJaiEKIAokACAIDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhCCDyEHQRAhCCADIAhqIQkgCSQAIAcPC6kBARZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQhA8hBSAEEIQPIQYgBBDnDiEHQRwhCCAHIAhsIQkgBiAJaiEKIAQQhA8hCyAEEP0MIQxBHCENIAwgDWwhDiALIA5qIQ8gBBCEDyEQIAQQ5w4hEUEcIRIgESASbCETIBAgE2ohFCAEIAUgCiAPIBQQhQ9BECEVIAMgFWohFiAWJAAPC4ECAR9/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhwgBiABNgIYIAYgAjYCFCAGIAM2AhAgBigCFCEHIAYoAhghCCAHIAhrIQlBHCEKIAkgCm0hCyAGIAs2AgwgBigCDCEMIAYoAhAhDSANKAIAIQ5BACEPIA8gDGshEEEcIREgECARbCESIA4gEmohEyANIBM2AgAgBigCDCEUQQAhFSAUIRYgFSEXIBYgF0ohGEEBIRkgGCAZcSEaAkAgGkUNACAGKAIQIRsgGygCACEcIAYoAhghHSAGKAIMIR5BHCEfIB4gH2whICAcIB0gIBDjGhoLQSAhISAGICFqISIgIiQADwufAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCGDyEGIAYoAgAhByAEIAc2AgQgBCgCCCEIIAgQhg8hCSAJKAIAIQogBCgCDCELIAsgCjYCAEEEIQwgBCAMaiENIA0hDiAOEIYPIQ8gDygCACEQIAQoAgghESARIBA2AgBBECESIAQgEmohEyATJAAPC7ABARZ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEIQPIQYgBRCEDyEHIAUQ5w4hCEEcIQkgCCAJbCEKIAcgCmohCyAFEIQPIQwgBRDnDiENQRwhDiANIA5sIQ8gDCAPaiEQIAUQhA8hESAEKAIIIRJBHCETIBIgE2whFCARIBRqIRUgBSAGIAsgECAVEIUPQRAhFiAEIBZqIRcgFyQADwsbAQN/IwAhAUEQIQIgASACayEDIAMgADYCDA8LQwEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCAFEIcPQRAhBiADIAZqIQcgByQADwteAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQiQ8hBSAFKAIAIQYgBCgCACEHIAYgB2shCEEcIQkgCCAJbSEKQRAhCyADIAtqIQwgDCQAIAoPC1oBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBSgCBCEIIAYgByAIEIgPQRAhCSAFIAlqIQogCiQADwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhD4DiEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD3DiEFQRAhBiADIAZqIQcgByQAIAUPC14BDH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD7DiEFIAUoAgAhBiAEKAIAIQcgBiAHayEIQRwhCSAIIAltIQpBECELIAMgC2ohDCAMJAAgCg8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEEPkOIQVBECEGIAMgBmohByAHJAAgBQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPoOIQVBECEGIAMgBmohByAHJAAgBQ8LJQEEfyMAIQFBECECIAEgAmshAyADIAA2AgxByaSSyQAhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQ/A4hB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ/Q4hBUEQIQYgAyAGaiEHIAckACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC1MBCH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEP4OIQcgBSAHNgIAQRAhCCAEIAhqIQkgCSQAIAUPC58BARN/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAYQ+Q4hCCAHIQkgCCEKIAkgCkshC0EBIQwgCyAMcSENAkAgDUUNAEHNCiEOIA4QgwEACyAFKAIIIQ9BHCEQIA8gEGwhEUEEIRIgESASEIQBIRNBECEUIAUgFGohFSAVJAAgEw8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEEIQUgBCAFaiEGIAYQgw8hB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ4Q4hBUEQIQYgAyAGaiEHIAckACAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC0UBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAUQ2Q4hBkEQIQcgAyAHaiEIIAgkACAGDws3AQN/IwAhBUEgIQYgBSAGayEHIAcgADYCHCAHIAE2AhggByACNgIUIAcgAzYCECAHIAQ2AgwPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtKAQd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEIoPQRAhByAEIAdqIQggCCQADwthAQp/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHQRwhCCAHIAhsIQlBBCEKIAYgCSAKEElBECELIAUgC2ohDCAMJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBDCEFIAQgBWohBiAGEI4PIQdBECEIIAMgCGohCSAJJAAgBw8LoAEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCBCEFAkADQCAEKAIAIQYgBSgCCCEHIAYhCCAHIQkgCCAJRyEKQQEhCyAKIAtxIQwgDEUNASAFEOkOIQ0gBSgCCCEOQWQhDyAOIA9qIRAgBSAQNgIIIBAQ2Q4hESANIBEQiw8MAAsAC0EQIRIgBCASaiETIBMkAA8LSgEHfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGIAUgBhCMD0EgIQcgBCAHaiEIIAgkAA8LSgEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBCgCACEGIAUgBhCND0EQIQcgBCAHaiEIIAgkAA8LIgEDfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ/Q4hBUEQIQYgAyAGaiEHIAckACAFDwuRAQESfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIcIAUgATYCGCAFKAIYIQZBCCEHIAUgB2ohCCAIIQkgCSACEK4JGkEQIQogBSAKaiELIAshDEEIIQ0gBSANaiEOIA4hDyAMIAYgDxCQD0EQIRAgBSAQaiERIBEhEiAAIBIQ4gEaQSAhEyAFIBNqIRQgFCQADwtdAQp/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUoAgghBiACELIJIQdBAyEIIAcgCHQhCSAGIAlqIQogACAKEOIBGkEQIQsgBSALaiEMIAwkAA8LtAEBFH8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAQoAhghBiAFEPoPIQcgBiEIIAchCSAIIAlLIQpBASELIAogC3EhDAJAIAxFDQAgBRD7DyENIAQgDTYCFCAEKAIYIQ4gBRD8DyEPIAQoAhQhECAEIREgESAOIA8gEBD9DxogBCESIAUgEhD+DyAEIRMgExD/DxoLQSAhFCAEIBRqIRUgFSQADwu0AQEUfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGIAUQgBAhByAGIQggByEJIAggCUshCkEBIQsgCiALcSEMAkAgDEUNACAFEIEQIQ0gBCANNgIUIAQoAhghDiAFEIIQIQ8gBCgCFCEQIAQhESARIA4gDyAQEIMQGiAEIRIgBSASEIQQIAQhEyATEIUQGgtBICEUIAQgFGohFSAVJAAPC7QBARR/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAEKAIYIQYgBRCGECEHIAYhCCAHIQkgCCAJSyEKQQEhCyAKIAtxIQwCQCAMRQ0AIAUQhxAhDSAEIA02AhQgBCgCGCEOIAUQmwwhDyAEKAIUIRAgBCERIBEgDiAPIBAQiBAaIAQhEiAFIBIQiRAgBCETIBMQihAaC0EgIRQgBCAUaiEVIBUkAA8LVQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEKAIAIQUgBCAFEKkPIQYgAyAGNgIIIAMoAgghB0EQIQggAyAIaiEJIAkkACAHDwtfAQt/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgggBSABNgIAQQghBiAFIAZqIQcgByEIIAgQqA8hCSAFIQogChCoDyELIAkgCyACEIMRQRAhDCAFIAxqIQ0gDSQADwu0AQEXfyMAIQJBMCEDIAIgA2shBCAEJAAgBCAANgIgIAQgATYCGEEQIQUgBCAFaiEGIAYhB0EgIQggBCAIaiEJIAkhCiAKKAIAIQsgByALNgIAQQghDCAEIAxqIQ0gDSEOQRghDyAEIA9qIRAgECERIBEoAgAhEiAOIBI2AgAgBCgCECETIAQoAgghFCATIBQQiREhFSAEIBU2AiggBCgCKCEWQTAhFyAEIBdqIRggGCQAIBYPC1oBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxCoDyEIIAYgCDYCAEEQIQkgBSAJaiEKIAokACAGDwvrAgEvfyMAIQNBMCEEIAMgBGshBSAFJAAgBSABNgIgIAUgAjYCGCAFIAA2AhQgBSgCFCEGIAYoAgAhByAGEJQPIQggBSAINgIIQSAhCSAFIAlqIQogCiELQQghDCAFIAxqIQ0gDSEOIAsgDhCEESEPQRwhECAPIBBsIREgByARaiESIAUgEjYCEEEgIRMgBSATaiEUIBQhFUEYIRYgBSAWaiEXIBchGCAVIBgQsw8hGUEBIRogGSAacSEbAkAgG0UNACAFKAIQIRxBGCEdIAUgHWohHiAeIR9BICEgIAUgIGohISAhISIgHyAiEIURISNBHCEkICMgJGwhJSAcICVqISYgBigCBCEnIAUoAhAhKCAmICcgKBCGESEpIAYgKRCHESAFKAIQISpBZCErICogK2ohLCAGICwQiBELIAUoAhAhLSAGIC0QqQ8hLiAFIC42AiggBSgCKCEvQTAhMCAFIDBqITEgMSQAIC8PC0sBCX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCACEGIAQoAgghB0EcIQggByAIbCEJIAYgCWohCiAKDws5AQV/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAY2AhAgBQ8LTAELfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAEKAIEIQYgBSEHIAYhCCAHIAhGIQlBASEKIAkgCnEhCyALDwuHAQEQfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGIAYQpxEhByAEKAIYIQggCBCoESEJQQghCiAEIApqIQsgCyEMIAwgByAJEKkRGkEIIQ0gBCANaiEOIA4hDyAFIA8QqhFBICEQIAQgEGohESARJAAPCz0BB38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQVBHCEGIAUgBmohByAEIAc2AgAgBA8LZAEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhCDDSEHQX8hCCAHIAhzIQlBASEKIAkgCnEhC0EQIQwgBCAMaiENIA0kACALDwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgAhBSAFEKsRIQZBECEHIAMgB2ohCCAIJAAgBg8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC0UBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAUQrBEhBkEQIQcgAyAHaiEIIAgkACAGDwttAQ5/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFENQOIQYgBCgCCCEHIAcQ1A4hCCAGIQkgCCEKIAkgCkYhC0EBIQwgCyAMcSENQRAhDiAEIA5qIQ8gDyQAIA0PC2ABDH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCgDyEFIAMoAgwhBiAGEMAPIQcgBSAHEKIPIQhBASEJIAggCXEhCkEQIQsgAyALaiEMIAwkACAKDwvwAgExfyMAIQJBwAAhAyACIANrIQQgBCQAIAQgADYCPCAEIAE2AjggBCgCPCEFQQQhBiAFIAZqIQcgBxCUDyEIIAQgCDYCKEEwIQkgBCAJaiEKIAohC0EoIQwgBCAMaiENIA0hDkEAIQ8gCyAOIA8Qlw8aQQQhECAFIBBqIREgERCUDyESIAQgEjYCGEEgIRMgBCATaiEUIBQhFUEYIRYgBCAWaiEXIBchGEEAIRkgFSAYIBkQlw8aQSAhGiAEIBpqIRsgGyEcIBwQnQ8aQTAhHSAEIB1qIR4gHiEfIB8Qhg0hIEEwISEgBCAhaiEiICIhIyAjEIYNISRBICElIAQgJWohJiAmIScgJxCGDSEoQcAAISkgBSApaiEqICoQtA8hKyAEICs2AhAgBCgCOCEsIAQoAhAhLSAFICAgJCAoIC0gLBC5DyEuIAQgLjYCCEEQIS8gBSAvaiEwIDAQnQ8aQcAAITEgBCAxaiEyIDIkAA8LugUBXn8jACECQdABIQMgAiADayEEIAQkACAEIAA2AswBIAQgATYCyAEgBCgCzAEhBUEEIQYgBSAGaiEHIAcQlA8hCCAEIAg2ArgBQcABIQkgBCAJaiEKIAohC0G4ASEMIAQgDGohDSANIQ5BACEPIAsgDiAPEJcPGkEEIRAgBSAQaiERIBEQlA8hEiAEIBI2AqgBQbABIRMgBCATaiEUIBQhFUGoASEWIAQgFmohFyAXIRhBACEZIBUgGCAZEJcPGkGwASEaIAQgGmohGyAbIRwgHBCdDxoCQANAQRAhHSAFIB1qIR5BsAEhHyAEIB9qISAgICEhICEgHhCzDyEiQQEhIyAiICNxISQgJEUNAUHAASElIAQgJWohJiAmIScgJxCGDSEoQbABISkgBCApaiEqICohKyArEIYNISxB8AAhLSAEIC1qIS4gLiEvIC8gKCAsEK0RGiAEKALIASEwQcABITEgBCAxaiEyIDIhMyAzEIYNITRBsAEhNSAEIDVqITYgNiE3IDcQhg0hOEHgACE5IAQgOWohOiA6ITsgOyAwIDQgOBCuESAEKAJgITwgBCA8NgJsQcAAIT0gBSA9aiE+QcAAIT8gBSA/aiFAIEAQtA8hQSAEIEE2AlAgBCgCUCFCQdgAIUMgBCBDaiFEIEQhRSBFIEIQrxEaIAQoAmwhRkEIIUcgBCBHaiFIIEghSSBJIEYQsBEaQRAhSiAEIEpqIUsgSyFMQfAAIU0gBCBNaiFOIE4hT0EIIVAgBCBQaiFRIFEhUiBMIE8gUhCxERogBCgCWCFTQRAhVCAEIFRqIVUgVSFWID4gUyBWELIRIVcgBCBXNgIAQcABIVggBCBYaiFZIFkhWiBaEJ0PGkGwASFbIAQgW2ohXCBcIV0gXRCdDxoMAAsAC0HQASFeIAQgXmohXyBfJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBChEyEFQQEhBiAFIAZxIQdBECEIIAMgCGohCSAJJAAgBw8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC1wBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCACEFQQghBiAEIAZqIQcgByEIIAggBRCaERogBCgCCCEJQRAhCiAEIApqIQsgCyQAIAkPC4ABAQ9/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgQhBUEIIQYgBCAGaiEHIAchCCAFKAIAIQkgCCAJNgIAIAQoAgAhCkEIIQsgBCALaiEMIAwhDSANIAoQohMaIAQoAgghDkEQIQ8gBCAPaiEQIBAkACAODwu0AQEbfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEENQOIQVBCCEGIAQgBmohByAHENQOIQggBSEJIAghCiAJIApHIQtBASEMQQEhDSALIA1xIQ4gDCEPAkAgDg0AIAQQ1Q4hEEEIIREgBCARaiESIBIQ1Q4hEyAQIRQgEyEVIBQgFUchFiAWIQ8LIA8hF0EBIRggFyAYcSEZQRAhGiADIBpqIRsgGyQAIBkPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCjEyEFQQEhBiAFIAZxIQdBECEIIAMgCGohCSAJJAAgBw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEKQTIQVBECEGIAMgBmohByAHJAAgBQ8LtAEBGX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgAhBiAEKAIIIQcgBxDUDiEIIAYhCSAIIQogCSAKRiELQQAhDEEBIQ0gCyANcSEOIAwhDwJAIA5FDQAgBSgCBCEQIAQoAgghESARENUOIRIgECETIBIhFCATIBRGIRUgFSEPCyAPIRZBASEXIBYgF3EhGEEQIRkgBCAZaiEaIBokACAYDwuuAQETfyMAIQFBICECIAEgAmshAyADJAAgAyAANgIcIAMoAhwhBCAEEN4RIQUgAyAFNgIYIAQQ3xEhBiADIAY2AhBBDCEHIAQgB2ohCEEIIQkgAyAJaiEKIAohCyAILQAAIQwgCyAMOgAAIAMoAhghDSADKAIQIQ4gAy0ACCEPIAMgDzoAB0EHIRAgAyAQaiERIA0gDiAREKUTIAQQphNBICESIAMgEmohEyATJAAPC8QBARh/IwAhAkEwIQMgAiADayEEIAQkACAEIAE2AiAgBCAANgIcIAQoAhwhBUEgIQYgBCAGaiEHIAchCEEIIQkgBCAJaiEKIAohCyAIKAIAIQwgCyAMNgIAIAQoAgghDUEQIQ4gBCAOaiEPIA8hECAQIA0Q2REaIAQoAhAhESAFIBEQpxMhEiAEIBI2AhggBCgCGCETQSghFCAEIBRqIRUgFSEWIBYgExDKERogBCgCKCEXQTAhGCAEIBhqIRkgGSQAIBcPC6ICAhx/Bn4jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYpAgAhHiAFIB43AgBBGCEHIAUgB2ohCCAGIAdqIQkgCSgCACEKIAggCjYCAEEQIQsgBSALaiEMIAYgC2ohDSANKQIAIR8gDCAfNwIAQQghDiAFIA5qIQ8gBiAOaiEQIBApAgAhICAPICA3AgBBHCERIAUgEWohEiAEKAIIIRMgEykCACEhIBIgITcCAEEYIRQgEiAUaiEVIBMgFGohFiAWKAIAIRcgFSAXNgIAQRAhGCASIBhqIRkgEyAYaiEaIBopAgAhIiAZICI3AgBBCCEbIBIgG2ohHCATIBtqIR0gHSkCACEjIBwgIzcCACAFDwt6AQ1/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhQgBCABNgIQIAQoAhQhBSAEKAIQIQYgBSAGEKgTIQcgBCAHNgIIIAQoAgghCEEYIQkgBCAJaiEKIAohCyALIAgQyhEaIAQoAhghDEEgIQ0gBCANaiEOIA4kACAMDwtkAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEJsRIQdBfyEIIAcgCHMhCUEBIQogCSAKcSELQRAhDCAEIAxqIQ0gDSQAIAsPC2oBDH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBDJESEFIAMgBTYCACADKAIAIQZBCCEHIAMgB2ohCCAIIQkgCSAGEMoRGiADKAIIIQpBECELIAMgC2ohDCAMJAAgCg8LWQEKfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhCpEyEHQQEhCCAHIAhxIQlBECEKIAQgCmohCyALJAAgCQ8LPQEGfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEKoTGkEQIQUgAyAFaiEGIAYkACAEDwtMAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQqxMhBSAFELkSIQYgBhCsEyEHQRAhCCADIAhqIQkgCSQAIAcPCy8BBn8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBEEcIQUgBCAFaiEGIAYPC68LAbIBfyMAIQZBkAQhByAGIAdrIQggCCQAIAggBDYCgAQgCCAANgL8AyAIIAE2AvgDIAggAjYC9AMgCCADNgLwAyAIIAU2AuwDIAgoAvwDIQkgCCgC+AMhCiAIKALwAyELQbADIQwgCCAMaiENIA0hDiAOIAogCxCtERogCCgC8AMhDyAIKAL0AyEQQfgCIREgCCARaiESIBIhEyATIA8gEBCtERogCCgC8AMhFCAUEKsPIRVBASEWIBUgFnEhFwJAIBdFDQBB+AIhGCAIIBhqIRkgGSEaIBoQwxEhGyAbEL0PGgsgCCgC7AMhHCAIKAL0AyEdIAgoAvADIR5B8AIhHyAIIB9qISAgICEhICEgHCAdIB4QrhFBwAAhIiAJICJqISNB2AIhJCAIICRqISUgJSEmQYAEIScgCCAnaiEoICghKSApKAIAISogJiAqNgIAIAgoAtgCIStB4AIhLCAIICxqIS0gLSEuIC4gKxCvERogCCgC9AIhL0GQAiEwIAggMGohMSAxITIgMiAvELARGkGYAiEzIAggM2ohNCA0ITVB+AIhNiAIIDZqITcgNyE4QZACITkgCCA5aiE6IDohOyA1IDggOxDEERogCCgC4AIhPEGYAiE9IAggPWohPiA+IT8gIyA8ID8QxREhQCAIIEA2AugCQYAEIUEgCCBBaiFCIEIhQ0HoAiFEIAggRGohRSBFIUYgRigCACFHIEMgRzYCACAIKALwAyFIIEgQqw8hSUEBIUogSSBKcSFLAkAgS0UNACAIKALwAyFMIAgoAvADIU1B2AEhTiAIIE5qIU8gTyFQIFAgTCBNEK0RGkHYASFRIAggUWohUiBSIVMgUxDGESFUIFQQvQ8aQcAAIVUgCSBVaiFWQcABIVcgCCBXaiFYIFghWUGABCFaIAggWmohWyBbIVwgXCgCACFdIFkgXTYCACAIKALAASFeQcgBIV8gCCBfaiFgIGAhYSBhIF4QrxEaQfgAIWIgCCBiaiFjIGMhZEEAIWUgZCBlELARGkGAASFmIAggZmohZyBnIWhB2AEhaSAIIGlqIWogaiFrQfgAIWwgCCBsaiFtIG0hbiBoIGsgbhDEERogCCgCyAEhb0GAASFwIAggcGohcSBxIXIgViBvIHIQxREhcyAIIHM2AtABQYAEIXQgCCB0aiF1IHUhdkHQASF3IAggd2oheCB4IXkgeSgCACF6IHYgejYCAEEUIXsgCSB7aiF8IAgoAvADIX0gfRDADyF+QegAIX8gCCB/aiGAASCAASGBAUGABCGCASAIIIIBaiGDASCDASGEASCBASB+IIQBEMcRQegAIYUBIAgghQFqIYYBIIYBIYcBIHwghwEQyBELQcAAIYgBIAkgiAFqIYkBQdAAIYoBIAggigFqIYsBIIsBIYwBQYAEIY0BIAggjQFqIY4BII4BIY8BII8BKAIAIZABIIwBIJABNgIAIAgoAlAhkQFB2AAhkgEgCCCSAWohkwEgkwEhlAEglAEgkQEQrxEaIAgoAvACIZUBQQghlgEgCCCWAWohlwEglwEhmAEgmAEglQEQsBEaQRAhmQEgCCCZAWohmgEgmgEhmwFBsAMhnAEgCCCcAWohnQEgnQEhngFBCCGfASAIIJ8BaiGgASCgASGhASCbASCeASChARDEERogCCgCWCGiAUEQIaMBIAggowFqIaQBIKQBIaUBIIkBIKIBIKUBEMURIaYBIAggpgE2AmBBgAQhpwEgCCCnAWohqAEgqAEhqQFB4AAhqgEgCCCqAWohqwEgqwEhrAEgrAEoAgAhrQEgqQEgrQE2AgBBiAQhrgEgCCCuAWohrwEgrwEhsAFBgAQhsQEgCCCxAWohsgEgsgEhswEgswEoAgAhtAEgsAEgtAE2AgAgCCgCiAQhtQFBkAQhtgEgCCC2AWohtwEgtwEkACC1AQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC80CASp/IwAhBUHwACEGIAUgBmshByAHJAAgByAENgJoIAcgADYCZCAHIAE2AmAgByACNgJcIAcgAzYCWCAHKAJkIQhBOCEJIAcgCWohCiAKIQsgCxCtExpB0AAhDCAIIAxqIQ0gBygCYCEOIAcoAlwhDyAHKAJYIRBBOCERIAcgEWohEiASIRMgDSAOIA8gECATEK4TIRRBASEVIBQgFXEhFgJAIBZFDQBBJCEXIAggF2ohGEEIIRkgByAZaiEaIBohG0E4IRwgByAcaiEdIB0hHkHoACEfIAcgH2ohICAgISEgGyAeICEQrxMaQQghIiAHICJqISMgIyEkIBggJBCwEyElIAcgJTYCNEHoACEmIAcgJmohJyAnISggKBC3DyEpQTghKiApICpqISsgBygCNCEsICsgLBCxExoLQfAAIS0gByAtaiEuIC4kAA8LagEMfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEEIYSIQUgAyAFNgIAIAMoAgAhBkEIIQcgAyAHaiEIIAghCSAJIAYQyhEaIAMoAgghCkEQIQsgAyALaiEMIAwkACAKDwtiAQt/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBCAGEMsRIAQoAhghB0EgIQggByAIcyEJIAQgCTYCGEEQIQogAyAKaiELIAskACAEDwuQAQERfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIIIQUgBRCyEyEGQQAhByAGIQggByEJIAggCUchCkEBIQsgCiALcSEMAkAgDEUNACAEKAIIIQ0gDRCyEyEOIA4QsxMaIAQoAgghD0EAIRAgDyAQELETGgtBECERIAQgEWohEiASJAAPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBQ8LLwEGfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBg8LrQECEX8DfiMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQZBHCEHIAUgB2ohCCAGKQIAIRMgCCATNwIAQRghCSAIIAlqIQogBiAJaiELIAsoAgAhDCAKIAw2AgBBECENIAggDWohDiAGIA1qIQ8gDykCACEUIA4gFDcCAEEIIRAgCCAQaiERIAYgEGohEiASKQIAIRUgESAVNwIAIAUPC6MIAnV/AnwjACEHQaABIQggByAIayEJIAkkACAJIAE2ApwBIAkgAjYCmAEgCSADNgKUASAJIAQ2ApABIAkgBTYCjAEgCSAGNgKIASAJKAKcASEKIAkoAowBIQsgCSALNgKEASAJKAKIASEMIAkgDDYCgAFBDCENIAogDWohDiAJKAKQASEPIA8Q/BMhfCAJIHw5A2AgCSgCkAEhECAQEPQTIX0gCSB9OQNYQegAIREgCSARaiESIBIhE0HgACEUIAkgFGohFSAVIRZB2AAhFyAJIBdqIRggGCEZIBMgFiAZEKwVGkHoACEaIAkgGmohGyAbIRwgDiAcEK0VQQwhHSAKIB1qIR4gHhCuFSEfIAkgHzYCVCAJKAKEASEgIAkoAlQhISAgICEQ7A8gCSgCgAEhIiAJKAJUISMgIiAjEOwPIAkoApgBISQgCSgClAEhJSAKICQgJRDNESEmQQEhJyAmICdxISggCSAoOgBTIAkoApgBISkgCSgClAEhKiAKICkgKhDOESErQQEhLCArICxxIS0gCSAtOgBSQRghLiAKIC5qIS8gCS0AUyEwIAktAFIhMUE4ITIgCSAyaiEzIDMhNEEBITUgMCA1cSE2QQEhNyAxIDdxITggNCA2IDgQzxEaQTghOSAJIDlqITogOiE7IC8gOxDQEUEYITwgCiA8aiE9ID0Q0REhPiAJID42AjQgCSgCNCE/IAkoApgBIUAgQBDMESFBIAogQRDTESFCID8gQhDUEUEYIUMgCiBDaiFEIAktAFMhRSAJLQBSIUZBGCFHIAkgR2ohSCBIIUlBASFKIEUgSnEhS0EBIUwgRiBMcSFNIEkgSyBNEM8RGkEYIU4gCSBOaiFPIE8hUCBEIFAQ0BFBGCFRIAogUWohUiBSENERIVMgCSBTNgIUIAkoAhQhVCAJKAKUASFVIFUQzBEhViAKIFYQ0xEhVyBUIFcQ1BEgCSgCNCFYIAkoAhQhWSBYIFkQ2g8gCSgCFCFaIAkoAjQhWyBaIFsQ2g8gCSgCFCFcIAkoAlQhXSBcIF0Q7A8gCSgChAEhXiAJKAI0IV8gXiBfEN4PIAkoAjQhYCAJKAKEASFhIGAgYRDcDyAJKAKEASFiIGIQrxUhYyAJKAKAASFkIGMgZBDcDyAJKAKAASFlIAkoAoQBIWYgZhCvFSFnIGUgZxDeDyAJKAKAASFoIGgQrxUhaSAJKAIUIWogaSBqENwPIAkoAhQhayAJKAKAASFsIGwQrxUhbSBrIG0Q3g8gCSgCNCFuIAkgbjYCBCAJKAIUIW8gCSBvNgIAQQghcCAJIHBqIXEgcSFyQQQhcyAJIHNqIXQgdCF1IAkhdiByIHUgdhDVEUEIIXcgCSB3aiF4IHgheSAAIHkQ1hEaQaABIXogCSB6aiF7IHskAA8LOQEFfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGNgIEIAUPC1kBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQsBUhB0EBIQggByAIcSEJQRAhCiAEIApqIQsgCyQAIAkPCz0BBn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDAExpBECEFIAMgBWohBiAGJAAgBA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEENQOIQVBECEGIAMgBmohByAHJAAgBQ8LOQIFfwF8IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCCCEFIAUoAgAhBiAGtyEHIAcPCy0CBH8BfCMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQrAxAhBSAFDws0AgR/AXwjACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIIIQUgBSsDACEGIAYPC5sEAid/IH4jACEEQTAhBSAEIAVrIQYgBiAANgIoIAYgATkDICAGIAI5AxggBiADNgIUQQghByAGIAdqIQggCCEJQSAhCiAGIApqIQsgCyEMIAwpAwAhKyAJICs3AwAgBiENQRghDiAGIA5qIQ8gDyEQIBApAwAhLCANICw3AwAgBikDCCEtQoCAgICAgICAgH8hLiAtIS8gLiEwIC8gMFQhEUEBIRIgESAScSETAkAgE0UNACAGKQMIITFCgICAgICAgICAfyEyIDIgMX0hMyAGIDM3AwgLIAYpAwAhNEKAgICAgICAgIB/ITUgNCE2IDUhNyA2IDdUIRRBASEVIBQgFXEhFgJAIBZFDQAgBikDACE4QoCAgICAgICAgH8hOSA5IDh9ITogBiA6NwMACyAGKQMIITsgBikDACE8IDshPSA8IT4gPSA+ViEXQQEhGCAXIBhxIRkCQAJAIBlFDQAgBikDCCE/IAYpAwAhQCA/IEB9IUEgBigCFCEaIBohGyAbrSFCIEEhQyBCIUQgQyBEWCEcQQAhHUF/IR5BASEfIBwgH3EhICAdIB4gIBshISAGICE2AiwMAQsgBikDACFFIAYpAwghRiBFIEZ9IUcgBigCFCEiICIhIyAjrSFIIEchSSBIIUogSSBKWCEkQQAhJUEBISZBASEnICQgJ3EhKCAlICYgKBshKSAGICk2AiwLIAYoAiwhKiAqDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQwRUhBUEQIQYgAyAGaiEHIAckACAFDwtQAQp/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgAhBSAFEMUUIQZBCCEHIAYgB2ohCEEQIQkgAyAJaiEKIAokACAIDwuuAQETfyMAIQFBICECIAEgAmshAyADJAAgAyAANgIcIAMoAhwhBCAEEMEUIQUgAyAFNgIYIAQQwhQhBiADIAY2AhBBDCEHIAQgB2ohCEEIIQkgAyAJaiEKIAohCyAILwAAIQwgCyAMOwAAIAMoAhghDSADKAIQIQ4gAy8BCCEPIAMgDzsBBkEGIRAgAyAQaiERIA0gDiAREMIVIAQQwxVBICESIAMgEmohEyATJAAPC0ABBn8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYoAgAhByAFIAc2AgAgBQ8LoAIBH38jACECQTAhAyACIANrIQQgBCQAIAQgATYCICAEIAA2AhwgBCgCHCEFIAUQtRQhBiAEIAY2AhggBCgCICEHIAQgBzYCFCAEKAIUIQggCCgCBCEJIAQgCTYCECAEKAIUIQogBCgCFCELIAogCxDEFSAFELwUIQwgDCgCACENQX8hDiANIA5qIQ8gDCAPNgIAIAQoAhQhECAQEMUUIREgBCARNgIMIAQoAhghEiAEKAIMIRNBCCEUIBMgFGohFSAVELgUIRYgEiAWEMUVIAQoAhghFyAEKAIMIRhBASEZIBcgGCAZEOAUIAQoAhAhGkEoIRsgBCAbaiEcIBwhHSAdIBoQqxUaIAQoAighHkEwIR8gBCAfaiEgICAkACAeDwt8AQ1/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQnBIhBSAEIAUQzxUgBBCUEiEGQQAhByAGIAc2AgAgBBDEDiEIIAQQxQ4hCSAJIAg2AgAgBBDEDiEKQQAhCyAKIAs2AgBBECEMIAMgDGohDSANJAAPC1UBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBCgCACEFIAQgBRDQFSEGIAMgBjYCCCADKAIIIQdBECEIIAMgCGohCSAJJAAgBw8LVQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEKAIEIQUgBCAFENAVIQYgAyAGNgIIIAMoAgghB0EQIQggAyAIaiEJIAkkACAHDwtkAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGENEVIQdBfyEIIAcgCHMhCUEBIQogCSAKcSELQRAhDCAEIAxqIQ0gDSQAIAsPC0UBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAUQ0hUhBkEQIQcgAyAHaiEIIAgkACAGDwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgghBSAFEJANIQZBECEHIAMgB2ohCCAIJAAgBg8L9AECG38EfCMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHEKIMIQggCCsDACEeIAUoAgQhCSAJEKIMIQogCisDACEfQYABIQsgBiAeIB8gCxDKDyEMQQAhDSANIQ4CQCAMDQAgBSgCCCEPIA8QowwhECAQKwMAISAgBSgCBCERIBEQowwhEiASKwMAISFBgAEhEyAGICAgISATEMoPIRRBACEVIBQhFiAVIRcgFiAXRiEYIBghDgsgDiEZQQEhGiAZIBpxIRtBECEcIAUgHGohHSAdJAAgGw8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwu0AwEtfyMAIQJBMCEDIAIgA2shBCAEJAAgBCAANgIsIAQgATYCKCAEKAIoIQUgBRCQDSEGIAQgBjYCJCAEKAIoIQcgBxCvFSEIIAgQ7Q8hCSAEIAk2AiACQANAIAQoAiAhCiAEKAIoIQsgCxCvFSEMIAohDSAMIQ4gDSAORyEPQQEhECAPIBBxIREgEUUNASAEKAIgIRIgBCgCJCETIBIgExDsDyAEKAIgIRQgFBDtDyEVIAQgFTYCIAwACwALIAQoAighFiAEIBY2AhwgBCgCKCEXIBcQrxUhGCAEIBg2AhggBCgCHCEZIBkQ0xUhGiAEIBo2AhQgBCgCHCEbIBsQ7Q8hHCAEIBw2AhAgBCgCGCEdIB0Q0xUhHiAEIB42AgwgBCgCGCEfIB8Q7Q8hICAEICA2AgggBCgCECEhICEQrxUhIiAEKAIMISMgIiAjENwPIAQoAgwhJCAEKAIQISUgJRCvFSEmICQgJhDeDyAEKAIUIScgBCgCCCEoICgQrxUhKSAnICkQ3g8gBCgCCCEqICoQrxUhKyAEKAIUISwgKyAsENwPQTAhLSAEIC1qIS4gLiQADwuAAQEPfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQVBCCEGIAQgBmohByAHIQggBSgCACEJIAggCTYCACAEKAIAIQpBCCELIAQgC2ohDCAMIQ0gDSAKEN8PGiAEKAIIIQ5BECEPIAQgD2ohECAQJAAgDg8LNwEFfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGNgIIDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCECEFIAUPCzcBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCDA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgwhBSAFDws3AQV/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAY2AhAPC1IBCX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUoAgAhB0EYIQggBiAIbCEJIAcgCWohCiAFIAo2AgAgBQ8LWgEIfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHENkVIQggBiAINgIAQRAhCSAFIAlqIQogCiQAIAYPC+sCAS9/IwAhA0EwIQQgAyAEayEFIAUkACAFIAE2AiAgBSACNgIYIAUgADYCFCAFKAIUIQYgBigCACEHIAYQ0Q8hCCAFIAg2AghBICEJIAUgCWohCiAKIQtBCCEMIAUgDGohDSANIQ4gCyAOENQVIQ9BGCEQIA8gEGwhESAHIBFqIRIgBSASNgIQQSAhEyAFIBNqIRQgFCEVQRghFiAFIBZqIRcgFyEYIBUgGBCXDCEZQQEhGiAZIBpxIRsCQCAbRQ0AIAUoAhAhHEEYIR0gBSAdaiEeIB4hH0EgISAgBSAgaiEhICEhIiAfICIQ1RUhI0EYISQgIyAkbCElIBwgJWohJiAGKAIEIScgBSgCECEoICYgJyAoENYVISkgBiApENcVIAUoAhAhKkFoISsgKiAraiEsIAYgLBDYFQsgBSgCECEtIAYgLRDQFSEuIAUgLjYCKCAFKAIoIS9BMCEwIAUgMGohMSAxJAAgLw8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDws3AQV/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAY2AgQPCzcBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCEA8LPQEHfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBUEYIQYgBSAGaiEHIAQgBzYCACAEDwtVAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQoAgAhBSAEIAUQ2hUhBiADIAY2AgggAygCCCEHQRAhCCADIAhqIQkgCSQAIAcPC1UBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBCgCBCEFIAQgBRDaFSEGIAMgBjYCCCADKAIIIQdBECEIIAMgCGohCSAJJAAgBw8LZAEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhDbFSEHQX8hCCAHIAhzIQlBASEKIAkgCnEhC0EQIQwgBCAMaiENIA0kACALDwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgAhBSAFENwVIQZBECEHIAMgB2ohCCAIJAAgBg8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAhAhBSAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPCzcBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCBA8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIQIQUgBRCvFSEGQRAhByADIAdqIQggCCQAIAYPCz0BB38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQVBGCEGIAUgBmohByAEIAc2AgAgBA8LWgEIfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHEOMVIQggBiAINgIAQRAhCSAFIAlqIQogCiQAIAYPC+sCAS9/IwAhA0EwIQQgAyAEayEFIAUkACAFIAE2AiAgBSACNgIYIAUgADYCFCAFKAIUIQYgBigCACEHIAYQ5g8hCCAFIAg2AghBICEJIAUgCWohCiAKIQtBCCEMIAUgDGohDSANIQ4gCyAOEN0VIQ9BGCEQIA8gEGwhESAHIBFqIRIgBSASNgIQQSAhEyAFIBNqIRQgFCEVQRghFiAFIBZqIRcgFyEYIBUgGBDeFSEZQQEhGiAZIBpxIRsCQCAbRQ0AIAUoAhAhHEEYIR0gBSAdaiEeIB4hH0EgISAgBSAgaiEhICEhIiAfICIQ3xUhI0EYISQgIyAkbCElIBwgJWohJiAGKAIEIScgBSgCECEoICYgJyAoEOAVISkgBiApEOEVIAUoAhAhKkFoISsgKiAraiEsIAYgLBDiFQsgBSgCECEtIAYgLRDaFSEuIAUgLjYCKCAFKAIoIS9BMCEwIAUgMGohMSAxJAAgLw8LTAELfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAEKAIEIQYgBSEHIAYhCCAHIAhGIQlBASEKIAkgCnEhCyALDwtMAQt/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAQoAgQhBiAFIQcgBiEIIAcgCEYhCUEBIQogCSAKcSELIAsPC1UBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBCgCACEFIAQgBRDkFSEGIAMgBjYCCCADKAIIIQdBECEIIAMgCGohCSAJJAAgBw8LVQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEKAIEIQUgBCAFEOQVIQYgAyAGNgIIIAMoAgghB0EQIQggAyAIaiEJIAkkACAHDwtkAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEOUVIQdBfyEIIAcgCHMhCUEBIQogCSAKcSELQRAhDCAEIAxqIQ0gDSQAIAsPC0UBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAUQ5hUhBkEQIQcgAyAHaiEIIAgkACAGDwtJAQt/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFQQAhBiAFIQcgBiEIIAcgCEYhCUEBIQogCSAKcSELIAsPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBQ8LPQEHfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBUEMIQYgBSAGaiEHIAQgBzYCACAEDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQixAhBUEQIQYgAyAGaiEHIAckACAFDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhCMECEHQRAhCCADIAhqIQkgCSQAIAcPC0QBCX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCgCACEGIAUgBmshB0EMIQggByAIbSEJIAkPC64CASB/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhggBiABNgIUIAYgAjYCECAGIAM2AgwgBigCGCEHIAYgBzYCHEEMIQggByAIaiEJQQAhCiAGIAo2AgggBigCDCELQQghDCAGIAxqIQ0gDSEOIAkgDiALEI0QGiAGKAIUIQ8CQAJAIA9FDQAgBxCOECEQIAYoAhQhESAQIBEQjxAhEiASIRMMAQtBACEUIBQhEwsgEyEVIAcgFTYCACAHKAIAIRYgBigCECEXQQwhGCAXIBhsIRkgFiAZaiEaIAcgGjYCCCAHIBo2AgQgBygCACEbIAYoAhQhHEEMIR0gHCAdbCEeIBsgHmohHyAHEJAQISAgICAfNgIAIAYoAhwhIUEgISIgBiAiaiEjICMkACAhDwv7AQEbfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCRECAFEPsPIQYgBSgCACEHIAUoAgQhCCAEKAIIIQlBBCEKIAkgCmohCyAGIAcgCCALEJIQIAQoAgghDEEEIQ0gDCANaiEOIAUgDhCTEEEEIQ8gBSAPaiEQIAQoAgghEUEIIRIgESASaiETIBAgExCTECAFEJQQIRQgBCgCCCEVIBUQkBAhFiAUIBYQkxAgBCgCCCEXIBcoAgQhGCAEKAIIIRkgGSAYNgIAIAUQ/A8hGiAFIBoQlRAgBRCWEEEQIRsgBCAbaiEcIBwkAA8LlQEBEX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCCCADKAIIIQQgAyAENgIMIAQQlxAgBCgCACEFQQAhBiAFIQcgBiEIIAcgCEchCUEBIQogCSAKcSELAkAgC0UNACAEEI4QIQwgBCgCACENIAQQmBAhDiAMIA0gDhCZEAsgAygCDCEPQRAhECADIBBqIREgESQAIA8PCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCzECEFQRAhBiADIAZqIQcgByQAIAUPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGELQQIQdBECEIIAMgCGohCSAJJAAgBw8LRAEJfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgQhBSAEKAIAIQYgBSAGayEHQRghCCAHIAhtIQkgCQ8LrgIBIH8jACEEQSAhBSAEIAVrIQYgBiQAIAYgADYCGCAGIAE2AhQgBiACNgIQIAYgAzYCDCAGKAIYIQcgBiAHNgIcQQwhCCAHIAhqIQlBACEKIAYgCjYCCCAGKAIMIQtBCCEMIAYgDGohDSANIQ4gCSAOIAsQtRAaIAYoAhQhDwJAAkAgD0UNACAHELYQIRAgBigCFCERIBAgERC3ECESIBIhEwwBC0EAIRQgFCETCyATIRUgByAVNgIAIAcoAgAhFiAGKAIQIRdBGCEYIBcgGGwhGSAWIBlqIRogByAaNgIIIAcgGjYCBCAHKAIAIRsgBigCFCEcQRghHSAcIB1sIR4gGyAeaiEfIAcQuBAhICAgIB82AgAgBigCHCEhQSAhIiAGICJqISMgIyQAICEPC/sBARt/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFELkQIAUQgRAhBiAFKAIAIQcgBSgCBCEIIAQoAgghCUEEIQogCSAKaiELIAYgByAIIAsQuhAgBCgCCCEMQQQhDSAMIA1qIQ4gBSAOELsQQQQhDyAFIA9qIRAgBCgCCCERQQghEiARIBJqIRMgECATELsQIAUQvBAhFCAEKAIIIRUgFRC4ECEWIBQgFhC7ECAEKAIIIRcgFygCBCEYIAQoAgghGSAZIBg2AgAgBRCCECEaIAUgGhC9ECAFEL4QQRAhGyAEIBtqIRwgHCQADwuVAQERfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIIIAMoAgghBCADIAQ2AgwgBBC/ECAEKAIAIQVBACEGIAUhByAGIQggByAIRyEJQQEhCiAJIApxIQsCQCALRQ0AIAQQthAhDCAEKAIAIQ0gBBDAECEOIAwgDSAOEMEQCyADKAIMIQ9BECEQIAMgEGohESARJAAgDw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEENsQIQVBECEGIAMgBmohByAHJAAgBQ8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQ3BAhB0EQIQggAyAIaiEJIAkkACAHDwuuAgEgfyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIYIAYgATYCFCAGIAI2AhAgBiADNgIMIAYoAhghByAGIAc2AhxBDCEIIAcgCGohCUEAIQogBiAKNgIIIAYoAgwhC0EIIQwgBiAMaiENIA0hDiAJIA4gCxDdEBogBigCFCEPAkACQCAPRQ0AIAcQ3hAhECAGKAIUIREgECAREN8QIRIgEiETDAELQQAhFCAUIRMLIBMhFSAHIBU2AgAgBygCACEWIAYoAhAhF0EYIRggFyAYbCEZIBYgGWohGiAHIBo2AgggByAaNgIEIAcoAgAhGyAGKAIUIRxBGCEdIBwgHWwhHiAbIB5qIR8gBxDgECEgICAgHzYCACAGKAIcISFBICEiIAYgImohIyAjJAAgIQ8L+wEBG38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ4RAgBRCHECEGIAUoAgAhByAFKAIEIQggBCgCCCEJQQQhCiAJIApqIQsgBiAHIAggCxDiECAEKAIIIQxBBCENIAwgDWohDiAFIA4Q4xBBBCEPIAUgD2ohECAEKAIIIRFBCCESIBEgEmohEyAQIBMQ4xAgBRDkECEUIAQoAgghFSAVEOAQIRYgFCAWEOMQIAQoAgghFyAXKAIEIRggBCgCCCEZIBkgGDYCACAFEJsMIRogBSAaEOUQIAUQ5hBBECEbIAQgG2ohHCAcJAAPC5UBARF/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgggAygCCCEEIAMgBDYCDCAEEOcQIAQoAgAhBUEAIQYgBSEHIAYhCCAHIAhHIQlBASEKIAkgCnEhCwJAIAtFDQAgBBDeECEMIAQoAgAhDSAEEOgQIQ4gDCANIA4Q6RALIAMoAgwhD0EQIRAgAyAQaiERIBEkACAPDwteAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQmhAhBSAFKAIAIQYgBCgCACEHIAYgB2shCEEMIQkgCCAJbSEKQRAhCyADIAtqIQwgDCQAIAoPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCdECEFQRAhBiADIAZqIQcgByQAIAUPC3sBDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxAzIQggBiAIEJgOGkEEIQkgBiAJaiEKIAUoAgQhCyALEJ4QIQwgCiAMEJ8QGkEQIQ0gBSANaiEOIA4kACAGDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhChECEHQRAhCCADIAhqIQkgCSQAIAcPC1QBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBkEAIQcgBSAGIAcQoBAhCEEQIQkgBCAJaiEKIAokACAIDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhCiECEHQRAhCCADIAhqIQkgCSQAIAcPC6kBARZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQphAhBSAEEKYQIQYgBBD6DyEHQQwhCCAHIAhsIQkgBiAJaiEKIAQQphAhCyAEEPwPIQxBDCENIAwgDWwhDiALIA5qIQ8gBBCmECEQIAQQ+g8hEUEMIRIgESASbCETIBAgE2ohFCAEIAUgCiAPIBQQpxBBECEVIAMgFWohFiAWJAAPC4ECAR9/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhwgBiABNgIYIAYgAjYCFCAGIAM2AhAgBigCFCEHIAYoAhghCCAHIAhrIQlBDCEKIAkgCm0hCyAGIAs2AgwgBigCDCEMIAYoAhAhDSANKAIAIQ5BACEPIA8gDGshEEEMIREgECARbCESIA4gEmohEyANIBM2AgAgBigCDCEUQQAhFSAUIRYgFSEXIBYgF0ohGEEBIRkgGCAZcSEaAkAgGkUNACAGKAIQIRsgGygCACEcIAYoAhghHSAGKAIMIR5BDCEfIB4gH2whICAcIB0gIBDjGhoLQSAhISAGICFqISIgIiQADwufAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCoECEGIAYoAgAhByAEIAc2AgQgBCgCCCEIIAgQqBAhCSAJKAIAIQogBCgCDCELIAsgCjYCAEEEIQwgBCAMaiENIA0hDiAOEKgQIQ8gDygCACEQIAQoAgghESARIBA2AgBBECESIAQgEmohEyATJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEKkQIQdBECEIIAMgCGohCSAJJAAgBw8LsAEBFn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQphAhBiAFEKYQIQcgBRD6DyEIQQwhCSAIIAlsIQogByAKaiELIAUQphAhDCAFEPoPIQ1BDCEOIA0gDmwhDyAMIA9qIRAgBRCmECERIAQoAgghEkEMIRMgEiATbCEUIBEgFGohFSAFIAYgCyAQIBUQpxBBECEWIAQgFmohFyAXJAAPCxsBA38jACEBQRAhAiABIAJrIQMgAyAANgIMDwtDAQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgQhBSAEIAUQqxBBECEGIAMgBmohByAHJAAPC14BDH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCtECEFIAUoAgAhBiAEKAIAIQcgBiAHayEIQQwhCSAIIAltIQpBECELIAMgC2ohDCAMJAAgCg8LWgEIfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAFKAIEIQggBiAHIAgQrBBBECEJIAUgCWohCiAKJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEJsQIQdBECEIIAMgCGohCSAJJAAgBw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEJwQIQVBECEGIAMgBmohByAHJAAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LUwEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQnhAhByAFIAc2AgBBECEIIAQgCGohCSAJJAAgBQ8LnwEBE38jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBhCjECEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AQc0KIQ4gDhCDAQALIAUoAgghD0EMIRAgDyAQbCERQQQhEiARIBIQhAEhE0EQIRQgBSAUaiEVIBUkACATDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQQhBSAEIAVqIQYgBhCkECEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBClECEFQRAhBiADIAZqIQcgByQAIAUPCyUBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMQdWq1aoBIQQgBA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIAIQUgBRCqECEGQRAhByADIAdqIQggCCQAIAYPCzcBA38jACEFQSAhBiAFIAZrIQcgByAANgIcIAcgATYCGCAHIAI2AhQgByADNgIQIAcgBDYCDA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBClECEFQRAhBiADIAZqIQcgByQAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtKAQd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEK4QQRAhByAEIAdqIQggCCQADwthAQp/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHQQwhCCAHIAhsIQlBBCEKIAYgCSAKEElBECELIAUgC2ohDCAMJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBDCEFIAQgBWohBiAGELIQIQdBECEIIAMgCGohCSAJJAAgBw8LoAEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCBCEFAkADQCAEKAIAIQYgBSgCCCEHIAYhCCAHIQkgCCAJRyEKQQEhCyAKIAtxIQwgDEUNASAFEI4QIQ0gBSgCCCEOQXQhDyAOIA9qIRAgBSAQNgIIIBAQqhAhESANIBEQrxAMAAsAC0EQIRIgBCASaiETIBMkAA8LSgEHfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGIAUgBhCwEEEgIQcgBCAHaiEIIAgkAA8LSgEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBCgCACEGIAUgBhCxEEEQIQcgBCAHaiEIIAgkAA8LIgEDfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQnBAhBUEQIQYgAyAGaiEHIAckACAFDwteAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQwhAhBSAFKAIAIQYgBCgCACEHIAYgB2shCEEYIQkgCCAJbSEKQRAhCyADIAtqIQwgDCQAIAoPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDFECEFQRAhBiADIAZqIQcgByQAIAUPC3sBDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxAzIQggBiAIEJwOGkEEIQkgBiAJaiEKIAUoAgQhCyALEMYQIQwgCiAMEMcQGkEQIQ0gBSANaiEOIA4kACAGDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhDJECEHQRAhCCADIAhqIQkgCSQAIAcPC1QBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBkEAIQcgBSAGIAcQyBAhCEEQIQkgBCAJaiEKIAokACAIDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhDKECEHQRAhCCADIAhqIQkgCSQAIAcPC6kBARZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQzhAhBSAEEM4QIQYgBBCAECEHQRghCCAHIAhsIQkgBiAJaiEKIAQQzhAhCyAEEIIQIQxBGCENIAwgDWwhDiALIA5qIQ8gBBDOECEQIAQQgBAhEUEYIRIgESASbCETIBAgE2ohFCAEIAUgCiAPIBQQzxBBECEVIAMgFWohFiAWJAAPC4ECAR9/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhwgBiABNgIYIAYgAjYCFCAGIAM2AhAgBigCFCEHIAYoAhghCCAHIAhrIQlBGCEKIAkgCm0hCyAGIAs2AgwgBigCDCEMIAYoAhAhDSANKAIAIQ5BACEPIA8gDGshEEEYIREgECARbCESIA4gEmohEyANIBM2AgAgBigCDCEUQQAhFSAUIRYgFSEXIBYgF0ohGEEBIRkgGCAZcSEaAkAgGkUNACAGKAIQIRsgGygCACEcIAYoAhghHSAGKAIMIR5BGCEfIB4gH2whICAcIB0gIBDjGhoLQSAhISAGICFqISIgIiQADwufAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRDQECEGIAYoAgAhByAEIAc2AgQgBCgCCCEIIAgQ0BAhCSAJKAIAIQogBCgCDCELIAsgCjYCAEEEIQwgBCAMaiENIA0hDiAOENAQIQ8gDygCACEQIAQoAgghESARIBA2AgBBECESIAQgEmohEyATJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGENEQIQdBECEIIAMgCGohCSAJJAAgBw8LsAEBFn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQzhAhBiAFEM4QIQcgBRCAECEIQRghCSAIIAlsIQogByAKaiELIAUQzhAhDCAFEIAQIQ1BGCEOIA0gDmwhDyAMIA9qIRAgBRDOECERIAQoAgghEkEYIRMgEiATbCEUIBEgFGohFSAFIAYgCyAQIBUQzxBBECEWIAQgFmohFyAXJAAPCxsBA38jACEBQRAhAiABIAJrIQMgAyAANgIMDwtDAQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgQhBSAEIAUQ0xBBECEGIAMgBmohByAHJAAPC14BDH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDVECEFIAUoAgAhBiAEKAIAIQcgBiAHayEIQRghCSAIIAltIQpBECELIAMgC2ohDCAMJAAgCg8LWgEIfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAFKAIEIQggBiAHIAgQ1BBBECEJIAUgCWohCiAKJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEMMQIQdBECEIIAMgCGohCSAJJAAgBw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMQQIQVBECEGIAMgBmohByAHJAAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LUwEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQxhAhByAFIAc2AgBBECEIIAQgCGohCSAJJAAgBQ8LnwEBE38jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBhDLECEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AQc0KIQ4gDhCDAQALIAUoAgghD0EYIRAgDyAQbCERQQghEiARIBIQhAEhE0EQIRQgBSAUaiEVIBUkACATDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQQhBSAEIAVqIQYgBhDMECEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDNECEFQRAhBiADIAZqIQcgByQAIAUPCyUBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMQarVqtUAIQQgBA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIAIQUgBRDSECEGQRAhByADIAdqIQggCCQAIAYPCzcBA38jACEFQSAhBiAFIAZrIQcgByAANgIcIAcgATYCGCAHIAI2AhQgByADNgIQIAcgBDYCDA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDNECEFQRAhBiADIAZqIQcgByQAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtKAQd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGENYQQRAhByAEIAdqIQggCCQADwthAQp/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHQRghCCAHIAhsIQlBCCEKIAYgCSAKEElBECELIAUgC2ohDCAMJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBDCEFIAQgBWohBiAGENoQIQdBECEIIAMgCGohCSAJJAAgBw8LoAEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCBCEFAkADQCAEKAIAIQYgBSgCCCEHIAYhCCAHIQkgCCAJRyEKQQEhCyAKIAtxIQwgDEUNASAFELYQIQ0gBSgCCCEOQWghDyAOIA9qIRAgBSAQNgIIIBAQ0hAhESANIBEQ1xAMAAsAC0EQIRIgBCASaiETIBMkAA8LSgEHfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGIAUgBhDYEEEgIQcgBCAHaiEIIAgkAA8LSgEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBCgCACEGIAUgBhDZEEEQIQcgBCAHaiEIIAgkAA8LIgEDfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQxBAhBUEQIQYgAyAGaiEHIAckACAFDwteAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ6hAhBSAFKAIAIQYgBCgCACEHIAYgB2shCEEYIQkgCCAJbSEKQRAhCyADIAtqIQwgDCQAIAoPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDtECEFQRAhBiADIAZqIQcgByQAIAUPC3sBDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxAzIQggBiAIEKAOGkEEIQkgBiAJaiEKIAUoAgQhCyALEO4QIQwgCiAMEO8QGkEQIQ0gBSANaiEOIA4kACAGDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhDxECEHQRAhCCADIAhqIQkgCSQAIAcPC1QBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBkEAIQcgBSAGIAcQ8BAhCEEQIQkgBCAJaiEKIAokACAIDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhDyECEHQRAhCCADIAhqIQkgCSQAIAcPC6kBARZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ9hAhBSAEEPYQIQYgBBCGECEHQRghCCAHIAhsIQkgBiAJaiEKIAQQ9hAhCyAEEJsMIQxBGCENIAwgDWwhDiALIA5qIQ8gBBD2ECEQIAQQhhAhEUEYIRIgESASbCETIBAgE2ohFCAEIAUgCiAPIBQQ9xBBECEVIAMgFWohFiAWJAAPC4ECAR9/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhwgBiABNgIYIAYgAjYCFCAGIAM2AhAgBigCFCEHIAYoAhghCCAHIAhrIQlBGCEKIAkgCm0hCyAGIAs2AgwgBigCDCEMIAYoAhAhDSANKAIAIQ5BACEPIA8gDGshEEEYIREgECARbCESIA4gEmohEyANIBM2AgAgBigCDCEUQQAhFSAUIRYgFSEXIBYgF0ohGEEBIRkgGCAZcSEaAkAgGkUNACAGKAIQIRsgGygCACEcIAYoAhghHSAGKAIMIR5BGCEfIB4gH2whICAcIB0gIBDjGhoLQSAhISAGICFqISIgIiQADwufAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRD4ECEGIAYoAgAhByAEIAc2AgQgBCgCCCEIIAgQ+BAhCSAJKAIAIQogBCgCDCELIAsgCjYCAEEEIQwgBCAMaiENIA0hDiAOEPgQIQ8gDygCACEQIAQoAgghESARIBA2AgBBECESIAQgEmohEyATJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEPkQIQdBECEIIAMgCGohCSAJJAAgBw8LsAEBFn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ9hAhBiAFEPYQIQcgBRCGECEIQRghCSAIIAlsIQogByAKaiELIAUQ9hAhDCAFEIYQIQ1BGCEOIA0gDmwhDyAMIA9qIRAgBRD2ECERIAQoAgghEkEYIRMgEiATbCEUIBEgFGohFSAFIAYgCyAQIBUQ9xBBECEWIAQgFmohFyAXJAAPCxsBA38jACEBQRAhAiABIAJrIQMgAyAANgIMDwtDAQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgQhBSAEIAUQ+xBBECEGIAMgBmohByAHJAAPC14BDH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD9ECEFIAUoAgAhBiAEKAIAIQcgBiAHayEIQRghCSAIIAltIQpBECELIAMgC2ohDCAMJAAgCg8LWgEIfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAFKAIEIQggBiAHIAgQ/BBBECEJIAUgCWohCiAKJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEOsQIQdBECEIIAMgCGohCSAJJAAgBw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEOwQIQVBECEGIAMgBmohByAHJAAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LUwEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQ7hAhByAFIAc2AgBBECEIIAQgCGohCSAJJAAgBQ8LnwEBE38jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBhDzECEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AQc0KIQ4gDhCDAQALIAUoAgghD0EYIRAgDyAQbCERQQQhEiARIBIQhAEhE0EQIRQgBSAUaiEVIBUkACATDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQQhBSAEIAVqIQYgBhD0ECEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD1ECEFQRAhBiADIAZqIQcgByQAIAUPCyUBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMQarVqtUAIQQgBA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIAIQUgBRD6ECEGQRAhByADIAdqIQggCCQAIAYPCzcBA38jACEFQSAhBiAFIAZrIQcgByAANgIcIAcgATYCGCAHIAI2AhQgByADNgIQIAcgBDYCDA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD1ECEFQRAhBiADIAZqIQcgByQAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtKAQd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEP4QQRAhByAEIAdqIQggCCQADwthAQp/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHQRghCCAHIAhsIQlBBCEKIAYgCSAKEElBECELIAUgC2ohDCAMJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBDCEFIAQgBWohBiAGEIIRIQdBECEIIAMgCGohCSAJJAAgBw8LoAEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCBCEFAkADQCAEKAIAIQYgBSgCCCEHIAYhCCAHIQkgCCAJRyEKQQEhCyAKIAtxIQwgDEUNASAFEN4QIQ0gBSgCCCEOQWghDyAOIA9qIRAgBSAQNgIIIBAQ+hAhESANIBEQ/xAMAAsAC0EQIRIgBCASaiETIBMkAA8LSgEHfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGIAUgBhCAEUEgIQcgBCAHaiEIIAgkAA8LSgEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBCgCACEGIAUgBhCBEUEQIQcgBCAHaiEIIAgkAA8LIgEDfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ7BAhBUEQIQYgAyAGaiEHIAckACAFDwtaAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAUoAgQhCCAGIAcgCBCKEUEQIQkgBSAJaiEKIAokAA8LZQEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCnDyEGIAQoAgghByAHEKgPIQggBiAIayEJQRwhCiAJIAptIQtBECEMIAQgDGohDSANJAAgCw8LZQEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCnDyEGIAQoAgghByAHEKcPIQggBiAIayEJQRwhCiAJIAptIQtBECEMIAQgDGohDSANJAAgCw8LcwEMfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAYQnhEhByAFKAIIIQggCBCeESEJIAUoAgQhCiAKEJ4RIQsgByAJIAsQnxEhDEEQIQ0gBSANaiEOIA4kACAMDwt0AQp/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEIgRIAUQ/QwhByAEIAc2AgQgBCgCCCEIIAUgCBCcESAEKAIEIQkgBSAJEJ0RQRAhCiAEIApqIQsgCyQADwsiAQN/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AggPC8EFAmB/A34jACECQcAAIQMgAiADayEEIAQkACAEIAA2AjAgBCABNgIoQRAhBSAEIAVqIQYgBiEHQTAhCCAEIAhqIQkgCSEKIAooAgAhCyAHIAs2AgBBCCEMIAQgDGohDSANIQ5BKCEPIAQgD2ohECAQIREgESgCACESIA4gEjYCACAEKAIQIRMgBCgCCCEUQSAhFSAEIBVqIRYgFiEXIBMgFCAXEKARIRggBCAYNgIYQTAhGSAEIBlqIRogGiEbQRghHCAEIBxqIR0gHSEeIB4oAgAhHyAbIB82AgBBMCEgIAQgIGohISAhISJBKCEjIAQgI2ohJCAkISUgIiAlEKERISZBASEnICYgJ3EhKAJAIChFDQAgBCEpQTAhKiAEICpqISsgKyEsICwoAgAhLSApIC02AgAgBCEuIC4QohEaAkADQCAEIS8gLxCiESEwQSghMSAEIDFqITIgMiEzIDAgMxChESE0QQEhNSA0IDVxITYgNkUNAUEwITcgBCA3aiE4IDghOSA5EKMRITogBCE7IDsQoxEhPEEgIT0gBCA9aiE+ID4hPyA/IDogPBCkESFAQQEhQSBAIEFxIUICQCBCDQAgBCFDIEMQoxEhRCBEENEOIUVBMCFGIAQgRmohRyBHIUggSBCiESFJIEkQoxEhSiBFKQIAIWIgSiBiNwIAQRghSyBKIEtqIUwgRSBLaiFNIE0oAgAhTiBMIE42AgBBECFPIEogT2ohUCBFIE9qIVEgUSkCACFjIFAgYzcCAEEIIVIgSiBSaiFTIEUgUmohVCBUKQIAIWQgUyBkNwIACwwACwALQTAhVSAEIFVqIVYgViFXIFcQohEaC0E4IVggBCBYaiFZIFkhWkEwIVsgBCBbaiFcIFwhXSBdKAIAIV4gWiBeNgIAIAQoAjghX0HAACFgIAQgYGohYSBhJAAgXw8L6BoB2QJ/IwAhA0EwIQQgAyAEayEFIAUkACAFIAA2AiwgBSABNgIoIAUgAjYCJEEeIQYgBSAGNgIgA0ACQAJAA0AgBSgCKCEHIAUoAiwhCCAHIAhrIQlBHCEKIAkgCm0hCyAFIAs2AhwgBSgCHCEMQQUhDSAMIA1LGgJAAkACQAJAAkACQCAMDgYAAAECAwQFCwwHCyAFKAIkIQ4gBSgCKCEPQWQhECAPIBBqIREgBSARNgIoIAUoAiwhEiAOIBEgEhCLESETQQEhFCATIBRxIRUCQCAVRQ0AIAUoAiwhFiAFKAIoIRcgFiAXEIwRCwwGCyAFKAIsIRggBSgCLCEZQRwhGiAZIBpqIRsgBSgCKCEcQWQhHSAcIB1qIR4gBSAeNgIoIAUoAiQhHyAYIBsgHiAfEI0RGgwFCyAFKAIsISAgBSgCLCEhQRwhIiAhICJqISMgBSgCLCEkQTghJSAkICVqISYgBSgCKCEnQWQhKCAnIChqISkgBSApNgIoIAUoAiQhKiAgICMgJiApICoQjhEaDAQLIAUoAiwhKyAFKAIsISxBHCEtICwgLWohLiAFKAIsIS9BOCEwIC8gMGohMSAFKAIsITJB1AAhMyAyIDNqITQgBSgCKCE1QWQhNiA1IDZqITcgBSA3NgIoIAUoAiQhOCArIC4gMSA0IDcgOBCPERoMAwsgBSgCHCE5QR4hOiA5ITsgOiE8IDsgPEwhPUEBIT4gPSA+cSE/AkAgP0UNACAFKAIsIUAgBSgCKCFBIAUoAiQhQiBAIEEgQhCQEQwDCyAFKAIsIUMgBSBDNgIYIAUoAighRCAFIEQ2AhQgBSgCFCFFQWQhRiBFIEZqIUcgBSBHNgIUIAUoAhwhSEHoByFJIEghSiBJIUsgSiBLTiFMQQEhTSBMIE1xIU4CQAJAIE5FDQAgBSgCHCFPQQIhUCBPIFBtIVEgBSBRNgIMIAUoAgwhUiAFKAIYIVNBHCFUIFIgVGwhVSBTIFVqIVYgBSBWNgIYIAUoAgwhV0ECIVggVyBYbSFZIAUgWTYCDCAFKAIsIVogBSgCLCFbIAUoAgwhXEEcIV0gXCBdbCFeIFsgXmohXyAFKAIYIWAgBSgCGCFhIAUoAgwhYkEcIWMgYiBjbCFkIGEgZGohZSAFKAIUIWYgBSgCJCFnIFogXyBgIGUgZiBnEI8RIWggBSBoNgIQDAELIAUoAhwhaUECIWogaSBqbSFrIAUgazYCDCAFKAIMIWwgBSgCGCFtQRwhbiBsIG5sIW8gbSBvaiFwIAUgcDYCGCAFKAIsIXEgBSgCGCFyIAUoAhQhcyAFKAIkIXQgcSByIHMgdBCNESF1IAUgdTYCEAsgBSgCLCF2IAUgdjYCCCAFKAIUIXcgBSB3NgIEIAUoAiQheCAFKAIIIXkgBSgCGCF6IHggeSB6EIsRIXtBASF8IHsgfHEhfSB9DQEDQCAFKAIIIX4gBSgCBCF/QWQhgAEgfyCAAWohgQEgBSCBATYCBCB+IYIBIIEBIYMBIIIBIIMBRiGEAUEBIYUBIIQBIIUBcSGGAQJAIIYBRQ0AIAUoAgghhwFBHCGIASCHASCIAWohiQEgBSCJATYCCCAFKAIoIYoBIAUgigE2AgQgBSgCJCGLASAFKAIsIYwBIAUoAgQhjQFBZCGOASCNASCOAWohjwEgBSCPATYCBCCLASCMASCPARCLESGQAUEBIZEBIJABIJEBcSGSAQJAIJIBDQADQCAFKAIIIZMBIAUoAgQhlAEgkwEhlQEglAEhlgEglQEglgFGIZcBQQEhmAEglwEgmAFxIZkBAkAgmQFFDQAMBwsgBSgCJCGaASAFKAIsIZsBIAUoAgghnAEgmgEgmwEgnAEQixEhnQFBASGeASCdASCeAXEhnwECQAJAIJ8BRQ0AIAUoAgghoAEgBSgCBCGhASCgASChARCMESAFKAIQIaIBQQEhowEgogEgowFqIaQBIAUgpAE2AhAgBSgCCCGlAUEcIaYBIKUBIKYBaiGnASAFIKcBNgIIDAELIAUoAgghqAFBHCGpASCoASCpAWohqgEgBSCqATYCCAwBCwsLIAUoAgghqwEgBSgCBCGsASCrASGtASCsASGuASCtASCuAUYhrwFBASGwASCvASCwAXEhsQECQCCxAUUNAAwFCwNAAkADQCAFKAIkIbIBIAUoAiwhswEgBSgCCCG0ASCyASCzASC0ARCLESG1AUF/IbYBILUBILYBcyG3AUEBIbgBILcBILgBcSG5ASC5AUUNASAFKAIIIboBQRwhuwEgugEguwFqIbwBIAUgvAE2AggMAAsACwJAA0AgBSgCJCG9ASAFKAIsIb4BIAUoAgQhvwFBZCHAASC/ASDAAWohwQEgBSDBATYCBCC9ASC+ASDBARCLESHCAUEBIcMBIMIBIMMBcSHEASDEAUUNAQwACwALIAUoAgghxQEgBSgCBCHGASDFASHHASDGASHIASDHASDIAU8hyQFBASHKASDJASDKAXEhywECQAJAIMsBRQ0ADAELIAUoAgghzAEgBSgCBCHNASDMASDNARCMESAFKAIQIc4BQQEhzwEgzgEgzwFqIdABIAUg0AE2AhAgBSgCCCHRAUEcIdIBINEBINIBaiHTASAFINMBNgIIDAELCyAFKAIIIdQBIAUg1AE2AiwMAgsgBSgCJCHVASAFKAIEIdYBIAUoAhgh1wEg1QEg1gEg1wEQixEh2AFBASHZASDYASDZAXEh2gECQAJAINoBRQ0AIAUoAggh2wEgBSgCBCHcASDbASDcARCMESAFKAIQId0BQQEh3gEg3QEg3gFqId8BIAUg3wE2AhAMAQsMAQsLCwsgBSgCCCHgAUEcIeEBIOABIOEBaiHiASAFIOIBNgIIIAUoAggh4wEgBSgCBCHkASDjASHlASDkASHmASDlASDmAUkh5wFBASHoASDnASDoAXEh6QECQCDpAUUNAANAAkADQCAFKAIkIeoBIAUoAggh6wEgBSgCGCHsASDqASDrASDsARCLESHtAUEBIe4BIO0BIO4BcSHvASDvAUUNASAFKAIIIfABQRwh8QEg8AEg8QFqIfIBIAUg8gE2AggMAAsACwJAA0AgBSgCJCHzASAFKAIEIfQBQWQh9QEg9AEg9QFqIfYBIAUg9gE2AgQgBSgCGCH3ASDzASD2ASD3ARCLESH4AUF/IfkBIPgBIPkBcyH6AUEBIfsBIPoBIPsBcSH8ASD8AUUNAQwACwALIAUoAggh/QEgBSgCBCH+ASD9ASH/ASD+ASGAAiD/ASCAAkshgQJBASGCAiCBAiCCAnEhgwICQAJAIIMCRQ0ADAELIAUoAgghhAIgBSgCBCGFAiCEAiCFAhCMESAFKAIQIYYCQQEhhwIghgIghwJqIYgCIAUgiAI2AhAgBSgCGCGJAiAFKAIIIYoCIIkCIYsCIIoCIYwCIIsCIIwCRiGNAkEBIY4CII0CII4CcSGPAgJAII8CRQ0AIAUoAgQhkAIgBSCQAjYCGAsgBSgCCCGRAkEcIZICIJECIJICaiGTAiAFIJMCNgIIDAELCwsgBSgCCCGUAiAFKAIYIZUCIJQCIZYCIJUCIZcCIJYCIJcCRyGYAkEBIZkCIJgCIJkCcSGaAgJAIJoCRQ0AIAUoAiQhmwIgBSgCGCGcAiAFKAIIIZ0CIJsCIJwCIJ0CEIsRIZ4CQQEhnwIgngIgnwJxIaACIKACRQ0AIAUoAgghoQIgBSgCGCGiAiChAiCiAhCMESAFKAIQIaMCQQEhpAIgowIgpAJqIaUCIAUgpQI2AhALIAUoAhAhpgICQCCmAg0AIAUoAiwhpwIgBSgCCCGoAiAFKAIkIakCIKcCIKgCIKkCEJERIaoCQQEhqwIgqgIgqwJxIawCIAUgrAI6AAMgBSgCCCGtAkEcIa4CIK0CIK4CaiGvAiAFKAIoIbACIAUoAiQhsQIgrwIgsAIgsQIQkREhsgJBASGzAiCyAiCzAnEhtAICQCC0AkUNACAFLQADIbUCQQEhtgIgtQIgtgJxIbcCAkAgtwJFDQAMAwsgBSgCCCG4AiAFILgCNgIoDAMLIAUtAAMhuQJBASG6AiC5AiC6AnEhuwICQCC7AkUNACAFKAIIIbwCQRwhvQIgvAIgvQJqIb4CIAUgvgI2AgggBSC+AjYCLAwDCwsgBSgCCCG/AiAFKAIsIcACIL8CIMACayHBAkEcIcICIMECIMICbSHDAiAFKAIoIcQCIAUoAgghxQIgxAIgxQJrIcYCQRwhxwIgxgIgxwJtIcgCIMMCIckCIMgCIcoCIMkCIMoCSCHLAkEBIcwCIMsCIMwCcSHNAgJAAkAgzQJFDQAgBSgCLCHOAiAFKAIIIc8CIAUoAiQh0AIgzgIgzwIg0AIQihEgBSgCCCHRAkEcIdICINECINICaiHTAiAFINMCNgIIIAUg0wI2AiwMAQsgBSgCCCHUAkEcIdUCINQCINUCaiHWAiAFKAIoIdcCIAUoAiQh2AIg1gIg1wIg2AIQihEgBSgCCCHZAiAFINkCNgIoCwwBCwtBMCHaAiAFINoCaiHbAiDbAiQADwvwBgF1fyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIIIAUgATYCBCAFIAI2AgAgBSgCBCEGIAYQxg8hByAFKAIAIQggCBDGDyEJIAchCiAJIQsgCiALRyEMQQEhDSAMIA1xIQ4CQAJAIA5FDQAgBSgCBCEPIA8Qxg8hECAFKAIAIREgERDGDyESIBAhEyASIRQgEyAUSCEVQQEhFiAVIBZxIRcgBSAXOgAPDAELIAUoAgQhGCAYEKsPIRlBASEaIBkgGnEhGwJAIBsNACAFKAIAIRwgHBCrDyEdQQEhHiAdIB5xIR8CQCAfDQAgBSgCBCEgICAQkhEhISAFKAIAISIgIhCSESEjICEhJCAjISUgJCAlSCEmQQEhJyAmICdxISggBSAoOgAPDAILIAUoAgAhKSApEKMPISpBASErICogK3EhLAJAICxFDQAgBSgCBCEtIC0QkhEhLiAFKAIAIS8gLxCSESEwIC4hMSAwITIgMSAyTCEzQQEhNCAzIDRxITUgBSA1OgAPDAILQQEhNkEBITcgNiA3cSE4IAUgODoADwwBCyAFKAIAITkgORCjDyE6QQEhOyA6IDtxITwCQCA8RQ0AIAUoAgQhPSA9EKMPIT5BASE/ID4gP3EhQAJAIEBFDQAgBSgCBCFBIEEQkhEhQiAFKAIAIUMgQxCSESFEIEIhRSBEIUYgRSBGSCFHQQEhSCBHIEhxIUkgBSBJOgAPDAILQQAhSkEBIUsgSiBLcSFMIAUgTDoADwwBCyAFKAIEIU0gTRCjDyFOQQEhTyBOIE9xIVACQCBQRQ0AQQEhUUEBIVIgUSBScSFTIAUgUzoADwwBCyAFKAIEIVQgVBCSESFVIAUoAgAhViBWEJIRIVcgVSFYIFchWSBYIFlHIVpBASFbIFogW3EhXAJAIFxFDQAgBSgCBCFdIF0QkhEhXiAFKAIAIV8gXxCSESFgIF4hYSBgIWIgYSBiSCFjQQEhZCBjIGRxIWUgBSBlOgAPDAELIAUoAgQhZiBmEMAPIWcgBSgCBCFoIGgQoA8haSAFKAIAIWogahDADyFrIGcgaSBrEJMRIWxBASFtIGwhbiBtIW8gbiBvRiFwQQEhcSBwIHFxIXIgBSByOgAPCyAFLQAPIXNBASF0IHMgdHEhdUEQIXYgBSB2aiF3IHckACB1DwvQAwIwfwl+IwAhAkEwIQMgAiADayEEIAQkACAEIAA2AiwgBCABNgIoIAQoAiwhBSAFENEOIQZBCCEHIAQgB2ohCCAIIQkgBikCACEyIAkgMjcCAEEYIQogCSAKaiELIAYgCmohDCAMKAIAIQ0gCyANNgIAQRAhDiAJIA5qIQ8gBiAOaiEQIBApAgAhMyAPIDM3AgBBCCERIAkgEWohEiAGIBFqIRMgEykCACE0IBIgNDcCACAEKAIoIRQgFBDRDiEVIAQoAiwhFiAVKQIAITUgFiA1NwIAQRghFyAWIBdqIRggFSAXaiEZIBkoAgAhGiAYIBo2AgBBECEbIBYgG2ohHCAVIBtqIR0gHSkCACE2IBwgNjcCAEEIIR4gFiAeaiEfIBUgHmohICAgKQIAITcgHyA3NwIAQQghISAEICFqISIgIiEjICMQ0Q4hJCAEKAIoISUgJCkCACE4ICUgODcCAEEYISYgJSAmaiEnICQgJmohKCAoKAIAISkgJyApNgIAQRAhKiAlICpqISsgJCAqaiEsICwpAgAhOSArIDk3AgBBCCEtICUgLWohLiAkIC1qIS8gLykCACE6IC4gOjcCAEEwITAgBCAwaiExIDEkAA8LtQQBOH8jACEEQSAhBSAEIAVrIQYgBiQAIAYgADYCGCAGIAE2AhQgBiACNgIQIAYgAzYCDEEAIQcgBiAHNgIIIAYoAgwhCCAGKAIUIQkgBigCGCEKIAggCSAKEIsRIQtBASEMIAsgDHEhDQJAAkAgDQ0AIAYoAgwhDiAGKAIQIQ8gBigCFCEQIA4gDyAQEIsRIRFBASESIBEgEnEhEwJAIBMNACAGKAIIIRQgBiAUNgIcDAILIAYoAhQhFSAGKAIQIRYgFSAWEIwRQQEhFyAGIBc2AgggBigCDCEYIAYoAhQhGSAGKAIYIRogGCAZIBoQixEhG0EBIRwgGyAccSEdAkAgHUUNACAGKAIYIR4gBigCFCEfIB4gHxCMEUECISAgBiAgNgIICyAGKAIIISEgBiAhNgIcDAELIAYoAgwhIiAGKAIQISMgBigCFCEkICIgIyAkEIsRISVBASEmICUgJnEhJwJAICdFDQAgBigCGCEoIAYoAhAhKSAoICkQjBFBASEqIAYgKjYCCCAGKAIIISsgBiArNgIcDAELIAYoAhghLCAGKAIUIS0gLCAtEIwRQQEhLiAGIC42AgggBigCDCEvIAYoAhAhMCAGKAIUITEgLyAwIDEQixEhMkEBITMgMiAzcSE0AkAgNEUNACAGKAIUITUgBigCECE2IDUgNhCMEUECITcgBiA3NgIICyAGKAIIITggBiA4NgIcCyAGKAIcITlBICE6IAYgOmohOyA7JAAgOQ8LpgMBLH8jACEFQSAhBiAFIAZrIQcgByQAIAcgADYCHCAHIAE2AhggByACNgIUIAcgAzYCECAHIAQ2AgwgBygCHCEIIAcoAhghCSAHKAIUIQogBygCDCELIAggCSAKIAsQjREhDCAHIAw2AgggBygCDCENIAcoAhAhDiAHKAIUIQ8gDSAOIA8QixEhEEEBIREgECARcSESAkAgEkUNACAHKAIUIRMgBygCECEUIBMgFBCMESAHKAIIIRVBASEWIBUgFmohFyAHIBc2AgggBygCDCEYIAcoAhQhGSAHKAIYIRogGCAZIBoQixEhG0EBIRwgGyAccSEdAkAgHUUNACAHKAIYIR4gBygCFCEfIB4gHxCMESAHKAIIISBBASEhICAgIWohIiAHICI2AgggBygCDCEjIAcoAhghJCAHKAIcISUgIyAkICUQixEhJkEBIScgJiAncSEoAkAgKEUNACAHKAIcISkgBygCGCEqICkgKhCMESAHKAIIIStBASEsICsgLGohLSAHIC02AggLCwsgBygCCCEuQSAhLyAHIC9qITAgMCQAIC4PC5cEATh/IwAhBkEgIQcgBiAHayEIIAgkACAIIAA2AhwgCCABNgIYIAggAjYCFCAIIAM2AhAgCCAENgIMIAggBTYCCCAIKAIcIQkgCCgCGCEKIAgoAhQhCyAIKAIQIQwgCCgCCCENIAkgCiALIAwgDRCOESEOIAggDjYCBCAIKAIIIQ8gCCgCDCEQIAgoAhAhESAPIBAgERCLESESQQEhEyASIBNxIRQCQCAURQ0AIAgoAhAhFSAIKAIMIRYgFSAWEIwRIAgoAgQhF0EBIRggFyAYaiEZIAggGTYCBCAIKAIIIRogCCgCECEbIAgoAhQhHCAaIBsgHBCLESEdQQEhHiAdIB5xIR8CQCAfRQ0AIAgoAhQhICAIKAIQISEgICAhEIwRIAgoAgQhIkEBISMgIiAjaiEkIAggJDYCBCAIKAIIISUgCCgCFCEmIAgoAhghJyAlICYgJxCLESEoQQEhKSAoIClxISoCQCAqRQ0AIAgoAhghKyAIKAIUISwgKyAsEIwRIAgoAgQhLUEBIS4gLSAuaiEvIAggLzYCBCAIKAIIITAgCCgCGCExIAgoAhwhMiAwIDEgMhCLESEzQQEhNCAzIDRxITUCQCA1RQ0AIAgoAhwhNiAIKAIYITcgNiA3EIwRIAgoAgQhOEEBITkgOCA5aiE6IAggOjYCBAsLCwsgCCgCBCE7QSAhPCAIIDxqIT0gPSQAIDsPC4QHAmR/CX4jACEDQcAAIQQgAyAEayEFIAUkACAFIAA2AjwgBSABNgI4IAUgAjYCNCAFKAI8IQZBOCEHIAYgB2ohCCAFIAg2AjAgBSgCPCEJIAUoAjwhCkEcIQsgCiALaiEMIAUoAjAhDSAFKAI0IQ4gCSAMIA0gDhCNERogBSgCMCEPQRwhECAPIBBqIREgBSARNgIsAkADQCAFKAIsIRIgBSgCOCETIBIhFCATIRUgFCAVRyEWQQEhFyAWIBdxIRggGEUNASAFKAI0IRkgBSgCLCEaIAUoAjAhGyAZIBogGxCLESEcQQEhHSAcIB1xIR4CQCAeRQ0AIAUoAiwhHyAfENEOISBBECEhIAUgIWohIiAiISMgICkCACFnICMgZzcCAEEYISQgIyAkaiElICAgJGohJiAmKAIAIScgJSAnNgIAQRAhKCAjIChqISkgICAoaiEqICopAgAhaCApIGg3AgBBCCErICMgK2ohLCAgICtqIS0gLSkCACFpICwgaTcCACAFKAIwIS4gBSAuNgIMIAUoAiwhLyAFIC82AjADQCAFKAIMITAgMBDRDiExIAUoAjAhMiAxKQIAIWogMiBqNwIAQRghMyAyIDNqITQgMSAzaiE1IDUoAgAhNiA0IDY2AgBBECE3IDIgN2ohOCAxIDdqITkgOSkCACFrIDggazcCAEEIITogMiA6aiE7IDEgOmohPCA8KQIAIWwgOyBsNwIAIAUoAgwhPSAFID02AjAgBSgCMCE+IAUoAjwhPyA+IUAgPyFBIEAgQUchQkEAIUNBASFEIEIgRHEhRSBDIUYCQCBFRQ0AIAUoAjQhRyAFKAIMIUhBZCFJIEggSWohSiAFIEo2AgxBECFLIAUgS2ohTCBMIU0gRyBNIEoQixEhTiBOIUYLIEYhT0EBIVAgTyBQcSFRIFENAAtBECFSIAUgUmohUyBTIVQgVBDRDiFVIAUoAjAhViBVKQIAIW0gViBtNwIAQRghVyBWIFdqIVggVSBXaiFZIFkoAgAhWiBYIFo2AgBBECFbIFYgW2ohXCBVIFtqIV0gXSkCACFuIFwgbjcCAEEIIV4gViBeaiFfIFUgXmohYCBgKQIAIW8gXyBvNwIACyAFKAIsIWEgBSBhNgIwIAUoAiwhYkEcIWMgYiBjaiFkIAUgZDYCLAwACwALQcAAIWUgBSBlaiFmIGYkAA8LkA4CvgF/CX4jACEDQdAAIQQgAyAEayEFIAUkACAFIAA2AkggBSABNgJEIAUgAjYCQCAFKAJEIQYgBSgCSCEHIAYgB2shCEEcIQkgCCAJbSEKQQUhCyAKIAtLGgJAAkACQAJAAkACQAJAIAoOBgAAAQIDBAULQQEhDEEBIQ0gDCANcSEOIAUgDjoATwwFCyAFKAJAIQ8gBSgCRCEQQWQhESAQIBFqIRIgBSASNgJEIAUoAkghEyAPIBIgExCLESEUQQEhFSAUIBVxIRYCQCAWRQ0AIAUoAkghFyAFKAJEIRggFyAYEIwRC0EBIRlBASEaIBkgGnEhGyAFIBs6AE8MBAsgBSgCSCEcIAUoAkghHUEcIR4gHSAeaiEfIAUoAkQhIEFkISEgICAhaiEiIAUgIjYCRCAFKAJAISMgHCAfICIgIxCNERpBASEkQQEhJSAkICVxISYgBSAmOgBPDAMLIAUoAkghJyAFKAJIIShBHCEpICggKWohKiAFKAJIIStBOCEsICsgLGohLSAFKAJEIS5BZCEvIC4gL2ohMCAFIDA2AkQgBSgCQCExICcgKiAtIDAgMRCOERpBASEyQQEhMyAyIDNxITQgBSA0OgBPDAILIAUoAkghNSAFKAJIITZBHCE3IDYgN2ohOCAFKAJIITlBOCE6IDkgOmohOyAFKAJIITxB1AAhPSA8ID1qIT4gBSgCRCE/QWQhQCA/IEBqIUEgBSBBNgJEIAUoAkAhQiA1IDggOyA+IEEgQhCPERpBASFDQQEhRCBDIERxIUUgBSBFOgBPDAELIAUoAkghRkE4IUcgRiBHaiFIIAUgSDYCPCAFKAJIIUkgBSgCSCFKQRwhSyBKIEtqIUwgBSgCPCFNIAUoAkAhTiBJIEwgTSBOEI0RGkEIIU8gBSBPNgI4QQAhUCAFIFA2AjQgBSgCPCFRQRwhUiBRIFJqIVMgBSBTNgIwAkADQCAFKAIwIVQgBSgCRCFVIFQhViBVIVcgViBXRyFYQQEhWSBYIFlxIVogWkUNASAFKAJAIVsgBSgCMCFcIAUoAjwhXSBbIFwgXRCLESFeQQEhXyBeIF9xIWACQCBgRQ0AIAUoAjAhYSBhENEOIWJBECFjIAUgY2ohZCBkIWUgYikCACHBASBlIMEBNwIAQRghZiBlIGZqIWcgYiBmaiFoIGgoAgAhaSBnIGk2AgBBECFqIGUgamohayBiIGpqIWwgbCkCACHCASBrIMIBNwIAQQghbSBlIG1qIW4gYiBtaiFvIG8pAgAhwwEgbiDDATcCACAFKAI8IXAgBSBwNgIMIAUoAjAhcSAFIHE2AjwDQCAFKAIMIXIgchDRDiFzIAUoAjwhdCBzKQIAIcQBIHQgxAE3AgBBGCF1IHQgdWohdiBzIHVqIXcgdygCACF4IHYgeDYCAEEQIXkgdCB5aiF6IHMgeWoheyB7KQIAIcUBIHogxQE3AgBBCCF8IHQgfGohfSBzIHxqIX4gfikCACHGASB9IMYBNwIAIAUoAgwhfyAFIH82AjwgBSgCPCGAASAFKAJIIYEBIIABIYIBIIEBIYMBIIIBIIMBRyGEAUEAIYUBQQEhhgEghAEghgFxIYcBIIUBIYgBAkAghwFFDQAgBSgCQCGJASAFKAIMIYoBQWQhiwEgigEgiwFqIYwBIAUgjAE2AgxBECGNASAFII0BaiGOASCOASGPASCJASCPASCMARCLESGQASCQASGIAQsgiAEhkQFBASGSASCRASCSAXEhkwEgkwENAAtBECGUASAFIJQBaiGVASCVASGWASCWARDRDiGXASAFKAI8IZgBIJcBKQIAIccBIJgBIMcBNwIAQRghmQEgmAEgmQFqIZoBIJcBIJkBaiGbASCbASgCACGcASCaASCcATYCAEEQIZ0BIJgBIJ0BaiGeASCXASCdAWohnwEgnwEpAgAhyAEgngEgyAE3AgBBCCGgASCYASCgAWohoQEglwEgoAFqIaIBIKIBKQIAIckBIKEBIMkBNwIAIAUoAjQhowFBASGkASCjASCkAWohpQEgBSClATYCNEEIIaYBIKUBIacBIKYBIagBIKcBIKgBRiGpAUEBIaoBIKkBIKoBcSGrAQJAIKsBRQ0AIAUoAjAhrAFBHCGtASCsASCtAWohrgEgBSCuATYCMCAFKAJEIa8BIK4BIbABIK8BIbEBILABILEBRiGyAUEBIbMBILIBILMBcSG0ASAFILQBOgBPDAQLCyAFKAIwIbUBIAUgtQE2AjwgBSgCMCG2AUEcIbcBILYBILcBaiG4ASAFILgBNgIwDAALAAtBASG5AUEBIboBILkBILoBcSG7ASAFILsBOgBPCyAFLQBPIbwBQQEhvQEgvAEgvQFxIb4BQdAAIb8BIAUgvwFqIcABIMABJAAgvgEPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDVDiEFQRAhBiADIAZqIQcgByQAIAUPC+ICAx5/EH4BfCMAIQNBMCEEIAMgBGshBSAFJAAgBSAANgIsIAUgATYCKCAFIAI2AiQgBSgCLCEGIAYQ1A4hByAHIQggCKwhISAFKAIoIQkgCRDUDiEKIAohCyALrCEiICEgIn0hIyAFICM3AxggBSgCKCEMIAwQ1A4hDSANIQ4gDqwhJCAFKAIkIQ8gDxDUDiEQIBAhESARrCElICQgJX0hJiAFICY3AxAgBSgCLCESIBIQ1Q4hEyATIRQgFKwhJyAFKAIoIRUgFRDVDiEWIBYhFyAXrCEoICcgKH0hKSAFICk3AwggBSgCKCEYIBgQ1Q4hGSAZIRogGqwhKiAFKAIkIRsgGxDVDiEcIBwhHSAdrCErICogK30hLCAFICw3AwAgBSkDGCEtIAUpAwghLiAFKQMQIS8gBSkDACEwIC0gLiAvIDAQlBEhMSAxEJURIR5BMCEfIAUgH2ohICAgJAAgHg8L3QoDYn84fg58IwAhBEGQASEFIAQgBWshBiAGJAAgBiAANwOAASAGIAE3A3ggBiACNwNwIAYgAzcDaEGAASEHIAYgB2ohCCAIIQkgCRCYESEKQQEhCyAKIAtxIQwCQAJAIAxFDQAgBikDgAEhZkIAIWcgZyBmfSFoIGghaQwBCyAGKQOAASFqIGohaQsgaSFrIAYgazcDYEH4ACENIAYgDWohDiAOIQ8gDxCYESEQQQEhESAQIBFxIRICQAJAIBJFDQAgBikDeCFsQgAhbSBtIGx9IW4gbiFvDAELIAYpA3ghcCBwIW8LIG8hcSAGIHE3A1hB8AAhEyAGIBNqIRQgFCEVIBUQmBEhFkEBIRcgFiAXcSEYAkACQCAYRQ0AIAYpA3AhckIAIXMgcyByfSF0IHQhdQwBCyAGKQNwIXYgdiF1CyB1IXcgBiB3NwNQQegAIRkgBiAZaiEaIBohGyAbEJgRIRxBASEdIBwgHXEhHgJAAkAgHkUNACAGKQNoIXhCACF5IHkgeH0heiB6IXsMAQsgBikDaCF8IHwhewsgeyF9IAYgfTcDSCAGKQNgIX4gBikDSCF/IH4gf34hgAEgBiCAATcDQCAGKQNYIYEBIAYpA1AhggEggQEgggF+IYMBIAYggwE3AzhBgAEhHyAGIB9qISAgICEhICEQmBEhIkEBISMgIiAjcSEkQegAISUgBiAlaiEmICYhJyAnEJgRIShBASEpICggKXEhKiAkICpzISsCQAJAICtFDQBB8AAhLCAGICxqIS0gLSEuIC4QmBEhL0EBITAgLyAwcSExQfgAITIgBiAyaiEzIDMhNCA0EJgRITVBASE2IDUgNnEhNyAxIDdzITgCQCA4RQ0AIAYpA0AhhAEgBikDOCGFASCEASGGASCFASGHASCGASCHAVYhOUEBITogOSA6cSE7AkACQCA7RQ0AIAYpA0AhiAEgBikDOCGJASCIASCJAX0higEgBiCKATcDMEHALCE8QTAhPSAGID1qIT4gPiE/IDwgPxCZESGeASCeAZohnwEgnwEhoAEMAQsgBikDOCGLASAGKQNAIYwBIIsBIIwBfSGNASAGII0BNwMoQcAsIUBBKCFBIAYgQWohQiBCIUMgQCBDEJkRIaEBIKEBIaABCyCgASGiASAGIKIBOQOIAQwCCyAGKQNAIY4BIAYpAzghjwEgjgEgjwF8IZABIAYgkAE3AyBBwCwhREEgIUUgBiBFaiFGIEYhRyBEIEcQmREhowEgowGaIaQBIAYgpAE5A4gBDAELQfAAIUggBiBIaiFJIEkhSiBKEJgRIUtBASFMIEsgTHEhTUH4ACFOIAYgTmohTyBPIVAgUBCYESFRQQEhUiBRIFJxIVMgTSBTcyFUAkAgVEUNACAGKQNAIZEBIAYpAzghkgEgkQEgkgF8IZMBIAYgkwE3AxhBwCwhVUEYIVYgBiBWaiFXIFchWCBVIFgQmREhpQEgBiClATkDiAEMAQsgBikDQCGUASAGKQM4IZUBIJQBIZYBIJUBIZcBIJYBIJcBVCFZQQEhWiBZIFpxIVsCQAJAIFtFDQAgBikDOCGYASAGKQNAIZkBIJgBIJkBfSGaASAGIJoBNwMQQcAsIVxBECFdIAYgXWohXiBeIV8gXCBfEJkRIaYBIKYBmiGnASCnASGoAQwBCyAGKQNAIZsBIAYpAzghnAEgmwEgnAF9IZ0BIAYgnQE3AwhBwCwhYEEIIWEgBiBhaiFiIGIhYyBgIGMQmREhqQEgqQEhqAELIKgBIaoBIAYgqgE5A4gBCyAGKwOIASGrAUGQASFkIAYgZGohZSBlJAAgqwEPC5MBARJ/IwAhAUEQIQIgASACayEDIAMkACADIAA5AwAgAyEEIAQQlhEhBUEBIQYgBSAGcSEHAkACQCAHRQ0AQQAhCCADIAg2AgwMAQsgAyEJIAkQlxEhCkF/IQtBASEMQQEhDSAKIA1xIQ4gCyAMIA4bIQ8gAyAPNgIMCyADKAIMIRBBECERIAMgEWohEiASJAAgEA8LSAIIfwJ8IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCsDACEJQQAhBSAFtyEKIAkgCmEhBkEBIQcgBiAHcSEIIAgPC0gCCH8CfCMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQrAwAhCUEAIQUgBbchCiAJIApjIQZBASEHIAYgB3EhCCAIDwtLAgd/BH4jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKQMAIQhCACEJIAghCiAJIQsgCiALUyEFQQEhBiAFIAZxIQcgBw8LOwMEfwF+AXwjACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIIIQUgBSkDACEGIAa6IQcgBw8LOQEFfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGNgIAIAUPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQpw8hBiAEKAIIIQcgBxCnDyEIIAYhCSAIIQogCSAKRiELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LvAEBFH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAEIAY2AgQCQANAIAQoAgghByAEKAIEIQggByEJIAghCiAJIApHIQtBASEMIAsgDHEhDSANRQ0BIAUQ2A4hDiAEKAIEIQ9BZCEQIA8gEGohESAEIBE2AgQgERDZDiESIA4gEhCLDwwACwALIAQoAgghEyAFIBM2AgRBECEUIAQgFGohFSAVJAAPC7ABARZ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEIQPIQYgBRCEDyEHIAUQ5w4hCEEcIQkgCCAJbCEKIAcgCmohCyAFEIQPIQwgBCgCCCENQRwhDiANIA5sIQ8gDCAPaiEQIAUQhA8hESAFEP0MIRJBHCETIBIgE2whFCARIBRqIRUgBSAGIAsgECAVEIUPQRAhFiAEIBZqIRcgFyQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8L3AEBG38jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIMIQcgBiAHayEIQRwhCSAIIAltIQogBSAKNgIAIAUoAgAhC0EAIQwgCyENIAwhDiANIA5LIQ9BASEQIA8gEHEhEQJAIBFFDQAgBSgCBCESIAUoAgwhEyAFKAIAIRRBHCEVIBQgFWwhFiASIBMgFhDlGhoLIAUoAgQhFyAFKAIAIRhBHCEZIBggGWwhGiAXIBpqIRtBECEcIAUgHGohHSAdJAAgGw8LoAMBOX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCECAFIAE2AgggBSACNgIEQRAhBiAFIAZqIQcgByEIQQghCSAFIAlqIQogCiELIAggCxChESEMQQEhDSAMIA1xIQ4CQAJAIA5FDQAgBSEPQRAhECAFIBBqIREgESESIBIoAgAhEyAPIBM2AgACQANAIAUhFCAUEKIRIRVBCCEWIAUgFmohFyAXIRggFSAYEKERIRlBASEaIBkgGnEhGyAbRQ0BIAUoAgQhHEEQIR0gBSAdaiEeIB4hHyAfEKMRISAgBSEhICEQoxEhIiAcICAgIhCkESEjQQEhJCAjICRxISUCQCAlRQ0AQRghJiAFICZqIScgJyEoQRAhKSAFIClqISogKiErICsoAgAhLCAoICw2AgAMBAtBECEtIAUgLWohLiAuIS8gBSEwIDAoAgAhMSAvIDE2AgAMAAsACwtBGCEyIAUgMmohMyAzITRBCCE1IAUgNWohNiA2ITcgNygCACE4IDQgODYCAAsgBSgCGCE5QSAhOiAFIDpqITsgOyQAIDkPC2QBDH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQpREhB0F/IQggByAIcyEJQQEhCiAJIApxIQtBECEMIAQgDGohDSANJAAgCw8LPQEHfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBUEcIQYgBSAGaiEHIAQgBzYCACAEDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC2ABCn8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQcgBiAHEKYRIQhBASEJIAggCXEhCkEQIQsgBSALaiEMIAwkACAKDwttAQ5/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEKgPIQYgBCgCCCEHIAcQqA8hCCAGIQkgCCEKIAkgCkYhC0EBIQwgCyAMcSENQRAhDiAEIA5qIQ8gDyQAIA0PC6IBARV/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEK4PIQdBACEIQQEhCSAHIAlxIQogCCELAkAgCkUNAEEIIQwgBSAMaiENIAQoAgghDkEIIQ8gDiAPaiEQIA0gEBCuDyERIBEhCwsgCyESQQEhEyASIBNxIRRBECEVIAQgFWohFiAWJAAgFA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAhQhBSAFDws2AQd/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCGCEFQR8hBiAFIAZxIQcgBw8LWQEHfyMAIQNBECEEIAMgBGshBSAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAYgBzYCAEEAIQggBiAINgIEIAUoAgQhCSAGIAk2AgggBg8LogEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAFEJQQIQcgBygCACEIIAYhCSAIIQogCSAKSSELQQEhDCALIAxxIQ0CQAJAIA1FDQAgBCgCCCEOIA4QsxEhDyAFIA8QtBEMAQsgBCgCCCEQIBAQsxEhESAFIBEQtRELQRAhEiAEIBJqIRMgEyQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC6kCAhx/Bn4jACEDQRAhBCADIARrIQUgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHKQIAIR8gBiAfNwIAQRghCCAGIAhqIQkgByAIaiEKIAooAgAhCyAJIAs2AgBBECEMIAYgDGohDSAHIAxqIQ4gDikCACEgIA0gIDcCAEEIIQ8gBiAPaiEQIAcgD2ohESARKQIAISEgECAhNwIAQRwhEiAGIBJqIRMgBSgCBCEUIBQpAgAhIiATICI3AgBBGCEVIBMgFWohFiAUIBVqIRcgFygCACEYIBYgGDYCAEEQIRkgEyAZaiEaIBQgGWohGyAbKQIAISMgGiAjNwIAQQghHCATIBxqIR0gFCAcaiEeIB4pAgAhJCAdICQ3AgAgBg8LqQYBY38jACEEQYABIQUgBCAFayEGIAYkACAGIAE2AnwgBiACNgJ4IAYgAzYCdCAGKAJ8IQcgBigCeCEIIAgQzBEhCSAGIAk2AnAgBigCdCEKIAoQzBEhCyAGIAs2AmwgBigCeCEMIAYoAnQhDSAHIAwgDRDNESEOQQEhDyAOIA9xIRAgBiAQOgBrIAYoAnghESAGKAJ0IRIgByARIBIQzhEhE0EBIRQgEyAUcSEVIAYgFToAakEYIRYgByAWaiEXIAYtAGshGCAGLQBqIRlB0AAhGiAGIBpqIRsgGyEcQQEhHSAYIB1xIR5BASEfIBkgH3EhICAcIB4gIBDPERpB0AAhISAGICFqISIgIiEjIBcgIxDQEUEYISQgByAkaiElICUQ0REhJiAGICY2AkxBGCEnIAcgJ2ohKCAGLQBrISkgBi0AaiEqQTAhKyAGICtqISwgLCEtQQEhLiApIC5xIS9BASEwICogMHEhMSAtIC8gMRDPERpBMCEyIAYgMmohMyAzITQgKCA0ENARQRghNSAHIDVqITYgNhDRESE3IAYgNzYCLCAHENIRIThBASE5IDggOXEhOgJAIDpFDQAgBigCeCE7IDsQpxEhPCAGKAJ4IT0gPRCoESE+QSAhPyAGID9qIUAgQCFBIEEgPCA+EKkRGkEgIUIgBiBCaiFDIEMhRCAHIEQQqhELIAYoAnQhRSBFEKcRIUYgBigCdCFHIEcQqBEhSEEQIUkgBiBJaiFKIEohSyBLIEYgSBCpERpBECFMIAYgTGohTSBNIU4gByBOEKoRIAYoAkwhTyAGKAJwIVAgByBQENMRIVEgTyBRENQRIAYoAiwhUiAGKAJsIVMgByBTENMRIVQgUiBUENQRIAYoAkwhVSAGKAIsIVYgVSBWENoPIAYoAiwhVyAGKAJMIVggVyBYENoPIAYoAkwhWSAGIFk2AgQgBigCLCFaIAYgWjYCAEEIIVsgBiBbaiFcIFwhXUEEIV4gBiBeaiFfIF8hYCAGIWEgXSBgIGEQ1RFBCCFiIAYgYmohYyBjIWQgACBkENYRGkGAASFlIAYgZWohZiBmJAAPC24BDH8jACECQRAhAyACIANrIQQgBCQAIAQgATYCCCAEIAA2AgQgBCgCBCEFQQghBiAEIAZqIQcgByEIIAQhCSAIKAIAIQogCSAKNgIAIAQoAgAhCyAFIAsQ2REaQRAhDCAEIAxqIQ0gDSQAIAUPC0QBBn8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQVBACEGIAUgBjYCACAEKAIIIQcgBSAHNgIEIAUPC8oCAh5/CH4jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxDaESEIIAgpAgAhISAGICE3AgBBMCEJIAYgCWohCiAIIAlqIQsgCykCACEiIAogIjcCAEEoIQwgBiAMaiENIAggDGohDiAOKQIAISMgDSAjNwIAQSAhDyAGIA9qIRAgCCAPaiERIBEpAgAhJCAQICQ3AgBBGCESIAYgEmohEyAIIBJqIRQgFCkCACElIBMgJTcCAEEQIRUgBiAVaiEWIAggFWohFyAXKQIAISYgFiAmNwIAQQghGCAGIBhqIRkgCCAYaiEaIBopAgAhJyAZICc3AgBBOCEbIAYgG2ohHCAFKAIEIR0gHRDbESEeIB4pAgAhKCAcICg3AgBBECEfIAUgH2ohICAgJAAgBg8LvQEBFn8jACEDQTAhBCADIARrIQUgBSQAIAUgATYCICAFIAA2AhwgBSACNgIYIAUoAhwhBkEgIQcgBSAHaiEIIAghCUEIIQogBSAKaiELIAshDCAJKAIAIQ0gDCANNgIAIAUoAhghDiAOEJYTIQ8gBSgCCCEQIAYgECAPEJcTIREgBSARNgIQIAUoAhAhEkEoIRMgBSATaiEUIBQhFSAVIBIQyhEaIAUoAighFkEwIRcgBSAXaiEYIBgkACAWDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LswEBFX8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFQQghBiAEIAZqIQcgByEIQQEhCSAIIAUgCRC2ERogBRD7DyEKIAQoAgwhCyALEKoQIQwgBCgCGCENIA0QtxEhDiAKIAwgDhC4ESAEKAIMIQ9BDCEQIA8gEGohESAEIBE2AgxBCCESIAQgEmohEyATIRQgFBC5ERpBICEVIAQgFWohFiAWJAAPC90BARh/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAFEPsPIQYgBCAGNgIUIAUQ/A8hB0EBIQggByAIaiEJIAUgCRC6ESEKIAUQ/A8hCyAEKAIUIQwgBCENIA0gCiALIAwQ/Q8aIAQoAhQhDiAEKAIIIQ8gDxCqECEQIAQoAhghESARELcRIRIgDiAQIBIQuBEgBCgCCCETQQwhFCATIBRqIRUgBCAVNgIIIAQhFiAFIBYQ/g8gBCEXIBcQ/w8aQSAhGCAEIBhqIRkgGSQADwuDAQENfyMAIQNBECEEIAMgBGshBSAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAYgBzYCACAFKAIIIQggCCgCBCEJIAYgCTYCBCAFKAIIIQogCigCBCELIAUoAgQhDEEMIQ0gDCANbCEOIAsgDmohDyAGIA82AgggBg8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC2EBCX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCHCAFIAE2AhggBSACNgIUIAUoAhwhBiAFKAIYIQcgBSgCFCEIIAgQtxEhCSAGIAcgCRC7EUEgIQogBSAKaiELIAskAA8LOQEGfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgQhBSAEKAIAIQYgBiAFNgIEIAQPC7ICASV/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhggBCABNgIUIAQoAhghBSAFEL0RIQYgBCAGNgIQIAQoAhQhByAEKAIQIQggByEJIAghCiAJIApLIQtBASEMIAsgDHEhDQJAIA1FDQAgBRC1GgALIAUQ+g8hDiAEIA42AgwgBCgCDCEPIAQoAhAhEEEBIREgECARdiESIA8hEyASIRQgEyAUTyEVQQEhFiAVIBZxIRcCQAJAIBdFDQAgBCgCECEYIAQgGDYCHAwBCyAEKAIMIRlBASEaIBkgGnQhGyAEIBs2AghBCCEcIAQgHGohHSAdIR5BFCEfIAQgH2ohICAgISEgHiAhEGchIiAiKAIAISMgBCAjNgIcCyAEKAIcISRBICElIAQgJWohJiAmJAAgJA8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIUIAUgATYCECAFIAI2AgwgBSgCFCEGIAUoAhAhByAFKAIMIQggCBC3ESEJIAYgByAJELwRQSAhCiAFIApqIQsgCyQADwuBAQIMfwF+IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHIAcQtxEhCCAIKQIAIQ8gBiAPNwIAQQghCSAGIAlqIQogCCAJaiELIAsoAgAhDCAKIAw2AgBBECENIAUgDWohDiAOJAAPC4QBARF/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQvhEhBSAFEL8RIQYgAyAGNgIIEHQhByADIAc2AgRBCCEIIAMgCGohCSAJIQpBBCELIAMgC2ohDCAMIQ0gCiANEHUhDiAOKAIAIQ9BECEQIAMgEGohESARJAAgDw8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQwREhB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQwBEhBUEQIQYgAyAGaiEHIAckACAFDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQoxAhBUEQIQYgAyAGaiEHIAckACAFDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQwhEhBUEQIQYgAyAGaiEHIAckACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC8oCAh5/CH4jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxDaESEIIAgpAgAhISAGICE3AgBBMCEJIAYgCWohCiAIIAlqIQsgCykCACEiIAogIjcCAEEoIQwgBiAMaiENIAggDGohDiAOKQIAISMgDSAjNwIAQSAhDyAGIA9qIRAgCCAPaiERIBEpAgAhJCAQICQ3AgBBGCESIAYgEmohEyAIIBJqIRQgFCkCACElIBMgJTcCAEEQIRUgBiAVaiEWIAggFWohFyAXKQIAISYgFiAmNwIAQQghGCAGIBhqIRkgCCAYaiEaIBopAgAhJyAZICc3AgBBOCEbIAYgG2ohHCAFKAIEIR0gHRDbESEeIB4pAgAhKCAcICg3AgBBECEfIAUgH2ohICAgJAAgBg8LvQEBFn8jACEDQTAhBCADIARrIQUgBSQAIAUgATYCICAFIAA2AhwgBSACNgIYIAUoAhwhBkEgIQcgBSAHaiEIIAghCUEIIQogBSAKaiELIAshDCAJKAIAIQ0gDCANNgIAIAUoAhghDiAOENcRIQ8gBSgCCCEQIAYgECAPENgRIREgBSARNgIQIAUoAhAhEkEoIRMgBSATaiEUIBQhFSAVIBIQyhEaIAUoAighFkEwIRcgBSAXaiEYIBgkACAWDwsvAQZ/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQRBHCEFIAQgBWohBiAGDwtbAQl/IwAhA0EQIQQgAyAEayEFIAUkACAFIAE2AgwgBSACNgIIIAUoAgwhBiAGEOERIQcgBSgCCCEIIAgQ4hEhCSAAIAcgCRDjERpBECEKIAUgCmohCyALJAAPC8UBARV/IwAhAkEwIQMgAiADayEEIAQkACAEIAA2AiwgBCABNgIoIAQoAiwhBSAEKAIoIQYgBhDcESEHIAUgBxDdESAFEN4RIQggBCAINgIgIAUQ3xEhCSAEIAk2AhhBDCEKIAUgCmohC0EQIQwgBCAMaiENIA0hDiALLQAAIQ8gDiAPOgAAIAQoAiAhECAEKAIYIREgBC0AECESIAQgEjoAD0EPIRMgBCATaiEUIBAgESAUEOARQTAhFSAEIBVqIRYgFiQADwtcAQt/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQxA4hBUEIIQYgAyAGaiEHIAchCCAIIAUQmBIaIAMoAgghCUEQIQogAyAKaiELIAskACAJDwtIAQh/IwAhAkEQIQMgAiADayEEIAQgATYCCCAEIAA2AgQgBCgCBCEFQQghBiAEIAZqIQcgByEIIAgoAgAhCSAFIAk2AgAgBQ8LmgECDn8DfiMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRDkESEGIAQhByAGKQIAIRAgByAQNwIAIAQoAgghCCAIEOQRIQkgBCgCDCEKIAkpAgAhESAKIBE3AgAgBCELIAsQ5BEhDCAEKAIIIQ0gDCkCACESIA0gEjcCAEEQIQ4gBCAOaiEPIA8kAA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAhAhBSAFDwuGAgEifyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIIIAUgATYCBCAFIAI2AgAgBSgCCCEGIAUoAgQhByAFKAIAIQggBiAHIAgQzhEhCUEBIQogCSAKcSELAkACQCALDQBBASEMQQEhDSAMIA1xIQ4gBSAOOgAPDAELIAUoAgQhDyAPEKsPIRBBASERIBAgEXEhEiAFKAIAIRMgExCrDyEUQQEhFSAUIBVxIRYgEiAWcyEXQQAhGCAXIRkgGCEaIBkgGkchG0F/IRwgGyAccyEdQQEhHiAdIB5xIR8gBSAfOgAPCyAFLQAPISBBASEhICAgIXEhIkEQISMgBSAjaiEkICQkACAiDwuLBAFBfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIYIAUgATYCFCAFIAI2AhAgBSgCFCEGIAYQqw8hB0EBIQggByAIcSEJIAUgCToADyAFKAIQIQogChCrDyELQQEhDCALIAxxIQ0gBSANOgAOIAUtAA8hDkEBIQ8gDiAPcSEQAkACQCAQRQ0AIAUtAA4hEUEBIRIgESAScSETIBMNACAFKAIUIRQgFBCgDyEVIAUoAhAhFiAWEKAPIRcgFSAXEOURIRhBACEZQQEhGiAYIBpxIRsgGSEcAkAgG0UNACAFKAIUIR0gHRDADyEeIAUoAhAhHyAfEKAPISAgHiAgEOURISEgISEcCyAcISJBASEjICIgI3EhJCAFICQ6AB8MAQsgBS0ADyElQQEhJiAlICZxIScCQCAnDQAgBS0ADiEoQQEhKSAoIClxISogKkUNACAFKAIQISsgKxCgDyEsIAUoAhQhLSAtEKAPIS4gLCAuEOURIS9BACEwQQEhMSAvIDFxITIgMCEzAkAgMkUNACAFKAIQITQgNBDADyE1IAUoAhQhNiA2EKAPITcgNSA3EOURITggOCEzCyAzITlBASE6IDkgOnEhOyAFIDs6AB8MAQtBASE8QQEhPSA8ID1xIT4gBSA+OgAfCyAFLQAfIT9BASFAID8gQHEhQUEgIUIgBSBCaiFDIEMkACBBDwvwAQEZfyMAIQNBECEEIAMgBGshBSAFIAA2AgggASEGIAUgBjoAByACIQcgBSAHOgAGIAUoAgghCCAFIAg2AgxBACEJIAggCTYCAEEAIQogCCAKNgIEQQAhCyAIIAs2AghBACEMIAggDDYCDEEAIQ0gCCANNgIQQQAhDiAIIA42AhQgBS0AByEPQQEhECAPIBBxIRECQCARRQ0AIAgoAhQhEkEBIRMgEiATciEUIAggFDYCFAsgBS0ABiEVQQEhFiAVIBZxIRcCQCAXRQ0AIAgoAhQhGEECIRkgGCAZciEaIAggGjYCFAsgBSgCDCEbIBsPC6IBARJ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIEIQYgBRDkECEHIAcoAgAhCCAGIQkgCCEKIAkgCkkhC0EBIQwgCyAMcSENAkACQCANRQ0AIAQoAgghDiAOEOYRIQ8gBSAPEOcRDAELIAQoAgghECAQEOYRIREgBSAREOgRC0EQIRIgBCASaiETIBMkAA8LNgEHfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgQhBUFoIQYgBSAGaiEHIAcPC0wBC38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBCgCBCEGIAUhByAGIQggByAIRiEJQQEhCiAJIApxIQsgCw8LSwEJfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIAIQYgBCgCCCEHQQwhCCAHIAhsIQkgBiAJaiEKIAoPCzcBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCAA8LWwEJfyMAIQNBECEEIAMgBGshBSAFJAAgBSABNgIMIAUgAjYCCCAFKAIMIQYgBhDpESEHIAUoAgghCCAIEOkRIQkgACAHIAkQ6hEaQRAhCiAFIApqIQsgCyQADwuBAQEOfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQ6REhByAHKAIAIQggBSAINgIAIAQoAgghCUEEIQogCSAKaiELIAsQ6REhDCAMKAIAIQ0gBSANNgIEQRAhDiAEIA5qIQ8gDyQAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwukAQESfyMAIQNBICEEIAMgBGshBSAFJAAgBSABNgIQIAUgADYCDCAFIAI2AgggBSgCDCEGIAUhB0EQIQggBSAIaiEJIAkhCiAKKAIAIQsgByALNgIAIAUoAgghDCAMEPgRIQ0gBSgCCCEOIA4Q1xEhDyAFKAIAIRAgBiAQIA0gDxD5ESERIAUgETYCGCAFKAIYIRJBICETIAUgE2ohFCAUJAAgEg8LOQEFfyMAIQJBECEDIAIgA2shBCAEIAE2AgggBCAANgIEIAQoAgQhBSAEKAIIIQYgBSAGNgIAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC6IBARJ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIEIQYgBRDMEiEHIAcoAgAhCCAGIQkgCCEKIAkgCkkhC0EBIQwgCyAMcSENAkACQCANRQ0AIAQoAgghDiAOENwRIQ8gBSAPEM0SDAELIAQoAgghECAQENwRIREgBSAREM4SC0EQIRIgBCASaiETIBMkAA8LVQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEKAIAIQUgBCAFENESIQYgAyAGNgIIIAMoAgghB0EQIQggAyAIaiEJIAkkACAHDwtVAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQoAgQhBSAEIAUQ0RIhBiADIAY2AgggAygCCCEHQRAhCCADIAhqIQkgCSQAIAcPC8IBARp/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhggBSABNgIQQQghBiAFIAZqIQcgByEIQRghCSAFIAlqIQogCiELIAsoAgAhDCAIIAw2AgAgBSENQRAhDiAFIA5qIQ8gDyEQIBAoAgAhESANIBE2AgBBECESIAUgEmohEyATIRRBGCEVIAUgFWohFiAWIRcgFCAXEM8SIRggBSgCCCEZIAUoAgAhGiAZIBogAiAYENASQSAhGyAFIBtqIRwgHCQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC4oBAg1/AX4jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxDhESEIIAgpAgAhECAGIBA3AgBBCCEJIAYgCWohCiAFKAIEIQsgCxDiESEMIAwoAgAhDSAKIA02AgBBECEOIAUgDmohDyAPJAAgBg8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC7MBARl/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIAIQYgBCgCCCEHIAcQ1A4hCCAGIQkgCCEKIAkgCkchC0EBIQxBASENIAsgDXEhDiAMIQ8CQCAODQAgBSgCBCEQIAQoAgghESARENUOIRIgECETIBIhFCATIBRHIRUgFSEPCyAPIRZBASEXIBYgF3EhGEEQIRkgBCAZaiEaIBokACAYDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LswEBFX8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFQQghBiAEIAZqIQcgByEIQQEhCSAIIAUgCRDrERogBRCHECEKIAQoAgwhCyALEPoQIQwgBCgCGCENIA0Q7BEhDiAKIAwgDhDtESAEKAIMIQ9BGCEQIA8gEGohESAEIBE2AgxBCCESIAQgEmohEyATIRQgFBDuERpBICEVIAQgFWohFiAWJAAPC90BARh/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAFEIcQIQYgBCAGNgIUIAUQmwwhB0EBIQggByAIaiEJIAUgCRDvESEKIAUQmwwhCyAEKAIUIQwgBCENIA0gCiALIAwQiBAaIAQoAhQhDiAEKAIIIQ8gDxD6ECEQIAQoAhghESAREOwRIRIgDiAQIBIQ7REgBCgCCCETQRghFCATIBRqIRUgBCAVNgIIIAQhFiAFIBYQiRAgBCEXIBcQihAaQSAhGCAEIBhqIRkgGSQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LfQEMfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHEOkRIQggCCgCACEJIAYgCTYCACAFKAIEIQogChDpESELIAsoAgAhDCAGIAw2AgRBECENIAUgDWohDiAOJAAgBg8LgwEBDX8jACEDQRAhBCADIARrIQUgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAGIAc2AgAgBSgCCCEIIAgoAgQhCSAGIAk2AgQgBSgCCCEKIAooAgQhCyAFKAIEIQxBGCENIAwgDWwhDiALIA5qIQ8gBiAPNgIIIAYPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhwgBSABNgIYIAUgAjYCFCAFKAIcIQYgBSgCGCEHIAUoAhQhCCAIEOwRIQkgBiAHIAkQ8BFBICEKIAUgCmohCyALJAAPCzkBBn8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCgCACEGIAYgBTYCBCAEDwuyAgElfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIYIAQgATYCFCAEKAIYIQUgBRDyESEGIAQgBjYCECAEKAIUIQcgBCgCECEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AIAUQtRoACyAFEIYQIQ4gBCAONgIMIAQoAgwhDyAEKAIQIRBBASERIBAgEXYhEiAPIRMgEiEUIBMgFE8hFUEBIRYgFSAWcSEXAkACQCAXRQ0AIAQoAhAhGCAEIBg2AhwMAQsgBCgCDCEZQQEhGiAZIBp0IRsgBCAbNgIIQQghHCAEIBxqIR0gHSEeQRQhHyAEIB9qISAgICEhIB4gIRBnISIgIigCACEjIAQgIzYCHAsgBCgCHCEkQSAhJSAEICVqISYgJiQAICQPC2EBCX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCFCAFIAE2AhAgBSACNgIMIAUoAhQhBiAFKAIQIQcgBSgCDCEIIAgQ7BEhCSAGIAcgCRDxEUEgIQogBSAKaiELIAskAA8LoQECDn8DfiMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAUoAgQhByAHEOwRIQggCCkCACERIAYgETcCAEEQIQkgBiAJaiEKIAggCWohCyALKQIAIRIgCiASNwIAQQghDCAGIAxqIQ0gCCAMaiEOIA4pAgAhEyANIBM3AgBBECEPIAUgD2ohECAQJAAPC4QBARF/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ8xEhBSAFEPQRIQYgAyAGNgIIEHQhByADIAc2AgRBCCEIIAMgCGohCSAJIQpBBCELIAMgC2ohDCAMIQ0gCiANEHUhDiAOKAIAIQ9BECEQIAMgEGohESARJAAgDw8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQ9hEhB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ9REhBUEQIQYgAyAGaiEHIAckACAFDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQ8xAhBUEQIQYgAyAGaiEHIAckACAFDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ9xEhBUEQIQYgAyAGaiEHIAckACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC4UDAS9/IwAhBEHAACEFIAQgBWshBiAGJAAgBiABNgIwIAYgADYCLCAGIAI2AiggBiADNgIkIAYoAiwhB0EQIQggBiAIaiEJIAkhCkEwIQsgBiALaiEMIAwhDSANKAIAIQ4gCiAONgIAIAYoAighDyAGKAIQIRBBICERIAYgEWohEiASIRNBHCEUIAYgFGohFSAVIRYgByAQIBMgFiAPEPoRIRcgBiAXNgIYIAYoAhghGCAYKAIAIRkgBiAZNgIMIAYoAhghGiAaKAIAIRtBACEcIBshHSAcIR4gHSAeRiEfQQEhICAfICBxISECQCAhRQ0AIAYoAiQhIiAiEPsRISMgBiEkICQgByAjEPwRIAYoAiAhJSAGKAIYISYgBiEnICcQ/REhKCAHICUgJiAoEP4RIAYhKSApEP8RISogBiAqNgIMIAYhKyArEIASGgsgBigCDCEsQTghLSAGIC1qIS4gLiEvIC8gLBCBEhogBigCOCEwQcAAITEgBiAxaiEyIDIkACAwDwu+CgGgAX8jACEFQeAAIQYgBSAGayEHIAckACAHIAE2AlggByAANgJUIAcgAjYCUCAHIAM2AkwgByAENgJIIAcoAlQhCCAIEMkRIQkgByAJNgI4IAcoAjghCkHAACELIAcgC2ohDCAMIQ0gDSAKENkRGkHYACEOIAcgDmohDyAPIRBBwAAhESAHIBFqIRIgEiETIBAgExCCEiEUQQEhFUEBIRYgFCAWcSEXIBUhGAJAIBcNACAIEIMSIRkgBygCSCEaQdgAIRsgByAbaiEcIBwhHSAdEIQSIR4gGSAaIB4QhRIhHyAfIRgLIBghIEEBISEgICAhcSEiAkACQCAiRQ0AQTAhIyAHICNqISQgJCElQdgAISYgByAmaiEnICchKCAoKAIAISkgJSApNgIAIAgQhhIhKiAHICo2AiAgBygCICErQSghLCAHICxqIS0gLSEuIC4gKxDZERpBMCEvIAcgL2ohMCAwITFBKCEyIAcgMmohMyAzITQgMSA0EIISITVBASE2QQEhNyA1IDdxITggNiE5AkAgOA0AIAgQgxIhOkEwITsgByA7aiE8IDwhPSA9EIcSIT4gPhCEEiE/IAcoAkghQCA6ID8gQBCIEiFBIEEhOQsgOSFCQQEhQyBCIENxIUQCQCBERQ0AIAcoAlghRSBFKAIAIUZBACFHIEYhSCBHIUkgSCBJRiFKQQEhSyBKIEtxIUwCQCBMRQ0AIAcoAlghTSAHKAJQIU4gTiBNNgIAIAcoAlAhTyBPKAIAIVAgByBQNgJcDAMLIAcoAjAhUSAHKAJQIVIgUiBRNgIAIAcoAjAhU0EEIVQgUyBUaiFVIAcgVTYCXAwCCyAHKAJQIVYgBygCSCFXIAggViBXEIkSIVggByBYNgJcDAELIAgQgxIhWUHYACFaIAcgWmohWyBbIVwgXBCEEiFdIAcoAkghXiBZIF0gXhCIEiFfQQEhYCBfIGBxIWECQCBhRQ0AQRAhYiAHIGJqIWMgYyFkQdgAIWUgByBlaiFmIGYhZyBnKAIAIWggZCBoNgIAIAcoAhAhaUEBIWogaSBqEIoSIWsgByBrNgIYIAgQyREhbCAHIGw2AgAgBygCACFtQQghbiAHIG5qIW8gbyFwIHAgbRDZERpBGCFxIAcgcWohciByIXNBCCF0IAcgdGohdSB1IXYgcyB2EIISIXdBASF4QQEheSB3IHlxIXogeCF7AkAgeg0AIAgQgxIhfCAHKAJIIX1BGCF+IAcgfmohfyB/IYABIIABEIQSIYEBIHwgfSCBARCFEiGCASCCASF7CyB7IYMBQQEhhAEggwEghAFxIYUBAkAghQFFDQBB2AAhhgEgByCGAWohhwEghwEhiAEgiAEQixIhiQEgiQEoAgQhigFBACGLASCKASGMASCLASGNASCMASCNAUYhjgFBASGPASCOASCPAXEhkAECQCCQAUUNACAHKAJYIZEBIAcoAlAhkgEgkgEgkQE2AgAgBygCWCGTAUEEIZQBIJMBIJQBaiGVASAHIJUBNgJcDAMLIAcoAhghlgEgBygCUCGXASCXASCWATYCACAHKAJQIZgBIJgBKAIAIZkBIAcgmQE2AlwMAgsgBygCUCGaASAHKAJIIZsBIAggmgEgmwEQiRIhnAEgByCcATYCXAwBCyAHKAJYIZ0BIAcoAlAhngEgngEgnQE2AgAgBygCWCGfASAHKAJMIaABIKABIJ8BNgIAIAcoAkwhoQEgByChATYCXAsgBygCXCGiAUHgACGjASAHIKMBaiGkASCkASQAIKIBDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LqwIBIn8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCHCAFIAE2AhggBSACNgIUIAUoAhghBiAGEIwSIQcgBSAHNgIQQQAhCEEBIQkgCCAJcSEKIAUgCjoADyAFKAIQIQtBASEMIAsgDBCNEiENIAUoAhAhDiAFIQ9BACEQQQEhESAQIBFxIRIgDyAOIBIQjhIaIAUhEyAAIA0gExCPEhogBSgCECEUIAAQkBIhFUEQIRYgFSAWaiEXIBcQkRIhGCAFKAIUIRkgGRD7ESEaIBQgGCAaEJISIAAQkxIhG0EBIRwgGyAcOgAEQQEhHUEBIR4gHSAecSEfIAUgHzoADyAFLQAPISBBASEhICAgIXEhIgJAICINACAAEIASGgtBICEjIAUgI2ohJCAkJAAPC0UBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCVEiEFIAUoAgAhBkEQIQcgAyAHaiEIIAgkACAGDwu5AgEjfyMAIQRBECEFIAQgBWshBiAGJAAgBiAANgIMIAYgATYCCCAGIAI2AgQgBiADNgIAIAYoAgwhByAGKAIAIQhBACEJIAggCTYCACAGKAIAIQpBACELIAogCzYCBCAGKAIIIQwgBigCACENIA0gDDYCCCAGKAIAIQ4gBigCBCEPIA8gDjYCACAHEMUOIRAgECgCACERIBEoAgAhEkEAIRMgEiEUIBMhFSAUIBVHIRZBASEXIBYgF3EhGAJAIBhFDQAgBxDFDiEZIBkoAgAhGiAaKAIAIRsgBxDFDiEcIBwgGzYCAAsgBxDEDiEdIB0oAgAhHiAGKAIEIR8gHygCACEgIB4gIBCTCCAHEJQSISEgISgCACEiQQEhIyAiICNqISQgISAkNgIAQRAhJSAGICVqISYgJiQADwtlAQt/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQlhIhBSAFKAIAIQYgAyAGNgIIIAQQlhIhB0EAIQggByAINgIAIAMoAgghCUEQIQogAyAKaiELIAskACAJDwtCAQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQAhBSAEIAUQlxJBECEGIAMgBmohByAHJAAgBA8LOQEFfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGNgIAIAUPC1oBDH8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCACEGIAQoAgghByAHKAIAIQggBiEJIAghCiAJIApGIQtBASEMIAsgDHEhDSANDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhCZEiEHQRAhCCADIAhqIQkgCSQAIAcPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCLEiEFQRAhBiAFIAZqIQdBECEIIAMgCGohCSAJJAAgBw8LcAEMfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAFKAIEIQggCBCaEiEJIAYgByAJEJsSIQpBASELIAogC3EhDEEQIQ0gBSANaiEOIA4kACAMDwtjAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQxQ4hBSAFKAIAIQZBCCEHIAMgB2ohCCAIIQkgCSAGEJgSGiADKAIIIQpBECELIAMgC2ohDCAMJAAgCg8LTAEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIAIQUgBRDUCCEGIAQgBjYCAEEQIQcgAyAHaiEIIAgkACAEDwtwAQx/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQmhIhCCAFKAIEIQkgBiAIIAkQmxIhCkEBIQsgCiALcSEMQRAhDSAFIA1qIQ4gDiQAIAwPC6AFAUp/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhggBSABNgIUIAUgAjYCECAFKAIYIQYgBhCcEiEHIAUgBzYCDCAGEJ0SIQggBSAINgIIIAUoAgwhCUEAIQogCSELIAohDCALIAxHIQ1BASEOIA0gDnEhDwJAAkAgD0UNAANAIAYQgxIhECAFKAIQIREgBSgCDCESQRAhEyASIBNqIRQgECARIBQQhRIhFUEBIRYgFSAWcSEXAkACQCAXRQ0AIAUoAgwhGCAYKAIAIRlBACEaIBkhGyAaIRwgGyAcRyEdQQEhHiAdIB5xIR8CQAJAIB9FDQAgBSgCDCEgICAQiQghISAFICE2AgggBSgCDCEiICIoAgAhIyAFICM2AgwMAQsgBSgCDCEkIAUoAhQhJSAlICQ2AgAgBSgCFCEmICYoAgAhJyAFICc2AhwMBQsMAQsgBhCDEiEoIAUoAgwhKUEQISogKSAqaiErIAUoAhAhLCAoICsgLBCIEiEtQQEhLiAtIC5xIS8CQAJAIC9FDQAgBSgCDCEwIDAoAgQhMUEAITIgMSEzIDIhNCAzIDRHITVBASE2IDUgNnEhNwJAAkAgN0UNACAFKAIMIThBBCE5IDggOWohOiA6EIkIITsgBSA7NgIIIAUoAgwhPCA8KAIEIT0gBSA9NgIMDAELIAUoAgwhPiAFKAIUIT8gPyA+NgIAIAUoAgwhQEEEIUEgQCBBaiFCIAUgQjYCHAwGCwwBCyAFKAIMIUMgBSgCFCFEIEQgQzYCACAFKAIIIUUgBSBFNgIcDAQLCwwACwALIAYQxA4hRiAFKAIUIUcgRyBGNgIAIAUoAhQhSCBIKAIAIUkgBSBJNgIcCyAFKAIcIUpBICFLIAUgS2ohTCBMJAAgSg8LhwEBEX8jACECQSAhAyACIANrIQQgBCQAIAQgADYCECAEIAE2AgwgBCgCDCEFQRAhBiAEIAZqIQcgByEIIAggBRCeEkEYIQkgBCAJaiEKIAohC0EQIQwgBCAMaiENIA0hDiAOKAIAIQ8gCyAPNgIAIAQoAhghEEEgIREgBCARaiESIBIkACAQDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBBCEFIAQgBWohBiAGELQSIQdBECEIIAMgCGohCSAJJAAgBw8LVAEJfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGQQAhByAFIAYgBxC1EiEIQRAhCSAEIAlqIQogCiQAIAgPC10BCX8jACEDQRAhBCADIARrIQUgBSAANgIMIAUgATYCCCACIQYgBSAGOgAHIAUoAgwhByAFKAIIIQggByAINgIAIAUtAAchCUEBIQogCSAKcSELIAcgCzoABCAHDwtsAQt/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCBCEHIAcQthIhCEEIIQkgBSAJaiEKIAohCyAGIAsgCBC3EhpBECEMIAUgDGohDSANJAAgBg8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEJUSIQUgBSgCACEGQRAhByADIAdqIQggCCQAIAYPC0UBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBC5EiEFIAUQuhIhBkEQIQcgAyAHaiEIIAgkACAGDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhwgBSABNgIYIAUgAjYCFCAFKAIcIQYgBSgCGCEHIAUoAhQhCCAIEPsRIQkgBiAHIAkQuBJBICEKIAUgCmohCyALJAAPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBC7EiEFQRAhBiADIAZqIQcgByQAIAUPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEMUSIQdBECEIIAMgCGohCSAJJAAgBw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMMSIQVBECEGIAMgBmohByAHJAAgBQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMYSIQVBECEGIAMgBmohByAHJAAgBQ8LqAEBE38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQlhIhBiAGKAIAIQcgBCAHNgIEIAQoAgghCCAFEJYSIQkgCSAINgIAIAQoAgQhCkEAIQsgCiEMIAshDSAMIA1HIQ5BASEPIA4gD3EhEAJAIBBFDQAgBRC7EiERIAQoAgQhEiARIBIQxxILQRAhEyAEIBNqIRQgFCQADws5AQV/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAY2AgAgBQ8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEEIQUgBCAFaiEGIAYQnxIhB0EQIQggAyAIaiEJIAkkACAHDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LoAsBtAF/IwAhA0HQACEEIAMgBGshBSAFJAAgBSAANgJIIAUgATYCRCAFIAI2AkAgBSgCSCEGIAUoAkQhByAGIAcQoBIhCCAFIAg2AjwgBSgCQCEJIAYgCRCgEiEKIAUgCjYCOCAFKAI8IQsgBiALEKESIQwgBSAMNgI0IAUoAjghDSAGIA0QoRIhDiAFIA42AjAgBSgCNCEPIA8Q1A4hECAFKAIwIREgERDUDiESIBAhEyASIRQgEyAUSCEVQQEhFiAVIBZxIRcCQAJAIBdFDQBBASEYIAYgGGohGSAFKAJEIRogGhC6DyEbIAUoAkQhHCAcELgPIR0gBSgCMCEeIBkgGyAdIB4QohIhH0EBISAgHyAgcSEhIAUgIToATwwBCyAFKAI0ISIgIhDUDiEjIAUoAjAhJCAkENQOISUgIyEmICUhJyAmICdKIShBASEpICggKXEhKgJAICpFDQBBASErIAYgK2ohLCAFKAJAIS0gLRC6DyEuIAUoAkAhLyAvELgPITAgBSgCNCExICwgLiAwIDEQohIhMkF/ITMgMiAzcyE0QQEhNSA0IDVxITYgBSA2OgBPDAELIAUoAjwhNyA3EMwRITggBSgCOCE5IDkQzBEhOiA4ITsgOiE8IDsgPEYhPUEBIT4gPSA+cSE/AkAgP0UNACAFKAJEIUBBKCFBIAUgQWohQiBCIUNBASFEQQEhRSBEIEVxIUYgQyAGIEAgRhCjEiAFKAJAIUdBICFIIAUgSGohSSBJIUpBASFLQQEhTCBLIExxIU0gSiAGIEcgTRCjEkEoIU4gBSBOaiFPIE8hUEEgIVEgBSBRaiFSIFIhUyBQIFMQ8QYhVEEBIVUgVCBVcSFWIAUgVjoATwwBCyAFKAI8IVcgVxDMESFYIAUoAjghWSBZEMwRIVogWCFbIFohXCBbIFxJIV1BASFeIF0gXnEhXwJAIF9FDQAgBSgCRCFgQRghYSAFIGFqIWIgYiFjQQAhZEEBIWUgZCBlcSFmIGMgBiBgIGYQoxIgBSgCQCFnQRAhaCAFIGhqIWkgaSFqQQEha0EBIWwgayBscSFtIGogBiBnIG0QoxIgBSgCGCFuIAUoAhAhbyBuIXAgbyFxIHAgcUchckEBIXMgciBzcSF0AkAgdEUNACAFKAIYIXUgBSgCECF2IHUhdyB2IXggdyB4SCF5QQEheiB5IHpxIXsgBSB7OgBPDAILIAUoAjwhfCB8EKsPIX1BASF+IH0gfnEhfwJAAkAgfw0AIAUoAhwhgAFBACGBASCAASGCASCBASGDASCCASCDAUghhAEghAEhhQEMAQtBACGGASCGASGFAQsghQEhhwFBASGIASCHASCIAXEhiQEgBSCJAToATwwBCyAFKAJEIYoBQQghiwEgBSCLAWohjAEgjAEhjQFBASGOAUEBIY8BII4BII8BcSGQASCNASAGIIoBIJABEKMSIAUoAkAhkQEgBSGSAUEAIZMBQQEhlAEgkwEglAFxIZUBIJIBIAYgkQEglQEQoxIgBSgCCCGWASAFKAIAIZcBIJYBIZgBIJcBIZkBIJgBIJkBRyGaAUEBIZsBIJoBIJsBcSGcAQJAIJwBRQ0AIAUoAgghnQEgBSgCACGeASCdASGfASCeASGgASCfASCgAUghoQFBASGiASChASCiAXEhowEgBSCjAToATwwBCyAFKAI4IaQBIKQBEKsPIaUBQQEhpgEgpQEgpgFxIacBAkACQCCnAQ0AIAUoAgQhqAFBACGpASCoASGqASCpASGrASCqASCrAUohrAEgrAEhrQEMAQtBASGuASCuASGtAQsgrQEhrwFBASGwASCvASCwAXEhsQEgBSCxAToATwsgBS0ATyGyAUEBIbMBILIBILMBcSG0AUHQACG1ASAFILUBaiG2ASC2ASQAILQBDwtFAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQsBIhBSAFKAIAIQZBECEHIAMgB2ohCCAIJAAgBg8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEELASIQUgBRCJCCEGQRAhByADIAdqIQggCCQAIAYPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQshJBECEHIAQgB2ohCCAIJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwu5AQEVfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIIIAQgATYCBCAEKAIEIQUgBRC6DyEGIAYQzBEhByAEKAIEIQggCBC4DyEJIAkQzBEhCiAHIQsgCiEMIAsgDEshDUEBIQ4gDSAOcSEPAkACQCAPRQ0AIAQoAgQhECAQELoPIREgBCARNgIMDAELIAQoAgQhEiASELgPIRMgBCATNgIMCyAEKAIMIRRBECEVIAQgFWohFiAWJAAgFA8LpQEBE38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEKAPIQcgBCgCCCEIIAgQwA8hCSAFIAcgCRD6DCEKQQEhCyAKIAtxIQwCQAJAIAxFDQAgBCgCCCENIA0QoA8hDiAOIQ8MAQsgBCgCCCEQIBAQwA8hESARIQ8LIA8hEkEQIRMgBCATaiEUIBQkACASDwu5AwEzfyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIYIAYgATYCFCAGIAI2AhAgBiADNgIMIAYoAhghByAGKAIUIQggCBCrDyEJQQEhCiAJIApxIQsCQAJAIAsNACAGKAIQIQwgDBCrDyENQQEhDiANIA5xIQ8CQCAPDQAgBigCFCEQIAYoAhAhESAGKAIMIRIgByAQIBEgEhCkEiETQQEhFCATIBRxIRUgBiAVOgAfDAILIAYoAhQhFiAGKAIQIRcgBigCDCEYQQAhGUEBIRogGSAacSEbIAcgFiAXIBggGxClEiEcQQEhHSAcIB1xIR4gBiAeOgAfDAELIAYoAhAhHyAfEKsPISBBASEhICAgIXEhIgJAICINACAGKAIQISMgBigCFCEkIAYoAgwhJUEBISZBASEnICYgJ3EhKCAHICMgJCAlICgQpRIhKUEBISogKSAqcSErIAYgKzoAHwwBCyAGKAIUISwgBigCECEtIAYoAgwhLiAHICwgLSAuEKYSIS9BASEwIC8gMHEhMSAGIDE6AB8LIAYtAB8hMkEBITMgMiAzcSE0QSAhNSAGIDVqITYgNiQAIDQPC/wEAVF/IwAhBEEwIQUgBCAFayEGIAYkACAGIAE2AiwgBiACNgIoIAMhByAGIAc6ACcgBigCKCEIIAgQug8hCSAJEMwRIQogBigCKCELIAsQuA8hDCAMEMwRIQ0gCiEOIA0hDyAOIA9GIRBBASERIBAgEXEhEgJAAkAgEkUNACAGKAIoIRMgExC6DyEUIBQQkhEhFSAGIBU2AiBBACEWIAYgFjYCHEEgIRcgBiAXaiEYIBghGUEcIRogBiAaaiEbIBshHCAAIBkgHBCABgwBCyAGKAIoIR0gHRC6DyEeIB4QzBEhHyAGKAIoISAgIBC4DyEhICEQzBEhIiAfISMgIiEkICMgJEshJUEBISYgJSAmcSEnAkAgJ0UNACAGLQAnIShBASEpICggKXEhKgJAICoNACAGKAIoISsgKxC6DyEsICwQqw8hLUEBIS4gLSAucSEvIC9FDQAgBigCKCEwIDAQug8hMSAxEKMPITJBASEzIDIgM3EhNCA0RQ0AIAYoAighNSA1ELoPITYgNhCSESE3IAYgNzYCGEEBITggBiA4NgIUQRghOSAGIDlqITogOiE7QRQhPCAGIDxqIT0gPSE+IAAgOyA+EIAGDAILIAYoAighPyA/ELoPIUAgQBCnEiFBIAYgQTYCEEEBIUIgBiBCNgIMQRAhQyAGIENqIUQgRCFFQQwhRiAGIEZqIUcgRyFIIAAgRSBIEIAGDAELIAYoAighSSBJELgPIUogShCSESFLIAYgSzYCCEF/IUwgBiBMNgIEQQghTSAGIE1qIU4gTiFPQQQhUCAGIFBqIVEgUSFSIAAgTyBSEIAGC0EwIVMgBiBTaiFUIFQkAA8LogUDSn8IfgR8IwAhBEEwIQUgBCAFayEGIAYkACAGIAA2AiggBiABNgIkIAYgAjYCICAGIAM2AhwgBigCKCEHIAYoAiQhCCAIEKAPIQkgBiAJNgIYIAYoAiAhCiAKEKAPIQsgBiALNgIUIAYoAhghDCAMENQOIQ0gBigCFCEOIA4Q1A4hDyANIRAgDyERIBAgEUohEkEBIRMgEiATcSEUAkACQAJAIBRFDQAgBigCHCEVIBUQ1Q4hFiAGKAIYIRcgFxDVDiEYIBYhGSAYIRogGSAaTCEbQQEhHCAbIBxxIR0CQCAdRQ0AQQAhHkEBIR8gHiAfcSEgIAYgIDoALwwDCwwBCyAGKAIYISEgIRDUDiEiIAYoAhQhIyAjENQOISQgIiElICQhJiAlICZIISdBASEoICcgKHEhKQJAAkAgKUUNACAGKAIcISogKhDVDiErIAYoAhQhLCAsENUOIS0gKyEuIC0hLyAuIC9OITBBASExIDAgMXEhMgJAIDJFDQBBASEzQQEhNCAzIDRxITUgBiA1OgAvDAQLDAELIAYoAhghNiA2ENUOITcgNyE4IDisIU4gBigCFCE5IDkQ1Q4hOiA6ITsgO6whTyBOIE98IVAgBigCHCE8IDwQ1Q4hPSA9IT4gPqwhUUIBIVIgUSBShiFTIFAhVCBTIVUgVCBVUyE/QQEhQCA/IEBxIUEgBiBBOgAvDAILCyAGKAIkIUIgBigCHCFDIAcgQiBDEKgSIVYgBiBWOQMIIAYoAiAhRCAGKAIcIUUgByBEIEUQqBIhVyAGIFc5AwAgBisDCCFYIAYrAwAhWSBYIFljIUZBASFHIEYgR3EhSCAGIEg6AC8LIAYtAC8hSUEBIUogSSBKcSFLQTAhTCAGIExqIU0gTSQAIEsPC4YDAip/BHwjACEFQTAhBiAFIAZrIQcgByQAIAcgADYCKCAHIAE2AiQgByACNgIgIAcgAzYCHCAEIQggByAIOgAbIAcoAighCSAHKAIkIQogBygCICELIAcoAhwhDCAHLQAbIQ1BASEOIA0gDnEhDyAJIAogCyAMIA8QqRIhECAHIBA2AhQgBygCFCERAkACQCARRQ0AIAcoAhQhEkF/IRMgEiEUIBMhFSAUIBVGIRZBASEXIBYgF3EhGCAHIBg6AC8MAQsgBygCJCEZIAcoAhwhGiAJIBkgGhCoEiEvIAcgLzkDCCAHKAIgIRsgBygCHCEcIAkgGyAcEKoSITAgByAwOQMAIActABshHUEBIR4gHSAecSEfIAcrAwghMSAHKwMAITIgMSAyYyEgQQEhISAgICFxISIgHyAicyEjQQAhJCAjISUgJCEmICUgJkchJ0EBISggJyAocSEpIAcgKToALwsgBy0ALyEqQQEhKyAqICtxISxBMCEtIAcgLWohLiAuJAAgLA8L3QICJX8EfCMAIQRBMCEFIAQgBWshBiAGJAAgBiAANgIoIAYgATYCJCAGIAI2AiAgBiADNgIcIAYoAighByAGKAIkIQggCBDMESEJIAYoAiAhCiAKEMwRIQsgCSEMIAshDSAMIA1GIQ5BASEPIA4gD3EhEAJAAkAgEEUNACAGKAIkIREgERCgDyESIAYoAiQhEyATEMAPIRQgBigCHCEVIBIgFCAVEJMRIRZBASEXIBYhGCAXIRkgGCAZRiEaQQEhGyAaIBtxIRwgBiAcOgAvDAELIAYoAiQhHSAGKAIcIR4gByAdIB4QqhIhKSAGICk5AxAgBigCICEfIAYoAhwhICAHIB8gIBCqEiEqIAYgKjkDCCAGKwMQISsgBisDCCEsICsgLGMhIUEBISIgISAicSEjIAYgIzoALwsgBi0ALyEkQQEhJSAkICVxISZBMCEnIAYgJ2ohKCAoJAAgJg8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQ1Q4hB0EQIQggAyAIaiEJIAkkACAHDwvAAwInfxJ8IwAhA0HAACEEIAMgBGshBSAFJAAgBSAANgI8IAUgATYCOCAFIAI2AjQgBSgCPCEGQQEhByAGIAdqIQggBSgCOCEJIAkQqxIhCiAFIAo2AiRBJCELIAUgC2ohDCAMIQ0gCCANEMcPISpBASEOIAYgDmohDyAFKAI0IRAgEBDUDiERIAUgETYCIEEgIRIgBSASaiETIBMhFCAPIBQQxw8hKyAqICuhISwgBSAsOQMoQQEhFSAGIBVqIRYgBSgCOCEXIBcQrBIhGCAFIBg2AhRBFCEZIAUgGWohGiAaIRsgFiAbEMcPIS1BASEcIAYgHGohHSAFKAI0IR4gHhDVDiEfIAUgHzYCEEEQISAgBSAgaiEhICEhIiAdICIQxw8hLiAtIC6hIS8gBSAvOQMYIAUrAyghMCAFKwMoITEgMCAxoiEyIAUrAxghMyAFKwMYITQgMyA0oiE1IDIgNaAhNkEBISMgBiAjaiEkRAAAAAAAAABAITcgBSA3OQMIQQghJSAFICVqISYgJiEnICQgJxDJDyE4IAUrAyghOSA4IDmiITogNiA6oyE7QcAAISggBSAoaiEpICkkACA7DwuKEAPDAX8ffAx+IwAhBUGQASEGIAUgBmshByAHJAAgByAANgKIASAHIAE2AoQBIAcgAjYCgAEgByADNgJ8IAQhCCAHIAg6AHsgBygCiAEhCSAHKAKEASEKIAoQoA8hCyAHIAs2AnQgBygCgAEhDCAMEKAPIQ0gByANNgJwIAcoAoABIQ4gDhDADyEPIAcgDzYCbCAHKAJwIRAgBygCbCERIAcoAnwhEiAQIBEgEhCTESETQX8hFCATIRUgFCEWIBUgFkchF0EBIRggFyAYcSEZAkACQCAZRQ0AIAcoAoABIRogGhCtEiEbQX8hHCAbIBxzIR1BfyEeQQEhH0EBISAgHSAgcSEhIB4gHyAhGyEiIAcgIjYCjAEMAQtBASEjIAkgI2ohJCAHKAJ8ISUgJRDUDiEmIAcgJjYCXEHcACEnIAcgJ2ohKCAoISkgJCApEMcPIcgBQQEhKiAJICpqISsgBygCdCEsICwQ1A4hLSAHIC02AlhB2AAhLiAHIC5qIS8gLyEwICsgMBDHDyHJASDIASDJAaEhygEgByDKATkDYEEBITEgCSAxaiEyIAcoAnwhMyAzENUOITQgByA0NgJMQcwAITUgByA1aiE2IDYhNyAyIDcQxw8hywFBASE4IAkgOGohOSAHKAJ0ITogOhDVDiE7IAcgOzYCSEHIACE8IAcgPGohPSA9IT4gOSA+EMcPIcwBIMsBIMwBoSHNASAHIM0BOQNQQQEhPyAJID9qIUAgBygCbCFBIEEQ1A4hQiAHIEI2AjxBPCFDIAcgQ2ohRCBEIUUgQCBFEMcPIc4BQQEhRiAJIEZqIUcgBygCcCFIIEgQ1A4hSSAHIEk2AjhBOCFKIAcgSmohSyBLIUwgRyBMEMcPIc8BIM4BIM8BoSHQASAHINABOQNAQQEhTSAJIE1qIU4gBygCbCFPIE8Q1Q4hUCAHIFA2AixBLCFRIAcgUWohUiBSIVMgTiBTEMcPIdEBQQEhVCAJIFRqIVUgBygCcCFWIFYQ1Q4hVyAHIFc2AihBKCFYIAcgWGohWSBZIVogVSBaEMcPIdIBINEBINIBoSHTASAHINMBOQMwIAcoAoABIVsgWxCjDyFcQQEhXSBcIF1xIV4CQCBeRQ0AIAcoAnwhXyBfENUOIWAgBygCdCFhIGEQ1Q4hYiBgIWMgYiFkIGMgZEghZUEBIWYgZSBmcSFnAkAgZ0UNACAHLQB7IWhBASFpIGggaXEhaiBqDQBBASFrIAcgazYCjAEMAgsgBygCfCFsIGwQ1Q4hbSAHKAJ0IW4gbhDVDiFvIG0hcCBvIXEgcCBxSiFyQQEhcyByIHNxIXQCQCB0RQ0AIActAHshdUEBIXYgdSB2cSF3IHdFDQBBfyF4IAcgeDYCjAEMAgtBACF5IAcgeTYCjAEMAQsgBygCbCF6IHoQ1A4heyB7IXwgfKwh5wEgBygCcCF9IH0Q1A4hfiB+IX8gf6wh6AEg5wEg6AF9IekBIAcoAmwhgAEggAEQ1Q4hgQEggQEhggEgggGsIeoBIAcoAnAhgwEggwEQ1Q4hhAEghAEhhQEghQGsIesBIOoBIOsBfSHsASAHKAJ8IYYBIIYBENQOIYcBIIcBIYgBIIgBrCHtASAHKAJ0IYkBIIkBENQOIYoBIIoBIYsBIIsBrCHuASDtASDuAX0h7wEgBygCfCGMASCMARDVDiGNASCNASGOASCOAawh8AEgBygCdCGPASCPARDVDiGQASCQASGRASCRAawh8QEg8AEg8QF9IfIBIOkBIOwBIO8BIPIBEK4SIZIBIAcgkgE2AiQgBygCJCGTAUEBIZQBIJMBIZUBIJQBIZYBIJUBIJYBRiGXAUEBIZgBIJcBIJgBcSGZAQJAIJkBRQ0AIAcoAoABIZoBIJoBEK0SIZsBQQEhnAEgmwEgnAFxIZ0BAkAgnQENACAHLQB7IZ4BQX8hnwFBACGgAUEBIaEBIJ4BIKEBcSGiASCfASCgASCiARshowEgByCjATYCjAEMAgsgBy0AeyGkAUEAIaUBQQEhpgFBASGnASCkASCnAXEhqAEgpQEgpgEgqAEbIakBIAcgqQE2AowBDAELIAcrA0Ah1AEgBysDUCHVASAHKwNgIdYBINUBINYBoCHXASDUASDXAaIh2AEgBysDUCHZASAHKwNgIdoBINkBINoBoSHbASDYASDbAaIh3AEgByDcATkDGEEBIaoBIAkgqgFqIasBRAAAAAAAAABAId0BIAcg3QE5AwhBCCGsASAHIKwBaiGtASCtASGuASCrASCuARDJDyHeASAHKwMwId8BIN4BIN8BoiHgASAHKwNgIeEBIOABIOEBoiHiASAHKwNQIeMBIOIBIOMBoiHkASAHIOQBOQMQIAcrAxgh5QEgBysDECHmAUEEIa8BIAkg5QEg5gEgrwEQyg8hsAEgByCwATYCBCAHKAIEIbEBAkAgsQFFDQAgBygCBCGyAUEBIbMBILIBIbQBILMBIbUBILQBILUBRiG2AUEBIbcBILYBILcBcSG4ASAHLQB7IbkBQQEhugEguQEgugFxIbsBILgBILsBcyG8AQJAILwBRQ0AIActAHshvQFBfyG+AUEBIb8BQQEhwAEgvQEgwAFxIcEBIL4BIL8BIMEBGyHCASAHIMIBNgKMAQwCC0EAIcMBIAcgwwE2AowBDAELQQAhxAEgByDEATYCjAELIAcoAowBIcUBQZABIcYBIAcgxgFqIccBIMcBJAAgxQEPC5EJA2N/JXwMfiMAIQNB8AAhBCADIARrIQUgBSQAIAUgADYCZCAFIAE2AmAgBSACNgJcIAUoAmQhBiAFKAJgIQcgBxCjDyEIQQEhCSAIIAlxIQoCQAJAIApFDQBBASELIAYgC2ohDCAFKAJgIQ0gDRCrEiEOIAUgDjYCWEHYACEPIAUgD2ohECAQIREgDCAREMcPIWZBASESIAYgEmohEyAFKAJcIRQgFBDUDiEVIAUgFTYCVEHUACEWIAUgFmohFyAXIRggEyAYEMcPIWcgZiBnoSFoQQEhGSAGIBlqIRpEAAAAAAAA4D8haSAFIGk5A0hByAAhGyAFIBtqIRwgHCEdIBogHRDJDyFqIGggaqIhayAFIGs5A2gMAQsgBSgCYCEeIB4QoA8hHyAFIB82AkQgBSgCYCEgICAQwA8hISAFICE2AkBBASEiIAYgImohIyAFKAJAISQgJBDUDiElIAUgJTYCNEE0ISYgBSAmaiEnICchKCAjICgQxw8hbEEBISkgBiApaiEqIAUoAkQhKyArENQOISwgBSAsNgIwQTAhLSAFIC1qIS4gLiEvICogLxDHDyFtIGwgbaEhbiAFIG45AzhBASEwIAYgMGohMSAFKAJAITIgMhDVDiEzIAUgMzYCJEEkITQgBSA0aiE1IDUhNiAxIDYQxw8hb0EBITcgBiA3aiE4IAUoAkQhOSA5ENUOITogBSA6NgIgQSAhOyAFIDtqITwgPCE9IDggPRDHDyFwIG8gcKEhcSAFIHE5AyggBSsDOCFyIAUrAzghcyByIHOiIXQgBSsDKCF1IAUrAyghdiB1IHaiIXcgdCB3oCF4IAUgeDkDEEEQIT4gBSA+aiE/ID8hQCBAEK8SIXkgBSB5OQMYQSghQSAFIEFqIUIgQiFDIEMQlxEhREEBIUUgRCBFcSFGAkACQCBGDQBBASFHIAYgR2ohSEQAAAAAAADwPyF6IAUgejkDCEEIIUkgBSBJaiFKIEohSyBIIEsQyQ8heyAFKwMoIXwgBSsDGCF9IHwgfaAhfiB7IH6jIX8gBSB/OQMYDAELIAUrAxghgAEgBSsDKCGBASCAASCBAaEhggEgBSsDOCGDASAFKwM4IYQBIIMBIIQBoiGFASCCASCFAaMhhgEgBSCGATkDGAsgBSsDGCGHASAFKAJAIUwgTBDUDiFNIE0hTiBOrCGLASAFKAJEIU8gTxDUDiFQIFAhUSBRrCGMASCLASCMAX0hjQEgBSgCQCFSIFIQ1Q4hUyBTIVQgVKwhjgEgBSgCRCFVIFUQ1Q4hViBWIVcgV6whjwEgjgEgjwF9IZABIAUoAlwhWCBYENQOIVkgWSFaIFqsIZEBIAUoAkQhWyBbENQOIVwgXCFdIF2sIZIBIJEBIJIBfSGTASAFKAJcIV4gXhDVDiFfIF8hYCBgrCGUASAFKAJEIWEgYRDVDiFiIGIhYyBjrCGVASCUASCVAX0hlgEgjQEgkAEgkwEglgEQlBEhiAEghwEgiAGiIYkBIAUgiQE5A2gLIAUrA2ghigFB8AAhZCAFIGRqIWUgZSQAIIoBDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ1A4hBUEQIQYgAyAGaiEHIAckACAFDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ1Q4hBUEQIQYgAyAGaiEHIAckACAFDwtSAQx/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCGCEFQSAhBiAFIAZxIQdBASEIQQAhCSAIIAkgBxshCkEBIQsgCiALcSEMIAwPC3kDBn8EfgF8IwAhBEEgIQUgBCAFayEGIAYkACAGIAA3AxggBiABNwMQIAYgAjcDCCAGIAM3AwAgBikDGCEKIAYpAxAhCyAGKQMIIQwgBikDACENIAogCyAMIA0QlBEhDiAOEJURIQdBICEIIAYgCGohCSAJJAAgBw8LMgIEfwJ8IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCsDACEFIAWfIQYgBg8LUAEKfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEEIQUgBCAFaiEGIAYQsRIhByAHEPcFIQhBECEJIAMgCWohCiAKJAAgCA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEJ8IIQVBECEGIAMgBmohByAHJAAgBQ8LmQIBIn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCACEFQQAhBiAFIQcgBiEIIAcgCE4hCUEBIQogCSAKcSELAkACQCALRQ0AAkADQCAEKAIAIQxBACENIAwhDiANIQ8gDiAPSiEQQQEhESAQIBFxIRIgEkUNASAEKAIEIRMgExCzEhogBCgCACEUQX8hFSAUIBVqIRYgBCAWNgIADAALAAsMAQsCQANAIAQoAgAhF0EAIRggFyEZIBghGiAZIBpIIRtBASEcIBsgHHEhHSAdRQ0BIAQoAgQhHiAeEIcSGiAEKAIAIR9BASEgIB8gIGohISAEICE2AgAMAAsACwtBECEiIAQgImohIyAjJAAPC0wBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAUQ1wghBiAEIAY2AgBBECEHIAMgB2ohCCAIJAAgBA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEELwSIQVBECEGIAMgBmohByAHJAAgBQ8LoAEBE38jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBhC9EiEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AQc0KIQ4gDhCDAQALIAUoAgghD0HQACEQIA8gEGwhEUEEIRIgESASEIQBIRNBECEUIAUgFGohFSAVJAAgEw8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC3wBDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxC+EiEIIAYgCBC/EhpBBCEJIAYgCWohCiAFKAIEIQsgCxDAEiEMIAogDBDBEhpBECENIAUgDWohDiAOJAAgBg8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIUIAUgATYCECAFIAI2AgwgBSgCFCEGIAUoAhAhByAFKAIMIQggCBD7ESEJIAYgByAJEMISQSAhCiAFIApqIQsgCyQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBBCEFIAQgBWohBiAGEMQSIQdBECEIIAMgCGohCSAJJAAgBw8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMQbPmzBkhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LWgEJfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQvhIhByAHKAIAIQggBSAINgIAQRAhCSAEIAlqIQogCiQAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtcAgh/AX4jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEMASIQcgBykCACEKIAUgCjcCAEEQIQggBCAIaiEJIAkkACAFDwvBAgIdfwh+IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHIAcQ+xEhCCAIKQIAISAgBiAgNwIAQTghCSAGIAlqIQogCCAJaiELIAspAgAhISAKICE3AgBBMCEMIAYgDGohDSAIIAxqIQ4gDikCACEiIA0gIjcCAEEoIQ8gBiAPaiEQIAggD2ohESARKQIAISMgECAjNwIAQSAhEiAGIBJqIRMgCCASaiEUIBQpAgAhJCATICQ3AgBBGCEVIAYgFWohFiAIIBVqIRcgFykCACElIBYgJTcCAEEQIRggBiAYaiEZIAggGGohGiAaKQIAISYgGSAmNwIAQQghGyAGIBtqIRwgCCAbaiEdIB0pAgAhJyAcICc3AgBBECEeIAUgHmohHyAfJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEELsIIQVBECEGIAMgBmohByAHJAAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC8UBARh/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFLQAEIQZBASEHIAYgB3EhCAJAIAhFDQAgBSgCACEJIAQoAgghCkEQIQsgCiALaiEMIAwQkRIhDSAJIA0QyBILIAQoAgghDkEAIQ8gDiEQIA8hESAQIBFHIRJBASETIBIgE3EhFAJAIBRFDQAgBSgCACEVIAQoAgghFkEBIRcgFSAWIBcQyRILQRAhGCAEIBhqIRkgGSQADwtKAQd/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAEKAIYIQYgBSAGEMoSQSAhByAEIAdqIQggCCQADwtaAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAUoAgQhCCAGIAcgCBDLEkEQIQkgBSAJaiEKIAokAA8LIgEDfyMAIQJBECEDIAIgA2shBCAEIAA2AgQgBCABNgIADwtiAQp/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHQdAAIQggByAIbCEJQQQhCiAGIAkgChBJQRAhCyAFIAtqIQwgDCQADwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhDSEiEHQRAhCCADIAhqIQkgCSQAIAcPC7MBARV/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBUEIIQYgBCAGaiEHIAchCEEBIQkgCCAFIAkQ0xIaIAUQ1BIhCiAEKAIMIQsgCxDVEiEMIAQoAhghDSANENYSIQ4gCiAMIA4Q1xIgBCgCDCEPQQwhECAPIBBqIREgBCARNgIMQQghEiAEIBJqIRMgEyEUIBQQ2BIaQSAhFSAEIBVqIRYgFiQADwvdAQEYfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBRDUEiEGIAQgBjYCFCAFENkSIQdBASEIIAcgCGohCSAFIAkQ2hIhCiAFENkSIQsgBCgCFCEMIAQhDSANIAogCyAMENsSGiAEKAIUIQ4gBCgCCCEPIA8Q1RIhECAEKAIYIREgERDWEiESIA4gECASENcSIAQoAgghE0EMIRQgEyAUaiEVIAQgFTYCCCAEIRYgBSAWENwSIAQhFyAXEN0SGkEgIRggBCAYaiEZIBkkAA8LZQEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCREyEGIAQoAgghByAHEJETIQggBiAIayEJQQwhCiAJIAptIQtBECEMIAQgDGohDSANJAAgCw8L3QUCZH8BfiMAIQRBwAAhBSAEIAVrIQYgBiQAIAYgADYCOCAGIAE2AjAgBiACNgIsIAYgAzYCKCAGKAIoIQdBASEIIAchCSAIIQogCSAKSiELQQEhDCALIAxxIQ0CQCANRQ0AIAYoAighDkECIQ8gDiAPayEQQQIhESAQIBFtIRIgBiASNgIoIAYoAighE0E4IRQgBiAUaiEVIBUhFiAWIBMQjBMhFyAGIBc2AiAgBigCLCEYQSAhGSAGIBlqIRogGiEbIBsQjRMhHEEwIR0gBiAdaiEeIB4hHyAfEI4TISAgIBCNEyEhIBggHCAhEI8TISJBASEjICIgI3EhJAJAICRFDQBBMCElIAYgJWohJiAmIScgJxCNEyEoICgQ3BEhKUEQISogBiAqaiErICshLCApKQIAIWggLCBoNwIAQQghLSAsIC1qIS4gKSAtaiEvIC8oAgAhMCAuIDA2AgACQANAQSAhMSAGIDFqITIgMiEzIDMQjRMhNCA0ENwRITVBMCE2IAYgNmohNyA3ITggOBCNEyE5IDkgNRCQExpBMCE6IAYgOmohOyA7ITxBICE9IAYgPWohPiA+IT8gPygCACFAIDwgQDYCACAGKAIoIUECQCBBDQAMAgsgBigCKCFCQQEhQyBCIENrIURBAiFFIEQgRW0hRiAGIEY2AiggBigCKCFHQTghSCAGIEhqIUkgSSFKIEogRxCMEyFLIAYgSzYCCEEgIUwgBiBMaiFNIE0hTkEIIU8gBiBPaiFQIFAhUSBRKAIAIVIgTiBSNgIAIAYoAiwhU0EgIVQgBiBUaiFVIFUhViBWEI0TIVdBECFYIAYgWGohWSBZIVogUyBXIFoQjxMhW0EBIVwgWyBccSFdIF0NAAsLQRAhXiAGIF5qIV8gXyFgIGAQ3BEhYUEwIWIgBiBiaiFjIGMhZCBkEI0TIWUgZSBhEJATGgsLQcAAIWYgBiBmaiFnIGckAA8LXAEKfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIAIQVBCCEGIAQgBmohByAHIQggCCAFEJUTGiAEKAIIIQlBECEKIAQgCmohCyALJAAgCQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEN4SIQVBECEGIAMgBmohByAHJAAgBQ8LgwEBDX8jACEDQRAhBCADIARrIQUgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAGIAc2AgAgBSgCCCEIIAgoAgQhCSAGIAk2AgQgBSgCCCEKIAooAgQhCyAFKAIEIQxBDCENIAwgDWwhDiALIA5qIQ8gBiAPNgIIIAYPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEOASIQdBECEIIAMgCGohCSAJJAAgBw8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhwgBSABNgIYIAUgAjYCFCAFKAIcIQYgBSgCGCEHIAUoAhQhCCAIENYSIQkgBiAHIAkQ3xJBICEKIAUgCmohCyALJAAPCzkBBn8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCgCACEGIAYgBTYCBCAEDwtEAQl/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFIAQoAgAhBiAFIAZrIQdBDCEIIAcgCG0hCSAJDwuyAgElfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIYIAQgATYCFCAEKAIYIQUgBRDjEiEGIAQgBjYCECAEKAIUIQcgBCgCECEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AIAUQtRoACyAFEOQSIQ4gBCAONgIMIAQoAgwhDyAEKAIQIRBBASERIBAgEXYhEiAPIRMgEiEUIBMgFE8hFUEBIRYgFSAWcSEXAkACQCAXRQ0AIAQoAhAhGCAEIBg2AhwMAQsgBCgCDCEZQQEhGiAZIBp0IRsgBCAbNgIIQQghHCAEIBxqIR0gHSEeQRQhHyAEIB9qISAgICEhIB4gIRBnISIgIigCACEjIAQgIzYCHAsgBCgCHCEkQSAhJSAEICVqISYgJiQAICQPC64CASB/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhggBiABNgIUIAYgAjYCECAGIAM2AgwgBigCGCEHIAYgBzYCHEEMIQggByAIaiEJQQAhCiAGIAo2AgggBigCDCELQQghDCAGIAxqIQ0gDSEOIAkgDiALEOUSGiAGKAIUIQ8CQAJAIA9FDQAgBxDmEiEQIAYoAhQhESAQIBEQ5xIhEiASIRMMAQtBACEUIBQhEwsgEyEVIAcgFTYCACAHKAIAIRYgBigCECEXQQwhGCAXIBhsIRkgFiAZaiEaIAcgGjYCCCAHIBo2AgQgBygCACEbIAYoAhQhHEEMIR0gHCAdbCEeIBsgHmohHyAHEOgSISAgICAfNgIAIAYoAhwhIUEgISIgBiAiaiEjICMkACAhDwv7AQEbfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRDpEiAFENQSIQYgBSgCACEHIAUoAgQhCCAEKAIIIQlBBCEKIAkgCmohCyAGIAcgCCALEOoSIAQoAgghDEEEIQ0gDCANaiEOIAUgDhDrEkEEIQ8gBSAPaiEQIAQoAgghEUEIIRIgESASaiETIBAgExDrEiAFEMwSIRQgBCgCCCEVIBUQ6BIhFiAUIBYQ6xIgBCgCCCEXIBcoAgQhGCAEKAIIIRkgGSAYNgIAIAUQ2RIhGiAFIBoQ7BIgBRDtEkEQIRsgBCAbaiEcIBwkAA8LlQEBEX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCCCADKAIIIQQgAyAENgIMIAQQ7hIgBCgCACEFQQAhBiAFIQcgBiEIIAcgCEchCUEBIQogCSAKcSELAkAgC0UNACAEEOYSIQwgBCgCACENIAQQ7xIhDiAMIA0gDhDwEgsgAygCDCEPQRAhECADIBBqIREgESQAIA8PCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhQgBSABNgIQIAUgAjYCDCAFKAIUIQYgBSgCECEHIAUoAgwhCCAIENYSIQkgBiAHIAkQ4RJBICEKIAUgCmohCyALJAAPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDiEiEFQRAhBiADIAZqIQcgByQAIAUPC4EBAgx/AX4jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQcgBxDWEiEIIAgpAgAhDyAGIA83AgBBCCEJIAYgCWohCiAIIAlqIQsgCygCACEMIAogDDYCAEEQIQ0gBSANaiEOIA4kAA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC4QBARF/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ8RIhBSAFEPISIQYgAyAGNgIIEHQhByADIAc2AgRBCCEIIAMgCGohCSAJIQpBBCELIAMgC2ohDCAMIQ0gCiANEHUhDiAOKAIAIQ9BECEQIAMgEGohESARJAAgDw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPMSIQVBECEGIAMgBmohByAHJAAgBQ8LewEMfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHEDMhCCAGIAgQsA4aQQQhCSAGIAlqIQogBSgCBCELIAsQ+xIhDCAKIAwQ/BIaQRAhDSAFIA1qIQ4gDiQAIAYPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBDCEFIAQgBWohBiAGEP4SIQdBECEIIAMgCGohCSAJJAAgBw8LVAEJfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGQQAhByAFIAYgBxD9EiEIQRAhCSAEIAlqIQogCiQAIAgPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBDCEFIAQgBWohBiAGEP8SIQdBECEIIAMgCGohCSAJJAAgBw8LqQEBFn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCBEyEFIAQQgRMhBiAEEOQSIQdBDCEIIAcgCGwhCSAGIAlqIQogBBCBEyELIAQQ2RIhDEEMIQ0gDCANbCEOIAsgDmohDyAEEIETIRAgBBDkEiERQQwhEiARIBJsIRMgECATaiEUIAQgBSAKIA8gFBCCE0EQIRUgAyAVaiEWIBYkAA8LgQIBH38jACEEQSAhBSAEIAVrIQYgBiQAIAYgADYCHCAGIAE2AhggBiACNgIUIAYgAzYCECAGKAIUIQcgBigCGCEIIAcgCGshCUEMIQogCSAKbSELIAYgCzYCDCAGKAIMIQwgBigCECENIA0oAgAhDkEAIQ8gDyAMayEQQQwhESAQIBFsIRIgDiASaiETIA0gEzYCACAGKAIMIRRBACEVIBQhFiAVIRcgFiAXSiEYQQEhGSAYIBlxIRoCQCAaRQ0AIAYoAhAhGyAbKAIAIRwgBigCGCEdIAYoAgwhHkEMIR8gHiAfbCEgIBwgHSAgEOMaGgtBICEhIAYgIWohIiAiJAAPC58BARJ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEIMTIQYgBigCACEHIAQgBzYCBCAEKAIIIQggCBCDEyEJIAkoAgAhCiAEKAIMIQsgCyAKNgIAQQQhDCAEIAxqIQ0gDSEOIA4QgxMhDyAPKAIAIRAgBCgCCCERIBEgEDYCAEEQIRIgBCASaiETIBMkAA8LsAEBFn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQgRMhBiAFEIETIQcgBRDkEiEIQQwhCSAIIAlsIQogByAKaiELIAUQgRMhDCAFEOQSIQ1BDCEOIA0gDmwhDyAMIA9qIRAgBRCBEyERIAQoAgghEkEMIRMgEiATbCEUIBEgFGohFSAFIAYgCyAQIBUQghNBECEWIAQgFmohFyAXJAAPCxsBA38jACEBQRAhAiABIAJrIQMgAyAANgIMDwtDAQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgQhBSAEIAUQhBNBECEGIAMgBmohByAHJAAPC14BDH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCGEyEFIAUoAgAhBiAEKAIAIQcgBiAHayEIQQwhCSAIIAltIQpBECELIAMgC2ohDCAMJAAgCg8LWgEIfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAFKAIEIQggBiAHIAgQhRNBECEJIAUgCWohCiAKJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEPUSIQdBECEIIAMgCGohCSAJJAAgBw8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPQSIQVBECEGIAMgBmohByAHJAAgBQ8LXgEMfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPgSIQUgBSgCACEGIAQoAgAhByAGIAdrIQhBDCEJIAggCW0hCkEQIQsgAyALaiEMIAwkACAKDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQ9hIhBUEQIQYgAyAGaiEHIAckACAFDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ9xIhBUEQIQYgAyAGaiEHIAckACAFDwslAQR/IwAhAUEQIQIgASACayEDIAMgADYCDEHVqtWqASEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhD5EiEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD6EiEFQRAhBiADIAZqIQcgByQAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LUwEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQ+xIhByAFIAc2AgBBECEIIAQgCGohCSAJJAAgBQ8LnwEBE38jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBhD2EiEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AQc0KIQ4gDhCDAQALIAUoAgghD0EMIRAgDyAQbCERQQQhEiARIBIQhAEhE0EQIRQgBSAUaiEVIBUkACATDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQQhBSAEIAVqIQYgBhCAEyEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDeEiEFQRAhBiADIAZqIQcgByQAIAUPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBQ8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIAIQUgBRDVEiEGQRAhByADIAdqIQggCCQAIAYPCzcBA38jACEFQSAhBiAFIAZrIQcgByAANgIcIAcgATYCGCAHIAI2AhQgByADNgIQIAcgBDYCDA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQhxNBECEHIAQgB2ohCCAIJAAPC2EBCn8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQdBDCEIIAcgCGwhCUEEIQogBiAJIAoQSUEQIQsgBSALaiEMIAwkAA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQixMhB0EQIQggAyAIaiEJIAkkACAHDwugAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUCQANAIAQoAgAhBiAFKAIIIQcgBiEIIAchCSAIIAlHIQpBASELIAogC3EhDCAMRQ0BIAUQ5hIhDSAFKAIIIQ5BdCEPIA4gD2ohECAFIBA2AgggEBDVEiERIA0gERCIEwwACwALQRAhEiAEIBJqIRMgEyQADwtKAQd/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAEKAIYIQYgBSAGEIkTQSAhByAEIAdqIQggCCQADwtKAQd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgQhBSAEKAIAIQYgBSAGEIoTQRAhByAEIAdqIQggCCQADwsiAQN/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AggPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD6EiEFQRAhBiADIAZqIQcgByQAIAUPC4ABAQ9/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgQhBUEIIQYgBCAGaiEHIAchCCAFKAIAIQkgCCAJNgIAIAQoAgAhCkEIIQsgBCALaiEMIAwhDSANIAoQkhMaIAQoAgghDkEQIQ8gBCAPaiEQIBAkACAODwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPCz0BB38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQVBdCEGIAUgBmohByAEIAc2AgAgBA8LaQELfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgQhByAFKAIIIQggBiAHIAgQ+gwhCUEBIQogCSAKcSELQRAhDCAFIAxqIQ0gDSQAIAsPC44BAg9/AX4jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEJMTIQcgBykCACERIAUgETcCACAEKAIIIQhBCCEJIAggCWohCiAKEJQTIQtBCCEMIAUgDGohDSALKAIAIQ4gDSAONgIAQRAhDyAEIA9qIRAgECQAIAUPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBQ8LUgEJfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSgCACEHQQwhCCAGIAhsIQkgByAJaiEKIAUgCjYCACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCzkBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LlAEBEH8jACEDQSAhBCADIARrIQUgBSQAIAUgATYCECAFIAA2AgwgBSACNgIIIAUoAgwhBiAFIQdBECEIIAUgCGohCSAJIQogCigCACELIAcgCzYCACAFKAIIIQwgDBCWEyENIAUoAgAhDiAGIA4gDRCYEyEPIAUgDzYCGCAFKAIYIRBBICERIAUgEWohEiASJAAgEA8LnwEBEn8jACEDQTAhBCADIARrIQUgBSQAIAUgATYCICAFIAA2AhwgBSACNgIYIAUoAhwhBkEQIQcgBSAHaiEIIAghCUEgIQogBSAKaiELIAshDCAMKAIAIQ0gCSANNgIAIAUoAhghDiAOEJYTIQ8gBSgCECEQIAYgECAPEJkTIREgBSARNgIoIAUoAighEkEwIRMgBSATaiEUIBQkACASDwuoAQETfyMAIQNBMCEEIAMgBGshBSAFJAAgBSABNgIgIAUgADYCFCAFIAI2AhAgBSgCFCEGQQghByAFIAdqIQggCCEJQSAhCiAFIApqIQsgCyEMIAwoAgAhDSAJIA02AgAgBSgCECEOIAUoAhAhDyAPEJYTIRAgBSgCCCERIAYgESAOIBAQmhMhEiAFIBI2AiggBSgCKCETQTAhFCAFIBRqIRUgFSQAIBMPC4UDAS9/IwAhBEHAACEFIAQgBWshBiAGJAAgBiABNgIwIAYgADYCLCAGIAI2AiggBiADNgIkIAYoAiwhB0EQIQggBiAIaiEJIAkhCkEwIQsgBiALaiEMIAwhDSANKAIAIQ4gCiAONgIAIAYoAighDyAGKAIQIRBBICERIAYgEWohEiASIRNBHCEUIAYgFGohFSAVIRYgByAQIBMgFiAPEPoRIRcgBiAXNgIYIAYoAhghGCAYKAIAIRkgBiAZNgIMIAYoAhghGiAaKAIAIRtBACEcIBshHSAcIR4gHSAeRiEfQQEhICAfICBxISECQCAhRQ0AIAYoAiQhIiAiEJYTISMgBiEkICQgByAjEJsTIAYoAiAhJSAGKAIYISYgBiEnICcQ/REhKCAHICUgJiAoEP4RIAYhKSApEP8RISogBiAqNgIMIAYhKyArEIASGgsgBigCDCEsQTghLSAGIC1qIS4gLiEvIC8gLBCBEhogBigCOCEwQcAAITEgBiAxaiEyIDIkACAwDwurAgEifyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSgCGCEGIAYQjBIhByAFIAc2AhBBACEIQQEhCSAIIAlxIQogBSAKOgAPIAUoAhAhC0EBIQwgCyAMEI0SIQ0gBSgCECEOIAUhD0EAIRBBASERIBAgEXEhEiAPIA4gEhCOEhogBSETIAAgDSATEI8SGiAFKAIQIRQgABCQEiEVQRAhFiAVIBZqIRcgFxCREiEYIAUoAhQhGSAZEJYTIRogFCAYIBoQnBMgABCTEiEbQQEhHCAbIBw6AARBASEdQQEhHiAdIB5xIR8gBSAfOgAPIAUtAA8hIEEBISEgICAhcSEiAkAgIg0AIAAQgBIaC0EgISMgBSAjaiEkICQkAA8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSgCHCEGIAUoAhghByAFKAIUIQggCBCWEyEJIAYgByAJEJ0TQSAhCiAFIApqIQsgCyQADwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhQgBSABNgIQIAUgAjYCDCAFKAIUIQYgBSgCECEHIAUoAgwhCCAIEJYTIQkgBiAHIAkQnhNBICEKIAUgCmohCyALJAAPC1kBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQcgBxCWEyEIIAYgCBCfExpBECEJIAUgCWohCiAKJAAPC84CAiB/CH4jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEKATIQcgBykCACEiIAUgIjcCAEEwIQggBSAIaiEJIAcgCGohCiAKKQIAISMgCSAjNwIAQSghCyAFIAtqIQwgByALaiENIA0pAgAhJCAMICQ3AgBBICEOIAUgDmohDyAHIA5qIRAgECkCACElIA8gJTcCAEEYIREgBSARaiESIAcgEWohEyATKQIAISYgEiAmNwIAQRAhFCAFIBRqIRUgByAUaiEWIBYpAgAhJyAVICc3AgBBCCEXIAUgF2ohGCAHIBdqIRkgGSkCACEoIBggKDcCAEE4IRogBSAaaiEbIAQoAgghHEE4IR0gHCAdaiEeIB4Q2xEhHyAfKQIAISkgGyApNwIAQRAhICAEICBqISEgISQAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtMAQt/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAQoAgQhBiAFIQcgBiEIIAcgCEYhCUEBIQogCSAKcSELIAsPC1IBCX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUoAgAhB0EcIQggBiAIbCEJIAcgCWohCiAFIAo2AgAgBQ8LTAELfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAEKAIEIQYgBSEHIAYhCCAHIAhGIQlBASEKIAkgCnEhCyALDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC8IBARp/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhggBSABNgIQQQghBiAFIAZqIQcgByEIQRghCSAFIAlqIQogCiELIAsoAgAhDCAIIAw2AgAgBSENQRAhDiAFIA5qIQ8gDyEQIBAoAgAhESANIBE2AgBBECESIAUgEmohEyATIRRBGCEVIAUgFWohFiAWIRcgFCAXEM8SIRggBSgCCCEZIAUoAgAhGiAZIBogAiAYELQTQSAhGyAFIBtqIRwgHCQADwtOAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAgQhBUF0IQYgBSAGaiEHIAQgBxC1E0EQIQggAyAIaiEJIAkkAA8LzQEBF38jACECQSAhAyACIANrIQQgBCQAIAQgATYCECAEIAA2AgwgBCgCDCEFQRAhBiAEIAZqIQcgByEIIAgQixIhCSAEIAk2AgggBCgCCCEKIAUgChC/EyELIAQgCzYCGCAFEIwSIQwgBCAMNgIEIAQoAgQhDUEQIQ4gBCAOaiEPIA8hECAQEIQSIREgERCREiESIA0gEhDIEiAEKAIEIRMgBCgCCCEUQQEhFSATIBQgFRDJEiAEKAIYIRZBICEXIAQgF2ohGCAYJAAgFg8LbgELfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBCgCACEGIAUQnBIhByAFEMQOIQggBSAGIAcgCBDDEyEJIAQgCTYCCCAEKAIIIQpBECELIAQgC2ohDCAMJAAgCg8LWgEMfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIAIQYgBCgCCCEHIAcoAgAhCCAGIQkgCCEKIAkgCkYhC0EBIQwgCyAMcSENIA0PC0wBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAUQ1AghBiAEIAY2AgBBECEHIAMgB2ohCCAIJAAgBA8LUAEKfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMQTIQVBECEGIAUgBmohByAHEMUTIQhBECEJIAMgCWohCiAKJAAgCA8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEELoSIQVBECEGIAMgBmohByAHJAAgBQ8LLwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEQQEhBSAEIAU6ABggBA8L3w4BzgF/IwAhBUEgIQYgBSAGayEHIAckACAHIAA2AhggByABNgIUIAcgAjYCECAHIAM2AgwgByAENgIIIAcoAhghCCAHKAIUIQkgCRCrDyEKQQEhCyAKIAtxIQwCQAJAAkAgDA0AIAcoAhAhDSANEKsPIQ5BASEPIA4gD3EhEAJAAkAgEA0AIAcoAgwhESAREKsPIRJBASETIBIgE3EhFAJAAkAgFA0AQQIhFSAIIBVqIRYgBygCFCEXIAcoAhAhGCAHKAIMIRkgFiAXIBggGRDHEyEaQQEhGyAaIBtxIRwCQCAcDQBBACEdQQEhHiAdIB5xIR8gByAfOgAfDAcLQQQhICAIICBqISEgBygCFCEiIAcoAhAhIyAHKAIMISQgBygCCCElICEgIiAjICQgJRDIEwwBC0ECISYgCCAmaiEnIAcoAhQhKCAHKAIQISkgBygCDCEqQQMhKyAnICggKSAqICsQyRMhLEEBIS0gLCAtcSEuAkAgLg0AQQAhL0EBITAgLyAwcSExIAcgMToAHwwGC0EEITIgCCAyaiEzIAcoAhQhNCAHKAIQITUgBygCDCE2IAcoAgghN0EDITggMyA0IDUgNiA4IDcQyhMLDAELIAcoAgwhOSA5EKsPITpBASE7IDogO3EhPAJAAkAgPA0AQQIhPSAIID1qIT4gBygCFCE/IAcoAgwhQCAHKAIQIUFBAiFCID4gPyBAIEEgQhDJEyFDQQEhRCBDIERxIUUCQCBFDQBBACFGQQEhRyBGIEdxIUggByBIOgAfDAYLQQQhSSAIIElqIUogBygCFCFLIAcoAgwhTCAHKAIQIU0gBygCCCFOQQIhTyBKIEsgTCBNIE8gThDKEwwBC0ECIVAgCCBQaiFRIAcoAhQhUiAHKAIQIVMgBygCDCFUQQEhVSBRIFIgUyBUIFUQyxMhVkEBIVcgViBXcSFYAkAgWA0AQQAhWUEBIVogWSBacSFbIAcgWzoAHwwFC0EEIVwgCCBcaiFdIAcoAhQhXiAHKAIQIV8gBygCDCFgIAcoAgghYUEBIWIgXSBeIF8gYCBiIGEQzBMLCwwBCyAHKAIQIWMgYxCrDyFkQQEhZSBkIGVxIWYCQAJAIGYNACAHKAIMIWcgZxCrDyFoQQEhaSBoIGlxIWoCQAJAIGoNAEECIWsgCCBraiFsIAcoAhAhbSAHKAIMIW4gBygCFCFvQQEhcCBsIG0gbiBvIHAQyRMhcUEBIXIgcSBycSFzAkAgcw0AQQAhdEEBIXUgdCB1cSF2IAcgdjoAHwwGC0EEIXcgCCB3aiF4IAcoAhAheSAHKAIMIXogBygCFCF7IAcoAgghfEEBIX0geCB5IHogeyB9IHwQyhMMAQtBAiF+IAggfmohfyAHKAIQIYABIAcoAhQhgQEgBygCDCGCAUECIYMBIH8ggAEggQEgggEggwEQyxMhhAFBASGFASCEASCFAXEhhgECQCCGAQ0AQQAhhwFBASGIASCHASCIAXEhiQEgByCJAToAHwwFC0EEIYoBIAggigFqIYsBIAcoAhAhjAEgBygCFCGNASAHKAIMIY4BIAcoAgghjwFBAiGQASCLASCMASCNASCOASCQASCPARDMEwsMAQsgBygCDCGRASCRARCrDyGSAUEBIZMBIJIBIJMBcSGUAQJAAkAglAENAEECIZUBIAgglQFqIZYBIAcoAgwhlwEgBygCFCGYASAHKAIQIZkBQQMhmgEglgEglwEgmAEgmQEgmgEQyxMhmwFBASGcASCbASCcAXEhnQECQCCdAQ0AQQAhngFBASGfASCeASCfAXEhoAEgByCgAToAHwwFC0EEIaEBIAggoQFqIaIBIAcoAgwhowEgBygCFCGkASAHKAIQIaUBIAcoAgghpgFBAyGnASCiASCjASCkASClASCnASCmARDMEwwBC0ECIagBIAggqAFqIakBIAcoAhQhqgEgBygCECGrASAHKAIMIawBIKkBIKoBIKsBIKwBEM0TIa0BQQEhrgEgrQEgrgFxIa8BAkAgrwENAEEAIbABQQEhsQEgsAEgsQFxIbIBIAcgsgE6AB8MBAtBBCGzASAIILMBaiG0ASAHKAIUIbUBIAcoAhAhtgEgBygCDCG3ASAHKAIIIbgBILQBILUBILYBILcBILgBEM4TCwsLIAcoAgghuQEgBygCFCG6ASAIILkBILoBEM8TIbsBQQEhvAEguwEgvAFxIb0BAkACQCC9AQ0AIAcoAgghvgEgBygCECG/ASAIIL4BIL8BEM8TIcABQQEhwQEgwAEgwQFxIcIBIMIBDQAgBygCCCHDASAHKAIMIcQBIAggwwEgxAEQzxMhxQFBASHGASDFASDGAXEhxwEgxwFFDQELQQAhyAFBASHJASDIASDJAXEhygEgByDKAToAHwwBC0EBIcsBQQEhzAEgywEgzAFxIc0BIAcgzQE6AB8LIActAB8hzgFBASHPASDOASDPAXEh0AFBICHRASAHINEBaiHSASDSASQAINABDwvqAQIWfwR+IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQ1BMhCCAIKQMAIRkgBiAZNwMAQRghCSAGIAlqIQogCCAJaiELIAspAwAhGiAKIBo3AwBBECEMIAYgDGohDSAIIAxqIQ4gDikDACEbIA0gGzcDAEEIIQ8gBiAPaiEQIAggD2ohESARKQMAIRwgECAcNwMAQSAhEiAGIBJqIRMgBSgCBCEUIBQQ4hEhFSAVKAIAIRYgEyAWNgIAQRAhFyAFIBdqIRggGCQAIAYPC40BARB/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBUEQIQYgBSAGaiEHIAQoAgghCCAHIAgQ0BNBECEJIAUgCWohCiAKENETIQsgBCALNgIAIAQhDCAFIAwQ0hNBECENIAUgDWohDiAOENMTIQ9BECEQIAQgEGohESARJAAgDw8LOQEFfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGNgIAIAUPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBQ8LLwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEQQAhBSAEIAU6ABggBA8L3gIBL38jACEEQTAhBSAEIAVrIQYgBiQAIAYgADYCKCAGIAE2AiAgBiACNgIcIAYgAzYCGCAGKAIYIQdBASEIIAchCSAIIQogCSAKSiELQQEhDCALIAxxIQ0CQCANRQ0AQSghDiAGIA5qIQ8gDyEQIBAQjRMhEUEgIRIgBiASaiETIBMhFCAUEI4TIRUgFRCNEyEWIBEgFhC2E0EQIRcgBiAXaiEYIBghGUEoIRogBiAaaiEbIBshHCAcKAIAIR0gGSAdNgIAQQghHiAGIB5qIR8gHyEgQSAhISAGICFqISIgIiEjICMoAgAhJCAgICQ2AgAgBigCHCElIAYoAhghJkEBIScgJiAnayEoIAYhKUEoISogBiAqaiErICshLCAsKAIAIS0gKSAtNgIAIAYoAhAhLiAGKAIIIS8gBigCACEwIC4gLyAlICggMBC3EwtBMCExIAYgMWohMiAyJAAPC3QBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQvBMgBRDZEiEHIAQgBzYCBCAEKAIIIQggBSAIEL0TIAQoAgQhCSAFIAkQvhNBECEKIAQgCmohCyALJAAPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQuBNBECEHIAQgB2ohCCAIJAAPC4QMAsUBfwF+IwAhBUHQACEGIAUgBmshByAHJAAgByAANgJIIAcgATYCQCAHIAQ2AjggByACNgI0IAcgAzYCMEE4IQggByAIaiEJIAkhCkHIACELIAcgC2ohDCAMIQ0gCiANEM8SIQ4gByAONgIsIAcoAjAhD0ECIRAgDyERIBAhEiARIBJIIRNBASEUIBMgFHEhFQJAAkACQCAVDQAgBygCMCEWQQIhFyAWIBdrIRhBAiEZIBggGW0hGiAHKAIsIRsgGiEcIBshHSAcIB1IIR5BASEfIB4gH3EhICAgRQ0BCwwBCyAHKAIsISFBASEiICEgInQhI0EBISQgIyAkaiElIAcgJTYCLCAHKAIsISZByAAhJyAHICdqISggKCEpICkgJhCMEyEqIAcgKjYCKCAHKAIsIStBASEsICsgLGohLSAHKAIwIS4gLSEvIC4hMCAvIDBIITFBACEyQQEhMyAxIDNxITQgMiE1AkAgNEUNACAHKAI0ITZBKCE3IAcgN2ohOCA4ITkgORCNEyE6QSghOyAHIDtqITwgPCE9QQEhPiA9ID4QjBMhPyAHID82AiBBICFAIAcgQGohQSBBIUIgQhCNEyFDIDYgOiBDEI8TIUQgRCE1CyA1IUVBASFGIEUgRnEhRwJAIEdFDQBBKCFIIAcgSGohSSBJIUogShC5ExogBygCLCFLQQEhTCBLIExqIU0gByBNNgIsCyAHKAI0IU5BKCFPIAcgT2ohUCBQIVEgURCNEyFSQTghUyAHIFNqIVQgVCFVIFUQjRMhViBOIFIgVhCPEyFXQQEhWCBXIFhxIVkCQCBZRQ0ADAELQTghWiAHIFpqIVsgWyFcIFwQjRMhXSBdENwRIV5BECFfIAcgX2ohYCBgIWEgXikCACHKASBhIMoBNwIAQQghYiBhIGJqIWMgXiBiaiFkIGQoAgAhZSBjIGU2AgACQANAQSghZiAHIGZqIWcgZyFoIGgQjRMhaSBpENwRIWpBOCFrIAcga2ohbCBsIW0gbRCNEyFuIG4gahCQExpBOCFvIAcgb2ohcCBwIXFBKCFyIAcgcmohcyBzIXQgdCgCACF1IHEgdTYCACAHKAIwIXZBAiF3IHYgd2sheEECIXkgeCB5bSF6IAcoAiwheyB6IXwgeyF9IHwgfUghfkEBIX8gfiB/cSGAAQJAIIABRQ0ADAILIAcoAiwhgQFBASGCASCBASCCAXQhgwFBASGEASCDASCEAWohhQEgByCFATYCLCAHKAIsIYYBQcgAIYcBIAcghwFqIYgBIIgBIYkBIIkBIIYBEIwTIYoBIAcgigE2AghBKCGLASAHIIsBaiGMASCMASGNAUEIIY4BIAcgjgFqIY8BII8BIZABIJABKAIAIZEBII0BIJEBNgIAIAcoAiwhkgFBASGTASCSASCTAWohlAEgBygCMCGVASCUASGWASCVASGXASCWASCXAUghmAFBACGZAUEBIZoBIJgBIJoBcSGbASCZASGcAQJAIJsBRQ0AIAcoAjQhnQFBKCGeASAHIJ4BaiGfASCfASGgASCgARCNEyGhAUEoIaIBIAcgogFqIaMBIKMBIaQBQQEhpQEgpAEgpQEQjBMhpgEgByCmATYCACAHIacBIKcBEI0TIagBIJ0BIKEBIKgBEI8TIakBIKkBIZwBCyCcASGqAUEBIasBIKoBIKsBcSGsAQJAIKwBRQ0AQSghrQEgByCtAWohrgEgrgEhrwEgrwEQuRMaIAcoAiwhsAFBASGxASCwASCxAWohsgEgByCyATYCLAsgBygCNCGzAUEoIbQBIAcgtAFqIbUBILUBIbYBILYBEI0TIbcBQRAhuAEgByC4AWohuQEguQEhugEgswEgtwEgugEQjxMhuwFBfyG8ASC7ASC8AXMhvQFBASG+ASC9ASC+AXEhvwEgvwENAAsLQRAhwAEgByDAAWohwQEgwQEhwgEgwgEQ3BEhwwFBOCHEASAHIMQBaiHFASDFASHGASDGARCNEyHHASDHASDDARCQExoLQdAAIcgBIAcgyAFqIckBIMkBJAAPC24BDH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQyxFBCCEHIAUgB2ohCCAEKAIIIQlBCCEKIAkgCmohCyAIIAsQuhNBECEMIAQgDGohDSANJAAPCz0BB38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQVBDCEGIAUgBmohByAEIAc2AgAgBA8LmAEBEX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQuxMhBiAEIQcgBigCACEIIAcgCDYCACAEKAIIIQkgCRC7EyEKIAQoAgwhCyAKKAIAIQwgCyAMNgIAIAQhDSANELsTIQ4gBCgCCCEPIA4oAgAhECAPIBA2AgBBECERIAQgEWohEiASJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwsiAQN/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AggPC7wBARR/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIEIQYgBCAGNgIEAkADQCAEKAIIIQcgBCgCBCEIIAchCSAIIQogCSAKRyELQQEhDCALIAxxIQ0gDUUNASAFENQSIQ4gBCgCBCEPQXQhECAPIBBqIREgBCARNgIEIBEQ1RIhEiAOIBIQiBMMAAsACyAEKAIIIRMgBSATNgIEQRAhFCAEIBRqIRUgFSQADwuwAQEWfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCBEyEGIAUQgRMhByAFEOQSIQhBDCEJIAggCWwhCiAHIApqIQsgBRCBEyEMIAQoAgghDUEMIQ4gDSAObCEPIAwgD2ohECAFEIETIREgBRDZEiESQQwhEyASIBNsIRQgESAUaiEVIAUgBiALIBAgFRCCE0EQIRYgBCAWaiEXIBckAA8LgAIBH38jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCBCEFIAQoAgAhBkEIIQcgBCAHaiEIIAghCSAJIAYQgRIaQQghCiAEIApqIQsgCyEMIAwQwBMaIAUQxQ4hDSANKAIAIQ4gBCgCACEPIA4hECAPIREgECARRiESQQEhEyASIBNxIRQCQCAURQ0AIAQoAgghFSAFEMUOIRYgFiAVNgIACyAFEJQSIRcgFygCACEYQX8hGSAYIBlqIRogFyAaNgIAIAUQxA4hGyAbKAIAIRwgBCgCACEdIBwgHRDBEyAEKAIIIR5BECEfIAQgH2ohICAgJAAgHg8LTAEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIAIQUgBRDXCCEGIAQgBjYCAEEQIQcgAyAHaiEIIAgkACAEDwvpGwH9An8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCGCEFIAUoAgAhBkEAIQcgBiEIIAchCSAIIAlGIQpBASELIAogC3EhDAJAAkACQCAMDQAgBCgCGCENIA0oAgQhDkEAIQ8gDiEQIA8hESAQIBFGIRJBASETIBIgE3EhFCAURQ0BCyAEKAIYIRUgFSEWDAELIAQoAhghFyAXEMITIRggGCEWCyAWIRkgBCAZNgIUIAQoAhQhGiAaKAIAIRtBACEcIBshHSAcIR4gHSAeRyEfQQEhICAfICBxISECQAJAICFFDQAgBCgCFCEiICIoAgAhIyAjISQMAQsgBCgCFCElICUoAgQhJiAmISQLICQhJyAEICc2AhBBACEoIAQgKDYCDCAEKAIQISlBACEqICkhKyAqISwgKyAsRyEtQQEhLiAtIC5xIS8CQCAvRQ0AIAQoAhQhMCAwKAIIITEgBCgCECEyIDIgMTYCCAsgBCgCFCEzIDMQtgghNEEBITUgNCA1cSE2AkACQCA2RQ0AIAQoAhAhNyAEKAIUITggOCgCCCE5IDkgNzYCACAEKAIUITogBCgCHCE7IDohPCA7IT0gPCA9RyE+QQEhPyA+ID9xIUACQAJAIEBFDQAgBCgCFCFBIEEQtQghQiBCKAIEIUMgBCBDNgIMDAELIAQoAhAhRCAEIEQ2AhwLDAELIAQoAhAhRSAEKAIUIUYgRhC1CCFHIEcgRTYCBCAEKAIUIUggSCgCCCFJIEkoAgAhSiAEIEo2AgwLIAQoAhQhSyBLLQAMIUxBASFNIEwgTXEhTiAEIE46AAsgBCgCFCFPIAQoAhghUCBPIVEgUCFSIFEgUkchU0EBIVQgUyBUcSFVAkAgVUUNACAEKAIYIVYgVigCCCFXIAQoAhQhWCBYIFc2AgggBCgCGCFZIFkQtgghWkEBIVsgWiBbcSFcAkACQCBcRQ0AIAQoAhQhXSAEKAIUIV4gXigCCCFfIF8gXTYCAAwBCyAEKAIUIWAgBCgCFCFhIGEQtQghYiBiIGA2AgQLIAQoAhghYyBjKAIAIWQgBCgCFCFlIGUgZDYCACAEKAIUIWYgZigCACFnIAQoAhQhaCBnIGgQugggBCgCGCFpIGkoAgQhaiAEKAIUIWsgayBqNgIEIAQoAhQhbCBsKAIEIW1BACFuIG0hbyBuIXAgbyBwRyFxQQEhciBxIHJxIXMCQCBzRQ0AIAQoAhQhdCB0KAIEIXUgBCgCFCF2IHUgdhC6CAsgBCgCGCF3IHctAAwheCAEKAIUIXlBASF6IHggenEheyB5IHs6AAwgBCgCHCF8IAQoAhghfSB8IX4gfSF/IH4gf0YhgAFBASGBASCAASCBAXEhggECQCCCAUUNACAEKAIUIYMBIAQggwE2AhwLCyAELQALIYQBQQEhhQEghAEghQFxIYYBAkAghgFFDQAgBCgCHCGHAUEAIYgBIIcBIYkBIIgBIYoBIIkBIIoBRyGLAUEBIYwBIIsBIIwBcSGNASCNAUUNACAEKAIQIY4BQQAhjwEgjgEhkAEgjwEhkQEgkAEgkQFHIZIBQQEhkwEgkgEgkwFxIZQBAkACQCCUAUUNACAEKAIQIZUBQQEhlgEglQEglgE6AAwMAQsDQCAEKAIMIZcBIJcBELYIIZgBQQEhmQEgmAEgmQFxIZoBAkACQAJAIJoBDQAgBCgCDCGbASCbAS0ADCGcAUEBIZ0BIJwBIJ0BcSGeAQJAIJ4BDQAgBCgCDCGfAUEBIaABIJ8BIKABOgAMIAQoAgwhoQEgoQEQtQghogFBACGjASCiASCjAToADCAEKAIMIaQBIKQBELUIIaUBIKUBELcIIAQoAhwhpgEgBCgCDCGnASCnASgCACGoASCmASGpASCoASGqASCpASCqAUYhqwFBASGsASCrASCsAXEhrQECQCCtAUUNACAEKAIMIa4BIAQgrgE2AhwLIAQoAgwhrwEgrwEoAgAhsAEgsAEoAgQhsQEgBCCxATYCDAsgBCgCDCGyASCyASgCACGzAUEAIbQBILMBIbUBILQBIbYBILUBILYBRiG3AUEBIbgBILcBILgBcSG5AQJAAkACQCC5AQ0AIAQoAgwhugEgugEoAgAhuwEguwEtAAwhvAFBASG9ASC8ASC9AXEhvgEgvgFFDQELIAQoAgwhvwEgvwEoAgQhwAFBACHBASDAASHCASDBASHDASDCASDDAUYhxAFBASHFASDEASDFAXEhxgECQCDGAQ0AIAQoAgwhxwEgxwEoAgQhyAEgyAEtAAwhyQFBASHKASDJASDKAXEhywEgywFFDQELIAQoAgwhzAFBACHNASDMASDNAToADCAEKAIMIc4BIM4BELUIIc8BIAQgzwE2AhAgBCgCECHQASAEKAIcIdEBINABIdIBINEBIdMBINIBINMBRiHUAUEBIdUBINQBINUBcSHWAQJAAkAg1gENACAEKAIQIdcBINcBLQAMIdgBQQEh2QEg2AEg2QFxIdoBINoBDQELIAQoAhAh2wFBASHcASDbASDcAToADAwFCyAEKAIQId0BIN0BELYIId4BQQEh3wEg3gEg3wFxIeABAkACQCDgAUUNACAEKAIQIeEBIOEBELUIIeIBIOIBKAIEIeMBIOMBIeQBDAELIAQoAhAh5QEg5QEoAggh5gEg5gEoAgAh5wEg5wEh5AELIOQBIegBIAQg6AE2AgwMAQsgBCgCDCHpASDpASgCBCHqAUEAIesBIOoBIewBIOsBIe0BIOwBIO0BRiHuAUEBIe8BIO4BIO8BcSHwAQJAAkAg8AENACAEKAIMIfEBIPEBKAIEIfIBIPIBLQAMIfMBQQEh9AEg8wEg9AFxIfUBIPUBRQ0BCyAEKAIMIfYBIPYBKAIAIfcBQQEh+AEg9wEg+AE6AAwgBCgCDCH5AUEAIfoBIPkBIPoBOgAMIAQoAgwh+wEg+wEQuAggBCgCDCH8ASD8ARC1CCH9ASAEIP0BNgIMCyAEKAIMIf4BIP4BELUIIf8BIP8BLQAMIYACIAQoAgwhgQJBASGCAiCAAiCCAnEhgwIggQIggwI6AAwgBCgCDCGEAiCEAhC1CCGFAkEBIYYCIIUCIIYCOgAMIAQoAgwhhwIghwIoAgQhiAJBASGJAiCIAiCJAjoADCAEKAIMIYoCIIoCELUIIYsCIIsCELcIDAMLDAELIAQoAgwhjAIgjAItAAwhjQJBASGOAiCNAiCOAnEhjwICQCCPAg0AIAQoAgwhkAJBASGRAiCQAiCRAjoADCAEKAIMIZICIJICELUIIZMCQQAhlAIgkwIglAI6AAwgBCgCDCGVAiCVAhC1CCGWAiCWAhC4CCAEKAIcIZcCIAQoAgwhmAIgmAIoAgQhmQIglwIhmgIgmQIhmwIgmgIgmwJGIZwCQQEhnQIgnAIgnQJxIZ4CAkAgngJFDQAgBCgCDCGfAiAEIJ8CNgIcCyAEKAIMIaACIKACKAIEIaECIKECKAIAIaICIAQgogI2AgwLIAQoAgwhowIgowIoAgAhpAJBACGlAiCkAiGmAiClAiGnAiCmAiCnAkYhqAJBASGpAiCoAiCpAnEhqgICQAJAAkAgqgINACAEKAIMIasCIKsCKAIAIawCIKwCLQAMIa0CQQEhrgIgrQIgrgJxIa8CIK8CRQ0BCyAEKAIMIbACILACKAIEIbECQQAhsgIgsQIhswIgsgIhtAIgswIgtAJGIbUCQQEhtgIgtQIgtgJxIbcCAkAgtwINACAEKAIMIbgCILgCKAIEIbkCILkCLQAMIboCQQEhuwIgugIguwJxIbwCILwCRQ0BCyAEKAIMIb0CQQAhvgIgvQIgvgI6AAwgBCgCDCG/AiC/AhC1CCHAAiAEIMACNgIQIAQoAhAhwQIgwQItAAwhwgJBASHDAiDCAiDDAnEhxAICQAJAIMQCRQ0AIAQoAhAhxQIgBCgCHCHGAiDFAiHHAiDGAiHIAiDHAiDIAkYhyQJBASHKAiDJAiDKAnEhywIgywJFDQELIAQoAhAhzAJBASHNAiDMAiDNAjoADAwECyAEKAIQIc4CIM4CELYIIc8CQQEh0AIgzwIg0AJxIdECAkACQCDRAkUNACAEKAIQIdICINICELUIIdMCINMCKAIEIdQCINQCIdUCDAELIAQoAhAh1gIg1gIoAggh1wIg1wIoAgAh2AIg2AIh1QILINUCIdkCIAQg2QI2AgwMAQsgBCgCDCHaAiDaAigCACHbAkEAIdwCINsCId0CINwCId4CIN0CIN4CRiHfAkEBIeACIN8CIOACcSHhAgJAAkAg4QINACAEKAIMIeICIOICKAIAIeMCIOMCLQAMIeQCQQEh5QIg5AIg5QJxIeYCIOYCRQ0BCyAEKAIMIecCIOcCKAIEIegCQQEh6QIg6AIg6QI6AAwgBCgCDCHqAkEAIesCIOoCIOsCOgAMIAQoAgwh7AIg7AIQtwggBCgCDCHtAiDtAhC1CCHuAiAEIO4CNgIMCyAEKAIMIe8CIO8CELUIIfACIPACLQAMIfECIAQoAgwh8gJBASHzAiDxAiDzAnEh9AIg8gIg9AI6AAwgBCgCDCH1AiD1AhC1CCH2AkEBIfcCIPYCIPcCOgAMIAQoAgwh+AIg+AIoAgAh+QJBASH6AiD5AiD6AjoADCAEKAIMIfsCIPsCELUIIfwCIPwCELgIDAILCwwBCwsLC0EgIf0CIAQg/QJqIf4CIP4CJAAPC+gBARt/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgggAygCCCEEIAQoAgQhBUEAIQYgBSEHIAYhCCAHIAhHIQlBASEKIAkgCnEhCwJAAkAgC0UNACADKAIIIQwgDCgCBCENIA0Q2AghDiADIA42AgwMAQsCQANAIAMoAgghDyAPELYIIRBBfyERIBAgEXMhEkEBIRMgEiATcSEUIBRFDQEgAygCCCEVIBUQtQghFiADIBY2AggMAAsACyADKAIIIRcgFxC1CCEYIAMgGDYCDAsgAygCDCEZQRAhGiADIBpqIRsgGyQAIBkPC54CAR9/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhQgBiABNgIQIAYgAjYCDCAGIAM2AgggBigCFCEHAkADQCAGKAIMIQhBACEJIAghCiAJIQsgCiALRyEMQQEhDSAMIA1xIQ4gDkUNASAHEIMSIQ8gBigCDCEQQRAhESAQIBFqIRIgBigCECETIA8gEiATEIgSIRRBASEVIBQgFXEhFgJAAkAgFg0AIAYoAgwhFyAGIBc2AgggBigCDCEYIBgoAgAhGSAGIBk2AgwMAQsgBigCDCEaIBooAgQhGyAGIBs2AgwLDAALAAsgBigCCCEcQRghHSAGIB1qIR4gHiEfIB8gHBCYEhogBigCGCEgQSAhISAGICFqISIgIiQAICAPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEMYTIQVBECEGIAMgBmohByAHJAAgBQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC5gBARJ/IwAhBEEQIQUgBCAFayEGIAYkACAGIAA2AgwgBiABNgIIIAYgAjYCBCAGIAM2AgAgBigCCCEHIAcQoA8hCCAGKAIEIQkgCRCgDyEKIAYoAgAhCyALEKAPIQwgCCAKIAwQkxEhDUF/IQ4gDSEPIA4hECAPIBBGIRFBASESIBEgEnEhE0EQIRQgBiAUaiEVIBUkACATDwv9KgO8A3+GAXwTfiMAIQVBwAUhBiAFIAZrIQcgByQAIAcgADYCvAUgByABNgK4BSAHIAI2ArQFIAcgAzYCsAUgByAENgKsBSAHKAK8BSEIQbAUIQkgCCAJaiEKIAcoArgFIQsgCxCrEiEMIAcgDDYCnAVBnAUhDSAHIA1qIQ4gDiEPIAogDxDHDyHBA0GwFCEQIAggEGohESAHKAK0BSESIBIQqxIhEyAHIBM2ApgFQZgFIRQgByAUaiEVIBUhFiARIBYQxw8hwgMgwQMgwgOhIcMDIAcgwwM5A6AFQbAUIRcgCCAXaiEYIAcoArQFIRkgGRCrEiEaIAcgGjYCjAVBjAUhGyAHIBtqIRwgHCEdIBggHRDHDyHEA0GwFCEeIAggHmohHyAHKAKwBSEgICAQqxIhISAHICE2AogFQYgFISIgByAiaiEjICMhJCAfICQQxw8hxQMgxAMgxQOhIcYDIAcgxgM5A5AFQbAUISUgCCAlaiEmIAcoArgFIScgJxCsEiEoIAcgKDYC/ARB/AQhKSAHIClqISogKiErICYgKxDHDyHHA0GwFCEsIAggLGohLSAHKAK0BSEuIC4QrBIhLyAHIC82AvgEQfgEITAgByAwaiExIDEhMiAtIDIQxw8hyAMgxwMgyAOhIckDIAcgyQM5A4AFQbAUITMgCCAzaiE0IAcoArQFITUgNRCsEiE2IAcgNjYC7ARB7AQhNyAHIDdqITggOCE5IDQgORDHDyHKA0GwFCE6IAggOmohOyAHKAKwBSE8IDwQrBIhPSAHID02AugEQegEIT4gByA+aiE/ID8hQCA7IEAQxw8hywMgygMgywOhIcwDIAcgzAM5A/AEIAcoArgFIUEgQRCrEiFCIEIhQyBDrCHHBCAHKAK0BSFEIEQQqxIhRSBFIUYgRqwhyAQgxwQgyAR9IckEIAcoArQFIUcgRxCrEiFIIEghSSBJrCHKBCAHKAKwBSFKIEoQqxIhSyBLIUwgTKwhywQgygQgywR9IcwEIAcoArgFIU0gTRCsEiFOIE4hTyBPrCHNBCAHKAK0BSFQIFAQrBIhUSBRIVIgUqwhzgQgzQQgzgR9Ic8EIAcoArQFIVMgUxCsEiFUIFQhVSBVrCHQBCAHKAKwBSFWIFYQrBIhVyBXIVggWKwh0QQg0AQg0QR9IdIEIMkEIMwEIM8EINIEEJQRIc0DIAcgzQM5A+AEQbAUIVkgCCBZaiFaRAAAAAAAAOA/Ic4DIAcgzgM5A8gEQcgEIVsgByBbaiFcIFwhXSBaIF0QyQ8hzwMgBysD4AQh0AMgzwMg0AOjIdEDQbAUIV4gCCBeaiFfRAAAAAAAAABAIdIDIAcg0gM5A8AEQcAEIWAgByBgaiFhIGEhYiBfIGIQyQ8h0wNB0AQhYyAHIGNqIWQgZCFlIGUg0QMg0wMQ1RMaQbAUIWYgCCBmaiFnIAcoArgFIWggaBCrEiFpIAcgaTYCtARBtAQhaiAHIGpqIWsgayFsIGcgbBDHDyHUA0GwFCFtIAggbWohbiAHKAK0BSFvIG8QqxIhcCAHIHA2ArAEQbAEIXEgByBxaiFyIHIhcyBuIHMQxw8h1QMg1AMg1QOgIdYDIAcg1gM5A7gEQbAUIXQgCCB0aiF1IAcoArQFIXYgdhCrEiF3IAcgdzYCpARBpAQheCAHIHhqIXkgeSF6IHUgehDHDyHXA0GwFCF7IAgge2ohfCAHKAKwBSF9IH0QqxIhfiAHIH42AqAEQaAEIX8gByB/aiGAASCAASGBASB8IIEBEMcPIdgDINcDINgDoCHZAyAHINkDOQOoBEGwFCGCASAIIIIBaiGDASAHKAK4BSGEASCEARCsEiGFASAHIIUBNgKUBEGUBCGGASAHIIYBaiGHASCHASGIASCDASCIARDHDyHaA0GwFCGJASAIIIkBaiGKASAHKAK0BSGLASCLARCsEiGMASAHIIwBNgKQBEGQBCGNASAHII0BaiGOASCOASGPASCKASCPARDHDyHbAyDaAyDbA6Ah3AMgByDcAzkDmARBsBQhkAEgCCCQAWohkQEgBygCtAUhkgEgkgEQrBIhkwEgByCTATYChARBhAQhlAEgByCUAWohlQEglQEhlgEgkQEglgEQxw8h3QNBsBQhlwEgCCCXAWohmAEgBygCsAUhmQEgmQEQrBIhmgEgByCaATYCgARBgAQhmwEgByCbAWohnAEgnAEhnQEgmAEgnQEQxw8h3gMg3QMg3gOgId8DIAcg3wM5A4gEQbAUIZ4BIAggngFqIZ8BIAcoArgFIaABIKABEKsSIaEBIAcgoQE2AvQDQfQDIaIBIAcgogFqIaMBIKMBIaQBIJ8BIKQBEMcPIeADQbAUIaUBIAggpQFqIaYBIAcoArAFIacBIKcBEKsSIagBIAcgqAE2AvADQfADIakBIAcgqQFqIaoBIKoBIasBIKYBIKsBEMcPIeEDIOADIOEDoSHiAyAHIOIDOQP4A0GwFCGsASAIIKwBaiGtASAHKAK4BSGuASCuARCsEiGvASAHIK8BNgLkA0HkAyGwASAHILABaiGxASCxASGyASCtASCyARDHDyHjA0GwFCGzASAIILMBaiG0ASAHKAKwBSG1ASC1ARCsEiG2ASAHILYBNgLgA0HgAyG3ASAHILcBaiG4ASC4ASG5ASC0ASC5ARDHDyHkAyDjAyDkA6Eh5QMgByDlAzkD6ANBwAMhugEgByC6AWohuwEguwEhvAEgvAEQ1hMaQaADIb0BIAcgvQFqIb4BIL4BIb8BIL8BENYTGiAHKwOgBSHmAyAHKwO4BCHnAyDmAyDnA6Ih6AMgBysD8AQh6QMg6AMg6QOiIeoDQbAUIcABIAggwAFqIcEBRAAAAAAAAABAIesDIAcg6wM5A4gDQYgDIcIBIAcgwgFqIcMBIMMBIcQBIMEBIMQBEMkPIewDQZADIcUBIAcgxQFqIcYBIMYBIccBIMcBIOoDIOwDENUTGkHAAyHIASAHIMgBaiHJASDJASHKAUGQAyHLASAHIMsBaiHMASDMASHNASDKASDNARDXExogBysDgAUh7QMgBysDmAQh7gMg7QMg7gOiIe8DIAcrA/AEIfADIO8DIPADoiHxA0GwFCHOASAIIM4BaiHPAUQAAAAAAAAAQCHyAyAHIPIDOQPwAkHwAiHQASAHINABaiHRASDRASHSASDPASDSARDJDyHzA0H4AiHTASAHINMBaiHUASDUASHVASDVASDxAyDzAxDVExpBwAMh1gEgByDWAWoh1wEg1wEh2AFB+AIh2QEgByDZAWoh2gEg2gEh2wEg2AEg2wEQ1xMaIAcrA5AFIfQDIAcrA6gEIfUDIPQDIPUDoiH2AyAHKwOABSH3AyD2AyD3A6Ih+ANBsBQh3AEgCCDcAWoh3QFEAAAAAAAAAEAh+QMgByD5AzkD2AJB2AIh3gEgByDeAWoh3wEg3wEh4AEg3QEg4AEQyQ8h+gNB4AIh4QEgByDhAWoh4gEg4gEh4wEg4wEg+AMg+gMQ1RMaQcADIeQBIAcg5AFqIeUBIOUBIeYBQeACIecBIAcg5wFqIegBIOgBIekBIOYBIOkBENgTGiAHKwPwBCH7AyAHKwOIBCH8AyD7AyD8A6Ih/QMgBysDgAUh/gMg/QMg/gOiIf8DQbAUIeoBIAgg6gFqIesBRAAAAAAAAABAIYAEIAcggAQ5A8ACQcACIewBIAcg7AFqIe0BIO0BIe4BIOsBIO4BEMkPIYEEQcgCIe8BIAcg7wFqIfABIPABIfEBIPEBIP8DIIEEENUTGkHAAyHyASAHIPIBaiHzASDzASH0AUHIAiH1ASAHIPUBaiH2ASD2ASH3ASD0ASD3ARDYExogBysDkAUhggQgBysDqAQhgwQgggQggwSiIYQEIAcrA6AFIYUEIIQEIIUEoiGGBEGwFCH4ASAIIPgBaiH5AUQAAAAAAAAAQCGHBCAHIIcEOQOoAkGoAiH6ASAHIPoBaiH7ASD7ASH8ASD5ASD8ARDJDyGIBEGwAiH9ASAHIP0BaiH+ASD+ASH/ASD/ASCGBCCIBBDVExpBoAMhgAIgByCAAmohgQIggQIhggJBsAIhgwIgByCDAmohhAIghAIhhQIgggIghQIQ1xMaIAcrA/AEIYkEIAcrA4gEIYoEIIkEIIoEoiGLBCAHKwOgBSGMBCCLBCCMBKIhjQRBsBQhhgIgCCCGAmohhwJEAAAAAAAAAEAhjgQgByCOBDkDkAJBkAIhiAIgByCIAmohiQIgiQIhigIghwIgigIQyQ8hjwRBmAIhiwIgByCLAmohjAIgjAIhjQIgjQIgjQQgjwQQ1RMaQaADIY4CIAcgjgJqIY8CII8CIZACQZgCIZECIAcgkQJqIZICIJICIZMCIJACIJMCENcTGiAHKwOgBSGQBCAHKwO4BCGRBCCQBCCRBKIhkgQgBysDkAUhkwQgkgQgkwSiIZQEQbAUIZQCIAgglAJqIZUCRAAAAAAAAABAIZUEIAcglQQ5A/gBQfgBIZYCIAcglgJqIZcCIJcCIZgCIJUCIJgCEMkPIZYEQYACIZkCIAcgmQJqIZoCIJoCIZsCIJsCIJQEIJYEENUTGkGgAyGcAiAHIJwCaiGdAiCdAiGeAkGAAiGfAiAHIJ8CaiGgAiCgAiGhAiCeAiChAhDYExogBysDgAUhlwQgBysDmAQhmAQglwQgmASiIZkEIAcrA5AFIZoEIJkEIJoEoiGbBEGwFCGiAiAIIKICaiGjAkQAAAAAAAAAQCGcBCAHIJwEOQPgAUHgASGkAiAHIKQCaiGlAiClAiGmAiCjAiCmAhDJDyGdBEHoASGnAiAHIKcCaiGoAiCoAiGpAiCpAiCbBCCdBBDVExpBoAMhqgIgByCqAmohqwIgqwIhrAJB6AEhrQIgByCtAmohrgIgrgIhrwIgrAIgrwIQ2BMaQcABIbACIAcgsAJqIbECILECIbICQcADIbMCIAcgswJqIbQCILQCIbUCILUCKQMAIdMEILICINMENwMAQRghtgIgsgIgtgJqIbcCILUCILYCaiG4AiC4AikDACHUBCC3AiDUBDcDAEEQIbkCILICILkCaiG6AiC1AiC5AmohuwIguwIpAwAh1QQgugIg1QQ3AwBBCCG8AiCyAiC8AmohvQIgtQIgvAJqIb4CIL4CKQMAIdYEIL0CINYENwMAIAcrA6AFIZ4EIAcrA6AFIZ8EIJ4EIJ8EoiGgBCAHKwOABSGhBCAHKwOABSGiBCChBCCiBKIhowQgoAQgowSgIaQEIAcrA5AFIaUEIAcrA5AFIaYEIKUEIKYEoiGnBCAHKwPwBCGoBCAHKwPwBCGpBCCoBCCpBKIhqgQgpwQgqgSgIasEIKQEIKsEoiGsBCAHKwP4AyGtBCAHKwP4AyGuBCCtBCCuBKIhrwQgBysD6AMhsAQgBysD6AMhsQQgsAQgsQSiIbIEIK8EILIEoCGzBCCsBCCzBKIhtAQgByC0BDkDqAFBqAEhvwIgByC/AmohwAIgwAIhwQIgwQIQrxIhtQRBsBQhwgIgCCDCAmohwwJEAAAAAAAAFEAhtgQgByC2BDkDoAFBoAEhxAIgByDEAmohxQIgxQIhxgIgwwIgxgIQyQ8htwRBsAEhxwIgByDHAmohyAIgyAIhyQIgyQIgtQQgtwQQ1RMaQcABIcoCIAcgygJqIcsCIMsCIcwCQbABIc0CIAcgzQJqIc4CIM4CIc8CIMwCIM8CENgTGkHwACHQAiAHINACaiHRAiDRAiHSAkHAAyHTAiAHINMCaiHUAiDUAiHVAiDSAiDVAhDZE0HwACHWAiAHINYCaiHXAiDXAiHYAiDYAhDaEyG4BEHQBCHZAiAHINkCaiHaAiDaAiHbAiDbAhDaEyG5BCC4BCC5BKIhugRB4AAh3AIgByDcAmoh3QIg3QIh3gJBoAMh3wIgByDfAmoh4AIg4AIh4QIg3gIg4QIQ2RNB4AAh4gIgByDiAmoh4wIg4wIh5AIg5AIQ2hMhuwRB0AQh5QIgByDlAmoh5gIg5gIh5wIg5wIQ2hMhvAQguwQgvASiIb0EQdAAIegCIAcg6AJqIekCIOkCIeoCQcABIesCIAcg6wJqIewCIOwCIe0CIOoCIO0CENkTQdAAIe4CIAcg7gJqIe8CIO8CIfACIPACENoTIb4EQdAEIfECIAcg8QJqIfICIPICIfMCIPMCENoTIb8EIL4EIL8EoiHABEGAASH0AiAHIPQCaiH1AiD1AiH2AiD2AiC6BCC9BCDABBDbExogBygCrAUh9wJBgAEh+AIgByD4Amoh+QIg+QIh+gIg+gIpAwAh1wQg9wIg1wQ3AwBBGCH7AiD3AiD7Amoh/AIg+gIg+wJqIf0CIP0CLQAAIf4CIPwCIP4COgAAQRAh/wIg9wIg/wJqIYADIPoCIP8CaiGBAyCBAykDACHYBCCAAyDYBDcDAEEIIYIDIPcCIIIDaiGDAyD6AiCCA2ohhAMghAMpAwAh2QQggwMg2QQ3AwBBOCGFAyAHIIUDaiGGAyCGAyGHA0HAAyGIAyAHIIgDaiGJAyCJAyGKAyCHAyCKAxDZE0E4IYsDIAcgiwNqIYwDIIwDIY0DII0DENwTIcEERAAAAAAAAFBAIcIEIMEEIMIEZCGOA0EBIY8DII4DII8DcSGQAyAHIJADOgBPQSAhkQMgByCRA2ohkgMgkgMhkwNBoAMhlAMgByCUA2ohlQMglQMhlgMgkwMglgMQ2RNBICGXAyAHIJcDaiGYAyCYAyGZAyCZAxDcEyHDBEQAAAAAAABQQCHEBCDDBCDEBGQhmgNBASGbAyCaAyCbA3EhnAMgByCcAzoAN0EIIZ0DIAcgnQNqIZ4DIJ4DIZ8DQcABIaADIAcgoANqIaEDIKEDIaIDIJ8DIKIDENkTQQghowMgByCjA2ohpAMgpAMhpQMgpQMQ3BMhxQREAAAAAAAAUEAhxgQgxQQgxgRkIaYDQQEhpwMgpgMgpwNxIagDIAcgqAM6AB8gBy0ATyGpA0EBIaoDIKkDIKoDcSGrAwJAAkAgqwMNACAHLQA3IawDQQEhrQMgrAMgrQNxIa4DIK4DDQAgBy0AHyGvA0EBIbADIK8DILADcSGxAyCxA0UNAQsgBygCuAUhsgMgBygCtAUhswMgBygCsAUhtAMgBygCrAUhtQMgBy0ATyG2AyAHLQA3IbcDIActAB8huANBASG5AyC2AyC5A3EhugNBASG7AyC3AyC7A3EhvANBASG9AyC4AyC9A3EhvgMgCCCyAyCzAyC0AyC1AyC6AyC8AyC+AxDdEwtBwAUhvwMgByC/A2ohwAMgwAMkAA8L9AYBdn8jACEFQSAhBiAFIAZrIQcgByQAIAcgADYCGCAHIAE2AhQgByACNgIQIAcgAzYCDCAHIAQ2AgggBygCCCEIQQIhCSAIIQogCSELIAogC0chDEEBIQ0gDCANcSEOAkACQAJAIA5FDQAgBygCFCEPIA8QoA8hECAHKAIQIREgERCgDyESIAcoAgwhEyATEKAPIRQgECASIBQQkxEhFSAHIBU2AgQgBygCFCEWIBYQoA8hFyAHKAIQIRggGBCgDyEZIAcoAgwhGiAaEMAPIRsgFyAZIBsQkxEhHCAHIBw2AgAgBygCCCEdQQEhHiAdIR8gHiEgIB8gIEYhIUEBISIgISAicSEjAkACQCAjRQ0AIAcoAhQhJCAkEMYPISUgBygCECEmICYQxg8hJyAlISggJyEpICggKU4hKkEBISsgKiArcSEsICxFDQAgBygCBCEtQX8hLiAtIS8gLiEwIC8gMEchMUEBITIgMSAycSEzAkAgM0UNAEEAITRBASE1IDQgNXEhNiAHIDY6AB8MBQsMAQsgBygCCCE3QQMhOCA3ITkgOCE6IDkgOkYhO0EBITwgOyA8cSE9AkACQCA9RQ0AIAcoAhAhPiA+EMYPIT8gBygCFCFAIEAQxg8hQSA/IUIgQSFDIEIgQ04hREEBIUUgRCBFcSFGIEZFDQAgBygCACFHQX8hSCBHIUkgSCFKIEkgSkchS0EBIUwgSyBMcSFNAkAgTUUNAEEAIU5BASFPIE4gT3EhUCAHIFA6AB8MBgsMAQsgBygCBCFRQX8hUiBRIVMgUiFUIFMgVEchVUEBIVYgVSBWcSFXAkAgV0UNACAHKAIAIVhBfyFZIFghWiBZIVsgWiBbRyFcQQEhXSBcIF1xIV4gXkUNAEEAIV9BASFgIF8gYHEhYSAHIGE6AB8MBQsLCwwBCyAHKAIMIWIgYhCgDyFjIAcoAhQhZCBkEKAPIWUgYyBlEOURIWZBASFnQQEhaCBmIGhxIWkgZyFqAkAgaQ0AIAcoAgwhayBrEMAPIWwgBygCECFtIG0QoA8hbiBsIG4Q5REhbyBvIWoLIGohcEEBIXEgcCBxcSFyIAcgcjoAHwwBC0EBIXNBASF0IHMgdHEhdSAHIHU6AB8LIActAB8hdkEBIXcgdiB3cSF4QSAheSAHIHlqIXogeiQAIHgPC+hAA58Gf0p8P34jACEGQfAKIQcgBiAHayEIIAgkACAIIAA2AuwKIAggATYC6AogCCACNgLkCiAIIAM2AuAKIAggBDYC3AogCCAFNgLYCiAIKALsCiEJQbAUIQogCSAKaiELIAgoAuAKIQwgDBCnEiENIAggDTYCzApBzAohDiAIIA5qIQ8gDyEQIAsgEBDHDyGlBkGwFCERIAkgEWohEiAIKALgCiETIBMQkhEhFCAIIBQ2AsgKQcgKIRUgCCAVaiEWIBYhFyASIBcQxw8hpgYgpQYgpgahIacGIAggpwY5A9AKQbAUIRggCSAYaiEZIAgoAuAKIRogGhDGDyEbIAggGzYCvApBvAohHCAIIBxqIR0gHSEeIBkgHhDHDyGoBkGwFCEfIAkgH2ohICAIKALgCiEhICEQ3hMhIiAIICI2ArgKQbgKISMgCCAjaiEkICQhJSAgICUQxw8hqQYgqAYgqQahIaoGIAggqgY5A8AKQbAUISYgCSAmaiEnIAgoAuQKISggKBCsEiEpIAggKTYCrApBrAohKiAIICpqISsgKyEsICcgLBDHDyGrBkGwFCEtIAkgLWohLiAIKALoCiEvIC8QrBIhMCAIIDA2AqgKQagKITEgCCAxaiEyIDIhMyAuIDMQxw8hrAYgqwYgrAahIa0GIAggrQY5A7AKQbAUITQgCSA0aiE1IAgoAugKITYgNhCrEiE3IAggNzYCnApBnAohOCAIIDhqITkgOSE6IDUgOhDHDyGuBkGwFCE7IAkgO2ohPCAIKALkCiE9ID0QqxIhPiAIID42ApgKQZgKIT8gCCA/aiFAIEAhQSA8IEEQxw8hrwYgrgYgrwahIbAGIAggsAY5A6AKIAgoAuAKIUIgQhCnEiFDIEMhRCBErCHvBiAIKALgCiFFIEUQkhEhRiBGIUcgR6wh8AYg7wYg8AZ9IfEGIAgoAuAKIUggSBDGDyFJIEkhSiBKrCHyBiAIKALgCiFLIEsQ3hMhTCBMIU0gTawh8wYg8gYg8wZ9IfQGIAgoAuQKIU4gThCrEiFPIE8hUCBQrCH1BiAIKALoCiFRIFEQqxIhUiBSIVMgU6wh9gYg9QYg9gZ9IfcGIAgoAuQKIVQgVBCsEiFVIFUhViBWrCH4BiAIKALoCiFXIFcQrBIhWCBYIVkgWawh+QYg+AYg+QZ9IfoGIPEGIPQGIPcGIPoGEJQRIbEGQbAUIVogCSBaaiFbRAAAAAAAAPA/IbIGIAggsgY5A4AKQYAKIVwgCCBcaiFdIF0hXiBbIF4QyQ8hswZBiAohXyAIIF9qIWAgYCFhIGEgsQYgswYQ1RMaIAgoAuAKIWIgYhCSESFjIGMhZCBkrCH7BiAIKALgCiFlIGUQpxIhZiBmIWcgZ6wh/AYg+wYg/AZ9If0GIAgoAuAKIWggaBDGDyFpIGkhaiBqrCH+BiAIKALgCiFrIGsQ3hMhbCBsIW0gbawh/wYg/gYg/wZ9IYAHIAgoAuAKIW4gbhCnEiFvIG8hcCBwrCGBByAIKALoCiFxIHEQrBIhciByIXMgc6whggcggQcgggd9IYMHIAgoAuAKIXQgdBDeEyF1IHUhdiB2rCGEByAIKALoCiF3IHcQqxIheCB4IXkgeawhhQcghAcghQd9IYYHIP0GIIAHIIMHIIYHEJQRIbQGQbAUIXogCSB6aiF7RAAAAAAAAPA/IbUGIAggtQY5A+gJQegJIXwgCCB8aiF9IH0hfiB7IH4QyQ8htgZB8AkhfyAIIH9qIYABIIABIYEBIIEBILQGILYGENUTGiAIKALgCiGCASCCARCSESGDASCDASGEASCEAawhhwcgCCgC4AohhQEghQEQpxIhhgEghgEhhwEghwGsIYgHIIcHIIgHfSGJByAIKALgCiGIASCIARDGDyGJASCJASGKASCKAawhigcgCCgC4AohiwEgiwEQ3hMhjAEgjAEhjQEgjQGsIYsHIIoHIIsHfSGMByAIKALgCiGOASCOARCnEiGPASCPASGQASCQAawhjQcgCCgC5AohkQEgkQEQrBIhkgEgkgEhkwEgkwGsIY4HII0HII4HfSGPByAIKALgCiGUASCUARDeEyGVASCVASGWASCWAawhkAcgCCgC5AohlwEglwEQqxIhmAEgmAEhmQEgmQGsIZEHIJAHIJEHfSGSByCJByCMByCPByCSBxCUESG3BkGwFCGaASAJIJoBaiGbAUQAAAAAAADwPyG4BiAIILgGOQPQCUHQCSGcASAIIJwBaiGdASCdASGeASCbASCeARDJDyG5BkHYCSGfASAIIJ8BaiGgASCgASGhASChASC3BiC5BhDVExogCCgC6AohogEgogEQrBIhowEgowEhpAEgpAGsIZMHIAgoAuQKIaUBIKUBEKwSIaYBIKYBIacBIKcBrCGUByCTByCUB30hlQcgCCgC6AohqAEgqAEQqxIhqQEgqQEhqgEgqgGsIZYHIAgoAuQKIasBIKsBEKsSIawBIKwBIa0BIK0BrCGXByCWByCXB30hmAcgCCgC4AohrgEgrgEQpxIhrwEgrwEhsAEgsAGsIZkHIAgoAuAKIbEBILEBEJIRIbIBILIBIbMBILMBrCGaByCZByCaB30hmwcgCCgC4AohtAEgtAEQ3hMhtQEgtQEhtgEgtgGsIZwHIAgoAuAKIbcBILcBEMYPIbgBILgBIbkBILkBrCGdByCcByCdB30hngcglQcgmAcgmwcgngcQlBEhugZBsBQhugEgCSC6AWohuwFEAAAAAAAA8D8huwYgCCC7BjkDuAlBuAkhvAEgCCC8AWohvQEgvQEhvgEguwEgvgEQyQ8hvAZBwAkhvwEgCCC/AWohwAEgwAEhwQEgwQEgugYgvAYQ1RMaQbAUIcIBIAkgwgFqIcMBRAAAAAAAAPA/Ib0GIAggvQY5A6AJQaAJIcQBIAggxAFqIcUBIMUBIcYBIMMBIMYBEMkPIb4GIAgrA9AKIb8GIAgrA9AKIcAGIL8GIMAGoiHBBiAIKwPACiHCBiAIKwPACiHDBiDCBiDDBqIhxAYgwQYgxAagIcUGIAggxQY5A5gJQZgJIccBIAggxwFqIcgBIMgBIckBIMkBEK8SIcYGIL4GIMYGoyHHBkGwFCHKASAJIMoBaiHLAUQAAAAAAAAIQCHIBiAIIMgGOQOQCUGQCSHMASAIIMwBaiHNASDNASHOASDLASDOARDJDyHJBkGoCSHPASAIIM8BaiHQASDQASHRASDRASDHBiDJBhDVExpB8Agh0gEgCCDSAWoh0wEg0wEh1AEg1AEQ1hMaQeAIIdUBIAgg1QFqIdYBINYBIdcBQcAJIdgBIAgg2AFqIdkBINkBIdoBINoBKQMAIZ8HINcBIJ8HNwMAQQgh2wEg1wEg2wFqIdwBINoBINsBaiHdASDdASkDACGgByDcASCgBzcDAEEIId4BIAgg3gFqId8BQeAIIeABIAgg4AFqIeEBIOEBIN4BaiHiASDiASkDACGhByDfASChBzcDACAIKQPgCCGiByAIIKIHNwMAIAgQ3xMh4wECQAJAIOMBDQBBsBQh5AEgCSDkAWoh5QFEAAAAAAAAIEAhygYgCCDKBjkDqAhBqAgh5gEgCCDmAWoh5wEg5wEh6AEg5QEg6AEQyQ8hywZBsAgh6QEgCCDpAWoh6gEg6gEh6wEg6wEgywYQ4BMaQcAIIewBIAgg7AFqIe0BIO0BIe4BQbAIIe8BIAgg7wFqIfABIPABIfEBQfAJIfIBIAgg8gFqIfMBIPMBIfQBIO4BIPEBIPQBEOETQdAIIfUBIAgg9QFqIfYBIPYBIfcBQYgKIfgBIAgg+AFqIfkBIPkBIfoBQcAIIfsBIAgg+wFqIfwBIPwBIf0BIPcBIPoBIP0BEOITQfAIIf4BIAgg/gFqIf8BIP8BIYACQdAIIYECIAgggQJqIYICIIICIYMCIIACIIMCENcTGkGwFCGEAiAJIIQCaiGFAkQAAAAAAAAAQCHMBiAIIMwGOQPwB0HwByGGAiAIIIYCaiGHAiCHAiGIAiCFAiCIAhDJDyHNBkH4ByGJAiAIIIkCaiGKAiCKAiGLAiCLAiDNBhDgExpBiAghjAIgCCCMAmohjQIgjQIhjgJB+AchjwIgCCCPAmohkAIgkAIhkQJBiAohkgIgCCCSAmohkwIgkwIhlAIgjgIgkQIglAIQ4RNBmAghlQIgCCCVAmohlgIglgIhlwJB8AkhmAIgCCCYAmohmQIgmQIhmgJBiAghmwIgCCCbAmohnAIgnAIhnQIglwIgmgIgnQIQ4hNB8AghngIgCCCeAmohnwIgnwIhoAJBmAghoQIgCCChAmohogIgogIhowIgoAIgowIQ2BMaDAELQaAHIaQCIAggpAJqIaUCIKUCIaYCQYgKIacCIAggpwJqIagCIKgCIakCIKYCIKkCIKkCEOETQZAHIaoCIAggqgJqIasCIKsCIawCQcAJIa0CIAggrQJqIa4CIK4CIa8CIKwCIK8CIK8CEOETQbAHIbACIAggsAJqIbECILECIbICQaAHIbMCIAggswJqIbQCILQCIbUCQZAHIbYCIAggtgJqIbcCILcCIbgCILICILUCILgCEOMTQcAHIbkCIAgguQJqIboCILoCIbsCQbAHIbwCIAggvAJqIb0CIL0CIb4CQfAJIb8CIAggvwJqIcACIMACIcECILsCIL4CIMECEOETQdAHIcICIAggwgJqIcMCIMMCIcQCQcAHIcUCIAggxQJqIcYCIMYCIccCQdgJIcgCIAggyAJqIckCIMkCIcoCIMQCIMcCIMoCEOETQeAHIcsCIAggywJqIcwCIMwCIc0CQdAHIc4CIAggzgJqIc8CIM8CIdACIM0CINACEOQTIAgoAtwKIdECQQIh0gIg0QIh0wIg0gIh1AIg0wIg1AJGIdUCQQEh1gIg1QIg1gJxIdcCAkACQCDXAkUNAEHwBiHYAiAIINgCaiHZAiDZAiHaAkHACSHbAiAIINsCaiHcAiDcAiHdAiDaAiDdAiDdAhDhE0GAByHeAiAIIN4CaiHfAiDfAiHgAkHgByHhAiAIIOECaiHiAiDiAiHjAkHwBiHkAiAIIOQCaiHlAiDlAiHmAiDgAiDjAiDmAhDiE0HwCCHnAiAIIOcCaiHoAiDoAiHpAkGAByHqAiAIIOoCaiHrAiDrAiHsAiDpAiDsAhDYExoMAQtB0AYh7QIgCCDtAmoh7gIg7gIh7wJBwAkh8AIgCCDwAmoh8QIg8QIh8gIg7wIg8gIg8gIQ4RNB4AYh8wIgCCDzAmoh9AIg9AIh9QJB4Ach9gIgCCD2Amoh9wIg9wIh+AJB0AYh+QIgCCD5Amoh+gIg+gIh+wIg9QIg+AIg+wIQ4hNB8Agh/AIgCCD8Amoh/QIg/QIh/gJB4AYh/wIgCCD/AmohgAMggAMhgQMg/gIggQMQ1xMaC0GgBiGCAyAIIIIDaiGDAyCDAyGEA0HwCSGFAyAIIIUDaiGGAyCGAyGHA0HYCSGIAyAIIIgDaiGJAyCJAyGKAyCEAyCHAyCKAxDjE0GwBiGLAyAIIIsDaiGMAyCMAyGNA0GICiGOAyAIII4DaiGPAyCPAyGQA0GgBiGRAyAIIJEDaiGSAyCSAyGTAyCNAyCQAyCTAxDhE0GwFCGUAyAJIJQDaiGVA0QAAAAAAAAAQCHOBiAIIM4GOQPoBUHoBSGWAyAIIJYDaiGXAyCXAyGYAyCVAyCYAxDJDyHPBkHwBSGZAyAIIJkDaiGaAyCaAyGbAyCbAyDPBhDgExpBgAYhnAMgCCCcA2ohnQMgnQMhngNB8AUhnwMgCCCfA2ohoAMgoAMhoQNBwAkhogMgCCCiA2ohowMgowMhpAMgngMgoQMgpAMQ4RNBkAYhpQMgCCClA2ohpgMgpgMhpwNBgAYhqAMgCCCoA2ohqQMgqQMhqgNBwAkhqwMgCCCrA2ohrAMgrAMhrQMgpwMgqgMgrQMQ4RNBwAYhrgMgCCCuA2ohrwMgrwMhsANBsAYhsQMgCCCxA2ohsgMgsgMhswNBkAYhtAMgCCC0A2ohtQMgtQMhtgMgsAMgswMgtgMQ4hNB8AghtwMgCCC3A2ohuAMguAMhuQNBwAYhugMgCCC6A2ohuwMguwMhvAMguQMgvAMQ1xMaC0HIBSG9AyAIIL0DaiG+AyC+AyG/AyC/AxDWExpBqAUhwAMgCCDAA2ohwQMgwQMhwgMgwgMQ1hMaQbAUIcMDIAkgwwNqIcQDRAAAAAAAAOA/IdAGIAgg0AY5A5AFQZAFIcUDIAggxQNqIcYDIMYDIccDIMQDIMcDEMkPIdEGQbAUIcgDIAkgyANqIckDIAgoAugKIcoDIMoDEKsSIcsDIAggywM2AowFQYwFIcwDIAggzANqIc0DIM0DIc4DIMkDIM4DEMcPIdIGQbAUIc8DIAkgzwNqIdADIAgoAuQKIdEDINEDEKsSIdIDIAgg0gM2AogFQYgFIdMDIAgg0wNqIdQDINQDIdUDINADINUDEMcPIdMGINIGINMGoCHUBiDRBiDUBqIh1QZBmAUh1gMgCCDWA2oh1wMg1wMh2AMg2AMg1QYQ4BMaQcgFIdkDIAgg2QNqIdoDINoDIdsDQZgFIdwDIAgg3ANqId0DIN0DId4DINsDIN4DENcTGiAIKwOwCiHWBkHYBCHfAyAIIN8DaiHgAyDgAyHhAyDhAyDWBhDgExpB6AQh4gMgCCDiA2oh4wMg4wMh5ANB2AQh5QMgCCDlA2oh5gMg5gMh5wNB8Agh6AMgCCDoA2oh6QMg6QMh6gMg5AMg5wMg6gMQ5RNByAUh6wMgCCDrA2oh7AMg7AMh7QNB6AQh7gMgCCDuA2oh7wMg7wMh8AMg7QMg8AMQ5hMaQbAUIfEDIAkg8QNqIfIDRAAAAAAAAOA/IdcGIAgg1wY5A8AEQcAEIfMDIAgg8wNqIfQDIPQDIfUDIPIDIPUDEMkPIdgGQbAUIfYDIAkg9gNqIfcDIAgoAugKIfgDIPgDEKwSIfkDIAgg+QM2ArwEQbwEIfoDIAgg+gNqIfsDIPsDIfwDIPcDIPwDEMcPIdkGQbAUIf0DIAkg/QNqIf4DIAgoAuQKIf8DIP8DEKwSIYAEIAgggAQ2ArgEQbgEIYEEIAgggQRqIYIEIIIEIYMEIP4DIIMEEMcPIdoGINkGINoGoCHbBiDYBiDbBqIh3AZByAQhhAQgCCCEBGohhQQghQQhhgQghgQg3AYQ4BMaQagFIYcEIAgghwRqIYgEIIgEIYkEQcgEIYoEIAggigRqIYsEIIsEIYwEIIkEIIwEENcTGiAIKwOgCiHdBkGIBCGNBCAIII0EaiGOBCCOBCGPBCCPBCDdBhDgExpBmAQhkAQgCCCQBGohkQQgkQQhkgRBiAQhkwQgCCCTBGohlAQglAQhlQRB8AghlgQgCCCWBGohlwQglwQhmAQgkgQglQQgmAQQ5RNBqAUhmQQgCCCZBGohmgQgmgQhmwRBmAQhnAQgCCCcBGohnQQgnQQhngQgmwQgngQQ5hMaQegDIZ8EIAggnwRqIaAEIKAEIaEEIKEEENYTGkHIAyGiBCAIIKIEaiGjBCCjBCGkBEHIBSGlBCAIIKUEaiGmBCCmBCGnBCCnBCkDACGjByCkBCCjBzcDAEEYIagEIKQEIKgEaiGpBCCnBCCoBGohqgQgqgQpAwAhpAcgqQQgpAc3AwBBECGrBCCkBCCrBGohrAQgpwQgqwRqIa0EIK0EKQMAIaUHIKwEIKUHNwMAQQghrgQgpAQgrgRqIa8EIKcEIK4EaiGwBCCwBCkDACGmByCvBCCmBzcDACAIKwPQCiHeBkGoAyGxBCAIILEEaiGyBCCyBCGzBCCzBCDeBhDgExogCCgC4AohtAQgtAQQxg8htQQgtQS3Id8GQZgDIbYEIAggtgRqIbcEILcEIbgEILgEIN8GEOATGkG4AyG5BCAIILkEaiG6BCC6BCG7BEGoAyG8BCAIILwEaiG9BCC9BCG+BEGYAyG/BCAIIL8EaiHABCDABCHBBCC7BCC+BCDBBBDhE0HoAyHCBCAIIMIEaiHDBCDDBCHEBEG4AyHFBCAIIMUEaiHGBCDGBCHHBCDEBCDHBBDYExogCCsDwAoh4AZB+AIhyAQgCCDIBGohyQQgyQQhygQgygQg4AYQ4BMaIAgoAuAKIcsEIMsEEJIRIcwEIMwEtyHhBkHoAiHNBCAIIM0EaiHOBCDOBCHPBCDPBCDhBhDgExpBiAMh0AQgCCDQBGoh0QQg0QQh0gRB+AIh0wQgCCDTBGoh1AQg1AQh1QRB6AIh1gQgCCDWBGoh1wQg1wQh2AQg0gQg1QQg2AQQ4RNB6AMh2QQgCCDZBGoh2gQg2gQh2wRBiAMh3AQgCCDcBGoh3QQg3QQh3gQg2wQg3gQQ2BMaIAgrA9AKIeIGQbgCId8EIAgg3wRqIeAEIOAEIeEEIOEEIOIGEOATGkHIAiHiBCAIIOIEaiHjBCDjBCHkBEG4AiHlBCAIIOUEaiHmBCDmBCHnBEHIBSHoBCAIIOgEaiHpBCDpBCHqBCDkBCDnBCDqBBDlE0HoAyHrBCAIIOsEaiHsBCDsBCHtBEHIAiHuBCAIIO4EaiHvBCDvBCHwBCDtBCDwBBDmExogCCsDwAoh4wZBiAIh8QQgCCDxBGoh8gQg8gQh8wQg8wQg4wYQ4BMaQZgCIfQEIAgg9ARqIfUEIPUEIfYEQYgCIfcEIAgg9wRqIfgEIPgEIfkEQagFIfoEIAgg+gRqIfsEIPsEIfwEIPYEIPkEIPwEEOUTQegDIf0EIAgg/QRqIf4EIP4EIf8EQZgCIYAFIAgggAVqIYEFIIEFIYIFIP8EIIIFEOYTGkH4ASGDBSAIIIMFaiGEBSCEBSGFBUHoAyGGBSAIIIYFaiGHBSCHBSGIBSCFBSCIBRDnE0H4ASGJBSAIIIkFaiGKBSCKBSGLBSCLBRDaEyHkBkHoASGMBSAIIIwFaiGNBSCNBSGOBUHoAyGPBSAIII8FaiGQBSCQBSGRBSCOBSCRBRDoE0HoASGSBSAIIJIFaiGTBSCTBSGUBSCUBRDaEyHlBiDkBiDlBmMhlQVBASGWBSCVBSCWBXEhlwUCQCCXBUUNAEHIASGYBSAIIJgFaiGZBSCZBSGaBUHoAyGbBSAIIJsFaiGcBSCcBSGdBSCaBSCdBRDpE0HoAyGeBSAIIJ4FaiGfBSCfBSGgBUHIASGhBSAIIKEFaiGiBSCiBSGjBSCjBSkDACGnByCgBSCnBzcDAEEYIaQFIKAFIKQFaiGlBSCjBSCkBWohpgUgpgUpAwAhqAcgpQUgqAc3AwBBECGnBSCgBSCnBWohqAUgowUgpwVqIakFIKkFKQMAIakHIKgFIKkHNwMAQQghqgUgoAUgqgVqIasFIKMFIKoFaiGsBSCsBSkDACGqByCrBSCqBzcDAAtBqAEhrQUgCCCtBWohrgUgrgUhrwVB6AMhsAUgCCCwBWohsQUgsQUhsgVBqAkhswUgCCCzBWohtAUgtAUhtQUgrwUgsgUgtQUQ6hNByAMhtgUgCCC2BWohtwUgtwUhuAVBqAEhuQUgCCC5BWohugUgugUhuwUguAUguwUQ5hMaQfgAIbwFIAggvAVqIb0FIL0FIb4FQcgFIb8FIAggvwVqIcAFIMAFIcEFIL4FIMEFENkTQfgAIcIFIAggwgVqIcMFIMMFIcQFIMQFENoTIeYGQegAIcUFIAggxQVqIcYFIMYFIccFQagFIcgFIAggyAVqIckFIMkFIcoFIMcFIMoFENkTQegAIcsFIAggywVqIcwFIMwFIc0FIM0FENoTIecGQdgAIc4FIAggzgVqIc8FIM8FIdAFQcgDIdEFIAgg0QVqIdIFINIFIdMFINAFINMFENkTQdgAIdQFIAgg1AVqIdUFINUFIdYFINYFENoTIegGQYgBIdcFIAgg1wVqIdgFINgFIdkFINkFIOYGIOcGIOgGENsTGiAIKALYCiHaBUGIASHbBSAIINsFaiHcBSDcBSHdBSDdBSkDACGrByDaBSCrBzcDAEEYId4FINoFIN4FaiHfBSDdBSDeBWoh4AUg4AUtAAAh4QUg3wUg4QU6AABBECHiBSDaBSDiBWoh4wUg3QUg4gVqIeQFIOQFKQMAIawHIOMFIKwHNwMAQQgh5QUg2gUg5QVqIeYFIN0FIOUFaiHnBSDnBSkDACGtByDmBSCtBzcDAEHAACHoBSAIIOgFaiHpBSDpBSHqBUHIBSHrBSAIIOsFaiHsBSDsBSHtBSDqBSDtBRDZE0HAACHuBSAIIO4FaiHvBSDvBSHwBSDwBRDcEyHpBkQAAAAAAABQQCHqBiDpBiDqBmQh8QVBASHyBSDxBSDyBXEh8wUgCCDzBToAV0EoIfQFIAgg9AVqIfUFIPUFIfYFQagFIfcFIAgg9wVqIfgFIPgFIfkFIPYFIPkFENkTQSgh+gUgCCD6BWoh+wUg+wUh/AUg/AUQ3BMh6wZEAAAAAAAAUEAh7AYg6wYg7AZkIf0FQQEh/gUg/QUg/gVxIf8FIAgg/wU6AD9BECGABiAIIIAGaiGBBiCBBiGCBkHIAyGDBiAIIIMGaiGEBiCEBiGFBiCCBiCFBhDZE0EQIYYGIAgghgZqIYcGIIcGIYgGIIgGENwTIe0GRAAAAAAAAFBAIe4GIO0GIO4GZCGJBkEBIYoGIIkGIIoGcSGLBiAIIIsGOgAnIAgtAFchjAZBASGNBiCMBiCNBnEhjgYCQAJAII4GDQAgCC0APyGPBkEBIZAGII8GIJAGcSGRBiCRBg0AIAgtACchkgZBASGTBiCSBiCTBnEhlAYglAZFDQELIAgoAugKIZUGIAgoAuQKIZYGIAgoAuAKIZcGIAgoAtwKIZgGIAgoAtgKIZkGIAgtAFchmgYgCC0APyGbBiAILQAnIZwGQQEhnQYgmgYgnQZxIZ4GQQEhnwYgmwYgnwZxIaAGQQEhoQYgnAYgoQZxIaIGIAkglQYglgYglwYgmAYgmQYgngYgoAYgogYQ6xMLQfAKIaMGIAggowZqIaQGIKQGJAAPC5QEAUZ/IwAhBUEgIQYgBSAGayEHIAckACAHIAA2AhggByABNgIUIAcgAjYCECAHIAM2AgwgByAENgIIIAcoAhAhCCAIEMwRIQkgBygCDCEKIAoQzBEhCyAJIQwgCyENIAwgDUYhDkEBIQ8gDiAPcSEQAkACQCAQRQ0AQQAhEUEBIRIgESAScSETIAcgEzoAHwwBCyAHKAIIIRRBAiEVIBQhFiAVIRcgFiAXRiEYQQEhGSAYIBlxIRoCQCAaRQ0AIAcoAhAhGyAbEK0SIRxBASEdIBwgHXEhHgJAIB4NACAHKAIMIR8gHxCtEiEgQQEhISAgICFxISIgIkUNAEEAISNBASEkICMgJHEhJSAHICU6AB8MAgsgBygCECEmICYQrRIhJ0EBISggJyAocSEpIAcoAgwhKiAqEK0SIStBASEsICsgLHEhLSApIS4gLSEvIC4gL0YhMEEBITEgMCAxcSEyAkAgMkUNACAHKAIQITMgMxCgDyE0IAcoAhQhNSA1EKAPITYgBygCDCE3IDcQwA8hOCA0IDYgOBCTESE5QX8hOiA5ITsgOiE8IDsgPEchPUEBIT4gPSA+cSE/ID9FDQBBACFAQQEhQSBAIEFxIUIgByBCOgAfDAILC0EBIUNBASFEIEMgRHEhRSAHIEU6AB8LIActAB8hRkEBIUcgRiBHcSFIQSAhSSAHIElqIUogSiQAIEgPC7SEAQPIDH+RAXyUAX4jACEGQfAUIQcgBiAHayEIIAgkACAIIAA2AuwUIAggATYC6BQgCCACNgLkFCAIIAM2AuAUIAggBDYC3BQgCCAFNgLYFCAIKALsFCEJIAgoAuQUIQogChDADyELIAggCzYC1BQgCCgC5BQhDCAMEKAPIQ0gCCANNgLQFCAIKALgFCEOIA4QoA8hDyAIIA82AswUIAgoAuAUIRAgEBDADyERIAggETYCyBRBsBQhEiAJIBJqIRMgCCgC0BQhFCAUENQOIRUgCCAVNgK8FEG8FCEWIAggFmohFyAXIRggEyAYEMcPIc4MQbAUIRkgCSAZaiEaIAgoAtQUIRsgGxDUDiEcIAggHDYCuBRBuBQhHSAIIB1qIR4gHiEfIBogHxDHDyHPDCDODCDPDKEh0AwgCCDQDDkDwBRBsBQhICAJICBqISEgCCgC0BQhIiAiENUOISMgCCAjNgKsFEGsFCEkIAggJGohJSAlISYgISAmEMcPIdEMQbAUIScgCSAnaiEoIAgoAtQUISkgKRDVDiEqIAggKjYCqBRBqBQhKyAIICtqISwgLCEtICggLRDHDyHSDCDRDCDSDKEh0wwgCCDTDDkDsBRBsBQhLiAJIC5qIS8gCCgCyBQhMCAwENQOITEgCCAxNgKcFEGcFCEyIAggMmohMyAzITQgLyA0EMcPIdQMQbAUITUgCSA1aiE2IAgoAswUITcgNxDUDiE4IAggODYCmBRBmBQhOSAIIDlqITogOiE7IDYgOxDHDyHVDCDUDCDVDKEh1gwgCCDWDDkDoBRBsBQhPCAJIDxqIT0gCCgCyBQhPiA+ENUOIT8gCCA/NgKMFEGMFCFAIAggQGohQSBBIUIgPSBCEMcPIdcMQbAUIUMgCSBDaiFEIAgoAswUIUUgRRDVDiFGIAggRjYCiBRBiBQhRyAIIEdqIUggSCFJIEQgSRDHDyHYDCDXDCDYDKEh2QwgCCDZDDkDkBQgCCgC0BQhSiBKENUOIUsgSyFMIEysId8NIAgoAtQUIU0gTRDVDiFOIE4hTyBPrCHgDSDfDSDgDX0h4Q0gCCgC0BQhUCBQENQOIVEgUSFSIFKsIeINIAgoAtQUIVMgUxDUDiFUIFQhVSBVrCHjDSDiDSDjDX0h5A0gCCgCyBQhViBWENUOIVcgVyFYIFisIeUNIAgoAswUIVkgWRDVDiFaIFohWyBbrCHmDSDlDSDmDX0h5w0gCCgCyBQhXCBcENQOIV0gXSFeIF6sIegNIAgoAswUIV8gXxDUDiFgIGAhYSBhrCHpDSDoDSDpDX0h6g0g4Q0g5A0g5w0g6g0QlBEh2gxBsBQhYiAJIGJqIWNEAAAAAAAA8D8h2wwgCCDbDDkD6BNB6BMhZCAIIGRqIWUgZSFmIGMgZhDJDyHcDEHwEyFnIAggZ2ohaCBoIWkgaSDaDCDcDBDVExpB2BMhaiAIIGpqIWsgayFsQfATIW0gCCBtaiFuIG4hbyBvKQMAIesNIGwg6w03AwBBCCFwIGwgcGohcSBvIHBqIXIgcikDACHsDSBxIOwNNwMAQQghc0EIIXQgCCB0aiF1IHUgc2ohdkHYEyF3IAggd2oheCB4IHNqIXkgeSkDACHtDSB2IO0NNwMAIAgpA9gTIe4NIAgg7g03AwhBCCF6IAggemoheyB7EN8TIXwCQAJAIHwNACAIKwPAFCHdDCAIKwPAFCHeDCDdDCDeDKIh3wwgCCsDsBQh4AwgCCsDsBQh4Qwg4Awg4QyiIeIMIN8MIOIMoCHjDEGwFCF9IAkgfWohfkQAAAAAAAAAQCHkDCAIIOQMOQPAE0HAEyF/IAggf2ohgAEggAEhgQEgfiCBARDJDyHlDEHIEyGCASAIIIIBaiGDASCDASGEASCEASDjDCDlDBDVExogCCgC0BQhhQEghQEQ1Q4hhgEghgEhhwEghwGsIe8NIAgoAtQUIYgBIIgBENUOIYkBIIkBIYoBIIoBrCHwDSDvDSDwDX0h8Q0gCCgC0BQhiwEgiwEQ1A4hjAEgjAEhjQEgjQGsIfINIAgoAtQUIY4BII4BENQOIY8BII8BIZABIJABrCHzDSDyDSDzDX0h9A0gCCgCzBQhkQEgkQEQ1Q4hkgEgkgEhkwEgkwGsIfUNIAgoAtQUIZQBIJQBENUOIZUBIJUBIZYBIJYBrCH2DSD1DSD2DX0h9w0gCCgCzBQhlwEglwEQ1A4hmAEgmAEhmQEgmQGsIfgNIAgoAtQUIZoBIJoBENQOIZsBIJsBIZwBIJwBrCH5DSD4DSD5DX0h+g0g8Q0g9A0g9w0g+g0QlBEh5gxBsBQhnQEgCSCdAWohngFEAAAAAAAA8D8h5wwgCCDnDDkDqBNBqBMhnwEgCCCfAWohoAEgoAEhoQEgngEgoQEQyQ8h6AxBsBMhogEgCCCiAWohowEgowEhpAEgpAEg5gwg6AwQ1RMaIAgoAtAUIaUBIKUBENQOIaYBIKYBIacBIKcBrCH7DSAIKALUFCGoASCoARDUDiGpASCpASGqASCqAawh/A0g+w0g/A19If0NIAgoAtAUIasBIKsBENUOIawBIKwBIa0BIK0BrCH+DSAIKALUFCGuASCuARDVDiGvASCvASGwASCwAawh/w0g/g0g/w19IYAOIAgoAugUIbEBILEBEKsSIbIBILIBIbMBILMBrCGBDiAIKALUFCG0ASC0ARDUDiG1ASC1ASG2ASC2Aawhgg4ggQ4ggg59IYMOIAgoAugUIbcBILcBEKwSIbgBILgBIbkBILkBrCGEDiAIKALUFCG6ASC6ARDVDiG7ASC7ASG8ASC8AawhhQ4ghA4ghQ59IYYOIP0NIIAOIIMOIIYOEJQRIekMIAgoAtAUIb0BIL0BENUOIb4BIL4BIb8BIL8BrCGHDiAIKALUFCHAASDAARDVDiHBASDBASHCASDCAawhiA4ghw4giA59IYkOIAgoAtAUIcMBIMMBENQOIcQBIMQBIcUBIMUBrCGKDiAIKALUFCHGASDGARDUDiHHASDHASHIASDIAawhiw4gig4giw59IYwOIAgoAugUIckBIMkBEKwSIcoBIMoBIcsBIMsBrCGNDiAIKALMFCHMASDMARDVDiHNASDNASHOASDOAawhjg4gjQ4gjg59IY8OIAgoAugUIc8BIM8BEKsSIdABINABIdEBINEBrCGQDiAIKALMFCHSASDSARDUDiHTASDTASHUASDUAawhkQ4gkA4gkQ59IZIOIIkOIIwOII8OIJIOEJQRIeoMIOkMIOoMoiHrDEGwFCHVASAJINUBaiHWAUQAAAAAAAAIQCHsDCAIIOwMOQOQE0GQEyHXASAIINcBaiHYASDYASHZASDWASDZARDJDyHtDEGYEyHaASAIINoBaiHbASDbASHcASDcASDrDCDtDBDVExpB8BIh3QEgCCDdAWoh3gEg3gEh3wEg3wEQ1hMaIAgrA8AUIe4MQdASIeABIAgg4AFqIeEBIOEBIeIBIOIBIO4MEOATGkGwFCHjASAJIOMBaiHkASAIKALUFCHlASDlARDUDiHmASAIIOYBNgK8EkG8EiHnASAIIOcBaiHoASDoASHpASDkASDpARDHDyHvDEGwFCHqASAJIOoBaiHrASAIKALMFCHsASDsARDUDiHtASAIIO0BNgK4EkG4EiHuASAIIO4BaiHvASDvASHwASDrASDwARDHDyHwDCDvDCDwDKAh8QxBsBQh8QEgCSDxAWoh8gFEAAAAAAAA4D8h8gwgCCDyDDkDsBJBsBIh8wEgCCDzAWoh9AEg9AEh9QEg8gEg9QEQyQ8h8wwg8Qwg8wyiIfQMQbAUIfYBIAkg9gFqIfcBIAgoAugUIfgBIPgBEKsSIfkBIAgg+QE2AqwSQawSIfoBIAgg+gFqIfsBIPsBIfwBIPcBIPwBEMcPIfUMIPQMIPUMoSH2DEHAEiH9ASAIIP0BaiH+ASD+ASH/ASD/ASD2DBDgExpB4BIhgAIgCCCAAmohgQIggQIhggJB0BIhgwIgCCCDAmohhAIghAIhhQJBwBIhhgIgCCCGAmohhwIghwIhiAIgggIghQIgiAIQ4RNB8BIhiQIgCCCJAmohigIgigIhiwJB4BIhjAIgCCCMAmohjQIgjQIhjgIgiwIgjgIQ2BMaIAgrA7AUIfcMQYgSIY8CIAggjwJqIZACIJACIZECIJECIPcMEOATGkGwFCGSAiAJIJICaiGTAiAIKALUFCGUAiCUAhDVDiGVAiAIIJUCNgL0EUH0ESGWAiAIIJYCaiGXAiCXAiGYAiCTAiCYAhDHDyH4DEGwFCGZAiAJIJkCaiGaAiAIKALMFCGbAiCbAhDVDiGcAiAIIJwCNgLwEUHwESGdAiAIIJ0CaiGeAiCeAiGfAiCaAiCfAhDHDyH5DCD4DCD5DKAh+gxBsBQhoAIgCSCgAmohoQJEAAAAAAAA4D8h+wwgCCD7DDkD6BFB6BEhogIgCCCiAmohowIgowIhpAIgoQIgpAIQyQ8h/Awg+gwg/AyiIf0MQbAUIaUCIAkgpQJqIaYCIAgoAugUIacCIKcCEKwSIagCIAggqAI2AuQRQeQRIakCIAggqQJqIaoCIKoCIasCIKYCIKsCEMcPIf4MIP0MIP4MoSH/DEH4ESGsAiAIIKwCaiGtAiCtAiGuAiCuAiD/DBDgExpBmBIhrwIgCCCvAmohsAIgsAIhsQJBiBIhsgIgCCCyAmohswIgswIhtAJB+BEhtQIgCCC1AmohtgIgtgIhtwIgsQIgtAIgtwIQ4RNB8BIhuAIgCCC4AmohuQIguQIhugJBmBIhuwIgCCC7AmohvAIgvAIhvQIgugIgvQIQ2BMaIAgoAtwUIb4CQQIhvwIgvgIhwAIgvwIhwQIgwAIgwQJGIcICQQEhwwIgwgIgwwJxIcQCAkACQCDEAkUNAEHQESHFAiAIIMUCaiHGAiDGAiHHAkGYEyHIAiAIIMgCaiHJAiDJAiHKAiDHAiDKAhDkE0HwEiHLAiAIIMsCaiHMAiDMAiHNAkHQESHOAiAIIM4CaiHPAiDPAiHQAiDNAiDQAhDXExoMAQtBwBEh0QIgCCDRAmoh0gIg0gIh0wJBmBMh1AIgCCDUAmoh1QIg1QIh1gIg0wIg1gIQ5BNB8BIh1wIgCCDXAmoh2AIg2AIh2QJBwBEh2gIgCCDaAmoh2wIg2wIh3AIg2QIg3AIQ2BMaC0HwEiHdAiAIIN0CaiHeAiDeAiHfAkHIEyHgAiAIIOACaiHhAiDhAiHiAiDfAiDiAhDsExpBoBEh4wIgCCDjAmoh5AIg5AIh5QIg5QIQ1hMaQYARIeYCIAgg5gJqIecCIOcCIegCIOgCENYTGkGwFCHpAiAJIOkCaiHqAkQAAAAAAADgPyGADSAIIIANOQPoEEHoECHrAiAIIOsCaiHsAiDsAiHtAiDqAiDtAhDJDyGBDUGwFCHuAiAJIO4CaiHvAiAIKALUFCHwAiDwAhDUDiHxAiAIIPECNgLkEEHkECHyAiAIIPICaiHzAiDzAiH0AiDvAiD0AhDHDyGCDUGwFCH1AiAJIPUCaiH2AiAIKALMFCH3AiD3AhDUDiH4AiAIIPgCNgLgEEHgECH5AiAIIPkCaiH6AiD6AiH7AiD2AiD7AhDHDyGDDSCCDSCDDaAhhA0ggQ0ghA2iIYUNQfAQIfwCIAgg/AJqIf0CIP0CIf4CIP4CIIUNEOATGkGgESH/AiAIIP8CaiGAAyCAAyGBA0HwECGCAyAIIIIDaiGDAyCDAyGEAyCBAyCEAxDXExogCCsDwBQhhg1BsBAhhQMgCCCFA2ohhgMghgMhhwMghwMghg0Q4BMaQcAQIYgDIAggiANqIYkDIIkDIYoDQbAQIYsDIAggiwNqIYwDIIwDIY0DQfASIY4DIAggjgNqIY8DII8DIZADIIoDII0DIJADEOUTQaARIZEDIAggkQNqIZIDIJIDIZMDQcAQIZQDIAgglANqIZUDIJUDIZYDIJMDIJYDEOYTGkGwFCGXAyAJIJcDaiGYA0QAAAAAAADgPyGHDSAIIIcNOQOYEEGYECGZAyAIIJkDaiGaAyCaAyGbAyCYAyCbAxDJDyGIDUGwFCGcAyAJIJwDaiGdAyAIKALUFCGeAyCeAxDVDiGfAyAIIJ8DNgKUEEGUECGgAyAIIKADaiGhAyChAyGiAyCdAyCiAxDHDyGJDUGwFCGjAyAJIKMDaiGkAyAIKALMFCGlAyClAxDVDiGmAyAIIKYDNgKQEEGQECGnAyAIIKcDaiGoAyCoAyGpAyCkAyCpAxDHDyGKDSCJDSCKDaAhiw0giA0giw2iIYwNQaAQIaoDIAggqgNqIasDIKsDIawDIKwDIIwNEOATGkGAESGtAyAIIK0DaiGuAyCuAyGvA0GgECGwAyAIILADaiGxAyCxAyGyAyCvAyCyAxDXExogCCsDsBQhjQ1B4A8hswMgCCCzA2ohtAMgtAMhtQMgtQMgjQ0Q4BMaQfAPIbYDIAggtgNqIbcDILcDIbgDQeAPIbkDIAgguQNqIboDILoDIbsDQfASIbwDIAggvANqIb0DIL0DIb4DILgDILsDIL4DEOUTQYARIb8DIAggvwNqIcADIMADIcEDQfAPIcIDIAggwgNqIcMDIMMDIcQDIMEDIMQDEOYTGkHADyHFAyAIIMUDaiHGAyDGAyHHA0GgESHIAyAIIMgDaiHJAyDJAyHKAyDKAykDACGTDiDHAyCTDjcDAEEYIcsDIMcDIMsDaiHMAyDKAyDLA2ohzQMgzQMpAwAhlA4gzAMglA43AwBBECHOAyDHAyDOA2ohzwMgygMgzgNqIdADINADKQMAIZUOIM8DIJUONwMAQQgh0QMgxwMg0QNqIdIDIMoDINEDaiHTAyDTAykDACGWDiDSAyCWDjcDAEGwEyHUAyAIINQDaiHVAyDVAyHWAyDWAxDtEyHXA0EBIdgDINcDINgDcSHZAwJAAkAg2QNFDQBBsBQh2gMgCSDaA2oh2wNEAAAAAAAA4D8hjg0gCCCODTkDiA9BiA8h3AMgCCDcA2oh3QMg3QMh3gMg2wMg3gMQyQ8hjw1BkA8h3wMgCCDfA2oh4AMg4AMh4QMg4QMgjw0Q4BMaQaAPIeIDIAgg4gNqIeMDIOMDIeQDQZAPIeUDIAgg5QNqIeYDIOYDIecDQbATIegDIAgg6ANqIekDIOkDIeoDIOQDIOcDIOoDEOETQfgOIesDIAgg6wNqIewDIOwDIe0DQcgTIe4DIAgg7gNqIe8DIO8DIfADIO0DIPADEOQTQbAPIfEDIAgg8QNqIfIDIPIDIfMDQaAPIfQDIAgg9ANqIfUDIPUDIfYDQfgOIfcDIAgg9wNqIfgDIPgDIfkDIPMDIPYDIPkDEOITQcAPIfoDIAgg+gNqIfsDIPsDIfwDQbAPIf0DIAgg/QNqIf4DIP4DIf8DIPwDIP8DENgTGgwBC0GwFCGABCAJIIAEaiGBBEQAAAAAAADgPyGQDSAIIJANOQPADkHADiGCBCAIIIIEaiGDBCCDBCGEBCCBBCCEBBDJDyGRDUHIDiGFBCAIIIUEaiGGBCCGBCGHBCCHBCCRDRDgExpB2A4hiAQgCCCIBGohiQQgiQQhigRByA4hiwQgCCCLBGohjAQgjAQhjQRBsBMhjgQgCCCOBGohjwQgjwQhkAQgigQgjQQgkAQQ4RNBsA4hkQQgCCCRBGohkgQgkgQhkwRByBMhlAQgCCCUBGohlQQglQQhlgQgkwQglgQQ5BNB6A4hlwQgCCCXBGohmAQgmAQhmQRB2A4hmgQgCCCaBGohmwQgmwQhnARBsA4hnQQgCCCdBGohngQgngQhnwQgmQQgnAQgnwQQ4hNBwA8hoAQgCCCgBGohoQQgoQQhogRB6A4howQgCCCjBGohpAQgpAQhpQQgogQgpQQQ1xMaC0GgDiGmBCAIIKYEaiGnBCCnBCGoBEGgESGpBCAIIKkEaiGqBCCqBCGrBCCoBCCrBBDZE0GgDiGsBCAIIKwEaiGtBCCtBCGuBCCuBBDcEyGSDUQAAAAAAABQQCGTDSCSDSCTDWQhrwRBASGwBCCvBCCwBHEhsQQgCCCxBDoAhxRBkA4hsgQgCCCyBGohswQgswQhtARBgBEhtQQgCCC1BGohtgQgtgQhtwQgtAQgtwQQ2RNBkA4huAQgCCC4BGohuQQguQQhugQgugQQ3BMhlA1EAAAAAAAAUEAhlQ0glA0glQ1kIbsEQQEhvAQguwQgvARxIb0EIAggvQQ6AIYUQYAOIb4EIAggvgRqIb8EIL8EIcAEQcAPIcEEIAggwQRqIcIEIMIEIcMEIMAEIMMEENkTQYAOIcQEIAggxARqIcUEIMUEIcYEIMYEENwTIZYNRAAAAAAAAFBAIZcNIJYNIJcNZCHHBEEBIcgEIMcEIMgEcSHJBCAIIMkEOgCFFEHQDSHKBCAIIMoEaiHLBCDLBCHMBEGgESHNBCAIIM0EaiHOBCDOBCHPBCDMBCDPBBDZE0HQDSHQBCAIINAEaiHRBCDRBCHSBCDSBBDaEyGYDUHADSHTBCAIINMEaiHUBCDUBCHVBEGAESHWBCAIINYEaiHXBCDXBCHYBCDVBCDYBBDZE0HADSHZBCAIINkEaiHaBCDaBCHbBCDbBBDaEyGZDUGwDSHcBCAIINwEaiHdBCDdBCHeBEHADyHfBCAIIN8EaiHgBCDgBCHhBCDeBCDhBBDZE0GwDSHiBCAIIOIEaiHjBCDjBCHkBCDkBBDaEyGaDUHgDSHlBCAIIOUEaiHmBCDmBCHnBCDnBCCYDSCZDSCaDRDbExogCCgC2BQh6ARB4A0h6QQgCCDpBGoh6gQg6gQh6wQg6wQpAwAhlw4g6AQglw43AwBBGCHsBCDoBCDsBGoh7QQg6wQg7ARqIe4EIO4ELQAAIe8EIO0EIO8EOgAAQRAh8AQg6AQg8ARqIfEEIOsEIPAEaiHyBCDyBCkDACGYDiDxBCCYDjcDAEEIIfMEIOgEIPMEaiH0BCDrBCDzBGoh9QQg9QQpAwAhmQ4g9AQgmQ43AwAMAQsgCCsDwBQhmw0gCCsDwBQhnA0gmw0gnA2iIZ0NIAgrA7AUIZ4NIAgrA7AUIZ8NIJ4NIJ8NoiGgDSCdDSCgDaAhoQ0gCCChDTkDmA1BmA0h9gQgCCD2BGoh9wQg9wQh+AQg+AQQrxIhog1BsBQh+QQgCSD5BGoh+gREAAAAAAAAAEAhow0gCCCjDTkDkA1BkA0h+wQgCCD7BGoh/AQg/AQh/QQg+gQg/QQQyQ8hpA1BoA0h/gQgCCD+BGoh/wQg/wQhgAUggAUgog0gpA0Q1RMaIAgrA6AUIaUNIAgrA6AUIaYNIKUNIKYNoiGnDSAIKwOQFCGoDSAIKwOQFCGpDSCoDSCpDaIhqg0gpw0gqg2gIasNIAggqw05A/gMQfgMIYEFIAgggQVqIYIFIIIFIYMFIIMFEK8SIawNQbAUIYQFIAkghAVqIYUFRAAAAAAAAABAIa0NIAggrQ05A/AMQfAMIYYFIAgghgVqIYcFIIcFIYgFIIUFIIgFEMkPIa4NQYANIYkFIAggiQVqIYoFIIoFIYsFIIsFIKwNIK4NENUTGiAIKALQFCGMBSCMBRDUDiGNBSCNBSGOBSCOBawhmg4gCCgC1BQhjwUgjwUQ1A4hkAUgkAUhkQUgkQWsIZsOIJoOIJsOfSGcDiAIKALQFCGSBSCSBRDVDiGTBSCTBSGUBSCUBawhnQ4gCCgC1BQhlQUglQUQ1Q4hlgUglgUhlwUglwWsIZ4OIJ0OIJ4OfSGfDiAIKALMFCGYBSCYBRDVDiGZBSCZBSGaBSCaBawhoA4gCCgCyBQhmwUgmwUQ1Q4hnAUgnAUhnQUgnQWsIaEOIKAOIKEOfSGiDiAIKALIFCGeBSCeBRDUDiGfBSCfBSGgBSCgBawhow4gCCgCzBQhoQUgoQUQ1A4hogUgogUhowUgowWsIaQOIKMOIKQOfSGlDiCcDiCfDiCiDiClDhCUESGvDUGwFCGkBSAJIKQFaiGlBUQAAAAAAADwPyGwDSAIILANOQPYDEHYDCGmBSAIIKYFaiGnBSCnBSGoBSClBSCoBRDJDyGxDUHgDCGpBSAIIKkFaiGqBSCqBSGrBSCrBSCvDSCxDRDVExpB4AwhrAUgCCCsBWohrQUgrQUhrgUgrgUQ7RMhrwVBASGwBSCvBSCwBXEhsQUCQAJAILEFDQBByAwhsgUgCCCyBWohswUgswUhtAVBoA0htQUgCCC1BWohtgUgtgUhtwVBgA0huAUgCCC4BWohuQUguQUhugUgtAUgtwUgugUQ4RNB4AwhuwUgCCC7BWohvAUgvAUhvQVByAwhvgUgCCC+BWohvwUgvwUhwAUgvQUgwAUQ7hMaDAELQagMIcEFIAggwQVqIcIFIMIFIcMFQfATIcQFIAggxAVqIcUFIMUFIcYFIMMFIMYFIMYFEOETQYgMIccFIAggxwVqIcgFIMgFIckFQaANIcoFIAggygVqIcsFIMsFIcwFQYANIc0FIAggzQVqIc4FIM4FIc8FIMkFIMwFIM8FEOETQZgMIdAFIAgg0AVqIdEFINEFIdIFQYgMIdMFIAgg0wVqIdQFINQFIdUFQeAMIdYFIAgg1gVqIdcFINcFIdgFINIFINUFINgFEO8TQbgMIdkFIAgg2QVqIdoFINoFIdsFQagMIdwFIAgg3AVqId0FIN0FId4FQZgMId8FIAgg3wVqIeAFIOAFIeEFINsFIN4FIOEFEOITQeAMIeIFIAgg4gVqIeMFIOMFIeQFQbgMIeUFIAgg5QVqIeYFIOYFIecFIOcFKQMAIaYOIOQFIKYONwMAQQgh6AUg5AUg6AVqIekFIOcFIOgFaiHqBSDqBSkDACGnDiDpBSCnDjcDAAsgCCgC0BQh6wUg6wUQ1Q4h7AUg7AUh7QUg7QWsIagOIAgoAtQUIe4FIO4FENUOIe8FIO8FIfAFIPAFrCGpDiCoDiCpDn0hqg4gCCgC0BQh8QUg8QUQ1A4h8gUg8gUh8wUg8wWsIasOIAgoAtQUIfQFIPQFENQOIfUFIPUFIfYFIPYFrCGsDiCrDiCsDn0hrQ4gCCgC0BQh9wUg9wUQ1Q4h+AUg+AUh+QUg+QWsIa4OIAgoAugUIfoFIPoFEKwSIfsFIPsFIfwFIPwFrCGvDiCuDiCvDn0hsA4gCCgC0BQh/QUg/QUQ1A4h/gUg/gUh/wUg/wWsIbEOIAgoAugUIYAGIIAGEKsSIYEGIIEGIYIGIIIGrCGyDiCxDiCyDn0hsw4gqg4grQ4gsA4gsw4QlBEhsg1BsBQhgwYgCSCDBmohhAZEAAAAAAAA8D8hsw0gCCCzDTkD8AtB8AshhQYgCCCFBmohhgYghgYhhwYghAYghwYQyQ8htA1B+AshiAYgCCCIBmohiQYgiQYhigYgigYgsg0gtA0Q1RMaIAgoAsgUIYsGIIsGENQOIYwGIIwGIY0GII0GrCG0DiAIKALMFCGOBiCOBhDUDiGPBiCPBiGQBiCQBqwhtQ4gtA4gtQ59IbYOIAgoAsgUIZEGIJEGENUOIZIGIJIGIZMGIJMGrCG3DiAIKALMFCGUBiCUBhDVDiGVBiCVBiGWBiCWBqwhuA4gtw4guA59IbkOIAgoAsgUIZcGIJcGENQOIZgGIJgGIZkGIJkGrCG6DiAIKALoFCGaBiCaBhCrEiGbBiCbBiGcBiCcBqwhuw4gug4guw59IbwOIAgoAsgUIZ0GIJ0GENUOIZ4GIJ4GIZ8GIJ8GrCG9DiAIKALoFCGgBiCgBhCsEiGhBiChBiGiBiCiBqwhvg4gvQ4gvg59Ib8OILYOILkOILwOIL8OEJQRIbUNQbAUIaMGIAkgowZqIaQGRAAAAAAAAPA/IbYNIAggtg05A9gLQdgLIaUGIAggpQZqIaYGIKYGIacGIKQGIKcGEMkPIbcNQeALIagGIAggqAZqIakGIKkGIaoGIKoGILUNILcNENUTGkGwFCGrBiAJIKsGaiGsBkQAAAAAAAAAQCG4DSAIILgNOQOQC0GQCyGtBiAIIK0GaiGuBiCuBiGvBiCsBiCvBhDJDyG5DUGYCyGwBiAIILAGaiGxBiCxBiGyBiCyBiC5DRDgExpBqAshswYgCCCzBmohtAYgtAYhtQZBmAshtgYgCCC2BmohtwYgtwYhuAZB4AwhuQYgCCC5BmohugYgugYhuwYgtQYguAYguwYQ4RNBuAshvAYgCCC8BmohvQYgvQYhvgZBqAshvwYgCCC/BmohwAYgwAYhwQZB+AshwgYgCCDCBmohwwYgwwYhxAYgvgYgwQYgxAYQ4RNByAshxQYgCCDFBmohxgYgxgYhxwZBuAshyAYgCCDIBmohyQYgyQYhygZB4AshywYgCCDLBmohzAYgzAYhzQYgxwYgygYgzQYQ4RMgCCgC0BQhzgYgzgYQ1Q4hzwYgzwYh0AYg0AasIcAOIAgoAtQUIdEGINEGENUOIdIGINIGIdMGINMGrCHBDiDADiDBDn0hwg4gCCgC0BQh1AYg1AYQ1A4h1QYg1QYh1gYg1gasIcMOIAgoAtQUIdcGINcGENQOIdgGINgGIdkGINkGrCHEDiDDDiDEDn0hxQ4gCCgC0BQh2gYg2gYQ1Q4h2wYg2wYh3AYg3AasIcYOIAgoAtAUId0GIN0GENQOId4GIN4GId8GIN8GrCHHDiDCDiDFDiDGDiDHDhCUESG6DUGwFCHgBiAJIOAGaiHhBkQAAAAAAADwPyG7DSAIILsNOQP4CkH4CiHiBiAIIOIGaiHjBiDjBiHkBiDhBiDkBhDJDyG8DUGACyHlBiAIIOUGaiHmBiDmBiHnBiDnBiC6DSC8DRDVExogCCgCyBQh6AYg6AYQ1A4h6QYg6QYh6gYg6gasIcgOIAgoAswUIesGIOsGENQOIewGIOwGIe0GIO0GrCHJDiDIDiDJDn0hyg4gCCgCyBQh7gYg7gYQ1Q4h7wYg7wYh8AYg8AasIcsOIAgoAswUIfEGIPEGENUOIfIGIPIGIfMGIPMGrCHMDiDLDiDMDn0hzQ4gCCgCyBQh9AYg9AYQ1A4h9QYg9QYh9gYg9gasIc4OIAgoAsgUIfcGIPcGENUOIfgGIPgGIfkGIPkGrCHPDiDKDiDNDiDODiDPDhCUESG9DUGwFCH6BiAJIPoGaiH7BkQAAAAAAADwPyG+DSAIIL4NOQPgCkHgCiH8BiAIIPwGaiH9BiD9BiH+BiD7BiD+BhDJDyG/DUHoCiH/BiAIIP8GaiGAByCAByGBByCBByC9DSC/DRDVExpBsBQhggcgCSCCB2ohgwdEAAAAAAAA8D8hwA0gCCDADTkDuApBuAohhAcgCCCEB2ohhQcghQchhgcggwcghgcQyQ8hwQ1BwAohhwcgCCCHB2ohiAcgiAchiQcgiQcgwQ0Q4BMaQdAKIYoHIAggigdqIYsHIIsHIYwHQcAKIY0HIAggjQdqIY4HII4HIY8HQfATIZAHIAggkAdqIZEHIJEHIZIHIIwHII8HIJIHEOITQZgKIZMHIAggkwdqIZQHIJQHIZUHIJUHENYTGkH4CSGWByAIIJYHaiGXByCXByGYByCYBxDWExpB2AkhmQcgCCCZB2ohmgcgmgchmwcgmwcQ1hMaQbgJIZwHIAggnAdqIZ0HIJ0HIZ4HIJ4HENYTGiAIKwOgFCHCDUGICSGfByAIIJ8HaiGgByCgByGhByChByDCDRDgExpBmAkhogcgCCCiB2ohowcgowchpAdBiAkhpQcgCCClB2ohpgcgpgchpwdBgAshqAcgCCCoB2ohqQcgqQchqgcgpAcgpwcgqgcQ4RNBqAkhqwcgCCCrB2ohrAcgrAchrQdBmAkhrgcgCCCuB2ohrwcgrwchsAdB0AohsQcgCCCxB2ohsgcgsgchswcgrQcgsAcgswcQ4RNB2AkhtAcgCCC0B2ohtQcgtQchtgdBqAkhtwcgCCC3B2ohuAcguAchuQcgtgcguQcQ1xMaIAgrA8AUIcMNQdgIIboHIAggugdqIbsHILsHIbwHILwHIMMNEOATGkHoCCG9ByAIIL0HaiG+ByC+ByG/B0HYCCHAByAIIMAHaiHBByDBByHCB0HoCiHDByAIIMMHaiHEByDEByHFByC/ByDCByDFBxDhE0H4CCHGByAIIMYHaiHHByDHByHIB0HoCCHJByAIIMkHaiHKByDKByHLB0HQCiHMByAIIMwHaiHNByDNByHOByDIByDLByDOBxDhE0HYCSHPByAIIM8HaiHQByDQByHRB0H4CCHSByAIINIHaiHTByDTByHUByDRByDUBxDXExogCCsDsBQhxA1BqAgh1QcgCCDVB2oh1gcg1gch1wcg1wcgxA0Q4BMaQbgIIdgHIAgg2AdqIdkHINkHIdoHQagIIdsHIAgg2wdqIdwHINwHId0HQegKId4HIAgg3gdqId8HIN8HIeAHINoHIN0HIOAHEOETQcgIIeEHIAgg4QdqIeIHIOIHIeMHQbgIIeQHIAgg5AdqIeUHIOUHIeYHQdAKIecHIAgg5wdqIegHIOgHIekHIOMHIOYHIOkHEOETQbgJIeoHIAgg6gdqIesHIOsHIewHQcgIIe0HIAgg7QdqIe4HIO4HIe8HIOwHIO8HENcTGiAIKwOQFCHFDUH4ByHwByAIIPAHaiHxByDxByHyByDyByDFDRDgExpBiAgh8wcgCCDzB2oh9Acg9Ach9QdB+Ach9gcgCCD2B2oh9wcg9wch+AdBgAsh+QcgCCD5B2oh+gcg+gch+wcg9Qcg+Acg+wcQ4RNBmAgh/AcgCCD8B2oh/Qcg/Qch/gdBiAgh/wcgCCD/B2ohgAgggAghgQhB0AohggggCCCCCGohgwgggwghhAgg/gcggQgghAgQ4RNBuAkhhQggCCCFCGohhggghgghhwhBmAghiAggCCCICGohiQggiQghiggghwggiggQ1xMaIAgrA8AUIcYNQbgHIYsIIAggiwhqIYwIIIwIIY0III0IIMYNEOATGkHIByGOCCAIII4IaiGPCCCPCCGQCEG4ByGRCCAIIJEIaiGSCCCSCCGTCEGADSGUCCAIIJQIaiGVCCCVCCGWCCCQCCCTCCCWCBDhE0HYByGXCCAIIJcIaiGYCCCYCCGZCEHYCSGaCCAIIJoIaiGbCCCbCCGcCEHIByGdCCAIIJ0IaiGeCCCeCCGfCCCZCCCcCCCfCBDqE0H4CSGgCCAIIKAIaiGhCCChCCGiCEHYByGjCCAIIKMIaiGkCCCkCCGlCCCiCCClCBDmExogCCsDoBQhxw1B+AYhpgggCCCmCGohpwggpwghqAggqAggxw0Q4BMaQYgHIakIIAggqQhqIaoIIKoIIasIQfgGIawIIAggrAhqIa0IIK0IIa4IQaANIa8IIAggrwhqIbAIILAIIbEIIKsIIK4IILEIEOETQZgHIbIIIAggsghqIbMIILMIIbQIQdgJIbUIIAggtQhqIbYIILYIIbcIQYgHIbgIIAgguAhqIbkIILkIIboIILQIILcIILoIEOoTQfgJIbsIIAgguwhqIbwIILwIIb0IQZgHIb4IIAggvghqIb8IIL8IIcAIIL0IIMAIEOYTGiAIKwOwFCHIDUG4BiHBCCAIIMEIaiHCCCDCCCHDCCDDCCDIDRDgExpByAYhxAggCCDECGohxQggxQghxghBuAYhxwggCCDHCGohyAggyAghyQhBgA0hygggCCDKCGohywggywghzAggxgggyQggzAgQ4RNB2AYhzQggCCDNCGohzgggzgghzwhBuAkh0AggCCDQCGoh0Qgg0Qgh0ghByAYh0wggCCDTCGoh1Agg1Agh1Qggzwgg0ggg1QgQ6hNB+Akh1gggCCDWCGoh1wgg1wgh2AhB2AYh2QggCCDZCGoh2ggg2ggh2wgg2Agg2wgQ5hMaIAgrA5AUIckNQfgFIdwIIAgg3AhqId0IIN0IId4IIN4IIMkNEOATGkGIBiHfCCAIIN8IaiHgCCDgCCHhCEH4BSHiCCAIIOIIaiHjCCDjCCHkCEGgDSHlCCAIIOUIaiHmCCDmCCHnCCDhCCDkCCDnCBDhE0GYBiHoCCAIIOgIaiHpCCDpCCHqCEG4CSHrCCAIIOsIaiHsCCDsCCHtCEGIBiHuCCAIIO4IaiHvCCDvCCHwCCDqCCDtCCDwCBDqE0H4CSHxCCAIIPEIaiHyCCDyCCHzCEGYBiH0CCAIIPQIaiH1CCD1CCH2CCDzCCD2CBDmExogCCgCyBQh9wgg9wgQ1A4h+Agg+Agh+Qgg+QisIdAOIAgoAswUIfoIIPoIENQOIfsIIPsIIfwIIPwIrCHRDiDQDiDRDn0h0g4gCCgCyBQh/Qgg/QgQ1Q4h/ggg/ggh/wgg/wisIdMOIAgoAswUIYAJIIAJENUOIYEJIIEJIYIJIIIJrCHUDiDTDiDUDn0h1Q4gCCgC6BQhgwkggwkQrBIhhAlBACGFCSCFCSCECWshhgkghgkhhwkghwmsIdYOIAgoAugUIYgJIIgJEKsSIYkJIIkJIYoJIIoJrCHXDiDSDiDVDiDWDiDXDhCUESHKDUGwFCGLCSAJIIsJaiGMCUQAAAAAAADwPyHLDSAIIMsNOQPQBUHQBSGNCSAIII0JaiGOCSCOCSGPCSCMCSCPCRDJDyHMDUHYBSGQCSAIIJAJaiGRCSCRCSGSCSCSCSDKDSDMDRDVExpB6AUhkwkgCCCTCWohlAkglAkhlQlBoA0hlgkgCCCWCWohlwkglwkhmAlB2AUhmQkgCCCZCWohmgkgmgkhmwkglQkgmAkgmwkQ4RNB+AkhnAkgCCCcCWohnQkgnQkhnglB6AUhnwkgCCCfCWohoAkgoAkhoQkgngkgoQkQ2BMaIAgoAtAUIaIJIKIJENQOIaMJIKMJIaQJIKQJrCHYDiAIKALUFCGlCSClCRDUDiGmCSCmCSGnCSCnCawh2Q4g2A4g2Q59IdoOIAgoAtAUIagJIKgJENUOIakJIKkJIaoJIKoJrCHbDiAIKALUFCGrCSCrCRDVDiGsCSCsCSGtCSCtCawh3A4g2w4g3A59Id0OIAgoAugUIa4JIK4JEKwSIa8JQQAhsAkgsAkgrwlrIbEJILEJIbIJILIJrCHeDiAIKALoFCGzCSCzCRCrEiG0CSC0CSG1CSC1Cawh3w4g2g4g3Q4g3g4g3w4QlBEhzQ1BsBQhtgkgCSC2CWohtwlEAAAAAAAA8D8hzg0gCCDODTkDqAVBqAUhuAkgCCC4CWohuQkguQkhugkgtwkgugkQyQ8hzw1BsAUhuwkgCCC7CWohvAkgvAkhvQkgvQkgzQ0gzw0Q1RMaQcAFIb4JIAggvglqIb8JIL8JIcAJQYANIcEJIAggwQlqIcIJIMIJIcMJQbAFIcQJIAggxAlqIcUJIMUJIcYJIMAJIMMJIMYJEOETQfgJIccJIAggxwlqIcgJIMgJIckJQcAFIcoJIAggyglqIcsJIMsJIcwJIMkJIMwJENgTGkGYCiHNCSAIIM0JaiHOCSDOCSHPCUH4CSHQCSAIINAJaiHRCSDRCSHSCSDPCSDSCRDwExogCCgC3BQh0wlBAiHUCSDTCSHVCSDUCSHWCSDVCSDWCUYh1wlBASHYCSDXCSDYCXEh2QkCQAJAINkJRQ0AQZgFIdoJIAgg2glqIdsJINsJIdwJQcgLId0JIAgg3QlqId4JIN4JId8JINwJIN8JEOQTQZgKIeAJIAgg4AlqIeEJIOEJIeIJQZgFIeMJIAgg4wlqIeQJIOQJIeUJIOIJIOUJENcTGgwBC0GIBSHmCSAIIOYJaiHnCSDnCSHoCUHICyHpCSAIIOkJaiHqCSDqCSHrCSDoCSDrCRDkE0GYCiHsCSAIIOwJaiHtCSDtCSHuCUGIBSHvCSAIIO8JaiHwCSDwCSHxCSDuCSDxCRDYExoLQfgEIfIJIAgg8glqIfMJIPMJIfQJQeAMIfUJIAgg9QlqIfYJIPYJIfcJIPQJIPcJIPcJEOETQZgKIfgJIAgg+AlqIfkJIPkJIfoJQfgEIfsJIAgg+wlqIfwJIPwJIf0JIPoJIP0JEOwTGkHYBCH+CSAIIP4JaiH/CSD/CSGACkHYCSGBCiAIIIEKaiGCCiCCCiGDCiCDCikDACHgDiCACiDgDjcDAEEYIYQKIIAKIIQKaiGFCiCDCiCECmohhgoghgopAwAh4Q4ghQog4Q43AwBBECGHCiCACiCHCmohiAoggwoghwpqIYkKIIkKKQMAIeIOIIgKIOIONwMAQQghigoggAogigpqIYsKIIMKIIoKaiGMCiCMCikDACHjDiCLCiDjDjcDAEG4BCGNCiAIII0KaiGOCiCOCiGPCkG4CSGQCiAIIJAKaiGRCiCRCiGSCiCSCikDACHkDiCPCiDkDjcDAEEYIZMKII8KIJMKaiGUCiCSCiCTCmohlQoglQopAwAh5Q4glAog5Q43AwBBECGWCiCPCiCWCmohlwogkgoglgpqIZgKIJgKKQMAIeYOIJcKIOYONwMAQQghmQogjwogmQpqIZoKIJIKIJkKaiGbCiCbCikDACHnDiCaCiDnDjcDACAIKwPAFCHQDUH4AyGcCiAIIJwKaiGdCiCdCiGeCiCeCiDQDRDgExpBiAQhnwogCCCfCmohoAogoAohoQpB+AMhogogCCCiCmohowogowohpApBgA0hpQogCCClCmohpgogpgohpwogoQogpAogpwoQ4RNBmAQhqAogCCCoCmohqQogqQohqgpBmAohqwogCCCrCmohrAogrAohrQpBiAQhrgogCCCuCmohrwogrwohsAogqgogrQogsAoQ6hNB2AQhsQogCCCxCmohsgogsgohswpBmAQhtAogCCC0CmohtQogtQohtgogswogtgoQ5hMaIAgrA6AUIdENQbgDIbcKIAggtwpqIbgKILgKIbkKILkKINENEOATGkHIAyG6CiAIILoKaiG7CiC7CiG8CkG4AyG9CiAIIL0KaiG+CiC+CiG/CkGgDSHACiAIIMAKaiHBCiDBCiHCCiC8CiC/CiDCChDhE0HYAyHDCiAIIMMKaiHECiDECiHFCkGYCiHGCiAIIMYKaiHHCiDHCiHICkHIAyHJCiAIIMkKaiHKCiDKCiHLCiDFCiDICiDLChDqE0HYBCHMCiAIIMwKaiHNCiDNCiHOCkHYAyHPCiAIIM8KaiHQCiDQCiHRCiDOCiDRChDmExogCCsDsBQh0g1B+AIh0gogCCDSCmoh0wog0woh1Aog1Aog0g0Q4BMaQYgDIdUKIAgg1QpqIdYKINYKIdcKQfgCIdgKIAgg2ApqIdkKINkKIdoKQYANIdsKIAgg2wpqIdwKINwKId0KINcKINoKIN0KEOETQZgDId4KIAgg3gpqId8KIN8KIeAKQZgKIeEKIAgg4QpqIeIKIOIKIeMKQYgDIeQKIAgg5ApqIeUKIOUKIeYKIOAKIOMKIOYKEOoTQbgEIecKIAgg5wpqIegKIOgKIekKQZgDIeoKIAgg6gpqIesKIOsKIewKIOkKIOwKEOYTGiAIKwOQFCHTDUG4AiHtCiAIIO0KaiHuCiDuCiHvCiDvCiDTDRDgExpByAIh8AogCCDwCmoh8Qog8Qoh8gpBuAIh8wogCCDzCmoh9Aog9Aoh9QpBoA0h9gogCCD2Cmoh9wog9woh+Aog8gog9Qog+AoQ4RNB2AIh+QogCCD5Cmoh+gog+goh+wpBmAoh/AogCCD8Cmoh/Qog/Qoh/gpByAIh/wogCCD/CmohgAsggAshgQsg+wog/goggQsQ6hNBuAQhggsgCCCCC2ohgwsggwshhAtB2AIhhQsgCCCFC2ohhgsghgshhwsghAsghwsQ5hMaQagCIYgLIAggiAtqIYkLIIkLIYoLQZgKIYsLIAggiwtqIYwLIIwLIY0LIIoLII0LEOcTQagCIY4LIAggjgtqIY8LII8LIZALIJALENoTIdQNQZgCIZELIAggkQtqIZILIJILIZMLQZgKIZQLIAgglAtqIZULIJULIZYLIJMLIJYLEOgTQZgCIZcLIAgglwtqIZgLIJgLIZkLIJkLENoTIdUNINQNINUNYyGaC0EBIZsLIJoLIJsLcSGcCwJAIJwLRQ0AQfgBIZ0LIAggnQtqIZ4LIJ4LIZ8LQZgKIaALIAggoAtqIaELIKELIaILIJ8LIKILEOkTQZgKIaMLIAggowtqIaQLIKQLIaULQfgBIaYLIAggpgtqIacLIKcLIagLIKgLKQMAIegOIKULIOgONwMAQRghqQsgpQsgqQtqIaoLIKgLIKkLaiGrCyCrCykDACHpDiCqCyDpDjcDAEEQIawLIKULIKwLaiGtCyCoCyCsC2ohrgsgrgspAwAh6g4grQsg6g43AwBBCCGvCyClCyCvC2ohsAsgqAsgrwtqIbELILELKQMAIesOILALIOsONwMAC0HYASGyCyAIILILaiGzCyCzCyG0C0HYBCG1CyAIILULaiG2CyC2CyG3CyC3CykDACHsDiC0CyDsDjcDAEEYIbgLILQLILgLaiG5CyC3CyC4C2ohugsgugspAwAh7Q4guQsg7Q43AwBBECG7CyC0CyC7C2ohvAsgtwsguwtqIb0LIL0LKQMAIe4OILwLIO4ONwMAQQghvgsgtAsgvgtqIb8LILcLIL4LaiHACyDACykDACHvDiC/CyDvDjcDAEHwEyHBCyAIIMELaiHCCyDCCyHDCyDDCxDtEyHEC0EBIcULIMQLIMULcSHGCwJAAkAgxgtFDQBBuAEhxwsgCCDHC2ohyAsgyAshyQtBmAohygsgCCDKC2ohywsgywshzAtB8BMhzQsgCCDNC2ohzgsgzgshzwsgyQsgzAsgzwsQ6hNB2AEh0AsgCCDQC2oh0Qsg0Qsh0gtBuAEh0wsgCCDTC2oh1Asg1Ash1Qsg0gsg1QsQ8BMaDAELQZgBIdYLIAgg1gtqIdcLINcLIdgLQZgKIdkLIAgg2QtqIdoLINoLIdsLQfATIdwLIAgg3AtqId0LIN0LId4LINgLINsLIN4LEOoTQdgBId8LIAgg3wtqIeALIOALIeELQZgBIeILIAgg4gtqIeMLIOMLIeQLIOELIOQLEOYTGgtBiAEh5QsgCCDlC2oh5gsg5gsh5wtB2AQh6AsgCCDoC2oh6Qsg6Qsh6gsg5wsg6gsQ2RNBiAEh6wsgCCDrC2oh7Asg7Ash7Qsg7QsQ3BMh1g1EAAAAAAAAUEAh1w0g1g0g1w1kIe4LQQEh7wsg7gsg7wtxIfALIAgg8As6AIcUQfgAIfELIAgg8QtqIfILIPILIfMLQbgEIfQLIAgg9AtqIfULIPULIfYLIPMLIPYLENkTQfgAIfcLIAgg9wtqIfgLIPgLIfkLIPkLENwTIdgNRAAAAAAAAFBAIdkNINgNINkNZCH6C0EBIfsLIPoLIPsLcSH8CyAIIPwLOgCGFEHoACH9CyAIIP0LaiH+CyD+CyH/C0HYASGADCAIIIAMaiGBDCCBDCGCDCD/CyCCDBDZE0HoACGDDCAIIIMMaiGEDCCEDCGFDCCFDBDcEyHaDUQAAAAAAABQQCHbDSDaDSDbDWQhhgxBASGHDCCGDCCHDHEhiAwgCCCIDDoAhRRBOCGJDCAIIIkMaiGKDCCKDCGLDEHYBCGMDCAIIIwMaiGNDCCNDCGODCCLDCCODBDZE0E4IY8MIAggjwxqIZAMIJAMIZEMIJEMENoTIdwNQSghkgwgCCCSDGohkwwgkwwhlAxBuAQhlQwgCCCVDGohlgwglgwhlwwglAwglwwQ2RNBKCGYDCAIIJgMaiGZDCCZDCGaDCCaDBDaEyHdDUEYIZsMIAggmwxqIZwMIJwMIZ0MQdgBIZ4MIAggngxqIZ8MIJ8MIaAMIJ0MIKAMENkTQRghoQwgCCChDGohogwgogwhowwgowwQ2hMh3g1ByAAhpAwgCCCkDGohpQwgpQwhpgwgpgwg3A0g3Q0g3g0Q2xMaIAgoAtgUIacMQcgAIagMIAggqAxqIakMIKkMIaoMIKoMKQMAIfAOIKcMIPAONwMAQRghqwwgpwwgqwxqIawMIKoMIKsMaiGtDCCtDC0AACGuDCCsDCCuDDoAAEEQIa8MIKcMIK8MaiGwDCCqDCCvDGohsQwgsQwpAwAh8Q4gsAwg8Q43AwBBCCGyDCCnDCCyDGohswwgqgwgsgxqIbQMILQMKQMAIfIOILMMIPIONwMACyAILQCHFCG1DEEBIbYMILUMILYMcSG3DAJAAkAgtwwNACAILQCGFCG4DEEBIbkMILgMILkMcSG6DCC6DA0AIAgtAIUUIbsMQQEhvAwguwwgvAxxIb0MIL0MRQ0BCyAIKALoFCG+DCAIKALkFCG/DCAIKALgFCHADCAIKALcFCHBDCAIKALYFCHCDCAILQCHFCHDDCAILQCGFCHEDCAILQCFFCHFDEEBIcYMIMMMIMYMcSHHDEEBIcgMIMQMIMgMcSHJDEEBIcoMIMUMIMoMcSHLDCAJIL4MIL8MIMAMIMEMIMIMIMcMIMkMIMsMEPETC0HwFCHMDCAIIMwMaiHNDCDNDCQADwvJAQEafyMAIQRBECEFIAQgBWshBiAGJAAgBiAANgIMIAYgATYCCCAGIAI2AgQgBiADNgIAIAYoAgghByAHEMwRIQggBigCBCEJIAkQzBEhCiAIIQsgCiEMIAsgDEchDUEAIQ5BASEPIA0gD3EhECAOIRECQCAQRQ0AIAYoAgQhEiASEMwRIRMgBigCACEUIBQQzBEhFSATIRYgFSEXIBYgF0chGCAYIRELIBEhGUEBIRogGSAacSEbQRAhHCAGIBxqIR0gHSQAIBsPC/o/A9kGfy18M34jACEFQZAKIQYgBSAGayEHIAckACAHIAA2AowKIAcgATYCiAogByACNgKECiAHIAM2AoAKIAcgBDYC/AkgBygCjAohCEGwFCEJIAggCWohCiAHKAKICiELIAsQ3hMhDCAHIAw2AuQJQeQJIQ0gByANaiEOIA4hDyAKIA8Qxw8h3gZBsBQhECAIIBBqIREgBygCiAohEiASEMYPIRMgByATNgLgCUHgCSEUIAcgFGohFSAVIRYgESAWEMcPId8GIN4GIN8GoSHgBkHoCSEXIAcgF2ohGCAYIRkgGSDgBhDgExpBsBQhGiAIIBpqIRsgBygCiAohHCAcEKcSIR0gByAdNgLMCUHMCSEeIAcgHmohHyAfISAgGyAgEMcPIeEGQbAUISEgCCAhaiEiIAcoAogKISMgIxCSESEkIAcgJDYCyAlByAkhJSAHICVqISYgJiEnICIgJxDHDyHiBiDhBiDiBqEh4wZB0AkhKCAHIChqISkgKSEqICog4wYQ4BMaIAcoAogKISsgKxDGDyEsICwhLSAtrCGLByAHKAKICiEuIC4QkhEhLyAvITAgMKwhjAcgBygCiAohMSAxEN4TITIgMiEzIDOsIY0HIAcoAogKITQgNBCnEiE1IDUhNiA2rCGOByCLByCMByCNByCOBxCUESHkBkGwFCE3IAggN2ohOEQAAAAAAADwPyHlBiAHIOUGOQOwCUGwCSE5IAcgOWohOiA6ITsgOCA7EMkPIeYGQbgJITwgByA8aiE9ID0hPiA+IOQGIOYGENUTGkGwFCE/IAggP2ohQCAHKAKECiFBIEEQ3hMhQiAHIEI2ApwJQZwJIUMgByBDaiFEIEQhRSBAIEUQxw8h5wZBsBQhRiAIIEZqIUcgBygChAohSCBIEMYPIUkgByBJNgKYCUGYCSFKIAcgSmohSyBLIUwgRyBMEMcPIegGIOcGIOgGoSHpBkGgCSFNIAcgTWohTiBOIU8gTyDpBhDgExpBsBQhUCAIIFBqIVEgBygChAohUiBSEKcSIVMgByBTNgKECUGECSFUIAcgVGohVSBVIVYgUSBWEMcPIeoGQbAUIVcgCCBXaiFYIAcoAoQKIVkgWRCSESFaIAcgWjYCgAlBgAkhWyAHIFtqIVwgXCFdIFggXRDHDyHrBiDqBiDrBqEh7AZBiAkhXiAHIF5qIV8gXyFgIGAg7AYQ4BMaIAcoAoQKIWEgYRDGDyFiIGIhYyBjrCGPByAHKAKECiFkIGQQkhEhZSBlIWYgZqwhkAcgBygChAohZyBnEN4TIWggaCFpIGmsIZEHIAcoAoQKIWogahCnEiFrIGshbCBsrCGSByCPByCQByCRByCSBxCUESHtBkGwFCFtIAggbWohbkQAAAAAAADwPyHuBiAHIO4GOQPoCEHoCCFvIAcgb2ohcCBwIXEgbiBxEMkPIe8GQfAIIXIgByByaiFzIHMhdCB0IO0GIO8GENUTGkGwFCF1IAggdWohdiAHKAKACiF3IHcQ3hMheCAHIHg2AtQIQdQIIXkgByB5aiF6IHoheyB2IHsQxw8h8AZBsBQhfCAIIHxqIX0gBygCgAohfiB+EMYPIX8gByB/NgLQCEHQCCGAASAHIIABaiGBASCBASGCASB9IIIBEMcPIfEGIPAGIPEGoSHyBkHYCCGDASAHIIMBaiGEASCEASGFASCFASDyBhDgExpBsBQhhgEgCCCGAWohhwEgBygCgAohiAEgiAEQpxIhiQEgByCJATYCvAhBvAghigEgByCKAWohiwEgiwEhjAEghwEgjAEQxw8h8wZBsBQhjQEgCCCNAWohjgEgBygCgAohjwEgjwEQkhEhkAEgByCQATYCuAhBuAghkQEgByCRAWohkgEgkgEhkwEgjgEgkwEQxw8h9AYg8wYg9AahIfUGQcAIIZQBIAcglAFqIZUBIJUBIZYBIJYBIPUGEOATGiAHKAKACiGXASCXARDGDyGYASCYASGZASCZAawhkwcgBygCgAohmgEgmgEQkhEhmwEgmwEhnAEgnAGsIZQHIAcoAoAKIZ0BIJ0BEN4TIZ4BIJ4BIZ8BIJ8BrCGVByAHKAKACiGgASCgARCnEiGhASChASGiASCiAawhlgcgkwcglAcglQcglgcQlBEh9gZBsBQhowEgCCCjAWohpAFEAAAAAAAA8D8h9wYgByD3BjkDoAhBoAghpQEgByClAWohpgEgpgEhpwEgpAEgpwEQyQ8h+AZBqAghqAEgByCoAWohqQEgqQEhqgEgqgEg9gYg+AYQ1RMaQfAHIasBIAcgqwFqIawBIKwBIa0BQegJIa4BIAcgrgFqIa8BIK8BIbABIK0BILABILABEOETQeAHIbEBIAcgsQFqIbIBILIBIbMBQdAJIbQBIAcgtAFqIbUBILUBIbYBILMBILYBILYBEOETQYAIIbcBIAcgtwFqIbgBILgBIbkBQfAHIboBIAcgugFqIbsBILsBIbwBQeAHIb0BIAcgvQFqIb4BIL4BIb8BILkBILwBIL8BEOMTQZAIIcABIAcgwAFqIcEBIMEBIcIBQYAIIcMBIAcgwwFqIcQBIMQBIcUBIMIBIMUBEOQTQbAHIcYBIAcgxgFqIccBIMcBIcgBQaAJIckBIAcgyQFqIcoBIMoBIcsBIMgBIMsBIMsBEOETQaAHIcwBIAcgzAFqIc0BIM0BIc4BQYgJIc8BIAcgzwFqIdABINABIdEBIM4BINEBINEBEOETQcAHIdIBIAcg0gFqIdMBINMBIdQBQbAHIdUBIAcg1QFqIdYBINYBIdcBQaAHIdgBIAcg2AFqIdkBINkBIdoBINQBINcBINoBEOMTQdAHIdsBIAcg2wFqIdwBINwBId0BQcAHId4BIAcg3gFqId8BIN8BIeABIN0BIOABEOQTQfAGIeEBIAcg4QFqIeIBIOIBIeMBQdgIIeQBIAcg5AFqIeUBIOUBIeYBIOMBIOYBIOYBEOETQeAGIecBIAcg5wFqIegBIOgBIekBQcAIIeoBIAcg6gFqIesBIOsBIewBIOkBIOwBIOwBEOETQYAHIe0BIAcg7QFqIe4BIO4BIe8BQfAGIfABIAcg8AFqIfEBIPEBIfIBQeAGIfMBIAcg8wFqIfQBIPQBIfUBIO8BIPIBIPUBEOMTQZAHIfYBIAcg9gFqIfcBIPcBIfgBQYAHIfkBIAcg+QFqIfoBIPoBIfsBIPgBIPsBEOQTIAcoAogKIfwBIPwBEN4TIf0BIP0BIf4BIP4BrCGXByAHKAKICiH/ASD/ARDGDyGAAiCAAiGBAiCBAqwhmAcglwcgmAd9IZkHIAcoAogKIYICIIICEKcSIYMCIIMCIYQCIIQCrCGaByAHKAKICiGFAiCFAhCSESGGAiCGAiGHAiCHAqwhmwcgmgcgmwd9IZwHIAcoAoQKIYgCIIgCEN4TIYkCIIkCIYoCIIoCrCGdByAHKAKECiGLAiCLAhDGDyGMAiCMAiGNAiCNAqwhngcgnQcgngd9IZ8HIAcoAoQKIY4CII4CEKcSIY8CII8CIZACIJACrCGgByAHKAKECiGRAiCRAhCSESGSAiCSAiGTAiCTAqwhoQcgoAcgoQd9IaIHIJkHIJwHIJ8HIKIHEJQRIfkGQbAUIZQCIAgglAJqIZUCRAAAAAAAAPA/IfoGIAcg+gY5A8gGQcgGIZYCIAcglgJqIZcCIJcCIZgCIJUCIJgCEMkPIfsGQdAGIZkCIAcgmQJqIZoCIJoCIZsCIJsCIPkGIPsGENUTGiAHKAKECiGcAiCcAhDeEyGdAiCdAiGeAiCeAqwhowcgBygChAohnwIgnwIQxg8hoAIgoAIhoQIgoQKsIaQHIKMHIKQHfSGlByAHKAKECiGiAiCiAhCnEiGjAiCjAiGkAiCkAqwhpgcgBygChAohpQIgpQIQkhEhpgIgpgIhpwIgpwKsIacHIKYHIKcHfSGoByAHKAKACiGoAiCoAhDeEyGpAiCpAiGqAiCqAqwhqQcgBygCgAohqwIgqwIQxg8hrAIgrAIhrQIgrQKsIaoHIKkHIKoHfSGrByAHKAKACiGuAiCuAhCnEiGvAiCvAiGwAiCwAqwhrAcgBygCgAohsQIgsQIQkhEhsgIgsgIhswIgswKsIa0HIKwHIK0HfSGuByClByCoByCrByCuBxCUESH8BkGwFCG0AiAIILQCaiG1AkQAAAAAAADwPyH9BiAHIP0GOQOwBkGwBiG2AiAHILYCaiG3AiC3AiG4AiC1AiC4AhDJDyH+BkG4BiG5AiAHILkCaiG6AiC6AiG7AiC7AiD8BiD+BhDVExogBygCgAohvAIgvAIQ3hMhvQIgvQIhvgIgvgKsIa8HIAcoAoAKIb8CIL8CEMYPIcACIMACIcECIMECrCGwByCvByCwB30hsQcgBygCgAohwgIgwgIQpxIhwwIgwwIhxAIgxAKsIbIHIAcoAoAKIcUCIMUCEJIRIcYCIMYCIccCIMcCrCGzByCyByCzB30htAcgBygCiAohyAIgyAIQ3hMhyQIgyQIhygIgygKsIbUHIAcoAogKIcsCIMsCEMYPIcwCIMwCIc0CIM0CrCG2ByC1ByC2B30htwcgBygCiAohzgIgzgIQpxIhzwIgzwIh0AIg0AKsIbgHIAcoAogKIdECINECEJIRIdICINICIdMCINMCrCG5ByC4ByC5B30hugcgsQcgtAcgtwcgugcQlBEh/wZBsBQh1AIgCCDUAmoh1QJEAAAAAAAA8D8hgAcgByCABzkDmAZBmAYh1gIgByDWAmoh1wIg1wIh2AIg1QIg2AIQyQ8hgQdBoAYh2QIgByDZAmoh2gIg2gIh2wIg2wIg/wYggQcQ1RMaQfgFIdwCIAcg3AJqId0CIN0CId4CIN4CENYTGkHoBSHfAiAHIN8CaiHgAiDgAiHhAkHQBiHiAiAHIOICaiHjAiDjAiHkAkGQByHlAiAHIOUCaiHmAiDmAiHnAiDhAiDkAiDnAhDhE0H4BSHoAiAHIOgCaiHpAiDpAiHqAkHoBSHrAiAHIOsCaiHsAiDsAiHtAiDqAiDtAhDXExpB2AUh7gIgByDuAmoh7wIg7wIh8AJBuAYh8QIgByDxAmoh8gIg8gIh8wJBkAgh9AIgByD0Amoh9QIg9QIh9gIg8AIg8wIg9gIQ4RNB+AUh9wIgByD3Amoh+AIg+AIh+QJB2AUh+gIgByD6Amoh+wIg+wIh/AIg+QIg/AIQ1xMaQcgFIf0CIAcg/QJqIf4CIP4CIf8CQaAGIYADIAcggANqIYEDIIEDIYIDQdAHIYMDIAcggwNqIYQDIIQDIYUDIP8CIIIDIIUDEOETQfgFIYYDIAcghgNqIYcDIIcDIYgDQcgFIYkDIAcgiQNqIYoDIIoDIYsDIIgDIIsDENcTGkGoBSGMAyAHIIwDaiGNAyCNAyGOAyCOAxDWExpBmAUhjwMgByCPA2ohkAMgkAMhkQNB0AYhkgMgByCSA2ohkwMgkwMhlANBqAghlQMgByCVA2ohlgMglgMhlwMgkQMglAMglwMQ4RNBqAUhmAMgByCYA2ohmQMgmQMhmgNBmAUhmwMgByCbA2ohnAMgnAMhnQMgmgMgnQMQ2BMaQYgFIZ4DIAcgngNqIZ8DIJ8DIaADQbgGIaEDIAcgoQNqIaIDIKIDIaMDQbgJIaQDIAcgpANqIaUDIKUDIaYDIKADIKMDIKYDEOETQagFIacDIAcgpwNqIagDIKgDIakDQYgFIaoDIAcgqgNqIasDIKsDIawDIKkDIKwDENgTGkH4BCGtAyAHIK0DaiGuAyCuAyGvA0GgBiGwAyAHILADaiGxAyCxAyGyA0HwCCGzAyAHILMDaiG0AyC0AyG1AyCvAyCyAyC1AxDhE0GoBSG2AyAHILYDaiG3AyC3AyG4A0H4BCG5AyAHILkDaiG6AyC6AyG7AyC4AyC7AxDYExpB2AQhvAMgByC8A2ohvQMgvQMhvgMgvgMQ1hMaQbgEIb8DIAcgvwNqIcADIMADIcEDQegJIcIDIAcgwgNqIcMDIMMDIcQDQfAIIcUDIAcgxQNqIcYDIMYDIccDIMEDIMQDIMcDEOETQcgEIcgDIAcgyANqIckDIMkDIcoDQbgEIcsDIAcgywNqIcwDIMwDIc0DQZAHIc4DIAcgzgNqIc8DIM8DIdADIMoDIM0DINADEOETQdgEIdEDIAcg0QNqIdIDINIDIdMDQcgEIdQDIAcg1ANqIdUDINUDIdYDINMDINYDENcTGkGYBCHXAyAHINcDaiHYAyDYAyHZA0GgCSHaAyAHINoDaiHbAyDbAyHcA0G4CSHdAyAHIN0DaiHeAyDeAyHfAyDZAyDcAyDfAxDhE0GoBCHgAyAHIOADaiHhAyDhAyHiA0GYBCHjAyAHIOMDaiHkAyDkAyHlA0GQByHmAyAHIOYDaiHnAyDnAyHoAyDiAyDlAyDoAxDhE0HYBCHpAyAHIOkDaiHqAyDqAyHrA0GoBCHsAyAHIOwDaiHtAyDtAyHuAyDrAyDuAxDYExpB+AMh7wMgByDvA2oh8AMg8AMh8QNBoAkh8gMgByDyA2oh8wMg8wMh9ANBqAgh9QMgByD1A2oh9gMg9gMh9wMg8QMg9AMg9wMQ4RNBiAQh+AMgByD4A2oh+QMg+QMh+gNB+AMh+wMgByD7A2oh/AMg/AMh/QNBkAgh/gMgByD+A2oh/wMg/wMhgAQg+gMg/QMggAQQ4RNB2AQhgQQgByCBBGohggQgggQhgwRBiAQhhAQgByCEBGohhQQghQQhhgQggwQghgQQ1xMaQdgDIYcEIAcghwRqIYgEIIgEIYkEQdgIIYoEIAcgigRqIYsEIIsEIYwEQfAIIY0EIAcgjQRqIY4EII4EIY8EIIkEIIwEII8EEOETQegDIZAEIAcgkARqIZEEIJEEIZIEQdgDIZMEIAcgkwRqIZQEIJQEIZUEQZAIIZYEIAcglgRqIZcEIJcEIZgEIJIEIJUEIJgEEOETQdgEIZkEIAcgmQRqIZoEIJoEIZsEQegDIZwEIAcgnARqIZ0EIJ0EIZ4EIJsEIJ4EENgTGkG4AyGfBCAHIJ8EaiGgBCCgBCGhBEHYCCGiBCAHIKIEaiGjBCCjBCGkBEG4CSGlBCAHIKUEaiGmBCCmBCGnBCChBCCkBCCnBBDhE0HIAyGoBCAHIKgEaiGpBCCpBCGqBEG4AyGrBCAHIKsEaiGsBCCsBCGtBEHQByGuBCAHIK4EaiGvBCCvBCGwBCCqBCCtBCCwBBDhE0HYBCGxBCAHILEEaiGyBCCyBCGzBEHIAyG0BCAHILQEaiG1BCC1BCG2BCCzBCC2BBDXExpBmAMhtwQgByC3BGohuAQguAQhuQRB6AkhugQgByC6BGohuwQguwQhvARBqAghvQQgByC9BGohvgQgvgQhvwQguQQgvAQgvwQQ4RNBqAMhwAQgByDABGohwQQgwQQhwgRBmAMhwwQgByDDBGohxAQgxAQhxQRB0AchxgQgByDGBGohxwQgxwQhyAQgwgQgxQQgyAQQ4RNB2AQhyQQgByDJBGohygQgygQhywRBqAMhzAQgByDMBGohzQQgzQQhzgQgywQgzgQQ2BMaQfgCIc8EIAcgzwRqIdAEINAEIdEEINEEENYTGkHYAiHSBCAHINIEaiHTBCDTBCHUBEHQCSHVBCAHINUEaiHWBCDWBCHXBEHwCCHYBCAHINgEaiHZBCDZBCHaBCDUBCDXBCDaBBDhE0HoAiHbBCAHINsEaiHcBCDcBCHdBEHYAiHeBCAHIN4EaiHfBCDfBCHgBEGQByHhBCAHIOEEaiHiBCDiBCHjBCDdBCDgBCDjBBDhE0H4AiHkBCAHIOQEaiHlBCDlBCHmBEHoAiHnBCAHIOcEaiHoBCDoBCHpBCDmBCDpBBDXExpBuAIh6gQgByDqBGoh6wQg6wQh7ARBiAkh7QQgByDtBGoh7gQg7gQh7wRBuAkh8AQgByDwBGoh8QQg8QQh8gQg7AQg7wQg8gQQ4RNByAIh8wQgByDzBGoh9AQg9AQh9QRBuAIh9gQgByD2BGoh9wQg9wQh+ARBkAch+QQgByD5BGoh+gQg+gQh+wQg9QQg+AQg+wQQ4RNB+AIh/AQgByD8BGoh/QQg/QQh/gRByAIh/wQgByD/BGohgAUggAUhgQUg/gQggQUQ2BMaQZgCIYIFIAcgggVqIYMFIIMFIYQFQYgJIYUFIAcghQVqIYYFIIYFIYcFQagIIYgFIAcgiAVqIYkFIIkFIYoFIIQFIIcFIIoFEOETQagCIYsFIAcgiwVqIYwFIIwFIY0FQZgCIY4FIAcgjgVqIY8FII8FIZAFQZAIIZEFIAcgkQVqIZIFIJIFIZMFII0FIJAFIJMFEOETQfgCIZQFIAcglAVqIZUFIJUFIZYFQagCIZcFIAcglwVqIZgFIJgFIZkFIJYFIJkFENcTGkH4ASGaBSAHIJoFaiGbBSCbBSGcBUHACCGdBSAHIJ0FaiGeBSCeBSGfBUHwCCGgBSAHIKAFaiGhBSChBSGiBSCcBSCfBSCiBRDhE0GIAiGjBSAHIKMFaiGkBSCkBSGlBUH4ASGmBSAHIKYFaiGnBSCnBSGoBUGQCCGpBSAHIKkFaiGqBSCqBSGrBSClBSCoBSCrBRDhE0H4AiGsBSAHIKwFaiGtBSCtBSGuBUGIAiGvBSAHIK8FaiGwBSCwBSGxBSCuBSCxBRDYExpB2AEhsgUgByCyBWohswUgswUhtAVBwAghtQUgByC1BWohtgUgtgUhtwVBuAkhuAUgByC4BWohuQUguQUhugUgtAUgtwUgugUQ4RNB6AEhuwUgByC7BWohvAUgvAUhvQVB2AEhvgUgByC+BWohvwUgvwUhwAVB0AchwQUgByDBBWohwgUgwgUhwwUgvQUgwAUgwwUQ4RNB+AIhxAUgByDEBWohxQUgxQUhxgVB6AEhxwUgByDHBWohyAUgyAUhyQUgxgUgyQUQ1xMaQbgBIcoFIAcgygVqIcsFIMsFIcwFQdAJIc0FIAcgzQVqIc4FIM4FIc8FQagIIdAFIAcg0AVqIdEFINEFIdIFIMwFIM8FINIFEOETQcgBIdMFIAcg0wVqIdQFINQFIdUFQbgBIdYFIAcg1gVqIdcFINcFIdgFQdAHIdkFIAcg2QVqIdoFINoFIdsFINUFINgFINsFEOETQfgCIdwFIAcg3AVqId0FIN0FId4FQcgBId8FIAcg3wVqIeAFIOAFIeEFIN4FIOEFENgTGkGYASHiBSAHIOIFaiHjBSDjBSHkBUHYBCHlBSAHIOUFaiHmBSDmBSHnBUGoBSHoBSAHIOgFaiHpBSDpBSHqBSDkBSDnBSDqBRDyE0GIASHrBSAHIOsFaiHsBSDsBSHtBUH4BSHuBSAHIO4FaiHvBSDvBSHwBSDtBSDwBRDZE0HoACHxBSAHIPEFaiHyBSDyBSHzBUHYBCH0BSAHIPQFaiH1BSD1BSH2BSDzBSD2BRDZE0H4ACH3BSAHIPcFaiH4BSD4BSH5BUHoACH6BSAHIPoFaiH7BSD7BSH8BUGIASH9BSAHIP0FaiH+BSD+BSH/BSD5BSD8BSD/BRDiE0HIACGABiAHIIAGaiGBBiCBBiGCBkH4AiGDBiAHIIMGaiGEBiCEBiGFBiCCBiCFBhDZE0HYACGGBiAHIIYGaiGHBiCHBiGIBkHIACGJBiAHIIkGaiGKBiCKBiGLBkGIASGMBiAHIIwGaiGNBiCNBiGOBiCIBiCLBiCOBhDiE0EoIY8GIAcgjwZqIZAGIJAGIZEGQZgBIZIGIAcgkgZqIZMGIJMGIZQGIJEGIJQGENkTQTghlQYgByCVBmohlgYglgYhlwZBKCGYBiAHIJgGaiGZBiCZBiGaBkGIASGbBiAHIJsGaiGcBiCcBiGdBiCXBiCaBiCdBhDiE0H4ACGeBiAHIJ4GaiGfBiCfBiGgBiCgBhDcEyGCB0QAAAAAAABQQCGDByCCByCDB2QhoQZBASGiBiChBiCiBnEhowYgByCjBjoAJ0HYACGkBiAHIKQGaiGlBiClBiGmBiCmBhDcEyGEB0QAAAAAAABQQCGFByCEByCFB2QhpwZBASGoBiCnBiCoBnEhqQYgByCpBjoAJkE4IaoGIAcgqgZqIasGIKsGIawGIKwGENwTIYYHRAAAAAAAAFBAIYcHIIYHIIcHZCGtBkEBIa4GIK0GIK4GcSGvBiAHIK8GOgAlQfgAIbAGIAcgsAZqIbEGILEGIbIGILIGENoTIYgHQdgAIbMGIAcgswZqIbQGILQGIbUGILUGENoTIYkHQTghtgYgByC2BmohtwYgtwYhuAYguAYQ2hMhigcgByG5BiC5BiCIByCJByCKBxDbExogBygC/AkhugYgByG7BiC7BikDACG7ByC6BiC7BzcDAEEYIbwGILoGILwGaiG9BiC7BiC8BmohvgYgvgYtAAAhvwYgvQYgvwY6AABBECHABiC6BiDABmohwQYguwYgwAZqIcIGIMIGKQMAIbwHIMEGILwHNwMAQQghwwYgugYgwwZqIcQGILsGIMMGaiHFBiDFBikDACG9ByDEBiC9BzcDACAHLQAnIcYGQQEhxwYgxgYgxwZxIcgGAkACQCDIBg0AIActACYhyQZBASHKBiDJBiDKBnEhywYgywYNACAHLQAlIcwGQQEhzQYgzAYgzQZxIc4GIM4GRQ0BCyAHKAKICiHPBiAHKAKECiHQBiAHKAKACiHRBiAHKAL8CSHSBiAHLQAnIdMGIActACYh1AYgBy0AJSHVBkEBIdYGINMGINYGcSHXBkEBIdgGINQGINgGcSHZBkEBIdoGINUGINoGcSHbBiAIIM8GINAGINEGINIGINcGINkGINsGEPMTC0GQCiHcBiAHINwGaiHdBiDdBiQADwvbBAJHfwZ8IwAhA0EwIQQgAyAEayEFIAUkACAFIAA2AiggBSABNgIkIAUgAjYCICAFKAIoIQYgBSgCICEHIAcQqw8hCEEBIQkgCCAJcSEKAkACQAJAIApFDQAgBSgCICELIAsQow8hDEEBIQ0gDCANcSEOIA4NAQtBACEPQQEhECAPIBBxIREgBSAROgAvDAELIAUoAiAhEiASEK0SIRNBASEUIBMgFHEhFQJAAkAgFUUNACAFKAIgIRYgFhCnEiEXIBchGAwBCyAFKAIgIRkgGRCSESEaIBohGAsgGCEbIAUgGzYCFEEUIRwgBSAcaiEdIB0hHiAGIB4Qxw8hSiAFIEo5AxggBSgCICEfIB8QrRIhIEEBISEgICAhcSEiAkACQCAiRQ0AIAUoAiAhIyAjEJIRISQgJCElDAELIAUoAiAhJiAmEKcSIScgJyElCyAlISggBSAoNgIEQQQhKSAFIClqISogKiErIAYgKxDHDyFLIAUgSzkDCEEBISwgBiAsaiEtIAUoAiQhLiAuEPQTIUwgBSsDGCFNQcAAIS8gLSBMIE0gLxDKDyEwQX8hMSAwITIgMSEzIDIgM0YhNEEBITVBASE2IDQgNnEhNyA1ITgCQCA3DQBBASE5IAYgOWohOiAFKAIkITsgOxD0EyFOIAUrAwghT0HAACE8IDogTiBPIDwQyg8hPUEBIT4gPSE/ID4hQCA/IEBGIUEgQSE4CyA4IUJBASFDIEIgQ3EhRCAFIEQ6AC8LIAUtAC8hRUEBIUYgRSBGcSFHQTAhSCAFIEhqIUkgSSQAIEcPC60CASV/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAFELUUIQYgBCAGNgIUIAQoAhQhB0EIIQggBCAIaiEJIAkhCiAKIAUgBxC2FCAEKAIUIQtBCCEMIAQgDGohDSANIQ4gDhC3FCEPQQghECAPIBBqIREgERC4FCESIAQoAhghEyALIBIgExC5FEEIIRQgBCAUaiEVIBUhFiAWELcUIRcgFxC6FCEYIAQgGDYCBCAEKAIEIRkgBCgCBCEaIAUgGSAaELsUIAUQvBQhGyAbKAIAIRxBASEdIBwgHWohHiAbIB42AgBBCCEfIAQgH2ohICAgISEgIRC9FBpBCCEiIAQgImohIyAjISQgJBC+FBpBICElIAQgJWohJiAmJAAPC0wBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBDEFCEFIAMgBTYCCCADKAIIIQZBECEHIAMgB2ohCCAIJAAgBg8LxQEBFX8jACECQTAhAyACIANrIQQgBCQAIAQgADYCLCAEIAE2AiggBCgCLCEFIAQoAighBiAGEL8UIQcgBSAHEMAUIAUQwRQhCCAEIAg2AiAgBRDCFCEJIAQgCTYCGEEMIQogBSAKaiELQRAhDCAEIAxqIQ0gDSEOIAsvAAAhDyAOIA87AAAgBCgCICEQIAQoAhghESAELwEQIRIgBCASOwEOQQ4hEyAEIBNqIRQgECARIBQQwxRBMCEVIAQgFWohFiAWJAAPC1ABCn8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCBCEFIAUQxRQhBkEIIQcgBiAHaiEIQRAhCSADIAlqIQogCiQAIAgPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtQAgR/AnwjACEDQSAhBCADIARrIQUgBSAANgIcIAUgATkDECAFIAI5AwggBSgCHCEGIAUrAxAhByAGIAc5AwAgBSsDCCEIIAYgCDkDCCAGDwtmAgp/AnwjACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBACEFIAW3IQsgBCALEOATGkEQIQYgBCAGaiEHQQAhCCAItyEMIAcgDBDgExpBECEJIAMgCWohCiAKJAAgBA8LjAEBDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEO0TIQdBASEIIAcgCHEhCQJAAkAgCQ0AIAQoAgghCiAFIAoQ7hMaDAELIAQoAgghC0EQIQwgBSAMaiENIA0gCxD1ExoLQRAhDiAEIA5qIQ8gDyQAIAUPC4wBAQ5/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBhDtEyEHQQEhCCAHIAhxIQkCQAJAIAkNACAEKAIIIQpBECELIAUgC2ohDCAMIAoQ7hMaDAELIAQoAgghDSAFIA0Q9RMaC0EQIQ4gBCAOaiEPIA8kACAFDwtJAQh/IwAhAkEQIQMgAiADayEEIAQkACAEIAE2AgwgBCgCDCEFQRAhBiAFIAZqIQcgACAFIAcQ7xNBECEIIAQgCGohCSAJJAAPCy0CBH8BfCMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQrAwAhBSAFDwtwAgV/A3wjACEEQSAhBSAEIAVrIQYgBiAANgIcIAYgATkDECAGIAI5AwggBiADOQMAIAYoAhwhByAGKwMQIQkgByAJOQMAIAYrAwghCiAHIAo5AwggBisDACELIAcgCzkDEEEBIQggByAIOgAYIAcPCy0CBH8BfCMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQrAwghBSAFDwuMJgOEBH8efh98IwAhCEHwzgAhCSAIIAlrIQogCiQAIAogADYC7E4gCiABNgLoTiAKIAI2AuROIAogAzYC4E4gCiAENgLcTiAFIQsgCiALOgDbTiAGIQwgCiAMOgDaTiAHIQ0gCiANOgDZTiAKKALsTiEOQcDIACEPIAogD2ohECAQIRFBjAYhEiARIBJqIRMgESEUA0AgFCEVIBUQzQ4aQYQCIRYgFSAWaiEXIBchGCATIRkgGCAZRiEaQQEhGyAaIBtxIRwgFyEUIBxFDQALQbDCACEdIAogHWohHiAeIR9BjAYhICAfICBqISEgHyEiA0AgIiEjICMQzQ4aQYQCISQgIyAkaiElICUhJiAhIScgJiAnRiEoQQEhKSAoIClxISogJSEiICpFDQALQaA+ISsgCiAraiEsICwhLUGIBCEuIC0gLmohLyAtITADQCAwITEgMRDNDhpBhAIhMiAxIDJqITMgMyE0IC8hNSA0IDVGITZBASE3IDYgN3EhOCAzITAgOEUNAAtBkDohOSAKIDlqITogOiE7QYgEITwgOyA8aiE9IDshPgNAID4hPyA/EM0OGkGEAiFAID8gQGohQSBBIUIgPSFDIEIgQ0YhREEBIUUgRCBFcSFGIEEhPiBGRQ0ACyAKKALoTiFHIEcQqxIhSCBIIUkgSawhjAQgCigC5E4hSiBKEKsSIUsgSyFMIEysIY0EIIwEII0EfSGOBEHAyAAhTSAKIE1qIU4gTiFPIE8gjgQQ9hMaIAooAuROIVAgUBCrEiFRIFEhUiBSrCGPBCAKKALgTiFTIFMQqxIhVCBUIVUgVawhkAQgjwQgkAR9IZEEQcDIACFWIAogVmohVyBXIVhBhAIhWSBYIFlqIVogWiCRBBD2ExogCigC6E4hWyBbEKsSIVwgXCFdIF2sIZIEIAooAuBOIV4gXhCrEiFfIF8hYCBgrCGTBCCSBCCTBH0hlARBwMgAIWEgCiBhaiFiIGIhY0GIBCFkIGMgZGohZSBlIJQEEPYTGiAKKALoTiFmIGYQrBIhZyBnIWggaKwhlQQgCigC5E4haSBpEKwSIWogaiFrIGusIZYEIJUEIJYEfSGXBEGwwgAhbCAKIGxqIW0gbSFuIG4glwQQ9hMaIAooAuROIW8gbxCsEiFwIHAhcSBxrCGYBCAKKALgTiFyIHIQrBIhcyBzIXQgdKwhmQQgmAQgmQR9IZoEQbDCACF1IAogdWohdiB2IXdBhAIheCB3IHhqIXkgeSCaBBD2ExogCigC6E4heiB6EKwSIXsgeyF8IHysIZsEIAooAuBOIX0gfRCsEiF+IH4hfyB/rCGcBCCbBCCcBH0hnQRBsMIAIYABIAoggAFqIYEBIIEBIYIBQYgEIYMBIIIBIIMBaiGEASCEASCdBBD2ExogCigC6E4hhQEghQEQqxIhhgEghgEhhwEghwGsIZ4EIAooAuROIYgBIIgBEKsSIYkBIIkBIYoBIIoBrCGfBCCeBCCfBHwhoARBoD4hiwEgCiCLAWohjAEgjAEhjQEgjQEgoAQQ9hMaIAooAuROIY4BII4BEKsSIY8BII8BIZABIJABrCGhBCAKKALgTiGRASCRARCrEiGSASCSASGTASCTAawhogQgoQQgogR8IaMEQaA+IZQBIAoglAFqIZUBIJUBIZYBQYQCIZcBIJYBIJcBaiGYASCYASCjBBD2ExogCigC6E4hmQEgmQEQrBIhmgEgmgEhmwEgmwGsIaQEIAooAuROIZwBIJwBEKwSIZ0BIJ0BIZ4BIJ4BrCGlBCCkBCClBHwhpgRBkDohnwEgCiCfAWohoAEgoAEhoQEgoQEgpgQQ9hMaIAooAuROIaIBIKIBEKwSIaMBIKMBIaQBIKQBrCGnBCAKKALgTiGlASClARCsEiGmASCmASGnASCnAawhqAQgpwQgqAR8IakEQZA6IagBIAogqAFqIakBIKkBIaoBQYQCIasBIKoBIKsBaiGsASCsASCpBBD2ExpBrBQhrQEgDiCtAWohrgFEAAAAAAAA4D8hqgQgCiCqBDkDgDpBgDohrwEgCiCvAWohsAEgsAEhsQEgrgEgsQEQyQ8hqwRBrBQhsgEgDiCyAWohswFBwMgAIbQBIAogtAFqIbUBILUBIbYBQbDCACG3ASAKILcBaiG4ASC4ASG5AUGEAiG6ASC5ASC6AWohuwFB8DUhvAEgCiC8AWohvQEgvQEhvgEgvgEgtgEguwEQ9xNBwMgAIb8BIAogvwFqIcABIMABIcEBQYQCIcIBIMEBIMIBaiHDAUGwwgAhxAEgCiDEAWohxQEgxQEhxgFB6DMhxwEgCiDHAWohyAEgyAEhyQEgyQEgwwEgxgEQ9xNB+DchygEgCiDKAWohywEgywEhzAFB8DUhzQEgCiDNAWohzgEgzgEhzwFB6DMh0AEgCiDQAWoh0QEg0QEh0gEgzAEgzwEg0gEQ+BNB+Dch0wEgCiDTAWoh1AEg1AEh1QEgswEg1QEQ+RMhrAQgqwQgrASjIa0EIAogrQQ5A4g6QcDIACHWASAKINYBaiHXASDXASHYAUGgPiHZASAKINkBaiHaASDaASHbAUHYLyHcASAKINwBaiHdASDdASHeASDeASDYASDbARD3E0GwwgAh3wEgCiDfAWoh4AEg4AEh4QFBkDoh4gEgCiDiAWoh4wEg4wEh5AFB0C0h5QEgCiDlAWoh5gEg5gEh5wEg5wEg4QEg5AEQ9xNB4DEh6AEgCiDoAWoh6QEg6QEh6gFB2C8h6wEgCiDrAWoh7AEg7AEh7QFB0C0h7gEgCiDuAWoh7wEg7wEh8AEg6gEg7QEg8AEQ+hNBwMgAIfEBIAog8QFqIfIBIPIBIfMBQYQCIfQBIPMBIPQBaiH1AUGgPiH2ASAKIPYBaiH3ASD3ASH4AUGEAiH5ASD4ASD5AWoh+gFBwCkh+wEgCiD7AWoh/AEg/AEh/QEg/QEg9QEg+gEQ9xNBsMIAIf4BIAog/gFqIf8BIP8BIYACQYQCIYECIIACIIECaiGCAkGQOiGDAiAKIIMCaiGEAiCEAiGFAkGEAiGGAiCFAiCGAmohhwJBuCchiAIgCiCIAmohiQIgiQIhigIgigIgggIghwIQ9xNByCshiwIgCiCLAmohjAIgjAIhjQJBwCkhjgIgCiCOAmohjwIgjwIhkAJBuCchkQIgCiCRAmohkgIgkgIhkwIgjQIgkAIgkwIQ+hMgCi0A204hlAJBASGVAiCUAiCVAnEhlgICQAJAIJYCDQAgCi0A2U4hlwJBASGYAiCXAiCYAnEhmQIgmQJFDQELQbDCACGaAiAKIJoCaiGbAiCbAiGcAkGEAiGdAiCcAiCdAmohngJBqCMhnwIgCiCfAmohoAIgoAIhoQJB4DEhogIgCiCiAmohowIgowIhpAIgoQIgpAIgngIQ9xNBsMIAIaUCIAogpQJqIaYCIKYCIacCQaAhIagCIAogqAJqIakCIKkCIaoCQcgrIasCIAogqwJqIawCIKwCIa0CIKoCIK0CIKcCEPcTQbAlIa4CIAogrgJqIa8CIK8CIbACQagjIbECIAogsQJqIbICILICIbMCQaAhIbQCIAogtAJqIbUCILUCIbYCILACILMCILYCEPgTIAooAtxOIbcCQawUIbgCIA4guAJqIbkCQbAlIboCIAogugJqIbsCILsCIbwCILkCILwCEPkTIa4EIAorA4g6Ia8EIK4EIK8EoiGwBCC3AiCwBBD7ExogCi0A2U4hvQJBASG+AiC9AiC+AnEhvwICQCC/AkUNAEHAyAAhwAIgCiDAAmohwQIgwQIhwgJBwMgAIcMCIAogwwJqIcQCIMQCIcUCQYAZIcYCIAogxgJqIccCIMcCIcgCIMgCIMICIMUCEPcTQbDCACHJAiAKIMkCaiHKAiDKAiHLAkGwwgAhzAIgCiDMAmohzQIgzQIhzgJB+BYhzwIgCiDPAmoh0AIg0AIh0QIg0QIgywIgzgIQ9xNBiBsh0gIgCiDSAmoh0wIg0wIh1AJBgBkh1QIgCiDVAmoh1gIg1gIh1wJB+BYh2AIgCiDYAmoh2QIg2QIh2gIg1AIg1wIg2gIQ+hNBwMgAIdsCIAog2wJqIdwCINwCId0CQYQCId4CIN0CIN4CaiHfAkHAyAAh4AIgCiDgAmoh4QIg4QIh4gJBhAIh4wIg4gIg4wJqIeQCQegSIeUCIAog5QJqIeYCIOYCIecCIOcCIN8CIOQCEPcTQbDCACHoAiAKIOgCaiHpAiDpAiHqAkGEAiHrAiDqAiDrAmoh7AJBsMIAIe0CIAog7QJqIe4CIO4CIe8CQYQCIfACIO8CIPACaiHxAkHgECHyAiAKIPICaiHzAiDzAiH0AiD0AiDsAiDxAhD3E0HwFCH1AiAKIPUCaiH2AiD2AiH3AkHoEiH4AiAKIPgCaiH5AiD5AiH6AkHgECH7AiAKIPsCaiH8AiD8AiH9AiD3AiD6AiD9AhD6E0GQHSH+AiAKIP4CaiH/AiD/AiGAA0GIGyGBAyAKIIEDaiGCAyCCAyGDA0HwFCGEAyAKIIQDaiGFAyCFAyGGAyCAAyCDAyCGAxD3E0HAyAAhhwMgCiCHA2ohiAMgiAMhiQNBiAQhigMgiQMgigNqIYsDQcDIACGMAyAKIIwDaiGNAyCNAyGOA0GIBCGPAyCOAyCPA2ohkANB0AwhkQMgCiCRA2ohkgMgkgMhkwMgkwMgiwMgkAMQ9xNBsMIAIZQDIAoglANqIZUDIJUDIZYDQYgEIZcDIJYDIJcDaiGYA0GwwgAhmQMgCiCZA2ohmgMgmgMhmwNBiAQhnAMgmwMgnANqIZ0DQcgKIZ4DIAogngNqIZ8DIJ8DIaADIKADIJgDIJ0DEPcTQdgOIaEDIAogoQNqIaIDIKIDIaMDQdAMIaQDIAogpANqIaUDIKUDIaYDQcgKIacDIAogpwNqIagDIKgDIakDIKMDIKYDIKkDEPoTQZgfIaoDIAogqgNqIasDIKsDIawDQZAdIa0DIAogrQNqIa4DIK4DIa8DQdgOIbADIAogsANqIbEDILEDIbIDIKwDIK8DILIDEPcTQawUIbMDIA4gswNqIbQDQZgfIbUDIAogtQNqIbYDILYDIbcDILQDILcDEPkTIbEEIAogsQQ5A7gKQbgKIbgDIAoguANqIbkDILkDIboDILoDEK8SIbIEIAogsgQ5A8AKIAooAtxOIbsDILsDEPwTIbMEIAogswQ5A7AKQbAKIbwDIAogvANqIb0DIL0DIb4DIL4DEJcRIb8DQX8hwAMgvwMgwANzIcEDQQEhwgMgwQMgwgNxIcMDAkACQCDDA0UNAEGIOiHEAyAKIMQDaiHFAyDFAyHGAyDGAxCXESHHA0EBIcgDIMcDIMgDcSHJAwJAAkAgyQMNACAKKALcTiHKAyAKKALcTiHLAyDLAxD8EyG0BCAKKwPACiG1BCAKKwOIOiG2BCC1BCC2BKIhtwQgtAQgtwSgIbgEIMoDILgEEP0TGgwBCyAKKALcTiHMAyAKKALcTiHNAyDNAxD8EyG5BCAKKwPACiG6BCAKKwOIOiG7BCC6BCC7BKIhvAQguQQgvAShIb0EIMwDIL0EEP0TGgsMAQtBoAYhzgMgCiDOA2ohzwMgzwMh0ANBsCUh0QMgCiDRA2oh0gMg0gMh0wMg0AMg0wMg0wMQ9xNBqAgh1AMgCiDUA2oh1QMg1QMh1gNBoAYh1wMgCiDXA2oh2AMg2AMh2QNBmB8h2gMgCiDaA2oh2wMg2wMh3AMg1gMg2QMg3AMQ+BNBrBQh3QMgDiDdA2oh3gNBqAgh3wMgCiDfA2oh4AMg4AMh4QMg3gMg4QMQ+RMhvgQgCisDiDohvwQgvgQgvwSiIcAEQawUIeIDIA4g4gNqIeMDQbAlIeQDIAog5ANqIeUDIOUDIeYDIOMDIOYDEPkTIcEEIAorA8AKIcIEIMEEIMIEoCHDBCDABCDDBKMhxAQgCiDEBDkDmAYgCigC3E4h5wMgCisDmAYhxQQg5wMgxQQQ/RMaCwsLIAotANpOIegDQQEh6QMg6AMg6QNxIeoDAkAg6gNFDQBBwMgAIesDIAog6wNqIewDIOwDIe0DQYgCIe4DIAog7gNqIe8DIO8DIfADQcgrIfEDIAog8QNqIfIDIPIDIfMDIPADIPMDIO0DEPcTQcDIACH0AyAKIPQDaiH1AyD1AyH2A0GEAiH3AyD2AyD3A2oh+AMgCiH5A0HgMSH6AyAKIPoDaiH7AyD7AyH8AyD5AyD8AyD4AxD3E0GQBCH9AyAKIP0DaiH+AyD+AyH/A0GIAiGABCAKIIAEaiGBBCCBBCGCBCAKIYMEIP8DIIIEIIMEEPgTIAooAtxOIYQEQawUIYUEIA4ghQRqIYYEQZAEIYcEIAoghwRqIYgEIIgEIYkEIIYEIIkEEPkTIcYEIAorA4g6IccEIMYEIMcEoiHIBCCEBCDIBBD+ExoLQfDOACGKBCAKIIoEaiGLBCCLBCQADwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhDUDiEHQRAhCCADIAhqIQkgCSQAIAcPC4QBARB/IwAhAUEQIQIgASACayEDIAMkACAAEJAUIQRBASEFIAQgBXEhBgJAAkAgBkUNAEEAIQcgAyAHNgIMDAELIAAQ7RMhCEF/IQlBASEKQQEhCyAIIAtxIQwgCSAKIAwbIQ0gAyANNgIMCyADKAIMIQ5BECEPIAMgD2ohECAQJAAgDg8LSwIFfwJ8IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE5AwAgBCgCDCEFIAQrAwAhByAFIAc5AwBBACEGIAa3IQggBSAIOQMIIAUPC64BAgh/CnwjACEDQSAhBCADIARrIQUgBSQAIAUgATYCHCAFIAI2AhggBSgCHCEGIAYrAwAhCyAFKAIYIQcgBysDACEMIAsgDKIhDSAFIA05AxAgBisDCCEOIAUoAhghCCAIKwMIIQ8gDiAPoCEQRAAAAAAAAPA/IREgECARoCESIAUgEjkDCCAFKwMQIRMgBSsDCCEUIAAgEyAUENUTGkEgIQkgBSAJaiEKIAokAA8LrgECCH8KfCMAIQNBICEEIAMgBGshBSAFJAAgBSABNgIcIAUgAjYCGCAFKAIcIQYgBisDACELIAUoAhghByAHKwMAIQwgCyAMoyENIAUgDTkDECAGKwMIIQ4gBSgCGCEIIAgrAwghDyAOIA+gIRBEAAAAAAAA8D8hESAQIBGgIRIgBSASOQMIIAUrAxAhEyAFKwMIIRQgACATIBQQ1RMaQSAhCSAFIAlqIQogCiQADwvZAwIhfxZ8IwAhA0EgIQQgAyAEayEFIAUkACAFIAE2AhwgBSACNgIYIAUoAhwhBiAGKwMAISQgBSgCGCEHIAcrAwAhJSAkICWgISYgBSAmOQMQIAYQlxEhCEEBIQkgCCAJcSEKAkACQAJAAkAgCg0AIAUoAhghCyALEJcRIQxBASENIAwgDXEhDiAORQ0BCyAGEIAUIQ9BASEQIA8gEHEhESARDQEgBSgCGCESIBIQgBQhE0EBIRQgEyAUcSEVIBUNAQtBCCEWIAYgFmohFyAFKAIYIRhBCCEZIBggGWohGiAXIBoQgRQhGyAbKwMAISdEAAAAAAAA8D8hKCAnICigISkgBSApOQMIDAELIAYrAwAhKiAGKwMIISsgKiAroiEsIAUoAhghHCAcKwMAIS0gBSgCGCEdIB0rAwghLiAtIC6iIS8gLCAvoSEwIAUrAxAhMSAwIDGjITIgBSAyOQMAIAUhHiAeEJcRIR9BASEgIB8gIHEhIQJAICFFDQAgBSsDACEzIDOaITQgBSA0OQMACyAFKwMAITVEAAAAAAAA8D8hNiA1IDagITcgBSA3OQMICyAFKwMQITggBSsDCCE5IAAgOCA5ENUTGkEgISIgBSAiaiEjICMkAA8LcwIGfwZ8IwAhAkEQIQMgAiADayEEIAQkACAEIAE2AgwgBCgCDCEFIAUQrxIhCCAFKwMIIQlEAAAAAAAA4D8hCiAJIAqiIQtEAAAAAAAA8D8hDCALIAygIQ0gACAIIA0Q1RMaQRAhBiAEIAZqIQcgByQADwu5BAFNfyMAIQNBsAEhBCADIARrIQUgBSQAIAUgATYCrAEgBSACNgKoASAFKAKsASEGIAYQ7RMhB0EBIQggByAIcSEJAkACQCAJDQAgBSgCrAEhCiAFKAKoASELQYgBIQwgBSAMaiENIA0hDiAOIAsQ5xNBmAEhDyAFIA9qIRAgECERQYgBIRIgBSASaiETIBMhFCARIAogFBDhEyAFKAKsASEVIAUoAqgBIRZB6AAhFyAFIBdqIRggGCEZIBkgFhDoE0H4ACEaIAUgGmohGyAbIRxB6AAhHSAFIB1qIR4gHiEfIBwgFSAfEOETQZgBISAgBSAgaiEhICEhIkH4ACEjIAUgI2ohJCAkISUgACAiICUQkRQaDAELIAUoAqwBISZByAAhJyAFICdqISggKCEpICkgJhCSFCAFKAKoASEqQTghKyAFICtqISwgLCEtIC0gKhDoE0HYACEuIAUgLmohLyAvITBByAAhMSAFIDFqITIgMiEzQTghNCAFIDRqITUgNSE2IDAgMyA2EOETIAUoAqwBITdBGCE4IAUgOGohOSA5ITogOiA3EJIUIAUoAqgBITtBCCE8IAUgPGohPSA9IT4gPiA7EOcTQSghPyAFID9qIUAgQCFBQRghQiAFIEJqIUMgQyFEQQghRSAFIEVqIUYgRiFHIEEgRCBHEOETQdgAIUggBSBIaiFJIEkhSkEoIUsgBSBLaiFMIEwhTSAAIEogTRCRFBoLQbABIU4gBSBOaiFPIE8kAA8LcgEMfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhDuExogBCgCCCEHQRAhCCAHIAhqIQlBECEKIAUgCmohCyALIAkQ7hMaQRAhDCAEIAxqIQ0gDSQAIAUPC1ICB38CfiMAIQJBECEDIAIgA2shBCAEIAE2AgwgBCgCDCEFIAUpAwAhCSAAIAk3AwBBCCEGIAAgBmohByAFIAZqIQggCCkDACEKIAcgCjcDAA8LXQIJfwJ+IwAhAkEQIQMgAiADayEEIAQgATYCDCAEKAIMIQVBECEGIAUgBmohByAHKQMAIQsgACALNwMAQQghCCAAIAhqIQkgByAIaiEKIAopAwAhDCAJIAw3AwAPC0oBCH8jACECQRAhAyACIANrIQQgBCQAIAQgATYCDCAEKAIMIQVBECEGIAUgBmohByAAIAcgBRCRFBpBECEIIAQgCGohCSAJJAAPC7kEAU1/IwAhA0GwASEEIAMgBGshBSAFJAAgBSABNgKsASAFIAI2AqgBIAUoAqgBIQYgBhDtEyEHQQEhCCAHIAhxIQkCQAJAIAkNACAFKAKsASEKQYgBIQsgBSALaiEMIAwhDSANIAoQ5xMgBSgCqAEhDkGYASEPIAUgD2ohECAQIRFBiAEhEiAFIBJqIRMgEyEUIBEgFCAOEOETIAUoAqwBIRVB6AAhFiAFIBZqIRcgFyEYIBggFRDoEyAFKAKoASEZQfgAIRogBSAaaiEbIBshHEHoACEdIAUgHWohHiAeIR8gHCAfIBkQ4RNBmAEhICAFICBqISEgISEiQfgAISMgBSAjaiEkICQhJSAAICIgJRCRFBoMAQsgBSgCrAEhJkE4IScgBSAnaiEoICghKSApICYQ6BNByAAhKiAFICpqISsgKyEsQTghLSAFIC1qIS4gLiEvICwgLxCSFCAFKAKoASEwQdgAITEgBSAxaiEyIDIhM0HIACE0IAUgNGohNSA1ITYgMyA2IDAQ4RMgBSgCrAEhN0EIITggBSA4aiE5IDkhOiA6IDcQ5xNBGCE7IAUgO2ohPCA8IT1BCCE+IAUgPmohPyA/IUAgPSBAEJIUIAUoAqgBIUFBKCFCIAUgQmohQyBDIURBGCFFIAUgRWohRiBGIUcgRCBHIEEQ4RNB2AAhSCAFIEhqIUkgSSFKQSghSyAFIEtqIUwgTCFNIAAgSiBNEJEUGgtBsAEhTiAFIE5qIU8gTyQADwvwSAPTB38efjV8IwAhCUHwlwEhCiAJIAprIQsgCyQAIAsgADYC7JcBIAsgATYC6JcBIAsgAjYC5JcBIAsgAzYC4JcBIAsgBDYC3JcBIAsgBTYC2JcBIAYhDCALIAw6ANeXASAHIQ0gCyANOgDWlwEgCCEOIAsgDjoA1ZcBIAsoAuyXASEPQcCPASEQIAsgEGohESARIRJBkAghEyASIBNqIRQgEiEVA0AgFSEWIBYQzQ4aQYQCIRcgFiAXaiEYIBghGSAUIRogGSAaRiEbQQEhHCAbIBxxIR0gGCEVIB1FDQALQbCHASEeIAsgHmohHyAfISBBkAghISAgICFqISIgICEjA0AgIyEkICQQzQ4aQYQCISUgJCAlaiEmICYhJyAiISggJyAoRiEpQQEhKiApICpxISsgJiEjICtFDQALIAsoAuCXASEsICwQpxIhLSAtIS4gLqwh3AcgCygC4JcBIS8gLxCSESEwIDAhMSAxrCHdByDcByDdB30h3gdBqIUBITIgCyAyaiEzIDMhNCA0IN4HEJMUGiALKALglwEhNSA1EMYPITYgNiE3IDesId8HIAsoAuCXASE4IDgQ3hMhOSA5ITogOqwh4Acg3wcg4Ad9IeEHQaCDASE7IAsgO2ohPCA8IT0gPSDhBxCTFBpBkP8AIT4gCyA+aiE/ID8hQEGohQEhQSALIEFqIUIgQiFDIEAgQyBDEPcTQYj9ACFEIAsgRGohRSBFIUZBoIMBIUcgCyBHaiFIIEghSSBGIEkgSRD3E0GYgQEhSiALIEpqIUsgSyFMQZD/ACFNIAsgTWohTiBOIU9BiP0AIVAgCyBQaiFRIFEhUiBMIE8gUhD6EyALKALklwEhUyBTEKwSIVQgVCFVIFWsIeIHIAsoAuiXASFWIFYQrBIhVyBXIVggWKwh4wcg4gcg4wd9IeQHQYD7ACFZIAsgWWohWiBaIVsgWyDkBxCTFBogCygC6JcBIVwgXBCrEiFdIF0hXiBerCHlByALKALklwEhXyBfEKsSIWAgYCFhIGGsIeYHIOUHIOYHfSHnB0H4+AAhYiALIGJqIWMgYyFkIGQg5wcQkxQaIAsoAuiXASFlIGUQqxIhZiBmIWcgZ6wh6AcgCygC5JcBIWggaBCrEiFpIGkhaiBqrCHpByDoByDpB3wh6gdB8PYAIWsgCyBraiFsIGwhbSBtIOoHEJMUGiALKALolwEhbiBuEKwSIW8gbyFwIHCsIesHIAsoAuSXASFxIHEQrBIhciByIXMgc6wh7Acg6wcg7Ad8Ie0HQej0ACF0IAsgdGohdSB1IXYgdiDtBxCTFBpB2PAAIXcgCyB3aiF4IHgheUGohQEheiALIHpqIXsgeyF8QYD7ACF9IAsgfWohfiB+IX8geSB8IH8Q9xNB0O4AIYABIAsggAFqIYEBIIEBIYIBQaCDASGDASALIIMBaiGEASCEASGFAUH4+AAhhgEgCyCGAWohhwEghwEhiAEgggEghQEgiAEQ9xNB4PIAIYkBIAsgiQFqIYoBIIoBIYsBQdjwACGMASALIIwBaiGNASCNASGOAUHQ7gAhjwEgCyCPAWohkAEgkAEhkQEgiwEgjgEgkQEQ+hNBwOoAIZIBIAsgkgFqIZMBIJMBIZQBQYD7ACGVASALIJUBaiGWASCWASGXAUGggwEhmAEgCyCYAWohmQEgmQEhmgEglAEglwEgmgEQ9xNBuOgAIZsBIAsgmwFqIZwBIJwBIZ0BQfj4ACGeASALIJ4BaiGfASCfASGgAUGohQEhoQEgCyChAWohogEgogEhowEgnQEgoAEgowEQ9xNByOwAIaQBIAsgpAFqIaUBIKUBIaYBQcDqACGnASALIKcBaiGoASCoASGpAUG46AAhqgEgCyCqAWohqwEgqwEhrAEgpgEgqQEgrAEQ+BMgCygC4JcBIa0BIK0BEKcSIa4BIK4BIa8BIK8BrCHuByALKALolwEhsAEgsAEQrBIhsQEgsQEhsgEgsgGsIe8HIO4HIO8HfSHwB0Gw5gAhswEgCyCzAWohtAEgtAEhtQEgtQEg8AcQkxQaIAsoAuiXASG2ASC2ARCrEiG3ASC3ASG4ASC4Aawh8QcgCygC4JcBIbkBILkBEN4TIboBILoBIbsBILsBrCHyByDxByDyB30h8wdBqOQAIbwBIAsgvAFqIb0BIL0BIb4BIL4BIPMHEJMUGkGY4AAhvwEgCyC/AWohwAEgwAEhwQFBqIUBIcIBIAsgwgFqIcMBIMMBIcQBQajkACHFASALIMUBaiHGASDGASHHASDBASDEASDHARD3E0GQ3gAhyAEgCyDIAWohyQEgyQEhygFBoIMBIcsBIAsgywFqIcwBIMwBIc0BQbDmACHOASALIM4BaiHPASDPASHQASDKASDNASDQARD3E0Gg4gAh0QEgCyDRAWoh0gEg0gEh0wFBmOAAIdQBIAsg1AFqIdUBINUBIdYBQZDeACHXASALINcBaiHYASDYASHZASDTASDWASDZARD4EyALKALglwEh2gEg2gEQpxIh2wEg2wEh3AEg3AGsIfQHIAsoAuSXASHdASDdARCsEiHeASDeASHfASDfAawh9Qcg9Acg9Qd9IfYHQbDmACHgASALIOABaiHhASDhASHiASDiASD2BxD2ExogCygC5JcBIeMBIOMBEKsSIeQBIOQBIeUBIOUBrCH3ByALKALglwEh5gEg5gEQ3hMh5wEg5wEh6AEg6AGsIfgHIPcHIPgHfSH5B0Go5AAh6QEgCyDpAWoh6gEg6gEh6wEg6wEg+QcQ9hMaQYDaACHsASALIOwBaiHtASDtASHuAUGohQEh7wEgCyDvAWoh8AEg8AEh8QFBqOQAIfIBIAsg8gFqIfMBIPMBIfQBIO4BIPEBIPQBEPcTQfjXACH1ASALIPUBaiH2ASD2ASH3AUGggwEh+AEgCyD4AWoh+QEg+QEh+gFBsOYAIfsBIAsg+wFqIfwBIPwBIf0BIPcBIPoBIP0BEPcTQYjcACH+ASALIP4BaiH/ASD/ASGAAkGA2gAhgQIgCyCBAmohggIgggIhgwJB+NcAIYQCIAsghAJqIYUCIIUCIYYCIIACIIMCIIYCEPgTQfDVACGHAiALIIcCaiGIAiCIAiGJAkGg4gAhigIgCyCKAmohiwIgiwIhjAJBiNwAIY0CIAsgjQJqIY4CII4CIY8CIIkCIIwCII8CEPoTQcjsACGQAiALIJACaiGRAiCRAiGSAiCSAhCUFCGTAkEBIZQCIJMCIJQCcSGVAgJAAkAglQJFDQBB4NEAIZYCIAsglgJqIZcCIJcCIZgCQeDyACGZAiALIJkCaiGaAiCaAiGbAiCYAiCbAiCbAhD3E0HYzwAhnAIgCyCcAmohnQIgnQIhngJB8NUAIZ8CIAsgnwJqIaACIKACIaECIJ4CIKECIKECEPcTQejTACGiAiALIKICaiGjAiCjAiGkAkHg0QAhpQIgCyClAmohpgIgpgIhpwJB2M8AIagCIAsgqAJqIakCIKkCIaoCIKQCIKcCIKoCEPgTQdDNACGrAiALIKsCaiGsAiCsAiGtAkHg8gAhrgIgCyCuAmohrwIgrwIhsAJB8NUAIbECIAsgsQJqIbICILICIbMCIK0CILACILMCEPcTQcjsACG0AiALILQCaiG1AiC1AiG2AkHQzQAhtwIgCyC3AmohuAIguAIhuQJBhAIhugIgtgIguQIgugIQ4xoaQbjHACG7AiALILsCaiG8AiC8AiG9AkHI7AAhvgIgCyC+AmohvwIgvwIhwAJB8PYAIcECIAsgwQJqIcICIMICIcMCIL0CIMACIMMCEPcTQcDJACHEAiALIMQCaiHFAiDFAiHGAkG4xwAhxwIgCyDHAmohyAIgyAIhyQJBAiHKAiDGAiDJAiDKAhCVFEGwxQAhywIgCyDLAmohzAIgzAIhzQJB6NMAIc4CIAsgzgJqIc8CIM8CIdACQYD7ACHRAiALINECaiHSAiDSAiHTAiDNAiDQAiDTAhD3E0HIywAh1AIgCyDUAmoh1QIg1QIh1gJBwMkAIdcCIAsg1wJqIdgCINgCIdkCQbDFACHaAiALINoCaiHbAiDbAiHcAiDWAiDZAiDcAhD6E0HAjwEh3QIgCyDdAmoh3gIg3gIh3wJByMsAIeACIAsg4AJqIeECIOECIeICQYQCIeMCIN8CIOICIOMCEOMaGkGwhwEh5AIgCyDkAmoh5QIg5QIh5gJBmIEBIecCIAsg5wJqIegCIOgCIekCQYQCIeoCIOYCIOkCIOoCEOMaGkGYPyHrAiALIOsCaiHsAiDsAiHtAkHI7AAh7gIgCyDuAmoh7wIg7wIh8AJB8NUAIfECIAsg8QJqIfICIPICIfMCIO0CIPACIPMCEPcTQaDBACH0AiALIPQCaiH1AiD1AiH2AkGYPyH3AiALIPcCaiH4AiD4AiH5AkECIfoCIPYCIPkCIPoCEJUUQZA9IfsCIAsg+wJqIfwCIPwCIf0CQejTACH+AiALIP4CaiH/AiD/AiGAA0Hg8gAhgQMgCyCBA2ohggMgggMhgwMg/QIggAMggwMQ9xNBqMMAIYQDIAsghANqIYUDIIUDIYYDQaDBACGHAyALIIcDaiGIAyCIAyGJA0GQPSGKAyALIIoDaiGLAyCLAyGMAyCGAyCJAyCMAxD6E0HAjwEhjQMgCyCNA2ohjgMgjgMhjwNBhAIhkAMgjwMgkANqIZEDQajDACGSAyALIJIDaiGTAyCTAyGUA0GEAiGVAyCRAyCUAyCVAxDjGhpBsIcBIZYDIAsglgNqIZcDIJcDIZgDQYQCIZkDIJgDIJkDaiGaA0EBIZsDIJoDIJsDEJYUGkH4NiGcAyALIJwDaiGdAyCdAyGeA0HI7AAhnwMgCyCfA2ohoAMgoAMhoQNB6PQAIaIDIAsgogNqIaMDIKMDIaQDIJ4DIKEDIKQDEPcTQYA5IaUDIAsgpQNqIaYDIKYDIacDQfg2IagDIAsgqANqIakDIKkDIaoDQQIhqwMgpwMgqgMgqwMQlRRB8DQhrAMgCyCsA2ohrQMgrQMhrgNB6NMAIa8DIAsgrwNqIbADILADIbEDQfj4ACGyAyALILIDaiGzAyCzAyG0AyCuAyCxAyC0AxD3E0GIOyG1AyALILUDaiG2AyC2AyG3A0GAOSG4AyALILgDaiG5AyC5AyG6A0HwNCG7AyALILsDaiG8AyC8AyG9AyC3AyC6AyC9AxD6E0HAjwEhvgMgCyC+A2ohvwMgvwMhwANBiAQhwQMgwAMgwQNqIcIDQYg7IcMDIAsgwwNqIcQDIMQDIcUDQYQCIcYDIMIDIMUDIMYDEOMaGkGsFCHHAyAPIMcDaiHIA0QAAAAAAADwPyH6ByALIPoHOQPgNEHgNCHJAyALIMkDaiHKAyDKAyHLAyDIAyDLAxDJDyH7B0GsFCHMAyAPIMwDaiHNA0HI7AAhzgMgCyDOA2ohzwMgzwMh0AMgzQMg0AMQ+RMh/Acg+wcg/AejIf0HIAsg/Qc5A+g0IAstANeXASHRA0EBIdIDINEDINIDcSHTAwJAINMDRQ0AIAsoAtiXASHUA0GsFCHVAyAPINUDaiHWA0QAAAAAAADQPyH+ByALIP4HOQPYNEHYNCHXAyALINcDaiHYAyDYAyHZAyDWAyDZAxDJDyH/B0GsFCHaAyAPINoDaiHbA0HAjwEh3AMgCyDcA2oh3QMg3QMh3gMg2wMg3gMQ+RMhgAgg/wcggAiiIYEIIAsrA+g0IYIIIIEIIIIIoiGDCCDUAyCDCBD7ExoLIAstANaXASHfA0EBIeADIN8DIOADcSHhAwJAIOEDRQ0AIAsoAtiXASHiA0GsFCHjAyAPIOMDaiHkA0QAAAAAAADQPyGECCALIIQIOQPQNEHQNCHlAyALIOUDaiHmAyDmAyHnAyDkAyDnAxDJDyGFCEGsFCHoAyAPIOgDaiHpA0HAjwEh6gMgCyDqA2oh6wMg6wMh7ANBiAQh7QMg7AMg7QNqIe4DIOkDIO4DEPkTIYYIIIUIIIYIoiGHCCALKwPoNCGICCCHCCCICKIhiQgg4gMgiQgQ/hMaCyALLQDVlwEh7wNBASHwAyDvAyDwA3Eh8QMCQCDxA0UNACALKALYlwEh8gNBrBQh8wMgDyDzA2oh9ANEAAAAAAAA0D8higggCyCKCDkDyDRByDQh9QMgCyD1A2oh9gMg9gMh9wMg9AMg9wMQyQ8hiwhBrBQh+AMgDyD4A2oh+QNBwI8BIfoDIAsg+gNqIfsDIPsDIfwDQbCHASH9AyALIP0DaiH+AyD+AyH/A0G4NCGABCALIIAEaiGBBCCBBCGCBCCCBCAPIPwDIP8DEJcUQbg0IYMEIAsggwRqIYQEIIQEIYUEIPkDIIUEEJgUIYwIIIsIIIwIoiGNCCALKwPoNCGOCCCNCCCOCKIhjwhBrBQhhgQgDyCGBGohhwRBmIEBIYgEIAsgiARqIYkEIIkEIYoEIIcEIIoEEPkTIZAIIAsgkAg5A7A0QbA0IYsEIAsgiwRqIYwEIIwEIY0EII0EEK8SIZEIII8IIJEIoyGSCCDyAyCSCBD9ExoLDAELQYgqIY4EIAsgjgRqIY8EII8EIZAEQeDyACGRBCALIJEEaiGSBCCSBCGTBCCQBCCTBCCTBBD3E0GAKCGUBCALIJQEaiGVBCCVBCGWBEHI7AAhlwQgCyCXBGohmAQgmAQhmQQglgQgmQQgmQQQ9xNBkCwhmgQgCyCaBGohmwQgmwQhnARBiCohnQQgCyCdBGohngQgngQhnwRBgCghoAQgCyCgBGohoQQgoQQhogQgnAQgnwQgogQQ+hNBmC4howQgCyCjBGohpAQgpAQhpQRBkCwhpgQgCyCmBGohpwQgpwQhqARBoOIAIakEIAsgqQRqIaoEIKoEIasEIKUEIKgEIKsEEPcTQaAwIawEIAsgrARqIa0EIK0EIa4EQZguIa8EIAsgrwRqIbAEILAEIbEEQYjcACGyBCALILIEaiGzBCCzBCG0BCCuBCCxBCC0BBD3E0GoMiG1BCALILUEaiG2BCC2BCG3BEGgMCG4BCALILgEaiG5BCC5BCG6BEEEIbsEILcEILoEILsEEJUUQawUIbwEIA8gvARqIb0ERAAAAAAAAPA/IZMIIAsgkwg5A/AnQfAnIb4EIAsgvgRqIb8EIL8EIcAEIL0EIMAEEMkPIZQIQawUIcEEIA8gwQRqIcIEQcjsACHDBCALIMMEaiHEBCDEBCHFBCDCBCDFBBD5EyGVCCCUCCCVCKMhlgggCyCWCDkD+CcgCysD+CchlwggCysD+CchmAggmAgglwiiIZkIIAsgmQg5A/gnIAstANeXASHGBEEBIccEIMYEIMcEcSHIBAJAAkAgyAQNACALLQDVlwEhyQRBASHKBCDJBCDKBHEhywQgywRFDQELQdghIcwEIAsgzARqIc0EIM0EIc4EQfD2ACHPBCALIM8EaiHQBCDQBCHRBEHI7AAh0gQgCyDSBGoh0wQg0wQh1AQgzgQg0QQg1AQQ9xNB4CMh1QQgCyDVBGoh1gQg1gQh1wRB2CEh2AQgCyDYBGoh2QQg2QQh2gRByOwAIdsEIAsg2wRqIdwEINwEId0EINcEINoEIN0EEPcTQcgdId4EIAsg3gRqId8EIN8EIeAEQeDyACHhBCALIOEEaiHiBCDiBCHjBEHw1QAh5AQgCyDkBGoh5QQg5QQh5gQg4AQg4wQg5gQQ9xNB0B8h5wQgCyDnBGoh6AQg6AQh6QRByB0h6gQgCyDqBGoh6wQg6wQh7ARBgPsAIe0EIAsg7QRqIe4EIO4EIe8EIOkEIOwEIO8EEPcTQeglIfAEIAsg8ARqIfEEIPEEIfIEQeAjIfMEIAsg8wRqIfQEIPQEIfUEQdAfIfYEIAsg9gRqIfcEIPcEIfgEIPIEIPUEIPgEEPoTQcCPASH5BCALIPkEaiH6BCD6BCH7BEHoJSH8BCALIPwEaiH9BCD9BCH+BEGEAiH/BCD7BCD+BCD/BBDjGhpBsIcBIYAFIAsggAVqIYEFIIEFIYIFQQEhgwUgggUggwUQlhQaIAsoAtyXASGEBUECIYUFIIQFIYYFIIUFIYcFIIYFIIcFRiGIBUEBIYkFIIgFIIkFcSGKBQJAAkAgigVFDQBBwBshiwUgCyCLBWohjAUgjAUhjQVBgPsAIY4FIAsgjgVqIY8FII8FIZAFII0FIJAFEJkUDAELQcAbIZEFIAsgkQVqIZIFIJIFIZMFQYD7ACGUBSALIJQFaiGVBSCVBSGWBUGEAiGXBSCTBSCWBSCXBRDjGhoLQcCPASGYBSALIJgFaiGZBSCZBSGaBUGEAiGbBSCaBSCbBWohnAVBwBshnQUgCyCdBWohngUgngUhnwVBhAIhoAUgnAUgnwUgoAUQ4xoaQbCHASGhBSALIKEFaiGiBSCiBSGjBUGEAiGkBSCjBSCkBWohpQVBqDIhpgUgCyCmBWohpwUgpwUhqAVBhAIhqQUgpQUgqAUgqQUQ4xoaIAstANeXASGqBUEBIasFIKoFIKsFcSGsBQJAIKwFRQ0AIAsoAtiXASGtBUGsFCGuBSAPIK4FaiGvBUQAAAAAAADgPyGaCCALIJoIOQO4G0G4GyGwBSALILAFaiGxBSCxBSGyBSCvBSCyBRDJDyGbCEGsFCGzBSAPILMFaiG0BUHAjwEhtQUgCyC1BWohtgUgtgUhtwVBsIcBIbgFIAsguAVqIbkFILkFIboFQagbIbsFIAsguwVqIbwFILwFIb0FIL0FIA8gtwUgugUQlxRBqBshvgUgCyC+BWohvwUgvwUhwAUgtAUgwAUQmBQhnAggmwggnAiiIZ0IIAsrA/gnIZ4IIJ0IIJ4IoiGfCCCtBSCfCBD7ExoLCyALLQDWlwEhwQVBASHCBSDBBSDCBXEhwwUCQAJAIMMFDQAgCy0A1ZcBIcQFQQEhxQUgxAUgxQVxIcYFIMYFRQ0BC0GQFSHHBSALIMcFaiHIBSDIBSHJBUHo9AAhygUgCyDKBWohywUgywUhzAVByOwAIc0FIAsgzQVqIc4FIM4FIc8FIMkFIMwFIM8FEPcTQZgXIdAFIAsg0AVqIdEFINEFIdIFQZAVIdMFIAsg0wVqIdQFINQFIdUFQcjsACHWBSALINYFaiHXBSDXBSHYBSDSBSDVBSDYBRD3E0GAESHZBSALINkFaiHaBSDaBSHbBUHg8gAh3AUgCyDcBWoh3QUg3QUh3gVB8NUAId8FIAsg3wVqIeAFIOAFIeEFINsFIN4FIOEFEPcTQYgTIeIFIAsg4gVqIeMFIOMFIeQFQYARIeUFIAsg5QVqIeYFIOYFIecFQfj4ACHoBSALIOgFaiHpBSDpBSHqBSDkBSDnBSDqBRD3E0GgGSHrBSALIOsFaiHsBSDsBSHtBUGYFyHuBSALIO4FaiHvBSDvBSHwBUGIEyHxBSALIPEFaiHyBSDyBSHzBSDtBSDwBSDzBRD6E0HAjwEh9AUgCyD0BWoh9QUg9QUh9gVBiAQh9wUg9gUg9wVqIfgFQaAZIfkFIAsg+QVqIfoFIPoFIfsFQYQCIfwFIPgFIPsFIPwFEOMaGkGwhwEh/QUgCyD9BWoh/gUg/gUh/wVBiAQhgAYg/wUggAZqIYEGQQEhggYggQYgggYQlhQaIAsoAtyXASGDBkECIYQGIIMGIYUGIIQGIYYGIIUGIIYGRiGHBkEBIYgGIIcGIIgGcSGJBgJAAkAgiQZFDQBB+A4higYgCyCKBmohiwYgiwYhjAZB+PgAIY0GIAsgjQZqIY4GII4GIY8GIIwGII8GEJkUDAELQfgOIZAGIAsgkAZqIZEGIJEGIZIGQfj4ACGTBiALIJMGaiGUBiCUBiGVBkGEAiGWBiCSBiCVBiCWBhDjGhoLQcCPASGXBiALIJcGaiGYBiCYBiGZBkGMBiGaBiCZBiCaBmohmwZB+A4hnAYgCyCcBmohnQYgnQYhngZBhAIhnwYgmwYgngYgnwYQ4xoaQbCHASGgBiALIKAGaiGhBiChBiGiBkGMBiGjBiCiBiCjBmohpAZBqDIhpQYgCyClBmohpgYgpgYhpwZBhAIhqAYgpAYgpwYgqAYQ4xoaIAstANaXASGpBkEBIaoGIKkGIKoGcSGrBgJAIKsGRQ0AIAsoAtiXASGsBkGsFCGtBiAPIK0GaiGuBkQAAAAAAADgPyGgCCALIKAIOQPwDkHwDiGvBiALIK8GaiGwBiCwBiGxBiCuBiCxBhDJDyGhCEGsFCGyBiAPILIGaiGzBkHAjwEhtAYgCyC0BmohtQYgtQYhtgZBiAQhtwYgtgYgtwZqIbgGQbCHASG5BiALILkGaiG6BiC6BiG7BkGIBCG8BiC7BiC8BmohvQZB4A4hvgYgCyC+BmohvwYgvwYhwAYgwAYgDyC4BiC9BhCXFEHgDiHBBiALIMEGaiHCBiDCBiHDBiCzBiDDBhCYFCGiCCChCCCiCKIhowggCysD+CchpAggowggpAiiIaUIIKwGIKUIEP4TGgsLIAstANWXASHEBkEBIcUGIMQGIMUGcSHGBiDGBkUNAEGwhwEhxwYgCyDHBmohyAYgyAYhyQZB2AwhygYgCyDKBmohywYgywYhzAZBmIEBIc0GIAsgzQZqIc4GIM4GIc8GIMwGIMkGIM8GEPcTQbCHASHQBiALINAGaiHRBiDRBiHSBkHYDCHTBiALINMGaiHUBiDUBiHVBkGEAiHWBiDSBiDVBiDWBhDjGhpBsIcBIdcGIAsg1wZqIdgGINgGIdkGQYQCIdoGINkGINoGaiHbBkHQCiHcBiALINwGaiHdBiDdBiHeBkGYgQEh3wYgCyDfBmoh4AYg4AYh4QYg3gYg2wYg4QYQ9xNBsIcBIeIGIAsg4gZqIeMGIOMGIeQGQYQCIeUGIOQGIOUGaiHmBkHQCiHnBiALIOcGaiHoBiDoBiHpBkGEAiHqBiDmBiDpBiDqBhDjGhpBuAQh6wYgCyDrBmoh7AYg7AYh7QZByOwAIe4GIAsg7gZqIe8GIO8GIfAGIO0GIPAGIPAGEPcTQbACIfEGIAsg8QZqIfIGIPIGIfMGQeDyACH0BiALIPQGaiH1BiD1BiH2BiDzBiD2BiD2BhD3E0HABiH3BiALIPcGaiH4BiD4BiH5BkG4BCH6BiALIPoGaiH7BiD7BiH8BkGwAiH9BiALIP0GaiH+BiD+BiH/BiD5BiD8BiD/BhD6E0HICCGAByALIIAHaiGBByCBByGCB0Hw1QAhgwcgCyCDB2ohhAcghAchhQdBwAYhhgcgCyCGB2ohhwcghwchiAcgggcghQcgiAcQ9xNBwI8BIYkHIAsgiQdqIYoHIIoHIYsHQYgEIYwHIIsHIIwHaiGNB0HICCGOByALII4HaiGPByCPByGQB0GEAiGRByCNByCQByCRBxDjGhpBsIcBIZIHIAsgkgdqIZMHIJMHIZQHQYgEIZUHIJQHIJUHaiGWB0EBIZcHIJYHIJcHEJYUGiALKALclwEhmAdBAiGZByCYByGaByCZByGbByCaByCbB0YhnAdBASGdByCcByCdB3EhngcCQAJAIJ4HRQ0AQSghnwcgCyCfB2ohoAcgoAchoQdB4PIAIaIHIAsgogdqIaMHIKMHIaQHIKEHIKQHEJkUDAELQSghpQcgCyClB2ohpgcgpgchpwdB4PIAIagHIAsgqAdqIakHIKkHIaoHQYQCIasHIKcHIKoHIKsHEOMaGgtBwI8BIawHIAsgrAdqIa0HIK0HIa4HQYwGIa8HIK4HIK8HaiGwB0EoIbEHIAsgsQdqIbIHILIHIbMHQYQCIbQHILAHILMHILQHEOMaGkGwhwEhtQcgCyC1B2ohtgcgtgchtwdBjAYhuAcgtwcguAdqIbkHQagyIboHIAsgugdqIbsHILsHIbwHQYQCIb0HILkHILwHIL0HEOMaGiALKALYlwEhvgdBrBQhvwcgDyC/B2ohwAdEAAAAAAAA4D8hpgggCyCmCDkDIEEgIcEHIAsgwQdqIcIHIMIHIcMHIMAHIMMHEMkPIacIQawUIcQHIA8gxAdqIcUHQcCPASHGByALIMYHaiHHByDHByHIB0GwhwEhyQcgCyDJB2ohygcgygchywdBECHMByALIMwHaiHNByDNByHOByDOByAPIMgHIMsHEJoUQRAhzwcgCyDPB2oh0Acg0Ach0QcgxQcg0QcQmBQhqAggpwggqAiiIakIIAsrA/gnIaoIIKkIIKoIoiGrCEGsFCHSByAPINIHaiHTB0GYgQEh1AcgCyDUB2oh1Qcg1Qch1gcg0wcg1gcQ+RMhrAggCyCsCDkDCEEIIdcHIAsg1wdqIdgHINgHIdkHINkHEK8SIa0IIKsIIK0IoyGuCCC+ByCuCBD9ExoLQfCXASHaByALINoHaiHbByDbByQADwuEAgEefyMAIQJBMCEDIAIgA2shBCAEJAAgBCAANgIsIAQgATYCKCAEKAIsIQUgBCgCKCEGIAYQ7RMhB0EBIQggByAIcSEJAkACQCAJDQAgBCgCKCEKIAUgChCtFBogBCgCKCELQRAhDCAFIAxqIQ0gDSALEK0UGgwBCyAEKAIoIQ5BGCEPIAQgD2ohECAQIREgESAOEJIUQRghEiAEIBJqIRMgEyEUIAUgFBCtFBogBCgCKCEVQQghFiAEIBZqIRcgFyEYIBggFRCSFEEQIRkgBSAZaiEaQQghGyAEIBtqIRwgHCEdIBogHRCtFBogBRCuFAtBMCEeIAQgHmohHyAfJAAgBQ8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEP8TIQVBASEGIAUgBnEhB0EQIQggAyAIaiEJIAkkACAHDwvcAwIjfxV8IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAFKwMAISUgBCgCGCEGIAYrAwAhJiAlICagIScgBCAnOQMQIAUQlxEhB0EBIQggByAIcSEJAkACQAJAAkAgCQ0AIAQoAhghCiAKEJcRIQtBASEMIAsgDHEhDSANRQ0BCyAFEIAUIQ5BASEPIA4gD3EhECAQDQEgBCgCGCERIBEQgBQhEkEBIRMgEiATcSEUIBQNAQtBCCEVIAUgFWohFiAEKAIYIRdBCCEYIBcgGGohGSAWIBkQgRQhGiAaKwMAIShEAAAAAAAA8D8hKSAoICmgISogBSAqOQMIDAELIAUrAwAhKyAFKwMIISwgKyAsoiEtIAQoAhghGyAbKwMAIS4gBCgCGCEcIBwrAwghLyAuIC+iITAgLSAwoSExIAQrAxAhMiAxIDKjITMgBCAzOQMIQQghHSAEIB1qIR4gHiEfIB8QlxEhIEEBISEgICAhcSEiAkAgIkUNACAEKwMIITQgNJohNSAEIDU5AwgLIAQrAwghNkQAAAAAAADwPyE3IDYgN6AhOCAFIDg5AwgLIAQrAxAhOSAFIDk5AwBBICEjIAQgI2ohJCAkJAAgBQ8L2QMCIX8WfCMAIQNBICEEIAMgBGshBSAFJAAgBSABNgIcIAUgAjYCGCAFKAIcIQYgBisDACEkIAUoAhghByAHKwMAISUgJCAloSEmIAUgJjkDECAGEJcRIQhBASEJIAggCXEhCgJAAkACQAJAIAoNACAFKAIYIQsgCxCAFCEMQQEhDSAMIA1xIQ4gDkUNAQsgBhCAFCEPQQEhECAPIBBxIREgEQ0BIAUoAhghEiASEJcRIRNBASEUIBMgFHEhFSAVDQELQQghFiAGIBZqIRcgBSgCGCEYQQghGSAYIBlqIRogFyAaEIEUIRsgGysDACEnRAAAAAAAAPA/ISggJyAooCEpIAUgKTkDCAwBCyAGKwMAISogBisDCCErICogK6IhLCAFKAIYIRwgHCsDACEtIAUoAhghHSAdKwMIIS4gLSAuoiEvICwgL6AhMCAFKwMQITEgMCAxoyEyIAUgMjkDACAFIR4gHhCXESEfQQEhICAfICBxISECQCAhRQ0AIAUrAwAhMyAzmiE0IAUgNDkDAAsgBSsDACE1RAAAAAAAAPA/ITYgNSA2oCE3IAUgNzkDCAsgBSsDECE4IAUrAwghOSAAIDggORDVExpBICEiIAUgImohIyAjJAAPC3IBDH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBkEQIQcgBiAHaiEIIAUgCBDuExogBCgCCCEJQRAhCiAFIApqIQsgCyAJEO4TGkEQIQwgBCAMaiENIA0kACAFDwuDfgPHDX87fip8IwAhCUHgoAIhCiAJIAprIQsgCyQAIAsgADYC3KACIAsgATYC2KACIAsgAjYC1KACIAsgAzYC0KACIAsgBDYCzKACIAsgBTYCyKACIAYhDCALIAw6AMegAiAHIQ0gCyANOgDGoAIgCCEOIAsgDjoAxaACIAsoAtygAiEPQbCcAiEQIAsgEGohESARIRJBiAQhEyASIBNqIRQgEiEVA0AgFSEWIBYQzQ4aQYQCIRcgFiAXaiEYIBghGSAUIRogGSAaRiEbQQEhHCAbIBxxIR0gGCEVIB1FDQALQaCYAiEeIAsgHmohHyAfISBBiAQhISAgICFqISIgICEjA0AgIyEkICQQzQ4aQYQCISUgJCAlaiEmICYhJyAiISggJyAoRiEpQQEhKiApICpxISsgJiEjICtFDQALQZCUAiEsIAsgLGohLSAtIS5BiAQhLyAuIC9qITAgLiExA0AgMSEyIDIQzQ4aQYQCITMgMiAzaiE0IDQhNSAwITYgNSA2RiE3QQEhOCA3IDhxITkgNCExIDlFDQALQYCMAiE6IAsgOmohOyA7ITxBkAghPSA8ID1qIT4gPCE/A0AgPyFAIEAQzQ4aQYQCIUEgQCBBaiFCIEIhQyA+IUQgQyBERiFFQQEhRiBFIEZxIUcgQiE/IEdFDQALQfCDAiFIIAsgSGohSSBJIUpBkAghSyBKIEtqIUwgSiFNA0AgTSFOIE4QzQ4aQYQCIU8gTiBPaiFQIFAhUSBMIVIgUSBSRiFTQQEhVCBTIFRxIVUgUCFNIFVFDQALIAsoAtSgAiFWIFYQwA8hVyALIFc2AuyDAiALKALUoAIhWCBYEKAPIVkgCyBZNgLogwIgCygC0KACIVogWhCgDyFbIAsgWzYC5IMCIAsoAtCgAiFcIFwQwA8hXSALIF02AuCDAiALKALogwIhXiBeENQOIV8gXyFgIGCsIdANIAsoAuyDAiFhIGEQ1A4hYiBiIWMgY6wh0Q0g0A0g0Q19IdINQbCcAiFkIAsgZGohZSBlIWYgZiDSDRD2ExogCygC6IMCIWcgZxDVDiFoIGghaSBprCHTDSALKALsgwIhaiBqENUOIWsgayFsIGysIdQNINMNINQNfSHVDUGgmAIhbSALIG1qIW4gbiFvIG8g1Q0Q9hMaIAsoAuCDAiFwIHAQ1A4hcSBxIXIgcqwh1g0gCygC5IMCIXMgcxDUDiF0IHQhdSB1rCHXDSDWDSDXDX0h2A1BsJwCIXYgCyB2aiF3IHcheEGEAiF5IHggeWoheiB6INgNEPYTGiALKALggwIheyB7ENUOIXwgfCF9IH2sIdkNIAsoAuSDAiF+IH4Q1Q4hfyB/IYABIIABrCHaDSDZDSDaDX0h2w1BoJgCIYEBIAsggQFqIYIBIIIBIYMBQYQCIYQBIIMBIIQBaiGFASCFASDbDRD2ExpBsJwCIYYBIAsghgFqIYcBIIcBIYgBQYQCIYkBIIgBIIkBaiGKAUGgmAIhiwEgCyCLAWohjAEgjAEhjQFB0P8BIY4BIAsgjgFqIY8BII8BIZABIJABIIoBII0BEPcTQbCcAiGRASALIJEBaiGSASCSASGTAUGgmAIhlAEgCyCUAWohlQEglQEhlgFBhAIhlwEglgEglwFqIZgBQcj9ASGZASALIJkBaiGaASCaASGbASCbASCTASCYARD3E0HYgQIhnAEgCyCcAWohnQEgnQEhngFB0P8BIZ8BIAsgnwFqIaABIKABIaEBQcj9ASGiASALIKIBaiGjASCjASGkASCeASChASCkARD4E0HYgQIhpQEgCyClAWohpgEgpgEhpwEgpwEQlBQhqAFBASGpASCoASCpAXEhqgECQAJAIKoBRQ0AQawUIasBIA8gqwFqIawBRAAAAAAAAABAIYsOIAsgiw45A7j9AUG4/QEhrQEgCyCtAWohrgEgrgEhrwEgrAEgrwEQyQ8hjA5BrBQhsAEgDyCwAWohsQFBsJwCIbIBIAsgsgFqIbMBILMBIbQBQbCcAiG1ASALILUBaiG2ASC2ASG3AUGo+QEhuAEgCyC4AWohuQEguQEhugEgugEgtAEgtwEQ9xNBoJgCIbsBIAsguwFqIbwBILwBIb0BQaCYAiG+ASALIL4BaiG/ASC/ASHAAUGg9wEhwQEgCyDBAWohwgEgwgEhwwEgwwEgvQEgwAEQ9xNBsPsBIcQBIAsgxAFqIcUBIMUBIcYBQaj5ASHHASALIMcBaiHIASDIASHJAUGg9wEhygEgCyDKAWohywEgywEhzAEgxgEgyQEgzAEQ+hNBsPsBIc0BIAsgzQFqIc4BIM4BIc8BILEBIM8BEPkTIY0OIIwOII0OoiGODiALII4OOQPA/QFBoJgCIdABIAsg0AFqIdEBINEBIdIBIAsoAuSDAiHTASDTARDUDiHUASDUASHVASDVAawh3A0gCygC7IMCIdYBINYBENQOIdcBINcBIdgBINgBrCHdDSDcDSDdDX0h3g1BkPMBIdkBIAsg2QFqIdoBINoBIdsBINsBINIBIN4NEK8UQbCcAiHcASALINwBaiHdASDdASHeASALKALkgwIh3wEg3wEQ1Q4h4AEg4AEh4QEg4QGsId8NIAsoAuyDAiHiASDiARDVDiHjASDjASHkASDkAawh4A0g3w0g4A19IeENQYjxASHlASALIOUBaiHmASDmASHnASDnASDeASDhDRCvFEGY9QEh6AEgCyDoAWoh6QEg6QEh6gFBkPMBIesBIAsg6wFqIewBIOwBIe0BQYjxASHuASALIO4BaiHvASDvASHwASDqASDtASDwARD4E0GQlAIh8QEgCyDxAWoh8gEg8gEh8wFBmPUBIfQBIAsg9AFqIfUBIPUBIfYBQYQCIfcBIPMBIPYBIPcBEOMaGkGwnAIh+AEgCyD4AWoh+QEg+QEh+gEgCygC2KACIfsBIPsBEKwSIfwBIPwBIf0BIP0BrCHiDSALKALsgwIh/gEg/gEQ1Q4h/wEg/wEhgAIggAKsIeMNIOINIOMNfSHkDUH47AEhgQIgCyCBAmohggIgggIhgwIggwIg+gEg5A0QrxRBoJgCIYQCIAsghAJqIYUCIIUCIYYCIAsoAtigAiGHAiCHAhCrEiGIAiCIAiGJAiCJAqwh5Q0gCygC7IMCIYoCIIoCENQOIYsCIIsCIYwCIIwCrCHmDSDlDSDmDX0h5w1B8OoBIY0CIAsgjQJqIY4CII4CIY8CII8CIIYCIOcNEK8UQYDvASGQAiALIJACaiGRAiCRAiGSAkH47AEhkwIgCyCTAmohlAIglAIhlQJB8OoBIZYCIAsglgJqIZcCIJcCIZgCIJICIJUCIJgCEPgTQaCYAiGZAiALIJkCaiGaAiCaAiGbAiALKALYoAIhnAIgnAIQqxIhnQIgnQIhngIgngKsIegNIAsoAuSDAiGfAiCfAhDUDiGgAiCgAiGhAiChAqwh6Q0g6A0g6Q19IeoNQeDmASGiAiALIKICaiGjAiCjAiGkAiCkAiCbAiDqDRCvFEGwnAIhpQIgCyClAmohpgIgpgIhpwIgCygC2KACIagCIKgCEKwSIakCIKkCIaoCIKoCrCHrDSALKALkgwIhqwIgqwIQ1Q4hrAIgrAIhrQIgrQKsIewNIOsNIOwNfSHtDUHY5AEhrgIgCyCuAmohrwIgrwIhsAIgsAIgpwIg7Q0QrxRB6OgBIbECIAsgsQJqIbICILICIbMCQeDmASG0AiALILQCaiG1AiC1AiG2AkHY5AEhtwIgCyC3AmohuAIguAIhuQIgswIgtgIguQIQ+BNB0OIBIboCIAsgugJqIbsCILsCIbwCQYDvASG9AiALIL0CaiG+AiC+AiG/AkHo6AEhwAIgCyDAAmohwQIgwQIhwgIgvAIgvwIgwgIQ9xNB8IMCIcMCIAsgwwJqIcQCIMQCIcUCQdDiASHGAiALIMYCaiHHAiDHAiHIAkGEAiHJAiDFAiDIAiDJAhDjGhpB8IMCIcoCIAsgygJqIcsCIMsCIcwCQYQCIc0CIMwCIM0CaiHOAkEBIc8CIM4CIM8CEJYUGiALLQDGoAIh0AJBASHRAiDQAiDRAnEh0gICQCDSAkUNAEGgmAIh0wIgCyDTAmoh1AIg1AIh1QIgCygCzKACIdYCQQIh1wIg1gIh2AIg1wIh2QIg2AIg2QJGIdoCQQIh2wJBfiHcAkEBId0CINoCIN0CcSHeAiDbAiDcAiDeAhsh3wJByOABIeACIAsg4AJqIeECIOECIeICIOICINUCIN8CEJUUQYCMAiHjAiALIOMCaiHkAiDkAiHlAkHI4AEh5gIgCyDmAmoh5wIg5wIh6AJBhAIh6QIg5QIg6AIg6QIQ4xoaQbCcAiHqAiALIOoCaiHrAiDrAiHsAkGwnAIh7QIgCyDtAmoh7gIg7gIh7wJBqNgBIfACIAsg8AJqIfECIPECIfICIPICIOwCIO8CEPcTIAsoAuyDAiHzAiDzAhDVDiH0AiD0AiH1AiD1Aqwh7g0gCygC5IMCIfYCIPYCENUOIfcCIPcCIfgCIPgCrCHvDSDuDSDvDXwh8A1BsNoBIfkCIAsg+QJqIfoCIPoCIfsCQajYASH8AiALIPwCaiH9AiD9AiH+AiD7AiD+AiDwDRCvFEGwnAIh/wIgCyD/AmohgAMggAMhgQNBoJgCIYIDIAsgggNqIYMDIIMDIYQDQZjUASGFAyALIIUDaiGGAyCGAyGHAyCHAyCBAyCEAxD3EyALKALsgwIhiAMgiAMQ1A4hiQMgiQMhigMgigOsIfENIAsoAuSDAiGLAyCLAxDUDiGMAyCMAyGNAyCNA6wh8g0g8Q0g8g18IfMNIAsoAtigAiGOAyCOAxCrEiGPAyCPAyGQAyCQA6wh9A1CASH1DSD0DSD1DYYh9g0g8w0g9g19IfcNQaDWASGRAyALIJEDaiGSAyCSAyGTA0GY1AEhlAMgCyCUA2ohlQMglQMhlgMgkwMglgMg9w0QrxRBuNwBIZcDIAsglwNqIZgDIJgDIZkDQbDaASGaAyALIJoDaiGbAyCbAyGcA0Gg1gEhnQMgCyCdA2ohngMgngMhnwMgmQMgnAMgnwMQ+BNBoJgCIaADIAsgoANqIaEDIKEDIaIDQaCYAiGjAyALIKMDaiGkAyCkAyGlA0GI0AEhpgMgCyCmA2ohpwMgpwMhqAMgqAMgogMgpQMQ9xMgCygC2KACIakDIKkDEKwSIaoDIKoDIasDIKsDrCH4DUIBIfkNIPgNIPkNhiH6DUGQ0gEhrAMgCyCsA2ohrQMgrQMhrgNBiNABIa8DIAsgrwNqIbADILADIbEDIK4DILEDIPoNEK8UQcDeASGyAyALILIDaiGzAyCzAyG0A0G43AEhtQMgCyC1A2ohtgMgtgMhtwNBkNIBIbgDIAsguANqIbkDILkDIboDILQDILcDILoDEPoTQYCMAiG7AyALILsDaiG8AyC8AyG9A0GEAiG+AyC9AyC+A2ohvwNBwN4BIcADIAsgwANqIcEDIMEDIcIDQYQCIcMDIL8DIMIDIMMDEOMaGkGsFCHEAyAPIMQDaiHFA0GAjAIhxgMgCyDGA2ohxwMgxwMhyANB8IMCIckDIAsgyQNqIcoDIMoDIcsDQfDPASHMAyALIMwDaiHNAyDNAyHOAyDOAyAPIMgDIMsDEJcUQfDPASHPAyALIM8DaiHQAyDQAyHRAyDFAyDRAxCYFCGPDiALII8OOQOA0AEgCygCyKACIdIDIAsrA4DQASGQDiALKwPA/QEhkQ4gkA4gkQ6jIZIOINIDIJIOEP4TGgsgCy0Ax6ACIdMDQQEh1AMg0wMg1ANxIdUDAkACQCDVAw0AIAstAMWgAiHWA0EBIdcDINYDINcDcSHYAyDYA0UNAQtBsJwCIdkDIAsg2QNqIdoDINoDIdsDIAsoAsygAiHcA0ECId0DINwDId4DIN0DId8DIN4DIN8DRiHgA0ECIeEDQX4h4gNBASHjAyDgAyDjA3Eh5AMg4QMg4gMg5AMbIeUDQejNASHmAyALIOYDaiHnAyDnAyHoAyDoAyDbAyDlAxCVFEGAjAIh6QMgCyDpA2oh6gMg6gMh6wNB6M0BIewDIAsg7ANqIe0DIO0DIe4DQYQCIe8DIOsDIO4DIO8DEOMaGkGgmAIh8AMgCyDwA2oh8QMg8QMh8gNBoJgCIfMDIAsg8wNqIfQDIPQDIfUDQcjFASH2AyALIPYDaiH3AyD3AyH4AyD4AyDyAyD1AxD3EyALKALsgwIh+QMg+QMQ1A4h+gMg+gMh+wMg+wOsIfsNIAsoAuSDAiH8AyD8AxDUDiH9AyD9AyH+AyD+A6wh/A0g+w0g/A18If0NQdDHASH/AyALIP8DaiGABCCABCGBBEHIxQEhggQgCyCCBGohgwQggwQhhAQggQQghAQg/Q0QrxRBsJwCIYUEIAsghQRqIYYEIIYEIYcEQaCYAiGIBCALIIgEaiGJBCCJBCGKBEG4wQEhiwQgCyCLBGohjAQgjAQhjQQgjQQghwQgigQQ9xMgCygC7IMCIY4EII4EENUOIY8EII8EIZAEIJAErCH+DSALKALkgwIhkQQgkQQQ1Q4hkgQgkgQhkwQgkwSsIf8NIP4NIP8NfCGADiALKALYoAIhlAQglAQQrBIhlQQglQQhlgQglgSsIYEOQgEhgg4ggQ4ggg6GIYMOIIAOIIMOfSGEDkHAwwEhlwQgCyCXBGohmAQgmAQhmQRBuMEBIZoEIAsgmgRqIZsEIJsEIZwEIJkEIJwEIIQOEK8UQdjJASGdBCALIJ0EaiGeBCCeBCGfBEHQxwEhoAQgCyCgBGohoQQgoQQhogRBwMMBIaMEIAsgowRqIaQEIKQEIaUEIJ8EIKIEIKUEEPgTQbCcAiGmBCALIKYEaiGnBCCnBCGoBEGwnAIhqQQgCyCpBGohqgQgqgQhqwRBqL0BIawEIAsgrARqIa0EIK0EIa4EIK4EIKgEIKsEEPcTIAsoAtigAiGvBCCvBBCrEiGwBCCwBCGxBCCxBKwhhQ5CASGGDiCFDiCGDoYhhw5BsL8BIbIEIAsgsgRqIbMEILMEIbQEQai9ASG1BCALILUEaiG2BCC2BCG3BCC0BCC3BCCHDhCvFEHgywEhuAQgCyC4BGohuQQguQQhugRB2MkBIbsEIAsguwRqIbwEILwEIb0EQbC/ASG+BCALIL4EaiG/BCC/BCHABCC6BCC9BCDABBD6E0GAjAIhwQQgCyDBBGohwgQgwgQhwwRBhAIhxAQgwwQgxARqIcUEQeDLASHGBCALIMYEaiHHBCDHBCHIBEGEAiHJBCDFBCDIBCDJBBDjGhogCy0Ax6ACIcoEQQEhywQgygQgywRxIcwEAkAgzARFDQBBrBQhzQQgDyDNBGohzgRBgIwCIc8EIAsgzwRqIdAEINAEIdEEQfCDAiHSBCALINIEaiHTBCDTBCHUBEGQvQEh1QQgCyDVBGoh1gQg1gQh1wQg1wQgDyDRBCDUBBCXFEGQvQEh2AQgCyDYBGoh2QQg2QQh2gQgzgQg2gQQmBQhkw4gCyCTDjkDoL0BIAsoAsigAiHbBCALKwOgvQEhlA4gCysDwP0BIZUOIJQOIJUOoyGWDiDbBCCWDhD7ExoLIAstAMWgAiHcBEEBId0EINwEIN0EcSHeBAJAIN4ERQ0AQZCUAiHfBCALIN8EaiHgBCDgBCHhBCDhBBCwFCHiBEEBIeMEIOIEIOMEcSHkBAJAAkAg5ARFDQBBkJQCIeUEIAsg5QRqIeYEIOYEIecEQYi7ASHoBCALIOgEaiHpBCDpBCHqBCDqBCDnBBCZFAwBC0GQlAIh6wQgCyDrBGoh7AQg7AQh7QRBiLsBIe4EIAsg7gRqIe8EIO8EIfAEQYQCIfEEIPAEIO0EIPEEEOMaGgtBgIwCIfIEIAsg8gRqIfMEIPMEIfQEQYgEIfUEIPQEIPUEaiH2BEGIuwEh9wQgCyD3BGoh+AQg+AQh+QRBhAIh+gQg9gQg+QQg+gQQ4xoaQbCcAiH7BCALIPsEaiH8BCD8BCH9BEGwnAIh/gQgCyD+BGoh/wQg/wQhgAVB+LYBIYEFIAsggQVqIYIFIIIFIYMFIIMFIP0EIIAFEPcTQaCYAiGEBSALIIQFaiGFBSCFBSGGBUGgmAIhhwUgCyCHBWohiAUgiAUhiQVB8LQBIYoFIAsgigVqIYsFIIsFIYwFIIwFIIYFIIkFEPcTQYC5ASGNBSALII0FaiGOBSCOBSGPBUH4tgEhkAUgCyCQBWohkQUgkQUhkgVB8LQBIZMFIAsgkwVqIZQFIJQFIZUFII8FIJIFIJUFEPoTQfCDAiGWBSALIJYFaiGXBSCXBSGYBUGIBCGZBSCYBSCZBWohmgVBgLkBIZsFIAsgmwVqIZwFIJwFIZ0FQYQCIZ4FIJoFIJ0FIJ4FEOMaGkGsFCGfBSAPIJ8FaiGgBUGAjAIhoQUgCyChBWohogUgogUhowVB8IMCIaQFIAsgpAVqIaUFIKUFIaYFQdi0ASGnBSALIKcFaiGoBSCoBSGpBSCpBSAPIKMFIKYFEKYUQdi0ASGqBSALIKoFaiGrBSCrBSGsBSCgBSCsBRCYFCGXDiALIJcOOQPotAEgCygCyKACIa0FIAsrA+i0ASGYDiALKwPA/QEhmQ4gmA4gmQ6jIZoOIK0FIJoOEP0TGgsLDAELQaCYAiGuBSALIK4FaiGvBSCvBSGwBSALKALogwIhsQUgsQUQ1A4hsgVByLABIbMFIAsgswVqIbQFILQFIbUFILUFILAFILIFEJUUQbCcAiG2BSALILYFaiG3BSC3BSG4BSALKALogwIhuQUguQUQ1Q4hugVBwK4BIbsFIAsguwVqIbwFILwFIb0FIL0FILgFILoFEJUUQdCyASG+BSALIL4FaiG/BSC/BSHABUHIsAEhwQUgCyDBBWohwgUgwgUhwwVBwK4BIcQFIAsgxAVqIcUFIMUFIcYFIMAFIMMFIMYFEPgTQZCUAiHHBSALIMcFaiHIBSDIBSHJBUHQsgEhygUgCyDKBWohywUgywUhzAVBhAIhzQUgyQUgzAUgzQUQ4xoaQbCcAiHOBSALIM4FaiHPBSDPBSHQBUGEAiHRBSDQBSDRBWoh0gUgCygC4IMCIdMFINMFENUOIdQFQbCqASHVBSALINUFaiHWBSDWBSHXBSDXBSDSBSDUBRCVFEGgmAIh2AUgCyDYBWoh2QUg2QUh2gVBhAIh2wUg2gUg2wVqIdwFIAsoAuCDAiHdBSDdBRDUDiHeBUGoqAEh3wUgCyDfBWoh4AUg4AUh4QUg4QUg3AUg3gUQlRRBuKwBIeIFIAsg4gVqIeMFIOMFIeQFQbCqASHlBSALIOUFaiHmBSDmBSHnBUGoqAEh6AUgCyDoBWoh6QUg6QUh6gUg5AUg5wUg6gUQ+BNBkJQCIesFIAsg6wVqIewFIOwFIe0FQYQCIe4FIO0FIO4FaiHvBUG4rAEh8AUgCyDwBWoh8QUg8QUh8gVBhAIh8wUg7wUg8gUg8wUQ4xoaQbCcAiH0BSALIPQFaiH1BSD1BSH2BUGQlAIh9wUgCyD3BWoh+AUg+AUh+QVBhAIh+gUg+QUg+gVqIfsFQZikASH8BSALIPwFaiH9BSD9BSH+BSD+BSD2BSD7BRD3E0GwnAIh/wUgCyD/BWohgAYggAYhgQZBhAIhggYggQYgggZqIYMGQZCUAiGEBiALIIQGaiGFBiCFBiGGBkGQogEhhwYgCyCHBmohiAYgiAYhiQYgiQYggwYghgYQ9xNBoKYBIYoGIAsgigZqIYsGIIsGIYwGQZikASGNBiALII0GaiGOBiCOBiGPBkGQogEhkAYgCyCQBmohkQYgkQYhkgYgjAYgjwYgkgYQ+hNBoJgCIZMGIAsgkwZqIZQGIJQGIZUGQZCUAiGWBiALIJYGaiGXBiCXBiGYBkGEAiGZBiCYBiCZBmohmgZBgJ4BIZsGIAsgmwZqIZwGIJwGIZ0GIJ0GIJUGIJoGEPcTQaCYAiGeBiALIJ4GaiGfBiCfBiGgBkGEAiGhBiCgBiChBmohogZBkJQCIaMGIAsgowZqIaQGIKQGIaUGQfibASGmBiALIKYGaiGnBiCnBiGoBiCoBiCiBiClBhD3E0GIoAEhqQYgCyCpBmohqgYgqgYhqwZBgJ4BIawGIAsgrAZqIa0GIK0GIa4GQfibASGvBiALIK8GaiGwBiCwBiGxBiCrBiCuBiCxBhD6EyALKALYoAIhsgYgsgYQqxIhswZB6JcBIbQGIAsgtAZqIbUGILUGIbYGQdiBAiG3BiALILcGaiG4BiC4BiG5BiC2BiC5BiCzBhCVFEHwmQEhugYgCyC6BmohuwYguwYhvAZBoKYBIb0GIAsgvQZqIb4GIL4GIb8GQeiXASHABiALIMAGaiHBBiDBBiHCBiC8BiC/BiDCBhD4EyALKALYoAIhwwYgwwYQrBIhxAZB2JMBIcUGIAsgxQZqIcYGIMYGIccGQdiBAiHIBiALIMgGaiHJBiDJBiHKBiDHBiDKBiDEBhCVFEHglQEhywYgCyDLBmohzAYgzAYhzQZBiKABIc4GIAsgzgZqIc8GIM8GIdAGQdiTASHRBiALINEGaiHSBiDSBiHTBiDNBiDQBiDTBhD4E0HwmQEh1AYgCyDUBmoh1QYg1QYh1gYg1gYQlBQh1wZBASHYBiDXBiDYBnEh2QYCQCDZBkUNAEHglQEh2gYgCyDaBmoh2wYg2wYh3AYg3AYQlBQh3QZBASHeBiDdBiDeBnEh3wYg3wZFDQBBrBQh4AYgDyDgBmoh4QZB2IECIeIGIAsg4gZqIeMGIOMGIeQGIOEGIOQGEPkTIZsOIAsgmw45A9CTAUGsFCHlBiAPIOUGaiHmBkGgpgEh5wYgCyDnBmoh6AYg6AYh6QYg5gYg6QYQ+RMhnA4gCysD0JMBIZ0OIJwOIJ0OoyGeDiALIJ4OOQPIkwFBrBQh6gYgDyDqBmoh6wZBiKABIewGIAsg7AZqIe0GIO0GIe4GIOsGIO4GEPkTIZ8OIAsrA9CTASGgDiCfDiCgDqMhoQ4gCyChDjkDwJMBIAsrA8iTASGiDiALKwPAkwEhow4gCysDyJMBIaQOQaCTASHvBiALIO8GaiHwBiDwBiHxBiDxBiCiDiCjDiCkDhDbExogCygCyKACIfIGQaCTASHzBiALIPMGaiH0BiD0BiH1BiD1BikDACGIDiDyBiCIDjcDAEEYIfYGIPIGIPYGaiH3BiD1BiD2Bmoh+AYg+AYtAAAh+QYg9wYg+QY6AABBECH6BiDyBiD6Bmoh+wYg9QYg+gZqIfwGIPwGKQMAIYkOIPsGIIkONwMAQQgh/QYg8gYg/QZqIf4GIPUGIP0GaiH/BiD/BikDACGKDiD+BiCKDjcDAAwBCyALKALMoAIhgAdBAiGBByCAByGCByCBByGDByCCByCDB0YhhAdBASGFB0F/IYYHQQEhhwcghAcghwdxIYgHIIUHIIYHIIgHGyGJB0HYgQIhigcgCyCKB2ohiwcgiwchjAcgjAcQsBQhjQdBASGOB0F/IY8HQQEhkAcgjQcgkAdxIZEHII4HII8HIJEHGyGSByCJByCSB2whkwdBmJEBIZQHIAsglAdqIZUHIJUHIZYHIJYHIJMHEJwUGkGwnAIhlwcgCyCXB2ohmAcgmAchmQdBhAIhmgcgmQcgmgdqIZsHQYCLASGcByALIJwHaiGdByCdByGeB0HwmQEhnwcgCyCfB2ohoAcgoAchoQcgngcgoQcQmRRBiI0BIaIHIAsgogdqIaMHIKMHIaQHQYCLASGlByALIKUHaiGmByCmByGnByCkByCbByCnBxD3E0GgmAIhqAcgCyCoB2ohqQcgqQchqgdBhAIhqwcgqgcgqwdqIawHQfCGASGtByALIK0HaiGuByCuByGvB0HglQEhsAcgCyCwB2ohsQcgsQchsgcgrwcgsgcQmRRB+IgBIbMHIAsgswdqIbQHILQHIbUHQfCGASG2ByALILYHaiG3ByC3ByG4ByC1ByCsByC4BxD3E0GQjwEhuQcgCyC5B2ohugcgugchuwdBiI0BIbwHIAsgvAdqIb0HIL0HIb4HQfiIASG/ByALIL8HaiHAByDAByHBByC7ByC+ByDBBxD6E0GAjAIhwgcgCyDCB2ohwwcgwwchxAdBkI8BIcUHIAsgxQdqIcYHIMYHIccHQYQCIcgHIMQHIMcHIMgHEOMaGkGwnAIhyQcgCyDJB2ohygcgygchywdB2IABIcwHIAsgzAdqIc0HIM0HIc4HQfCZASHPByALIM8HaiHQByDQByHRByDOByDRBxCZFEHgggEh0gcgCyDSB2oh0wcg0wch1AdB2IABIdUHIAsg1QdqIdYHINYHIdcHINQHIMsHINcHEPcTQaCYAiHYByALINgHaiHZByDZByHaB0HI/AAh2wcgCyDbB2oh3Acg3Ach3QdB4JUBId4HIAsg3gdqId8HIN8HIeAHIN0HIOAHEJkUQdD+ACHhByALIOEHaiHiByDiByHjB0HI/AAh5AcgCyDkB2oh5Qcg5Qch5gcg4wcg2gcg5gcQ9xNB6IQBIecHIAsg5wdqIegHIOgHIekHQeCCASHqByALIOoHaiHrByDrByHsB0HQ/gAh7QcgCyDtB2oh7gcg7gch7wcg6Qcg7Acg7wcQ+hNBgIwCIfAHIAsg8AdqIfEHIPEHIfIHQYQCIfMHIPIHIPMHaiH0B0HohAEh9QcgCyD1B2oh9gcg9gch9wdBhAIh+Acg9Acg9wcg+AcQ4xoaQYCMAiH5ByALIPkHaiH6ByD6ByH7B0GIBCH8ByD7ByD8B2oh/QdBmJEBIf4HIAsg/gdqIf8HIP8HIYAIQYQCIYEIIP0HIIAIIIEIEOMaGkGAjAIhggggCyCCCGohgwgggwghhAhBjAYhhQgghAgghQhqIYYIQQAhhwgghggghwgQlhQaQbCcAiGICCALIIgIaiGJCCCJCCGKCEGwnAIhiwggCyCLCGohjAggjAghjQhBuPgAIY4IIAsgjghqIY8III8IIZAIIJAIIIoIII0IEPcTQaCYAiGRCCALIJEIaiGSCCCSCCGTCEGgmAIhlAggCyCUCGohlQgglQghlghBsPYAIZcIIAsglwhqIZgIIJgIIZkIIJkIIJMIIJYIEPcTQcD6ACGaCCALIJoIaiGbCCCbCCGcCEG4+AAhnQggCyCdCGohngggngghnwhBsPYAIaAIIAsgoAhqIaEIIKEIIaIIIJwIIJ8IIKIIEPoTQfCDAiGjCCALIKMIaiGkCCCkCCGlCEHA+gAhpgggCyCmCGohpwggpwghqAhBhAIhqQggpQggqAggqQgQ4xoaQbCcAiGqCCALIKoIaiGrCCCrCCGsCEGEAiGtCCCsCCCtCGohrghBsJwCIa8IIAsgrwhqIbAIILAIIbEIQYQCIbIIILEIILIIaiGzCEGg8gAhtAggCyC0CGohtQggtQghtgggtgggrgggswgQ9xNBoJgCIbcIIAsgtwhqIbgIILgIIbkIQYQCIboIILkIILoIaiG7CEGgmAIhvAggCyC8CGohvQggvQghvghBhAIhvwggvgggvwhqIcAIQZjwACHBCCALIMEIaiHCCCDCCCHDCCDDCCC7CCDACBD3E0Go9AAhxAggCyDECGohxQggxQghxghBoPIAIccIIAsgxwhqIcgIIMgIIckIQZjwACHKCCALIMoIaiHLCCDLCCHMCCDGCCDJCCDMCBD6E0HwgwIhzQggCyDNCGohzgggzgghzwhBhAIh0Aggzwgg0AhqIdEIQaj0ACHSCCALINIIaiHTCCDTCCHUCEGEAiHVCCDRCCDUCCDVCBDjGhpBsJwCIdYIIAsg1ghqIdcIINcIIdgIQbCcAiHZCCALINkIaiHaCCDaCCHbCEGEAiHcCCDbCCDcCGoh3QhBiOwAId4IIAsg3ghqId8IIN8IIeAIIOAIINgIIN0IEPcTQaCYAiHhCCALIOEIaiHiCCDiCCHjCEGgmAIh5AggCyDkCGoh5Qgg5Qgh5ghBhAIh5wgg5ggg5whqIegIQYDqACHpCCALIOkIaiHqCCDqCCHrCCDrCCDjCCDoCBD3E0GQ7gAh7AggCyDsCGoh7Qgg7Qgh7ghBiOwAIe8IIAsg7whqIfAIIPAIIfEIQYDqACHyCCALIPIIaiHzCCDzCCH0CCDuCCDxCCD0CBD6E0HwgwIh9QggCyD1CGoh9ggg9ggh9whBiAQh+Agg9wgg+AhqIfkIQZDuACH6CCALIPoIaiH7CCD7CCH8CEGEAiH9CCD5CCD8CCD9CBDjGhpBsJwCIf4IIAsg/ghqIf8IIP8IIYAJQeDhACGBCSALIIEJaiGCCSCCCSGDCUHglQEhhAkgCyCECWohhQkghQkhhgkggwkggAkghgkQ9xNBoJgCIYcJIAsghwlqIYgJIIgJIYkJQdjfACGKCSALIIoJaiGLCSCLCSGMCUHwmQEhjQkgCyCNCWohjgkgjgkhjwkgjAkgiQkgjwkQ9xNB6OMAIZAJIAsgkAlqIZEJIJEJIZIJQeDhACGTCSALIJMJaiGUCSCUCSGVCUHY3wAhlgkgCyCWCWohlwkglwkhmAkgkgkglQkgmAkQ+BNBsJwCIZkJIAsgmQlqIZoJIJoJIZsJQYQCIZwJIJsJIJwJaiGdCUHI2wAhngkgCyCeCWohnwkgnwkhoAlB4JUBIaEJIAsgoQlqIaIJIKIJIaMJIKAJIJ0JIKMJEPcTQaCYAiGkCSALIKQJaiGlCSClCSGmCUGEAiGnCSCmCSCnCWohqAlBwNkAIakJIAsgqQlqIaoJIKoJIasJQfCZASGsCSALIKwJaiGtCSCtCSGuCSCrCSCoCSCuCRD3E0HQ3QAhrwkgCyCvCWohsAkgsAkhsQlByNsAIbIJIAsgsglqIbMJILMJIbQJQcDZACG1CSALILUJaiG2CSC2CSG3CSCxCSC0CSC3CRD4E0Hw5QAhuAkgCyC4CWohuQkguQkhuglB6OMAIbsJIAsguwlqIbwJILwJIb0JQdDdACG+CSALIL4JaiG/CSC/CSHACSC6CSC9CSDACRD3E0H45wAhwQkgCyDBCWohwgkgwgkhwwlB8OUAIcQJIAsgxAlqIcUJIMUJIcYJQX4hxwkgwwkgxgkgxwkQlRRB8IMCIcgJIAsgyAlqIckJIMkJIcoJQYwGIcsJIMoJIMsJaiHMCUH45wAhzQkgCyDNCWohzgkgzgkhzwlBhAIh0AkgzAkgzwkg0AkQ4xoaQawUIdEJIA8g0QlqIdIJQYCMAiHTCSALINMJaiHUCSDUCSHVCUHwgwIh1gkgCyDWCWoh1wkg1wkh2AlBqNkAIdkJIAsg2QlqIdoJINoJIdsJINsJIA8g1Qkg2AkQsRRBqNkAIdwJIAsg3AlqId0JIN0JId4JINIJIN4JEJgUIaUOIAsgpQ45A7hZIAsrA7hZIaYOQawUId8JIA8g3wlqIeAJQdiBAiHhCSALIOEJaiHiCSDiCSHjCSDgCSDjCRD5EyGnDiCmDiCnDqIhqA4gCyCoDjkDoFkgCy0AxqACIeQJQQEh5Qkg5Akg5QlxIeYJAkAg5glFDQBBoJgCIecJIAsg5wlqIegJIOgJIekJQYQCIeoJIOkJIOoJaiHrCUGA0QAh7AkgCyDsCWoh7Qkg7Qkh7glB8JkBIe8JIAsg7wlqIfAJIPAJIfEJIO4JIPEJIPEJEPcTQfjOACHyCSALIPIJaiHzCSDzCSH0CUHglQEh9QkgCyD1CWoh9gkg9gkh9wkg9Akg9wkg9wkQ9xNBiNMAIfgJIAsg+AlqIfkJIPkJIfoJQYDRACH7CSALIPsJaiH8CSD8CSH9CUH4zgAh/gkgCyD+CWoh/wkg/wkhgAog+gkg/QkggAoQ+hNBkNUAIYEKIAsggQpqIYIKIIIKIYMKQYjTACGECiALIIQKaiGFCiCFCiGGCiCDCiDrCSCGChD3E0GwnAIhhwogCyCHCmohiAogiAohiQpBhAIhigogiQogigpqIYsKQeDIACGMCiALIIwKaiGNCiCNCiGOCkHwmQEhjwogCyCPCmohkAogkAohkQogjgogkQogiwoQ9xNBoJgCIZIKIAsgkgpqIZMKIJMKIZQKQYQCIZUKIJQKIJUKaiGWCkHYxgAhlwogCyCXCmohmAogmAohmQpB4JUBIZoKIAsgmgpqIZsKIJsKIZwKIJkKIJwKIJYKEPcTQejKACGdCiALIJ0KaiGeCiCeCiGfCkHgyAAhoAogCyCgCmohoQogoQohogpB2MYAIaMKIAsgowpqIaQKIKQKIaUKIJ8KIKIKIKUKEPoTQfDMACGmCiALIKYKaiGnCiCnCiGoCkGIoAEhqQogCyCpCmohqgogqgohqwpB6MoAIawKIAsgrApqIa0KIK0KIa4KIKgKIKsKIK4KEPcTQZjXACGvCiALIK8KaiGwCiCwCiGxCkGQ1QAhsgogCyCyCmohswogswohtApB8MwAIbUKIAsgtQpqIbYKILYKIbcKILEKILQKILcKEPgTQYCMAiG4CiALILgKaiG5CiC5CiG6CkGY1wAhuwogCyC7CmohvAogvAohvQpBhAIhvgogugogvQogvgoQ4xoaQaCYAiG/CiALIL8KaiHACiDACiHBCkG4PiHCCiALIMIKaiHDCiDDCiHECkHwmQEhxQogCyDFCmohxgogxgohxwogxAogxwogxwoQ9xNBsDwhyAogCyDICmohyQogyQohygpB4JUBIcsKIAsgywpqIcwKIMwKIc0KIMoKIM0KIM0KEPcTQcDAACHOCiALIM4KaiHPCiDPCiHQCkG4PiHRCiALINEKaiHSCiDSCiHTCkGwPCHUCiALINQKaiHVCiDVCiHWCiDQCiDTCiDWChD6E0HIwgAh1wogCyDXCmoh2Aog2Aoh2QpBwMAAIdoKIAsg2gpqIdsKINsKIdwKINkKIMEKINwKEPcTQbCcAiHdCiALIN0KaiHeCiDeCiHfCkGYNiHgCiALIOAKaiHhCiDhCiHiCkHwmQEh4wogCyDjCmoh5Aog5Aoh5Qog4gog5Qog3woQ9xNBoJgCIeYKIAsg5gpqIecKIOcKIegKQZA0IekKIAsg6QpqIeoKIOoKIesKQeCVASHsCiALIOwKaiHtCiDtCiHuCiDrCiDuCiDoChD3E0GgOCHvCiALIO8KaiHwCiDwCiHxCkGYNiHyCiALIPIKaiHzCiDzCiH0CkGQNCH1CiALIPUKaiH2CiD2CiH3CiDxCiD0CiD3ChD6E0GoOiH4CiALIPgKaiH5CiD5CiH6CkGIoAEh+wogCyD7Cmoh/Aog/Aoh/QpBoDgh/gogCyD+Cmoh/wog/wohgAsg+gog/QoggAsQ9xNB0MQAIYELIAsggQtqIYILIIILIYMLQcjCACGECyALIIQLaiGFCyCFCyGGC0GoOiGHCyALIIcLaiGICyCICyGJCyCDCyCGCyCJCxD4E0GAjAIhigsgCyCKC2ohiwsgiwshjAtBhAIhjQsgjAsgjQtqIY4LQdDEACGPCyALII8LaiGQCyCQCyGRC0GEAiGSCyCOCyCRCyCSCxDjGhpBiDIhkwsgCyCTC2ohlAsglAshlQtBiKABIZYLIAsglgtqIZcLIJcLIZgLQZiRASGZCyALIJkLaiGaCyCaCyGbCyCVCyCYCyCbCxD3E0GAjAIhnAsgCyCcC2ohnQsgnQshngtBiAQhnwsgngsgnwtqIaALQYgyIaELIAsgoQtqIaILIKILIaMLQYQCIaQLIKALIKMLIKQLEOMaGkGsFCGlCyAPIKULaiGmC0GAjAIhpwsgCyCnC2ohqAsgqAshqQtB8IMCIaoLIAsgqgtqIasLIKsLIawLQfAxIa0LIAsgrQtqIa4LIK4LIa8LIK8LIA8gqQsgrAsQsRRB8DEhsAsgCyCwC2ohsQsgsQshsgsgpgsgsgsQmBQhqQ4gCyCpDjkDgDIgCygCyKACIbMLIAsrA4AyIaoOIAsrA6BZIasOIKoOIKsOoyGsDiCzCyCsDhD+ExoLIAstAMegAiG0C0EBIbULILQLILULcSG2CwJAILYLDQAgCy0AxaACIbcLQQEhuAsgtwsguAtxIbkLILkLRQ0BC0GwnAIhugsgCyC6C2ohuwsguwshvAtBhAIhvQsgvAsgvQtqIb4LQdApIb8LIAsgvwtqIcALIMALIcELQfCZASHCCyALIMILaiHDCyDDCyHECyDBCyDECyDECxD3E0HIJyHFCyALIMULaiHGCyDGCyHHC0HglQEhyAsgCyDIC2ohyQsgyQshygsgxwsgygsgygsQ9xNB2CshywsgCyDLC2ohzAsgzAshzQtB0CkhzgsgCyDOC2ohzwsgzwsh0AtByCch0QsgCyDRC2oh0gsg0gsh0wsgzQsg0Asg0wsQ+hNB4C0h1AsgCyDUC2oh1Qsg1Qsh1gtB2Csh1wsgCyDXC2oh2Asg2Ash2Qsg1gsgvgsg2QsQ9xNBsJwCIdoLIAsg2gtqIdsLINsLIdwLQYQCId0LINwLIN0LaiHeC0GwISHfCyALIN8LaiHgCyDgCyHhC0HwmQEh4gsgCyDiC2oh4wsg4wsh5Asg4Qsg5Asg3gsQ9xNBoJgCIeULIAsg5QtqIeYLIOYLIecLQYQCIegLIOcLIOgLaiHpC0GoHyHqCyALIOoLaiHrCyDrCyHsC0HglQEh7QsgCyDtC2oh7gsg7gsh7wsg7Asg7wsg6QsQ9xNBuCMh8AsgCyDwC2oh8Qsg8Qsh8gtBsCEh8wsgCyDzC2oh9Asg9Ash9QtBqB8h9gsgCyD2C2oh9wsg9wsh+Asg8gsg9Qsg+AsQ+hNBwCUh+QsgCyD5C2oh+gsg+gsh+wtBoKYBIfwLIAsg/AtqIf0LIP0LIf4LQbgjIf8LIAsg/wtqIYAMIIAMIYEMIPsLIP4LIIEMEPcTQegvIYIMIAsgggxqIYMMIIMMIYQMQeAtIYUMIAsghQxqIYYMIIYMIYcMQcAlIYgMIAsgiAxqIYkMIIkMIYoMIIQMIIcMIIoMEPgTQYCMAiGLDCALIIsMaiGMDCCMDCGNDEHoLyGODCALII4MaiGPDCCPDCGQDEGEAiGRDCCNDCCQDCCRDBDjGhpBsJwCIZIMIAsgkgxqIZMMIJMMIZQMQYgXIZUMIAsglQxqIZYMIJYMIZcMQfCZASGYDCALIJgMaiGZDCCZDCGaDCCXDCCaDCCaDBD3E0GAFSGbDCALIJsMaiGcDCCcDCGdDEHglQEhngwgCyCeDGohnwwgnwwhoAwgnQwgoAwgoAwQ9xNBkBkhoQwgCyChDGohogwgogwhowxBiBchpAwgCyCkDGohpQwgpQwhpgxBgBUhpwwgCyCnDGohqAwgqAwhqQwgowwgpgwgqQwQ+hNBmBshqgwgCyCqDGohqwwgqwwhrAxBkBkhrQwgCyCtDGohrgwgrgwhrwwgrAwglAwgrwwQ9xNBsJwCIbAMIAsgsAxqIbEMILEMIbIMQegOIbMMIAsgswxqIbQMILQMIbUMQfCZASG2DCALILYMaiG3DCC3DCG4DCC1DCC4DCCyDBD3E0GgmAIhuQwgCyC5DGohugwgugwhuwxB4AwhvAwgCyC8DGohvQwgvQwhvgxB4JUBIb8MIAsgvwxqIcAMIMAMIcEMIL4MIMEMILsMEPcTQfAQIcIMIAsgwgxqIcMMIMMMIcQMQegOIcUMIAsgxQxqIcYMIMYMIccMQeAMIcgMIAsgyAxqIckMIMkMIcoMIMQMIMcMIMoMEPoTQfgSIcsMIAsgywxqIcwMIMwMIc0MQaCmASHODCALIM4MaiHPDCDPDCHQDEHwECHRDCALINEMaiHSDCDSDCHTDCDNDCDQDCDTDBD3E0GgHSHUDCALINQMaiHVDCDVDCHWDEGYGyHXDCALINcMaiHYDCDYDCHZDEH4EiHaDCALINoMaiHbDCDbDCHcDCDWDCDZDCDcDBD4E0GAjAIh3QwgCyDdDGoh3gwg3gwh3wxBhAIh4Awg3wwg4AxqIeEMQaAdIeIMIAsg4gxqIeMMIOMMIeQMQYQCIeUMIOEMIOQMIOUMEOMaGkHYCiHmDCALIOYMaiHnDCDnDCHoDEGgpgEh6QwgCyDpDGoh6gwg6gwh6wxBmJEBIewMIAsg7AxqIe0MIO0MIe4MIOgMIOsMIO4MEPcTQYCMAiHvDCALIO8MaiHwDCDwDCHxDEGIBCHyDCDxDCDyDGoh8wxB2Aoh9AwgCyD0DGoh9Qwg9Qwh9gxBhAIh9wwg8wwg9gwg9wwQ4xoaIAstAMegAiH4DEEBIfkMIPgMIPkMcSH6DAJAIPoMRQ0AQawUIfsMIA8g+wxqIfwMQYCMAiH9DCALIP0MaiH+DCD+DCH/DEHwgwIhgA0gCyCADWohgQ0ggQ0hgg1BwAohgw0gCyCDDWohhA0ghA0hhQ0ghQ0gDyD/DCCCDRCxFEHACiGGDSALIIYNaiGHDSCHDSGIDSD8DCCIDRCYFCGtDiALIK0OOQPQCiALKALIoAIhiQ0gCysD0Aohrg4gCysDoFkhrw4grg4grw6jIbAOIIkNILAOEPsTGgsgCy0AxaACIYoNQQEhiw0gig0giw1xIYwNAkAgjA1FDQBBoAIhjQ0gCyCNDWohjg0gjg0hjw1B8JkBIZANIAsgkA1qIZENIJENIZINII8NIJINIJINEPcTQRghkw0gCyCTDWohlA0glA0hlQ1B4JUBIZYNIAsglg1qIZcNIJcNIZgNIJUNIJgNIJgNEPcTQagEIZkNIAsgmQ1qIZoNIJoNIZsNQaACIZwNIAsgnA1qIZ0NIJ0NIZ4NQRghnw0gCyCfDWohoA0goA0hoQ0gmw0gng0goQ0Q+hNBsAYhog0gCyCiDWohow0gow0hpA1B2IECIaUNIAsgpQ1qIaYNIKYNIacNQagEIagNIAsgqA1qIakNIKkNIaoNIKQNIKcNIKoNEPcTQbjZACGrDSALIKsNaiGsDSCsDSGtDSCtDRCXESGuDUF/Ia8NQQEhsA1BASGxDSCuDSCxDXEhsg0grw0gsA0gsg0bIbMNQbgIIbQNIAsgtA1qIbUNILUNIbYNQbAGIbcNIAsgtw1qIbgNILgNIbkNILYNILkNILMNEJUUQYCMAiG6DSALILoNaiG7DSC7DSG8DUGMBiG9DSC8DSC9DWohvg1BuAghvw0gCyC/DWohwA0gwA0hwQ1BhAIhwg0gvg0gwQ0gwg0Q4xoaQawUIcMNIA8gww1qIcQNQYCMAiHFDSALIMUNaiHGDSDGDSHHDUHwgwIhyA0gCyDIDWohyQ0gyQ0hyg0gCyHLDSDLDSAPIMcNIMoNELEUIAshzA0gxA0gzA0QmBQhsQ4gCyCxDjkDECALKALIoAIhzQ0gCysDECGyDiALKwOgWSGzDiCyDiCzDqMhtA4gzQ0gtA4Q/RMaCwtB4KACIc4NIAsgzg1qIc8NIM8NJAAPC8MCAS1/IwAhA0HwACEEIAMgBGshBSAFJAAgBSABNgJsIAUgAjYCaCAFKAJsIQZByAAhByAFIAdqIQggCCEJIAkgBhDnEyAFKAJoIQpBOCELIAUgC2ohDCAMIQ0gDSAKEOcTQdgAIQ4gBSAOaiEPIA8hEEHIACERIAUgEWohEiASIRNBOCEUIAUgFGohFSAVIRYgECATIBYQ4xMgBSgCbCEXQRghGCAFIBhqIRkgGSEaIBogFxDoEyAFKAJoIRtBCCEcIAUgHGohHSAdIR4gHiAbEOgTQSghHyAFIB9qISAgICEhQRghIiAFICJqISMgIyEkQQghJSAFICVqISYgJiEnICEgJCAnEOMTQdgAISggBSAoaiEpICkhKkEoISsgBSAraiEsICwhLSAAICogLRCRFBpB8AAhLiAFIC5qIS8gLyQADwuMLAPeBH8nfg18IwAhCEHgwAAhCSAIIAlrIQogCiQAIAogADYC3EAgCiABNgLYQCAKIAI2AtRAIAogAzYC0EAgCiAENgLMQCAFIQsgCiALOgDLQCAGIQwgCiAMOgDKQCAHIQ0gCiANOgDJQCAKKALcQCEOQbA6IQ8gCiAPaiEQIBAhEUGMBiESIBEgEmohEyARIRQDQCAUIRUgFRDNDhpBhAIhFiAVIBZqIRcgFyEYIBMhGSAYIBlGIRpBASEbIBogG3EhHCAXIRQgHEUNAAtBoDQhHSAKIB1qIR4gHiEfQYwGISAgHyAgaiEhIB8hIgNAICIhIyAjEM0OGkGEAiEkICMgJGohJSAlISYgISEnICYgJ0YhKEEBISkgKCApcSEqICUhIiAqRQ0AC0GQLiErIAogK2ohLCAsIS1BjAYhLiAtIC5qIS8gLSEwA0AgMCExIDEQzQ4aQYQCITIgMSAyaiEzIDMhNCAvITUgNCA1RiE2QQEhNyA2IDdxITggMyEwIDhFDQALQYAmITkgCiA5aiE6IDohO0GQCCE8IDsgPGohPSA7IT4DQCA+IT8gPxDNDhpBhAIhQCA/IEBqIUEgQSFCID0hQyBCIENGIURBASFFIEQgRXEhRiBBIT4gRkUNAAtB8B0hRyAKIEdqIUggSCFJQZAIIUogSSBKaiFLIEkhTANAIEwhTSBNEM0OGkGEAiFOIE0gTmohTyBPIVAgSyFRIFAgUUYhUkEBIVMgUiBTcSFUIE8hTCBURQ0ACyAKKALYQCFVIFUQ3hMhViBWIVcgV6wh5gQgCigC2EAhWCBYEMYPIVkgWSFaIFqsIecEIOYEIOcEfSHoBEGwOiFbIAogW2ohXCBcIV0gXSDoBBD2ExogCigC1EAhXiBeEN4TIV8gXyFgIGCsIekEIAooAtRAIWEgYRDGDyFiIGIhYyBjrCHqBCDpBCDqBH0h6wRBsDohZCAKIGRqIWUgZSFmQYQCIWcgZiBnaiFoIGgg6wQQ9hMaIAooAtBAIWkgaRDeEyFqIGohayBrrCHsBCAKKALQQCFsIGwQxg8hbSBtIW4gbqwh7QQg7AQg7QR9Ie4EQbA6IW8gCiBvaiFwIHAhcUGIBCFyIHEgcmohcyBzIO4EEPYTGiAKKALYQCF0IHQQpxIhdSB1IXYgdqwh7wQgCigC2EAhdyB3EJIRIXggeCF5IHmsIfAEIO8EIPAEfSHxBEGgNCF6IAogemoheyB7IXwgfCDxBBD2ExogCigC1EAhfSB9EKcSIX4gfiF/IH+sIfIEIAooAtRAIYABIIABEJIRIYEBIIEBIYIBIIIBrCHzBCDyBCDzBH0h9ARBoDQhgwEgCiCDAWohhAEghAEhhQFBhAIhhgEghQEghgFqIYcBIIcBIPQEEPYTGiAKKALQQCGIASCIARCnEiGJASCJASGKASCKAawh9QQgCigC0EAhiwEgiwEQkhEhjAEgjAEhjQEgjQGsIfYEIPUEIPYEfSH3BEGgNCGOASAKII4BaiGPASCPASGQAUGIBCGRASCQASCRAWohkgEgkgEg9wQQ9hMaIAooAthAIZMBIJMBEMYPIZQBIJQBIZUBIJUBrCH4BCAKKALYQCGWASCWARCnEiGXASCXASGYASCYAawh+QQg+AQg+QR+IfoEIAooAthAIZkBIJkBEJIRIZoBIJoBIZsBIJsBrCH7BCAKKALYQCGcASCcARDeEyGdASCdASGeASCeAawh/AQg+wQg/AR+If0EIPoEIP0EfSH+BEGQLiGfASAKIJ8BaiGgASCgASGhASChASD+BBD2ExogCigC1EAhogEgogEQxg8howEgowEhpAEgpAGsIf8EIAooAtRAIaUBIKUBEKcSIaYBIKYBIacBIKcBrCGABSD/BCCABX4hgQUgCigC1EAhqAEgqAEQkhEhqQEgqQEhqgEgqgGsIYIFIAooAtRAIasBIKsBEN4TIawBIKwBIa0BIK0BrCGDBSCCBSCDBX4hhAUggQUghAV9IYUFQZAuIa4BIAogrgFqIa8BIK8BIbABQYQCIbEBILABILEBaiGyASCyASCFBRD2ExogCigC0EAhswEgswEQxg8htAEgtAEhtQEgtQGsIYYFIAooAtBAIbYBILYBEKcSIbcBILcBIbgBILgBrCGHBSCGBSCHBX4hiAUgCigC0EAhuQEguQEQkhEhugEgugEhuwEguwGsIYkFIAooAtBAIbwBILwBEN4TIb0BIL0BIb4BIL4BrCGKBSCJBSCKBX4hiwUgiAUgiwV9IYwFQZAuIb8BIAogvwFqIcABIMABIcEBQYgEIcIBIMEBIMIBaiHDASDDASCMBRD2ExpBACHEASAKIMQBNgLsHQJAA0AgCigC7B0hxQFBAyHGASDFASHHASDGASHIASDHASDIAUghyQFBASHKASDJASDKAXEhywEgywFFDQEgCigC7B0hzAFBsDohzQEgCiDNAWohzgEgzgEhzwFBhAIh0AEgzAEg0AFsIdEBIM8BINEBaiHSASAKKALsHSHTAUGwOiHUASAKINQBaiHVASDVASHWAUGEAiHXASDTASDXAWwh2AEg1gEg2AFqIdkBQeAZIdoBIAog2gFqIdsBINsBIdwBINwBINIBINkBEPcTIAooAuwdId0BQaA0Id4BIAog3gFqId8BIN8BIeABQYQCIeEBIN0BIOEBbCHiASDgASDiAWoh4wEgCigC7B0h5AFBoDQh5QEgCiDlAWoh5gEg5gEh5wFBhAIh6AEg5AEg6AFsIekBIOcBIOkBaiHqAUHYFyHrASAKIOsBaiHsASDsASHtASDtASDjASDqARD3E0HoGyHuASAKIO4BaiHvASDvASHwAUHgGSHxASAKIPEBaiHyASDyASHzAUHYFyH0ASAKIPQBaiH1ASD1ASH2ASDwASDzASD2ARD6EyAKKALsHSH3AUHwHSH4ASAKIPgBaiH5ASD5ASH6AUGEAiH7ASD3ASD7AWwh/AEg+gEg/AFqIf0BQegbIf4BIAog/gFqIf8BIP8BIYACQYQCIYECIP0BIIACIIECEOMaGiAKKALsHSGCAkEBIYMCIIICIIMCaiGEAiAKIIQCNgLsHQwACwALQQAhhQIgCiCFAjYC1BcCQANAIAooAtQXIYYCQQMhhwIghgIhiAIghwIhiQIgiAIgiQJIIYoCQQEhiwIgigIgiwJxIYwCIIwCRQ0BIAooAtQXIY0CQQEhjgIgjQIgjgJqIY8CQQMhkAIgjwIgkAJvIZECIAogkQI2AtAXIAooAtQXIZICQQIhkwIgkgIgkwJqIZQCQQMhlQIglAIglQJvIZYCIAoglgI2AswXIAooAtAXIZcCQbA6IZgCIAogmAJqIZkCIJkCIZoCQYQCIZsCIJcCIJsCbCGcAiCaAiCcAmohnQIgCigCzBchngJBoDQhnwIgCiCfAmohoAIgoAIhoQJBhAIhogIgngIgogJsIaMCIKECIKMCaiGkAkHAEyGlAiAKIKUCaiGmAiCmAiGnAiCnAiCdAiCkAhD3EyAKKALMFyGoAkGwOiGpAiAKIKkCaiGqAiCqAiGrAkGEAiGsAiCoAiCsAmwhrQIgqwIgrQJqIa4CIAooAtAXIa8CQaA0IbACIAogsAJqIbECILECIbICQYQCIbMCIK8CILMCbCG0AiCyAiC0AmohtQJBuBEhtgIgCiC2AmohtwIgtwIhuAIguAIgrgIgtQIQ9xNByBUhuQIgCiC5AmohugIgugIhuwJBwBMhvAIgCiC8AmohvQIgvQIhvgJBuBEhvwIgCiC/AmohwAIgwAIhwQIguwIgvgIgwQIQ+BMgCigC1BchwgJBgCYhwwIgCiDDAmohxAIgxAIhxQJBhAIhxgIgwgIgxgJsIccCIMUCIMcCaiHIAkHIFSHJAiAKIMkCaiHKAiDKAiHLAkGEAiHMAiDIAiDLAiDMAhDjGhogCigC1BchzQJBASHOAiDNAiDOAmohzwIgCiDPAjYC1BcMAAsAC0GsFCHQAiAOINACaiHRAkGAJiHSAiAKINICaiHTAiDTAiHUAkHwHSHVAiAKINUCaiHWAiDWAiHXAkGgESHYAiAKINgCaiHZAiDZAiHaAiDaAiAOINQCINcCEKYUQaARIdsCIAog2wJqIdwCINwCId0CINECIN0CEJgUIY0FIAogjQU5A7ARIAotAMpAId4CQQEh3wIg3gIg3wJxIeACAkAg4AJFDQBBACHhAiAKIOECNgKcEQJAA0AgCigCnBEh4gJBAyHjAiDiAiHkAiDjAiHlAiDkAiDlAkgh5gJBASHnAiDmAiDnAnEh6AIg6AJFDQEgCigCnBEh6QJBASHqAiDpAiDqAmoh6wJBAyHsAiDrAiDsAm8h7QIgCiDtAjYCmBEgCigCnBEh7gJBAiHvAiDuAiDvAmoh8AJBAyHxAiDwAiDxAm8h8gIgCiDyAjYClBEgCigCmBEh8wJBoDQh9AIgCiD0Amoh9QIg9QIh9gJBhAIh9wIg8wIg9wJsIfgCIPYCIPgCaiH5AiAKKAKUESH6AkGQLiH7AiAKIPsCaiH8AiD8AiH9AkGEAiH+AiD6AiD+Amwh/wIg/QIg/wJqIYADQYgNIYEDIAoggQNqIYIDIIIDIYMDIIMDIPkCIIADEPcTIAooApQRIYQDQaA0IYUDIAoghQNqIYYDIIYDIYcDQYQCIYgDIIQDIIgDbCGJAyCHAyCJA2ohigMgCigCmBEhiwNBkC4hjAMgCiCMA2ohjQMgjQMhjgNBhAIhjwMgiwMgjwNsIZADII4DIJADaiGRA0GACyGSAyAKIJIDaiGTAyCTAyGUAyCUAyCKAyCRAxD3E0GQDyGVAyAKIJUDaiGWAyCWAyGXA0GIDSGYAyAKIJgDaiGZAyCZAyGaA0GACyGbAyAKIJsDaiGcAyCcAyGdAyCXAyCaAyCdAxD4EyAKKAKcESGeA0GAJiGfAyAKIJ8DaiGgAyCgAyGhA0GEAiGiAyCeAyCiA2whowMgoQMgowNqIaQDQZAPIaUDIAogpQNqIaYDIKYDIacDQYQCIagDIKQDIKcDIKgDEOMaGiAKKAKcESGpA0EBIaoDIKkDIKoDaiGrAyAKIKsDNgKcEQwACwALQawUIawDIA4grANqIa0DQYAmIa4DIAogrgNqIa8DIK8DIbADQfAdIbEDIAogsQNqIbIDILIDIbMDQegKIbQDIAogtANqIbUDILUDIbYDILYDIA4gsAMgswMQphRB6AohtwMgCiC3A2ohuAMguAMhuQMgrQMguQMQmBQhjgUgCiCOBTkD+AogCigCzEAhugMgCisD+AohjwUgCisDsBEhkAUgjwUgkAWjIZEFILoDIJEFEP4TGgsgCi0Ay0AhuwNBASG8AyC7AyC8A3EhvQMCQAJAIL0DDQAgCi0AyUAhvgNBASG/AyC+AyC/A3EhwAMgwANFDQELQYAmIcEDIAogwQNqIcIDIMIDIcMDQYwGIcQDIMMDIMQDaiHFA0EAIcYDIMUDIMYDEJYUGkEAIccDIAogxwM2AuQKAkADQCAKKALkCiHIA0EDIckDIMgDIcoDIMkDIcsDIMoDIMsDSCHMA0EBIc0DIMwDIM0DcSHOAyDOA0UNASAKKALkCiHPA0EBIdADIM8DINADaiHRA0EDIdIDINEDINIDbyHTAyAKINMDNgLgCiAKKALkCiHUA0ECIdUDINQDINUDaiHWA0EDIdcDINYDINcDbyHYAyAKINgDNgLcCiAKKALgCiHZA0GwOiHaAyAKINoDaiHbAyDbAyHcA0GEAiHdAyDZAyDdA2wh3gMg3AMg3gNqId8DIAooAtwKIeADQZAuIeEDIAog4QNqIeIDIOIDIeMDQYQCIeQDIOADIOQDbCHlAyDjAyDlA2oh5gNB0AYh5wMgCiDnA2oh6AMg6AMh6QMg6QMg3wMg5gMQ9xMgCigC3Aoh6gNBsDoh6wMgCiDrA2oh7AMg7AMh7QNBhAIh7gMg6gMg7gNsIe8DIO0DIO8DaiHwAyAKKALgCiHxA0GQLiHyAyAKIPIDaiHzAyDzAyH0A0GEAiH1AyDxAyD1A2wh9gMg9AMg9gNqIfcDQcgEIfgDIAog+ANqIfkDIPkDIfoDIPoDIPADIPcDEPcTQdgIIfsDIAog+wNqIfwDIPwDIf0DQdAGIf4DIAog/gNqIf8DIP8DIYAEQcgEIYEEIAoggQRqIYIEIIIEIYMEIP0DIIAEIIMEEPgTIAooAuQKIYQEQYAmIYUEIAoghQRqIYYEIIYEIYcEQYQCIYgEIIQEIIgEbCGJBCCHBCCJBGohigRB2AghiwQgCiCLBGohjAQgjAQhjQRBhAIhjgQgigQgjQQgjgQQ4xoaIAotAMlAIY8EQQEhkAQgjwQgkARxIZEEAkAgkQRFDQBBgCYhkgQgCiCSBGohkwQgkwQhlARBjAYhlQQglAQglQRqIZYEIAooAuQKIZcEQYAmIZgEIAogmARqIZkEIJkEIZoEQYQCIZsEIJcEIJsEbCGcBCCaBCCcBGohnQQgCigC5AohngRBoDQhnwQgCiCfBGohoAQgoAQhoQRBhAIhogQgngQgogRsIaMEIKEEIKMEaiGkBEE4IaUEIAogpQRqIaYEIKYEIacEIKcEIJ0EIKQEEPcTQcACIagEIAogqARqIakEIKkEIaoEQTghqwQgCiCrBGohrAQgrAQhrQQgqgQglgQgrQQQ+hNBgCYhrgQgCiCuBGohrwQgrwQhsARBjAYhsQQgsAQgsQRqIbIEQcACIbMEIAogswRqIbQEILQEIbUEQYQCIbYEILIEILUEILYEEOMaGgsgCigC5AohtwRBASG4BCC3BCC4BGohuQQgCiC5BDYC5AoMAAsACyAKLQDLQCG6BEEBIbsEILoEILsEcSG8BAJAILwERQ0AQawUIb0EIA4gvQRqIb4EQYAmIb8EIAogvwRqIcAEIMAEIcEEQfAdIcIEIAogwgRqIcMEIMMEIcQEQSAhxQQgCiDFBGohxgQgxgQhxwQgxwQgDiDBBCDEBBCmFEEgIcgEIAogyARqIckEIMkEIcoEIL4EIMoEEJgUIZIFIAogkgU5AzAgCigCzEAhywQgCisDMCGTBSAKKwOwESGUBSCTBSCUBaMhlQUgywQglQUQ+xMaCyAKLQDJQCHMBEEBIc0EIMwEIM0EcSHOBAJAIM4ERQ0AQfAdIc8EIAogzwRqIdAEINAEIdEEQYwGIdIEINEEINIEaiHTBEEBIdQEINMEINQEEJYUGkGsFCHVBCAOINUEaiHWBEGAJiHXBCAKINcEaiHYBCDYBCHZBEHwHSHaBCAKINoEaiHbBCDbBCHcBEEIId0EIAog3QRqId4EIN4EId8EIN8EIA4g2QQg3AQQmhRBCCHgBCAKIOAEaiHhBCDhBCHiBCDWBCDiBBCYFCGWBSAKIJYFOQMYIAooAsxAIeMEIAorAxghlwUgCisDsBEhmAUglwUgmAWjIZkFIOMEIJkFEP0TGgsLQeDAACHkBCAKIOQEaiHlBCDlBCQADwstAgR/AXwjACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKwMIIQUgBQ8L3AMCI38VfCMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBSsDACElIAQoAhghBiAGKwMAISYgJSAmoSEnIAQgJzkDECAFEJcRIQdBASEIIAcgCHEhCQJAAkACQAJAIAkNACAEKAIYIQogChCAFCELQQEhDCALIAxxIQ0gDUUNAQsgBRCAFCEOQQEhDyAOIA9xIRAgEA0BIAQoAhghESAREJcRIRJBASETIBIgE3EhFCAUDQELQQghFSAFIBVqIRYgBCgCGCEXQQghGCAXIBhqIRkgFiAZEIEUIRogGisDACEoRAAAAAAAAPA/ISkgKCApoCEqIAUgKjkDCAwBCyAFKwMAISsgBSsDCCEsICsgLKIhLSAEKAIYIRsgGysDACEuIAQoAhghHCAcKwMIIS8gLiAvoiEwIC0gMKAhMSAEKwMQITIgMSAyoyEzIAQgMzkDCEEIIR0gBCAdaiEeIB4hHyAfEJcRISBBASEhICAgIXEhIgJAICJFDQAgBCsDCCE0IDSaITUgBCA1OQMICyAEKwMIITZEAAAAAAAA8D8hNyA2IDegITggBSA4OQMICyAEKwMQITkgBSA5OQMAQSAhIyAEICNqISQgJCQAIAUPC9gCAhd/E34jACECQRAhAyACIANrIQQgBCAANgIMIAQgATcDACAEKAIMIQUgBCkDACEZQgAhGiAZIRsgGiEcIBsgHFUhBkEBIQcgBiAHcSEIAkACQCAIRQ0AIAQpAwAhHSAdpyEJIAUgCTYCACAEKQMAIR5CICEfIB4gH4chICAgpyEKIAUgCjYCBCAFKAIEIQtBAiEMQQEhDSAMIA0gCxshDiAFIA42AoACDAELIAQpAwAhIUIAISIgISEjICIhJCAjICRTIQ9BASEQIA8gEHEhEQJAAkAgEUUNACAEKQMAISVCACEmICYgJX0hJyAEICc3AwAgBCkDACEoICinIRIgBSASNgIAIAQpAwAhKUIgISogKSAqhyErICunIRMgBSATNgIEIAUoAgQhFEF+IRVBfyEWIBUgFiAUGyEXIAUgFzYCgAIMAQtBACEYIAUgGDYCgAILCyAFDwtSAQd/IwAhA0EQIQQgAyAEayEFIAUkACAFIAE2AgwgBSACNgIIIAUoAgwhBiAAEM0OGiAFKAIIIQcgACAGIAcQhRRBECEIIAUgCGohCSAJJAAPC1IBB38jACEDQRAhBCADIARrIQUgBSQAIAUgATYCDCAFIAI2AgggBSgCDCEGIAAQzQ4aIAUoAgghByAAIAYgBxCGFEEQIQggBSAIaiEJIAkkAA8LRwIGfwF8IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgghBSAFEIQUIQhBECEGIAQgBmohByAHJAAgCA8LUgEHfyMAIQNBECEEIAMgBGshBSAFJAAgBSABNgIMIAUgAjYCCCAFKAIMIQYgABDNDhogBSgCCCEHIAAgBiAHEIcUQRAhCCAFIAhqIQkgCSQADws7AgR/AXwjACECQRAhAyACIANrIQQgBCAANgIMIAQgATkDACAEKAIMIQUgBCsDACEGIAUgBjkDACAFDwstAgR/AXwjACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKwMAIQUgBQ8LOwIEfwF8IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE5AwAgBCgCDCEFIAQrAwAhBiAFIAY5AxAgBQ8LOwIEfwF8IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE5AwAgBCgCDCEFIAQrAwAhBiAFIAY5AwggBQ8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEJcRIQVBASEGIAUgBnEhB0EQIQggAyAIaiEJIAkkACAHDwtIAgh/AnwjACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKwMAIQlBACEFIAW3IQogCSAKZCEGQQEhByAGIAdxIQggCA8LTgEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhCCFCEHQRAhCCAEIAhqIQkgCSQAIAcPC5EBARF/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgQhBSAEKAIAIQZBCCEHIAQgB2ohCCAIIQkgCSAFIAYQgxQhCkEBIQsgCiALcSEMAkACQCAMRQ0AIAQoAgAhDSANIQ4MAQsgBCgCBCEPIA8hDgsgDiEQQRAhESAEIBFqIRIgEiQAIBAPC1sCCH8CfCMAIQNBECEEIAMgBGshBSAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBisDACELIAUoAgQhByAHKwMAIQwgCyAMYyEIQQEhCSAIIAlxIQogCg8LZgIKfwJ8IwAhAUEgIQIgASACayEDIAMkACADIAA2AhwgAygCHCEEQQghBSADIAVqIQYgBiEHIAcgBBCIFCADKwMIIQsgAygCECEIIAsgCBCZGiEMQSAhCSADIAlqIQogCiQAIAwPC8MCASd/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQixQhCAJAAkACQCAIRQ0AIAUoAgQhCSAJEIsUIQogCg0BC0EAIQsgBiALNgKAAgwBCyAFKAIIIQwgDBCMFCENIAUoAgghDiAOEIoUIQ8gBSgCBCEQIBAQjBQhESAFKAIEIRIgEhCKFCETIAYgDSAPIBEgExCNFCAFKAIIIRQgFBCLFCEVQQAhFiAVIRcgFiEYIBcgGEohGUEBIRogGSAacSEbIAUoAgQhHCAcEIsUIR1BACEeIB0hHyAeISAgHyAgSiEhQQEhIiAhICJxISMgGyAjcyEkICRFDQAgBigCgAIhJUEAISYgJiAlayEnIAYgJzYCgAILQRAhKCAFIChqISkgKSQADwuOBAFAfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHEIsUIQgCQAJAIAgNACAFKAIEIQlBhAIhCiAGIAkgChDjGhogBigCgAIhC0EAIQwgDCALayENIAYgDTYCgAIMAQsgBSgCBCEOIA4QixQhDwJAIA8NACAFKAIIIRBBhAIhESAGIBAgERDjGhoMAQsgBSgCCCESIBIQixQhE0EAIRQgEyEVIBQhFiAVIBZKIRdBASEYIBcgGHEhGSAFKAIEIRogGhCLFCEbQQAhHCAbIR0gHCEeIB0gHkohH0EBISAgHyAgcSEhIBkgIXMhIgJAAkAgIkUNACAFKAIIISMgIxCMFCEkIAUoAgghJSAlEIoUISYgBSgCBCEnICcQjBQhKCAFKAIEISkgKRCKFCEqIAYgJCAmICggKhCOFAwBCyAFKAIIISsgKxCMFCEsIAUoAgghLSAtEIoUIS4gBSgCBCEvIC8QjBQhMCAFKAIEITEgMRCKFCEyQQAhM0EBITQgMyA0cSE1IAYgLCAuIDAgMiA1EI8UCyAFKAIIITYgNhCLFCE3QQAhOCA3ITkgOCE6IDkgOkghO0EBITwgOyA8cSE9ID1FDQAgBigCgAIhPkEAIT8gPyA+ayFAIAYgQDYCgAILQRAhQSAFIEFqIUIgQiQADwvzAwE9fyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHEIsUIQgCQAJAIAgNACAFKAIEIQlBhAIhCiAGIAkgChDjGhoMAQsgBSgCBCELIAsQixQhDAJAIAwNACAFKAIIIQ1BhAIhDiAGIA0gDhDjGhoMAQsgBSgCCCEPIA8QixQhEEEAIREgECESIBEhEyASIBNKIRRBASEVIBQgFXEhFiAFKAIEIRcgFxCLFCEYQQAhGSAYIRogGSEbIBogG0ohHEEBIR0gHCAdcSEeIBYgHnMhHwJAAkAgH0UNACAFKAIIISAgIBCMFCEhIAUoAgghIiAiEIoUISMgBSgCBCEkICQQjBQhJSAFKAIEISYgJhCKFCEnQQAhKEEBISkgKCApcSEqIAYgISAjICUgJyAqEI8UDAELIAUoAgghKyArEIwUISwgBSgCCCEtIC0QihQhLiAFKAIEIS8gLxCMFCEwIAUoAgQhMSAxEIoUITIgBiAsIC4gMCAyEI4UCyAFKAIIITMgMxCLFCE0QQAhNSA0ITYgNSE3IDYgN0ghOEEBITkgOCA5cSE6IDpFDQAgBigCgAIhO0EAITwgPCA7ayE9IAYgPTYCgAILQRAhPiAFID5qIT8gPyQADwvpBAI/fw58IwAhAkEgIQMgAiADayEEIAQkACAEIAE2AhwgBCgCHCEFQQAhBiAEIAY2AhhBACEHIAQgBzYCFEEYIQggBCAIaiEJIAkhCkEUIQsgBCALaiEMIAwhDSAAIAogDRCJFBogBRCKFCEOIAQgDjYCECAEKAIQIQ8CQAJAIA8NAAwBCyAEKAIQIRBBASERIBAhEiARIRMgEiATRiEUQQEhFSAUIBVxIRYCQAJAIBZFDQAgBSgCACEXIBe4IUEgACBBOQMADAELIAQoAhAhGEECIRkgGCEaIBkhGyAaIBtGIRxBASEdIBwgHXEhHgJAAkAgHkUNACAFKAIEIR8gH7ghQkQAAAAAAADwQSFDIEIgQ6IhRCAFKAIAISAgILghRSBEIEWgIUYgACBGOQMADAELQQEhISAEICE2AgwCQANAIAQoAgwhIkEDISMgIiEkICMhJSAkICVNISZBASEnICYgJ3EhKCAoRQ0BIAArAwAhR0QAAAAAAADwQSFIIEcgSKIhSSAAIEk5AwAgBCgCECEpIAQoAgwhKiApICprIStBAiEsICsgLHQhLSAFIC1qIS4gLigCACEvIC+4IUogACsDACFLIEsgSqAhTCAAIEw5AwAgBCgCDCEwQQEhMSAwIDFqITIgBCAyNgIMDAALAAsgBCgCECEzQQMhNCAzIDRrITVBBSE2IDUgNnQhNyAAIDc2AggLCyAFKAKAAiE4QQAhOSA4ITogOSE7IDogO0ghPEEBIT0gPCA9cSE+AkAgPkUNACAAKwMAIU0gTZohTiAAIE45AwALC0EgIT8gBCA/aiFAIEAkAA8LhAECDH8BfCMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHEPYDIQggCCgCACEJIAm3IQ8gBiAPOQMAIAUoAgQhCiAKEPYDIQsgCygCACEMIAYgDDYCCEEQIQ0gBSANaiEOIA4kACAGDwtGAQh/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQoAoACIQUgBRCkGiEGQRAhByADIAdqIQggCCQAIAYPCywBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAKAAiEFIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwu+BwJifxl+IwAhBUHQACEGIAUgBmshByAHJAAgByAANgJMIAcgATYCSCAHIAI2AkQgByADNgJAIAcgBDYCPCAHKAJMIQhCACFnIAcgZzcDMEHAACEJIAcgCTYCHCAHKAJEIQogBygCPCELIAogC2ohDEEBIQ0gDCANayEOIAcgDjYCGEEcIQ8gByAPaiEQIBAhEUEYIRIgByASaiETIBMhFCARIBQQdSEVIBUoAgAhFiAIIBY2AoACQQAhFyAHIBc2AhQCQANAIAcoAhQhGCAIKAKAAiEZIBghGiAZIRsgGiAbSSEcQQEhHSAcIB1xIR4gHkUNAUIAIWggByBoNwMoQQAhHyAHIB82AhACQANAIAcoAhAhICAHKAIUISEgICEiICEhIyAiICNNISRBASElICQgJXEhJiAmRQ0BIAcoAhAhJyAHKAJEISggJyEpICghKiApICpPIStBASEsICsgLHEhLQJAIC1FDQAMAgsgBygCFCEuIAcoAhAhLyAuIC9rITAgByAwNgIMIAcoAgwhMSAHKAI8ITIgMSEzIDIhNCAzIDRPITVBASE2IDUgNnEhNwJAAkAgN0UNAAwBCyAHKAJIITggBygCECE5QQIhOiA5IDp0ITsgOCA7aiE8IDwoAgAhPSA9IT4gPq0haSAHKAJAIT8gBygCDCFAQQIhQSBAIEF0IUIgPyBCaiFDIEMoAgAhRCBEIUUgRa0haiBpIGp+IWsgByBrNwMgIAcpAyAhbCBspyFGIEYhRyBHrSFtIAcpAzAhbiBuIG18IW8gByBvNwMwIAcpAyAhcEIgIXEgcCBxiCFyIAcpAyghcyBzIHJ8IXQgByB0NwMoCyAHKAIQIUhBASFJIEggSWohSiAHIEo2AhAMAAsACyAHKQMwIXUgdachSyAHKAIUIUxBAiFNIEwgTXQhTiAIIE5qIU8gTyBLNgIAIAcpAyghdiAHKQMwIXdCICF4IHcgeIgheSB2IHl8IXogByB6NwMwIAcoAhQhUEEBIVEgUCBRaiFSIAcgUjYCFAwACwALIAcpAzAhe0IAIXwgeyF9IHwhfiB9IH5SIVNBASFUIFMgVHEhVQJAIFVFDQAgCCgCgAIhVkHAACFXIFYhWCBXIVkgWCBZRyFaQQEhWyBaIFtxIVwgXEUNACAHKQMwIX8gf6chXSAIKAKAAiFeQQIhXyBeIF90IWAgCCBgaiFhIGEgXTYCACAIKAKAAiFiQQEhYyBiIGNqIWQgCCBkNgKAAgtB0AAhZSAHIGVqIWYgZiQADwvrBgJZfxZ+IwAhBUEwIQYgBSAGayEHIAckACAHIAA2AiwgByABNgIoIAcgAjYCJCAHIAM2AiAgByAENgIcIAcoAiwhCCAHKAIkIQkgBygCHCEKIAkhCyAKIQwgCyAMSSENQQEhDiANIA5xIQ8CQAJAIA9FDQAgBygCICEQIAcoAhwhESAHKAIoIRIgBygCJCETIAggECARIBIgExCOFAwBCyAHKAIkIRQgCCAUNgKAAkIAIV4gByBeNwMQQQAhFSAHIBU2AgwCQANAIAcoAgwhFiAHKAIcIRcgFiEYIBchGSAYIBlJIRpBASEbIBogG3EhHCAcRQ0BIAcoAighHSAHKAIMIR5BAiEfIB4gH3QhICAdICBqISEgISgCACEiICIhIyAjrSFfIAcoAiAhJCAHKAIMISVBAiEmICUgJnQhJyAkICdqISggKCgCACEpICkhKiAqrSFgIF8gYHwhYSAHKQMQIWIgYiBhfCFjIAcgYzcDECAHKQMQIWQgZKchKyAHKAIMISxBAiEtICwgLXQhLiAIIC5qIS8gLyArNgIAIAcpAxAhZUIgIWYgZSBmiCFnIAcgZzcDECAHKAIMITBBASExIDAgMWohMiAHIDI2AgwMAAsACyAHKAIcITMgByAzNgIIAkADQCAHKAIIITQgBygCJCE1IDQhNiA1ITcgNiA3SSE4QQEhOSA4IDlxITogOkUNASAHKAIoITsgBygCCCE8QQIhPSA8ID10IT4gOyA+aiE/ID8oAgAhQCBAIUEgQa0haCAHKQMQIWkgaSBofCFqIAcgajcDECAHKQMQIWsga6chQiAHKAIIIUNBAiFEIEMgRHQhRSAIIEVqIUYgRiBCNgIAIAcpAxAhbEIgIW0gbCBtiCFuIAcgbjcDECAHKAIIIUdBASFIIEcgSGohSSAHIEk2AggMAAsACyAHKQMQIW9CACFwIG8hcSBwIXIgcSByUiFKQQEhSyBKIEtxIUwgTEUNACAIKAKAAiFNQcAAIU4gTSFPIE4hUCBPIFBHIVFBASFSIFEgUnEhUyBTRQ0AIAcpAxAhcyBzpyFUIAgoAoACIVVBAiFWIFUgVnQhVyAIIFdqIVggWCBUNgIAIAgoAoACIVlBASFaIFkgWmohWyAIIFs2AoACC0EwIVwgByBcaiFdIF0kAA8L0Q4B3QF/IwAhBkEgIQcgBiAHayEIIAgkACAIIAA2AhwgCCABNgIYIAggAjYCFCAIIAM2AhAgCCAENgIMIAUhCSAIIAk6AAsgCCgCHCEKIAgoAhQhCyAIKAIMIQwgCyENIAwhDiANIA5JIQ9BASEQIA8gEHEhEQJAAkAgEUUNACAIKAIQIRIgCCgCDCETIAgoAhghFCAIKAIUIRVBASEWQQEhFyAWIBdxIRggCiASIBMgFCAVIBgQjxQgCigCgAIhGUEAIRogGiAZayEbIAogGzYCgAIMAQsgCCgCFCEcIAgoAgwhHSAcIR4gHSEfIB4gH0YhIEEBISEgICAhcSEiAkAgIkUNACAILQALISNBASEkICMgJHEhJSAlDQADQCAIKAIUISZBfyEnICYgJ2ohKCAIICg2AhQgCCgCGCEpIAgoAhQhKkECISsgKiArdCEsICkgLGohLSAtKAIAIS4gCCgCECEvIAgoAhQhMEECITEgMCAxdCEyIC8gMmohMyAzKAIAITQgLiE1IDQhNiA1IDZJITdBASE4IDcgOHEhOQJAIDlFDQAgCCgCFCE6QQEhOyA6IDtqITwgCCA8NgIUIAgoAhAhPSAIKAIUIT4gCCgCGCE/IAgoAhQhQEEBIUFBASFCIEEgQnEhQyAKID0gPiA/IEAgQxCPFCAKKAKAAiFEQQAhRSBFIERrIUYgCiBGNgKAAgwDCyAIKAIYIUcgCCgCFCFIQQIhSSBIIEl0IUogRyBKaiFLIEsoAgAhTCAIKAIQIU0gCCgCFCFOQQIhTyBOIE90IVAgTSBQaiFRIFEoAgAhUiBMIVMgUiFUIFMgVEshVUEBIVYgVSBWcSFXAkACQCBXRQ0AIAgoAhQhWEEBIVkgWCBZaiFaIAggWjYCFAwBCyAIKAIUIVsgWw0BCwsgCCgCFCFcAkAgXA0AQQAhXSAKIF02AoACDAILIAgoAhQhXiAIIF42AgwLIAgoAhQhX0EBIWAgXyBgayFhIAogYTYCgAJBACFiIAggYjoACkEAIWMgCCBjNgIEAkADQCAIKAIEIWQgCCgCDCFlIGQhZiBlIWcgZiBnSSFoQQEhaSBoIGlxIWogakUNASAIKAIYIWsgCCgCBCFsQQIhbSBsIG10IW4gayBuaiFvIG8oAgAhcCAIKAIQIXEgCCgCBCFyQQIhcyByIHN0IXQgcSB0aiF1IHUoAgAhdiBwIHZrIXcgCC0ACiF4QQEheUEAIXpBASF7IHgge3EhfCB5IHogfBshfSB3IH1rIX4gCCgCBCF/QQIhgAEgfyCAAXQhgQEgCiCBAWohggEgggEgfjYCACAIKAIYIYMBIAgoAgQhhAFBAiGFASCEASCFAXQhhgEggwEghgFqIYcBIIcBKAIAIYgBIAgoAhAhiQEgCCgCBCGKAUECIYsBIIoBIIsBdCGMASCJASCMAWohjQEgjQEoAgAhjgEgiAEhjwEgjgEhkAEgjwEgkAFJIZEBQQEhkgFBASGTASCRASCTAXEhlAEgkgEhlQECQCCUAQ0AIAgoAhghlgEgCCgCBCGXAUECIZgBIJcBIJgBdCGZASCWASCZAWohmgEgmgEoAgAhmwEgCCgCECGcASAIKAIEIZ0BQQIhngEgnQEgngF0IZ8BIJwBIJ8BaiGgASCgASgCACGhASCbASGiASChASGjASCiASCjAUYhpAFBACGlAUEBIaYBIKQBIKYBcSGnASClASGoAQJAIKcBRQ0AIAgtAAohqQEgqQEhqAELIKgBIaoBIKoBIZUBCyCVASGrAUEBIawBIKsBIKwBcSGtASAIIK0BOgAKIAgoAgQhrgFBASGvASCuASCvAWohsAEgCCCwATYCBAwACwALIAgoAgwhsQEgCCCxATYCAAJAA0AgCCgCACGyASAIKAIUIbMBILIBIbQBILMBIbUBILQBILUBSSG2AUEBIbcBILYBILcBcSG4ASC4AUUNASAIKAIYIbkBIAgoAgAhugFBAiG7ASC6ASC7AXQhvAEguQEgvAFqIb0BIL0BKAIAIb4BIAgtAAohvwFBASHAAUEAIcEBQQEhwgEgvwEgwgFxIcMBIMABIMEBIMMBGyHEASC+ASDEAWshxQEgCCgCACHGAUECIccBIMYBIMcBdCHIASAKIMgBaiHJASDJASDFATYCACAIKAIYIcoBIAgoAgAhywFBAiHMASDLASDMAXQhzQEgygEgzQFqIc4BIM4BKAIAIc8BQQAh0AEg0AEh0QECQCDPAQ0AIAgtAAoh0gEg0gEh0QELINEBIdMBQQEh1AEg0wEg1AFxIdUBIAgg1QE6AAogCCgCACHWAUEBIdcBINYBINcBaiHYASAIINgBNgIADAALAAsgCigCgAIh2QFBAiHaASDZASDaAXQh2wEgCiDbAWoh3AEg3AEoAgAh3QEg3QFFDQAgCigCgAIh3gFBASHfASDeASDfAWoh4AEgCiDgATYCgAILQSAh4QEgCCDhAWoh4gEg4gEkAA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEJsUIQVBASEGIAUgBnEhB0EQIQggAyAIaiEJIAkkACAHDwupAQIOfwR+IwAhA0EQIQQgAyAEayEFIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBykDACERIAYgETcDAEEIIQggBiAIaiEJIAcgCGohCiAKKQMAIRIgCSASNwMAQRAhCyAGIAtqIQwgBSgCBCENIA0pAwAhEyAMIBM3AwBBCCEOIAwgDmohDyANIA5qIRAgECkDACEUIA8gFDcDACAGDwtUAgZ/A3wjACECQRAhAyACIANrIQQgBCQAIAQgATYCDCAEKAIMIQUgBSsDACEIIAiaIQkgBSsDCCEKIAAgCSAKENUTGkEQIQYgBCAGaiEHIAckAA8L5gICGH8TfiMAIQJBECEDIAIgA2shBCAEIAA2AgggBCABNwMAIAQoAgghBSAEIAU2AgwgBCkDACEaQgAhGyAaIRwgGyEdIBwgHVUhBkEBIQcgBiAHcSEIAkACQCAIRQ0AIAQpAwAhHiAepyEJIAUgCTYCACAEKQMAIR9CICEgIB8gIIchISAhpyEKIAUgCjYCBCAFKAIEIQtBAiEMQQEhDSAMIA0gCxshDiAFIA42AoACDAELIAQpAwAhIkIAISMgIiEkICMhJSAkICVTIQ9BASEQIA8gEHEhEQJAAkAgEUUNACAEKQMAISZCACEnICcgJn0hKCAEICg3AwAgBCkDACEpICmnIRIgBSASNgIAIAQpAwAhKkIgISsgKiArhyEsICynIRMgBSATNgIEIAUoAgQhFEF+IRVBfyEWIBUgFiAUGyEXIAUgFzYCgAIMAQtBACEYIAUgGDYCgAILCyAEKAIMIRkgGQ8LZwEPfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEIsUIQVBACEGIAUhByAGIQggByAIRyEJQX8hCiAJIApzIQtBASEMIAsgDHEhDUEQIQ4gAyAOaiEPIA8kACANDwtiAQl/IwAhA0GQAiEEIAMgBGshBSAFJAAgBSABNgKMAiAFIAI2AogCIAUoAowCIQYgBSgCiAIhByAFIQggCCAHEJwUGiAFIQkgACAGIAkQ9xNBkAIhCiAFIApqIQsgCyQADwvaAQEZfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQZBACEHIAYhCCAHIQkgCCAJSiEKQQEhCyAKIAtxIQwCQAJAIAxFDQAgBCgCCCENIAUgDTYCAEEBIQ4gBSAONgKAAgwBCyAEKAIIIQ9BACEQIA8hESAQIRIgESASSCETQQEhFCATIBRxIRUCQAJAIBVFDQAgBCgCCCEWQQAhFyAXIBZrIRggBSAYNgIAQX8hGSAFIBk2AoACDAELQQAhGiAFIBo2AoACCwsgBQ8LqwYBcH8jACEEQYALIQUgBCAFayEGIAYkACAGIAE2AvwKIAYgAjYC+AogBiADNgL0CiAGKAL8CiEHIAYoAvgKIQggBigC9AohCUHgCiEKIAYgCmohCyALIQwgDCAHIAggCRCeFCAGKAL4CiENQYQCIQ4gDSAOaiEPIAYoAvQKIRBBhAIhESAQIBFqIRJB0AohEyAGIBNqIRQgFCEVIBUgByAPIBIQnhRB4AohFiAGIBZqIRcgFyEYIBgQnxQhGUEBIRogGSAacSEbAkACQAJAAkAgGw0AQdAKIRwgBiAcaiEdIB0hHiAeEJ8UIR9BASEgIB8gIHEhISAhRQ0BC0HgCiEiIAYgImohIyAjISQgJBCgFCElQQEhJiAlICZxIScgJw0BQdAKISggBiAoaiEpICkhKiAqEKAUIStBASEsICsgLHEhLSAtDQELQeAKIS4gBiAuaiEvIC8hMEHQCiExIAYgMWohMiAyITMgACAwIDMQoRQMAQtBqBQhNCAHIDRqITUgBigC+AohNiAGKAL4CiE3QagEITggBiA4aiE5IDkhOiA6IDYgNxD3EyAGKAL0CiE7QbAGITwgBiA8aiE9ID0hPkGoBCE/IAYgP2ohQCBAIUEgPiBBIDsQ9xMgBigC+AohQkGEAiFDIEIgQ2ohRCAGKAL4CiFFQYQCIUYgRSBGaiFHQRghSCAGIEhqIUkgSSFKIEogRCBHEPcTIAYoAvQKIUtBhAIhTCBLIExqIU1BoAIhTiAGIE5qIU8gTyFQQRghUSAGIFFqIVIgUiFTIFAgUyBNEPcTQbgIIVQgBiBUaiFVIFUhVkGwBiFXIAYgV2ohWCBYIVlBoAIhWiAGIFpqIVsgWyFcIFYgWSBcEPgTQcAKIV0gBiBdaiFeIF4hX0G4CCFgIAYgYGohYSBhIWIgXyA1IGIQohRBCCFjIAYgY2ohZCBkIWVB4AohZiAGIGZqIWcgZyFoQdAKIWkgBiBpaiFqIGohayBlIGggaxCjFEHACiFsIAYgbGohbSBtIW5BCCFvIAYgb2ohcCBwIXEgACBuIHEQpBQLQYALIXIgBiByaiFzIHMkAA8LRwIGfwF8IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgghBSAFEJ0UIQhBECEGIAQgBmohByAHJAAgCA8LSQEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCABNgIMIAQoAgwhBUGEAiEGIAAgBSAGEOMaGiAAEKUUQRAhByAEIAdqIQggCCQADwu7DwH0AX8jACEEQeAjIQUgBCAFayEGIAYkACAGIAE2AtwjIAYgAjYC2CMgBiADNgLUIyAGKALcIyEHIAYoAtgjIQggBigC1CMhCUHAIyEKIAYgCmohCyALIQwgDCAHIAggCRCXFCAGKALYIyENQYgEIQ4gDSAOaiEPIAYoAtQjIRBBiAQhESAQIBFqIRJBsCMhEyAGIBNqIRQgFCEVIBUgByAPIBIQlxRBwCMhFiAGIBZqIRcgFyEYIBgQnxQhGUEBIRogGSAacSEbAkACQAJAAkAgGw0AQbAjIRwgBiAcaiEdIB0hHiAeEJ8UIR9BASEgIB8gIHEhISAhRQ0BC0HAIyEiIAYgImohIyAjISQgJBCgFCElQQEhJiAlICZxIScgJw0BQbAjISggBiAoaiEpICkhKiAqEKAUIStBASEsICsgLHEhLSAtDQELQcAjIS4gBiAuaiEvIC8hMEGwIyExIAYgMWohMiAyITMgACAwIDMQoRQMAQsgBigC2CMhNCAGKALYIyE1QYgZITYgBiA2aiE3IDchOCA4IDQgNRD3EyAGKALUIyE5QZAbITogBiA6aiE7IDshPEGIGSE9IAYgPWohPiA+IT8gPCA/IDkQ9xMgBigC2CMhQEGEAiFBIEAgQWohQiAGKALYIyFDQYQCIUQgQyBEaiFFQfgUIUYgBiBGaiFHIEchSCBIIEIgRRD3EyAGKALUIyFJQYQCIUogSSBKaiFLQYAXIUwgBiBMaiFNIE0hTkH4FCFPIAYgT2ohUCBQIVEgTiBRIEsQ9xNBmB0hUiAGIFJqIVMgUyFUQZAbIVUgBiBVaiFWIFYhV0GAFyFYIAYgWGohWSBZIVogVCBXIFoQ+hMgBigC2CMhW0GIBCFcIFsgXGohXSAGKALYIyFeQYgEIV8gXiBfaiFgQegQIWEgBiBhaiFiIGIhYyBjIF0gYBD3EyAGKALUIyFkQYgEIWUgZCBlaiFmQfASIWcgBiBnaiFoIGghaUHoECFqIAYgamohayBrIWwgaSBsIGYQ9xNBoB8hbSAGIG1qIW4gbiFvQZgdIXAgBiBwaiFxIHEhckHwEiFzIAYgc2ohdCB0IXUgbyByIHUQ+BMgBigC2CMhdkGMBiF3IHYgd2oheCAGKALYIyF5QYwGIXogeSB6aiF7QdgMIXwgBiB8aiF9IH0hfiB+IHggexD3EyAGKALUIyF/QYwGIYABIH8ggAFqIYEBQeAOIYIBIAYgggFqIYMBIIMBIYQBQdgMIYUBIAYghQFqIYYBIIYBIYcBIIQBIIcBIIEBEPcTQaghIYgBIAYgiAFqIYkBIIkBIYoBQaAfIYsBIAYgiwFqIYwBIIwBIY0BQeAOIY4BIAYgjgFqIY8BII8BIZABIIoBII0BIJABEPgTQaghIZEBIAYgkQFqIZIBIJIBIZMBQYQCIZQBIAcgkwEglAEQ4xoaQZQKIZUBIAcglQFqIZYBQQEhlwEglgEglwEQlhQaIAYoAtgjIZgBIAYoAtgjIZkBQYQCIZoBIJkBIJoBaiGbAUHICCGcASAGIJwBaiGdASCdASGeASCeASCYASCbARD3E0HQCiGfASAGIJ8BaiGgASCgASGhAUHICCGiASAGIKIBaiGjASCjASGkAUECIaUBIKEBIKQBIKUBEJUUQYQCIaYBIAcgpgFqIacBQdAKIagBIAYgqAFqIakBIKkBIaoBQYQCIasBIKcBIKoBIKsBEOMaGiAGKALUIyGsASAGKALUIyGtAUGEAiGuASCtASCuAWohrwFBwAYhsAEgBiCwAWohsQEgsQEhsgEgsgEgrAEgrwEQ9xNBlAohswEgByCzAWohtAFBhAIhtQEgtAEgtQFqIbYBQcAGIbcBIAYgtwFqIbgBILgBIbkBQYQCIboBILYBILkBILoBEOMaGiAGKALYIyG7AUGIBCG8ASC7ASC8AWohvQEgBigC2CMhvgFBjAYhvwEgvgEgvwFqIcABQbACIcEBIAYgwQFqIcIBIMIBIcMBIMMBIL0BIMABEPcTQbgEIcQBIAYgxAFqIcUBIMUBIcYBQbACIccBIAYgxwFqIcgBIMgBIckBQX4hygEgxgEgyQEgygEQlRRBiAQhywEgByDLAWohzAFBuAQhzQEgBiDNAWohzgEgzgEhzwFBhAIh0AEgzAEgzwEg0AEQ4xoaIAYoAtQjIdEBQYgEIdIBINEBINIBaiHTASAGKALUIyHUAUGMBiHVASDUASDVAWoh1gFBKCHXASAGINcBaiHYASDYASHZASDZASDTASDWARD3E0GUCiHaASAHINoBaiHbAUGIBCHcASDbASDcAWoh3QFBKCHeASAGIN4BaiHfASDfASHgAUGEAiHhASDdASDgASDhARDjGhpBlAoh4gEgByDiAWoh4wFBGCHkASAGIOQBaiHlASDlASHmASDmASAHIAcg4wEQphRBCCHnASAGIOcBaiHoASDoASHpAUHAIyHqASAGIOoBaiHrASDrASHsAUGwIyHtASAGIO0BaiHuASDuASHvASDpASDsASDvARCjFEEYIfABIAYg8AFqIfEBIPEBIfIBQQgh8wEgBiDzAWoh9AEg9AEh9QEgACDyASD1ARCkFAtB4CMh9gEgBiD2AWoh9wEg9wEkAA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEJYRIQVBASEGIAUgBnEhB0EQIQggAyAIaiEJIAkkACAHDwvoAQEafyMAIQJBECEDIAIgA2shBCAEIAA2AgggBCABNgIEIAQoAgghBSAEIAU2AgwgBCgCBCEGQQAhByAGIQggByEJIAggCUohCkEBIQsgCiALcSEMAkACQCAMRQ0AIAQoAgQhDSAFIA02AgBBASEOIAUgDjYCgAIMAQsgBCgCBCEPQQAhECAPIREgECESIBEgEkghE0EBIRQgEyAUcSEVAkACQCAVRQ0AIAQoAgQhFkEAIRcgFyAWayEYIAUgGDYCAEF/IRkgBSAZNgKAAgwBC0EAIRogBSAaNgKAAgsLIAQoAgwhGyAbDwtQAgd/AnwjACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCsDACEIIAQoAgghBSAIIAUQmRohCUEQIQYgAyAGaiEHIAckACAJDwvRAQEafyMAIQRBwAAhBSAEIAVrIQYgBiQAIAYgATYCPCAGIAI2AjggBiADNgI0IAYoAjwhB0GoFCEIIAcgCGohCSAGKAI4IQpBICELIAYgC2ohDCAMIQ0gDSAJIAoQohRBqBQhDiAHIA5qIQ8gBigCNCEQQRAhESAGIBFqIRIgEiETIBMgDyAQEKIUIAYhFEEQIRUgBiAVaiEWIBYhFyAUIBcQpxRBICEYIAYgGGohGSAZIRogBiEbIAAgGiAbEKgUQcAAIRwgBiAcaiEdIB0kAA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEKkUIQVBASEGIAUgBnEhB0EQIQggAyAIaiEJIAkkACAHDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQqhQhBUEBIQYgBSAGcSEHQRAhCCADIAhqIQkgCSQAIAcPC6MFA0F/DnwEfiMAIQNBMCEEIAMgBGshBSAFJAAgBSABNgIsIAUgAjYCKCAFKAIsIQYgBisDACFEQQAhByAHtyFFIEQgRWEhCEEBIQkgCCAJcSEKAkACQAJAIAoNACAFKAIoIQsgCygCCCEMIAYoAgghDUE2IQ4gDSAOaiEPIAwhECAPIREgECARSiESQQEhEyASIBNxIRQgFEUNAQsgBSgCKCEVIBUpAwAhUiAAIFI3AwBBCCEWIAAgFmohFyAVIBZqIRggGCkDACFTIBcgUzcDAAwBCyAFKAIoIRkgGSsDACFGQQAhGiAatyFHIEYgR2EhG0EBIRwgGyAccSEdAkACQCAdDQAgBigCCCEeIAUoAighHyAfKAIIISBBNiEhICAgIWohIiAeISMgIiEkICMgJEohJUEBISYgJSAmcSEnICdFDQELIAYpAwAhVCAAIFQ3AwBBCCEoIAAgKGohKSAGIChqISogKikDACFVICkgVTcDAAwBCyAGKAIIISsgBSgCKCEsICwoAgghLSArIS4gLSEvIC4gL04hMEEBITEgMCAxcSEyAkAgMkUNACAGKAIIITMgBSgCKCE0IDQoAgghNSAzIDVrITYgBSA2NgIkIAYrAwAhSCAFKAIkITcgSCA3EJkaIUkgBSgCKCE4IDgrAwAhSiBJIEqgIUsgBSBLOQMYIAUrAxghTCAFKAIoITkgOSgCCCE6IAAgTCA6EKsUGgwBCyAFKAIoITsgOygCCCE8IAYoAgghPSA8ID1rIT4gBSA+NgIUIAUoAighPyA/KwMAIU0gBSgCFCFAIE0gQBCZGiFOIAYrAwAhTyBOIE+gIVAgBSBQOQMIIAUrAwghUSAGKAIIIUEgACBRIEEQqxQaC0EwIUIgBSBCaiFDIEMkAA8LbAIKfwF8IwAhA0EgIQQgAyAEayEFIAUkACAFIAE2AhwgBSACNgIYIAUoAhghBkEIIQcgBSAHaiEIIAghCSAJIAYQiBQgBSsDCCENIAUoAhAhCiAAIA0gChCrFBpBICELIAUgC2ohDCAMJAAPC54FA0B/EXwCfiMAIQNBMCEEIAMgBGshBSAFJAAgBSABNgIsIAUgAjYCKCAFKAIsIQYgBisDACFDQQAhByAHtyFEIEMgRGEhCEEBIQkgCCAJcSEKAkACQAJAIAoNACAFKAIoIQsgCygCCCEMIAYoAgghDUE2IQ4gDSAOaiEPIAwhECAPIREgECARSiESQQEhEyASIBNxIRQgFEUNAQsgBSgCKCEVIBUrAwAhRSBFmiFGIAUoAighFiAWKAIIIRcgACBGIBcQqxQaDAELIAUoAighGCAYKwMAIUdBACEZIBm3IUggRyBIYSEaQQEhGyAaIBtxIRwCQAJAIBwNACAGKAIIIR0gBSgCKCEeIB4oAgghH0E2ISAgHyAgaiEhIB0hIiAhISMgIiAjSiEkQQEhJSAkICVxISYgJkUNAQsgBikDACFUIAAgVDcDAEEIIScgACAnaiEoIAYgJ2ohKSApKQMAIVUgKCBVNwMADAELIAYoAgghKiAFKAIoISsgKygCCCEsICohLSAsIS4gLSAuTiEvQQEhMCAvIDBxITECQCAxRQ0AIAYoAgghMiAFKAIoITMgMygCCCE0IDIgNGshNSAFIDU2AiQgBisDACFJIAUoAiQhNiBJIDYQmRohSiAFKAIoITcgNysDACFLIEogS6EhTCAFIEw5AxggBSsDGCFNIAUoAighOCA4KAIIITkgACBNIDkQqxQaDAELIAUoAighOiA6KAIIITsgBigCCCE8IDsgPGshPSAFID02AhQgBSgCKCE+ID4rAwAhTiBOmiFPIAUoAhQhPyBPID8QmRohUCAGKwMAIVEgUCBRoCFSIAUgUjkDCCAFKwMIIVMgBigCCCFAIAAgUyBAEKsUGgtBMCFBIAUgQWohQiBCJAAPC5wBAgx/BHwjACEDQSAhBCADIARrIQUgBSQAIAUgATYCHCAFIAI2AhggBSgCHCEGIAYrAwAhDyAFKAIYIQcgBysDACEQIA8gEKMhESAFIBE5AxAgBigCCCEIIAUoAhghCSAJKAIIIQogCCAKayELIAUgCzYCDCAFKwMQIRIgBSgCDCEMIAAgEiAMEKsUGkEgIQ0gBSANaiEOIA4kAA8LPQEHfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAoACIQVBACEGIAYgBWshByAEIAc2AoACDwuvCwG6AX8jACEEQbAXIQUgBCAFayEGIAYkACAGIAE2AqwXIAYgAjYCqBcgBiADNgKkFyAGKAKsFyEHIAYoAqgXIQggBigCpBchCUGQFyEKIAYgCmohCyALIQwgDCAHIAggCRCXFCAGKAKoFyENQYgEIQ4gDSAOaiEPIAYoAqQXIRBBiAQhESAQIBFqIRJBgBchEyAGIBNqIRQgFCEVIBUgByAPIBIQnhRBkBchFiAGIBZqIRcgFyEYIBgQnxQhGUEBIRogGSAacSEbAkACQAJAAkAgGw0AQYAXIRwgBiAcaiEdIB0hHiAeEJ8UIR9BASEgIB8gIHEhISAhRQ0BC0GQFyEiIAYgImohIyAjISQgJBCgFCElQQEhJiAlICZxIScgJw0BQYAXISggBiAoaiEpICkhKiAqEKAUIStBASEsICsgLHEhLSAtDQELQZAXIS4gBiAuaiEvIC8hMEGAFyExIAYgMWohMiAyITMgACAwIDMQoRQMAQsgBigCqBchNCAGKAKoFyE1QeAOITYgBiA2aiE3IDchOCA4IDQgNRD3EyAGKAKkFyE5QegQITogBiA6aiE7IDshPEHgDiE9IAYgPWohPiA+IT8gPCA/IDkQ9xMgBigCqBchQEGEAiFBIEAgQWohQiAGKAKoFyFDQYQCIUQgQyBEaiFFQdAKIUYgBiBGaiFHIEchSCBIIEIgRRD3EyAGKAKkFyFJQYQCIUogSSBKaiFLQdgMIUwgBiBMaiFNIE0hTkHQCiFPIAYgT2ohUCBQIVEgTiBRIEsQ9xNB8BIhUiAGIFJqIVMgUyFUQegQIVUgBiBVaiFWIFYhV0HYDCFYIAYgWGohWSBZIVogVCBXIFoQ+hMgBigCqBchW0GIBCFcIFsgXGohXSAGKAKoFyFeQYgEIV8gXiBfaiFgQcAGIWEgBiBhaiFiIGIhYyBjIF0gYBD3EyAGKAKkFyFkQYgEIWUgZCBlaiFmQcgIIWcgBiBnaiFoIGghaUHABiFqIAYgamohayBrIWwgaSBsIGYQ9xNB+BQhbSAGIG1qIW4gbiFvQfASIXAgBiBwaiFxIHEhckHICCFzIAYgc2ohdCB0IXUgbyByIHUQ+BNBjAYhdiAHIHZqIXdB+BQheCAGIHhqIXkgeSF6QYQCIXsgdyB6IHsQ4xoaQZQKIXwgByB8aiF9QYwGIX4gfSB+aiF/QQEhgAEgfyCAARCWFBogBigCqBchgQEgBigCqBchggFBhAIhgwEgggEggwFqIYQBQbACIYUBIAYghQFqIYYBIIYBIYcBIIcBIIEBIIQBEPcTQbgEIYgBIAYgiAFqIYkBIIkBIYoBQbACIYsBIAYgiwFqIYwBIIwBIY0BQQIhjgEgigEgjQEgjgEQlRRBkAghjwEgByCPAWohkAFBuAQhkQEgBiCRAWohkgEgkgEhkwFBhAIhlAEgkAEgkwEglAEQ4xoaIAYoAqQXIZUBIAYoAqQXIZYBQYQCIZcBIJYBIJcBaiGYAUEoIZkBIAYgmQFqIZoBIJoBIZsBIJsBIJUBIJgBEPcTQZQKIZwBIAcgnAFqIZ0BQZAIIZ4BIJ0BIJ4BaiGfAUEoIaABIAYgoAFqIaEBIKEBIaIBQYQCIaMBIJ8BIKIBIKMBEOMaGkGMBiGkASAHIKQBaiGlAUGUCiGmASAHIKYBaiGnAUGMBiGoASCnASCoAWohqQFBGCGqASAGIKoBaiGrASCrASGsASCsASAHIKUBIKkBEJcUQQghrQEgBiCtAWohrgEgrgEhrwFBkBchsAEgBiCwAWohsQEgsQEhsgFBgBchswEgBiCzAWohtAEgtAEhtQEgrwEgsgEgtQEQoxRBGCG2ASAGILYBaiG3ASC3ASG4AUEIIbkBIAYguQFqIboBILoBIbsBIAAguAEguwEQpBQLQbAXIbwBIAYgvAFqIb0BIL0BJAAPCzwBBn8jACECQRAhAyACIANrIQQgBCQAIAQgATYCDCAEKAIMIQUgACAFEKwUQRAhBiAEIAZqIQcgByQADwucAQIMfwR8IwAhA0EgIQQgAyAEayEFIAUkACAFIAE2AhwgBSACNgIYIAUoAhwhBiAGKwMAIQ8gBSgCGCEHIAcrAwAhECAPIBCiIREgBSAROQMQIAYoAgghCCAFKAIYIQkgCSgCCCEKIAggCmohCyAFIAs2AgwgBSsDECESIAUoAgwhDCAAIBIgDBCrFBpBICENIAUgDWohDiAOJAAPC0gCCH8CfCMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQrAwAhCUEAIQUgBbchCiAJIApjIQZBASEHIAYgB3EhCCAIDwtIAgh/AnwjACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKwMAIQlBACEFIAW3IQogCSAKZCEGQQEhByAGIAdxIQggCA8LhQECC38CfCMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIcIAUgATkDECAFIAI2AgwgBSgCHCEGIAUrAxAhDkEIIQcgBiAHaiEIIA4gCBCYGiEPIAYgDzkDACAFKAIMIQkgBigCCCEKIAogCWohCyAGIAs2AghBICEMIAUgDGohDSANJAAgBg8LzgECEH8GfCMAIQJBICEDIAIgA2shBCAEJAAgBCABNgIcIAQoAhwhBSAFKwMAIRIgBCASOQMQIAUoAgghBiAEIAY2AgwgBCgCDCEHQQEhCCAHIAhxIQkCQCAJRQ0AIAQrAxAhE0QAAAAAAAAAQCEUIBMgFKIhFSAEIBU5AxAgBCgCDCEKQX8hCyAKIAtqIQwgBCAMNgIMCyAEKwMQIRYgFp8hFyAEKAIMIQ1BASEOIA0gDnUhDyAAIBcgDxCrFBpBICEQIAQgEGohESARJAAPC4UBAgZ/CHwjACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYrAwghCEQAAAAAAADwPyEJIAggCaAhCiAFKwMIIQsgCyAKoCEMIAUgDDkDCCAEKAIIIQcgBysDACENIAUrAwAhDiAOIA2jIQ8gBSAPOQMAIAUPC0cBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBECEFIAQgBWohBiAEIAYQshRBECEHIAMgB2ohCCAIJAAPC3oCDH8BfiMAIQNBoAIhBCADIARrIQUgBSQAIAUgATYCnAIgBSACNwOQAiAFKAKcAiEGIAUpA5ACIQ9BCCEHIAUgB2ohCCAIIQkgCSAPEJMUGkEIIQogBSAKaiELIAshDCAAIAYgDBD3E0GgAiENIAUgDWohDiAOJAAPC1wBDX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCLFCEFQQAhBiAFIQcgBiEIIAcgCEghCUEBIQogCSAKcSELQRAhDCADIAxqIQ0gDSQAIAsPC50vAbsFfyMAIQRBwOAAIQUgBCAFayEGIAYkACAGIAE2ArxgIAYgAjYCuGAgBiADNgK0YCAGKAK8YCEHQaDYACEIIAYgCGohCSAJIQpBkAghCyAKIAtqIQwgCiENA0AgDSEOIA4QzQ4aQYQCIQ8gDiAPaiEQIBAhESAMIRIgESASRiETQQEhFCATIBRxIRUgECENIBVFDQALQZDQACEWIAYgFmohFyAXIRhBkAghGSAYIBlqIRogGCEbA0AgGyEcIBwQzQ4aQYQCIR0gHCAdaiEeIB4hHyAaISAgHyAgRiEhQQEhIiAhICJxISMgHiEbICNFDQALIAYoArhgISRBjAYhJSAkICVqISYgJhCUFCEnQQEhKCAnIChxISkCQAJAIClFDQAgBigCuGAhKiAGKAK0YCErQYDQACEsIAYgLGohLSAtIS4gLiAHICogKxCXFEGg2AAhLyAGIC9qITAgMCExQQEhMiAxIDIQlhQaIAYoArRgITMgBigCtGAhNEGEAiE1IDQgNWohNkH4zQAhNyAGIDdqITggOCE5IDkgMyA2EPcTQZDQACE6IAYgOmohOyA7ITxB+M0AIT0gBiA9aiE+ID4hP0GEAiFAIDwgPyBAEOMaGiAGKAK0YCFBQYgEIUIgQSBCaiFDQaDYACFEIAYgRGohRSBFIUZBhAIhRyBGIEdqIUhBhAIhSSBIIEMgSRDjGhpBkNAAIUogBiBKaiFLIEshTEGEAiFNIEwgTWohTkEBIU8gTiBPEJYUGiAGKAK4YCFQQYgEIVEgUCBRaiFSIAYoArRgIVNBjAYhVCBTIFRqIVVB2M0AIVYgBiBWaiFXIFchWCBYIAcgUiBVEJ4UQaDYACFZIAYgWWohWiBaIVtBkNAAIVwgBiBcaiFdIF0hXkG4zQAhXyAGIF9qIWAgYCFhIGEgByBbIF4QlxRByM0AIWIgBiBiaiFjIGMhZEG4zQAhZSAGIGVqIWYgZiFnIGQgZxCnFEHozQAhaCAGIGhqIWkgaSFqQdjNACFrIAYga2ohbCBsIW1ByM0AIW4gBiBuaiFvIG8hcCBqIG0gcBCoFEGA0AAhcSAGIHFqIXIgciFzIHMQnxQhdEEBIXUgdCB1cSF2AkACQAJAIHYNAEHozQAhdyAGIHdqIXggeCF5IHkQnxQhekEBIXsgeiB7cSF8IHxFDQELQYDQACF9IAYgfWohfiB+IX8gfxCgFCGAAUEBIYEBIIABIIEBcSGCASCCAQ0BQejNACGDASAGIIMBaiGEASCEASGFASCFARCgFCGGAUEBIYcBIIYBIIcBcSGIASCIAQ0BC0GA0AAhiQEgBiCJAWohigEgigEhiwFB6M0AIYwBIAYgjAFqIY0BII0BIY4BIAAgiwEgjgEQoRQMAgsgBigCuGAhjwEgBigCuGAhkAFBmMUAIZEBIAYgkQFqIZIBIJIBIZMBIJMBII8BIJABEPcTIAYoArRgIZQBQaDHACGVASAGIJUBaiGWASCWASGXAUGYxQAhmAEgBiCYAWohmQEgmQEhmgEglwEgmgEglAEQ9xMgBigCuGAhmwFBhAIhnAEgmwEgnAFqIZ0BIAYoArhgIZ4BQYQCIZ8BIJ4BIJ8BaiGgAUGIwQAhoQEgBiChAWohogEgogEhowEgowEgnQEgoAEQ9xMgBigCtGAhpAFBhAIhpQEgpAEgpQFqIaYBQZDDACGnASAGIKcBaiGoASCoASGpAUGIwQAhqgEgBiCqAWohqwEgqwEhrAEgqQEgrAEgpgEQ9xNBqMkAIa0BIAYgrQFqIa4BIK4BIa8BQaDHACGwASAGILABaiGxASCxASGyAUGQwwAhswEgBiCzAWohtAEgtAEhtQEgrwEgsgEgtQEQ+hMgBigCuGAhtgFBiAQhtwEgtgEgtwFqIbgBIAYoArhgIbkBQYgEIboBILkBILoBaiG7AUHwOiG8ASAGILwBaiG9ASC9ASG+ASC+ASC4ASC7ARD3EyAGKAK0YCG/AUGMBiHAASC/ASDAAWohwQFB+DwhwgEgBiDCAWohwwEgwwEhxAFB8DohxQEgBiDFAWohxgEgxgEhxwEgxAEgxwEgwQEQ9xMgBigCtGAhyAFBiAQhyQEgyAEgyQFqIcoBQYA/IcsBIAYgywFqIcwBIMwBIc0BQfg8Ic4BIAYgzgFqIc8BIM8BIdABIM0BINABIMoBEPcTQbDLACHRASAGINEBaiHSASDSASHTAUGoyQAh1AEgBiDUAWoh1QEg1QEh1gFBgD8h1wEgBiDXAWoh2AEg2AEh2QEg0wEg1gEg2QEQ+BNBoNgAIdoBIAYg2gFqIdsBINsBIdwBQbDLACHdASAGIN0BaiHeASDeASHfAUGEAiHgASDcASDfASDgARDjGhpBkNAAIeEBIAYg4QFqIeIBIOIBIeMBQQEh5AEg4wEg5AEQlhQaIAYoArhgIeUBIAYoArhgIeYBQYQCIecBIOYBIOcBaiHoAUHYNCHpASAGIOkBaiHqASDqASHrASDrASDlASDoARD3E0HgNiHsASAGIOwBaiHtASDtASHuAUHYNCHvASAGIO8BaiHwASDwASHxAUECIfIBIO4BIPEBIPIBEJUUIAYoArhgIfMBQYgEIfQBIPMBIPQBaiH1ASAGKAK4YCH2AUGIBCH3ASD2ASD3AWoh+AFByDAh+QEgBiD5AWoh+gEg+gEh+wEg+wEg9QEg+AEQ9xMgBigCtGAh/AFBjAYh/QEg/AEg/QFqIf4BQdAyIf8BIAYg/wFqIYACIIACIYECQcgwIYICIAYgggJqIYMCIIMCIYQCIIECIIQCIP4BEPcTQeg4IYUCIAYghQJqIYYCIIYCIYcCQeA2IYgCIAYgiAJqIYkCIIkCIYoCQdAyIYsCIAYgiwJqIYwCIIwCIY0CIIcCIIoCII0CEPgTQaDYACGOAiAGII4CaiGPAiCPAiGQAkGEAiGRAiCQAiCRAmohkgJB6DghkwIgBiCTAmohlAIglAIhlQJBhAIhlgIgkgIglQIglgIQ4xoaIAYoArRgIZcCIAYoArRgIZgCQYQCIZkCIJgCIJkCaiGaAkHALiGbAiAGIJsCaiGcAiCcAiGdAiCdAiCXAiCaAhD3E0GQ0AAhngIgBiCeAmohnwIgnwIhoAJBhAIhoQIgoAIgoQJqIaICQcAuIaMCIAYgowJqIaQCIKQCIaUCQYQCIaYCIKICIKUCIKYCEOMaGkGg2AAhpwIgBiCnAmohqAIgqAIhqQJBkNAAIaoCIAYgqgJqIasCIKsCIawCQbAuIa0CIAYgrQJqIa4CIK4CIa8CIK8CIAcgqQIgrAIQlxRBoC4hsAIgBiCwAmohsQIgsQIhsgJBgNAAIbMCIAYgswJqIbQCILQCIbUCQejNACG2AiAGILYCaiG3AiC3AiG4AiCyAiC1AiC4AhCjFEGwLiG5AiAGILkCaiG6AiC6AiG7AkGgLiG8AiAGILwCaiG9AiC9AiG+AiAAILsCIL4CEKQUDAELQaDYACG/AiAGIL8CaiHAAiDAAiHBAkEBIcICIMECIMICEJYUGiAGKAK0YCHDAiAGKAK0YCHEAkGEAiHFAiDEAiDFAmohxgJBmCwhxwIgBiDHAmohyAIgyAIhyQIgyQIgwwIgxgIQ9xNBkNAAIcoCIAYgygJqIcsCIMsCIcwCQZgsIc0CIAYgzQJqIc4CIM4CIc8CQYQCIdACIMwCIM8CINACEOMaGiAGKAK0YCHRAkGIBCHSAiDRAiDSAmoh0wJBoNgAIdQCIAYg1AJqIdUCINUCIdYCQYQCIdcCINYCINcCaiHYAkGEAiHZAiDYAiDTAiDZAhDjGhpBkNAAIdoCIAYg2gJqIdsCINsCIdwCQYQCId0CINwCIN0CaiHeAkEBId8CIN4CIN8CEJYUGiAGKAK4YCHgAkGIBCHhAiDgAiDhAmoh4gIgBigCtGAh4wJBjAYh5AIg4wIg5AJqIeUCQfgrIeYCIAYg5gJqIecCIOcCIegCIOgCIAcg4gIg5QIQnhRBoNgAIekCIAYg6QJqIeoCIOoCIesCQZDQACHsAiAGIOwCaiHtAiDtAiHuAkHYKyHvAiAGIO8CaiHwAiDwAiHxAiDxAiAHIOsCIO4CEJcUQegrIfICIAYg8gJqIfMCIPMCIfQCQdgrIfUCIAYg9QJqIfYCIPYCIfcCIPQCIPcCEKcUQYgsIfgCIAYg+AJqIfkCIPkCIfoCQfgrIfsCIAYg+wJqIfwCIPwCIf0CQegrIf4CIAYg/gJqIf8CIP8CIYADIPoCIP0CIIADEKgUIAYoArhgIYEDQaDYACGCAyAGIIIDaiGDAyCDAyGEA0GEAiGFAyCEAyCBAyCFAxDjGhogBigCtGAhhgNBkNAAIYcDIAYghwNqIYgDIIgDIYkDQYQCIYoDIIkDIIYDIIoDEOMaGiAGKAK4YCGLA0GEAiGMAyCLAyCMA2ohjQNBoNgAIY4DIAYgjgNqIY8DII8DIZADQYQCIZEDIJADIJEDaiGSA0GEAiGTAyCSAyCNAyCTAxDjGhogBigCtGAhlANBhAIhlQMglAMglQNqIZYDQZDQACGXAyAGIJcDaiGYAyCYAyGZA0GEAiGaAyCZAyCaA2ohmwNBhAIhnAMgmwMglgMgnAMQ4xoaIAYoArhgIZ0DQYwGIZ4DIJ0DIJ4DaiGfA0Gg2AAhoAMgBiCgA2ohoQMgoQMhogNBiAQhowMgogMgowNqIaQDQYQCIaUDIKQDIJ8DIKUDEOMaGkGQ0AAhpgMgBiCmA2ohpwMgpwMhqANBiAQhqQMgqAMgqQNqIaoDQQEhqwMgqgMgqwMQlhQaQaDYACGsAyAGIKwDaiGtAyCtAyGuA0GQ0AAhrwMgBiCvA2ohsAMgsAMhsQNByCshsgMgBiCyA2ohswMgswMhtAMgtAMgByCuAyCxAxCmFEHIKyG1AyAGILUDaiG2AyC2AyG3AyC3AxCfFCG4A0EBIbkDILgDILkDcSG6AwJAAkACQCC6Aw0AQYgsIbsDIAYguwNqIbwDILwDIb0DIL0DEJ8UIb4DQQEhvwMgvgMgvwNxIcADIMADRQ0BC0HIKyHBAyAGIMEDaiHCAyDCAyHDAyDDAxCgFCHEA0EBIcUDIMQDIMUDcSHGAyDGAw0BQYgsIccDIAYgxwNqIcgDIMgDIckDIMkDEKAUIcoDQQEhywMgygMgywNxIcwDIMwDDQELQcgrIc0DIAYgzQNqIc4DIM4DIc8DQYgsIdADIAYg0ANqIdEDINEDIdIDIAAgzwMg0gMQoRQMAQsgBigCuGAh0wNBjAYh1AMg0wMg1ANqIdUDIAYoArhgIdYDQbgnIdcDIAYg1wNqIdgDINgDIdkDINkDINUDINYDEPcTQcApIdoDIAYg2gNqIdsDINsDIdwDQbgnId0DIAYg3QNqId4DIN4DId8DQQIh4AMg3AMg3wMg4AMQlRRBoNgAIeEDIAYg4QNqIeIDIOIDIeMDQcApIeQDIAYg5ANqIeUDIOUDIeYDQYQCIecDIOMDIOYDIOcDEOMaGiAGKAK4YCHoA0GMBiHpAyDoAyDpA2oh6gMgBigCuGAh6wNBhAIh7AMg6wMg7ANqIe0DQagjIe4DIAYg7gNqIe8DIO8DIfADIPADIOoDIO0DEPcTQbAlIfEDIAYg8QNqIfIDIPIDIfMDQagjIfQDIAYg9ANqIfUDIPUDIfYDQQIh9wMg8wMg9gMg9wMQlRRBoNgAIfgDIAYg+ANqIfkDIPkDIfoDQYQCIfsDIPoDIPsDaiH8A0GwJSH9AyAGIP0DaiH+AyD+AyH/A0GEAiGABCD8AyD/AyCABBDjGhogBigCuGAhgQQgBigCuGAhggRBgBkhgwQgBiCDBGohhAQghAQhhQQghQQggQQgggQQ9xMgBigCtGAhhgRBiBshhwQgBiCHBGohiAQgiAQhiQRBgBkhigQgBiCKBGohiwQgiwQhjAQgiQQgjAQghgQQ9xMgBigCuGAhjQRBhAIhjgQgjQQgjgRqIY8EIAYoArhgIZAEQYQCIZEEIJAEIJEEaiGSBEHwFCGTBCAGIJMEaiGUBCCUBCGVBCCVBCCPBCCSBBD3EyAGKAK0YCGWBEGEAiGXBCCWBCCXBGohmARB+BYhmQQgBiCZBGohmgQgmgQhmwRB8BQhnAQgBiCcBGohnQQgnQQhngQgmwQgngQgmAQQ9xNBkB0hnwQgBiCfBGohoAQgoAQhoQRBiBshogQgBiCiBGohowQgowQhpARB+BYhpQQgBiClBGohpgQgpgQhpwQgoQQgpAQgpwQQ+hMgBigCuGAhqARBjAYhqQQgqAQgqQRqIaoEIAYoArhgIasEQYwGIawEIKsEIKwEaiGtBEHoEiGuBCAGIK4EaiGvBCCvBCGwBCCwBCCqBCCtBBD3E0GYHyGxBCAGILEEaiGyBCCyBCGzBEGQHSG0BCAGILQEaiG1BCC1BCG2BEHoEiG3BCAGILcEaiG4BCC4BCG5BCCzBCC2BCC5BBD6EyAGKAK4YCG6BEGIBCG7BCC6BCC7BGohvAQgBigCuGAhvQRBiAQhvgQgvQQgvgRqIb8EQdAMIcAEIAYgwARqIcEEIMEEIcIEIMIEILwEIL8EEPcTIAYoArRgIcMEQYgEIcQEIMMEIMQEaiHFBEHYDiHGBCAGIMYEaiHHBCDHBCHIBEHQDCHJBCAGIMkEaiHKBCDKBCHLBCDIBCDLBCDFBBD3EyAGKAK0YCHMBEGMBiHNBCDMBCDNBGohzgRB4BAhzwQgBiDPBGoh0AQg0AQh0QRB2A4h0gQgBiDSBGoh0wQg0wQh1AQg0QQg1AQgzgQQ9xNBoCEh1QQgBiDVBGoh1gQg1gQh1wRBmB8h2AQgBiDYBGoh2QQg2QQh2gRB4BAh2wQgBiDbBGoh3AQg3AQh3QQg1wQg2gQg3QQQ+BNBoNgAId4EIAYg3gRqId8EIN8EIeAEQYgEIeEEIOAEIOEEaiHiBEGgISHjBCAGIOMEaiHkBCDkBCHlBEGEAiHmBCDiBCDlBCDmBBDjGhogBigCuGAh5wQgBigCuGAh6ARBhAIh6QQg6AQg6QRqIeoEQbgGIesEIAYg6wRqIewEIOwEIe0EIO0EIOcEIOoEEPcTQcAIIe4EIAYg7gRqIe8EIO8EIfAEQbgGIfEEIAYg8QRqIfIEIPIEIfMEQQIh9AQg8AQg8wQg9AQQlRQgBigCuGAh9QRBiAQh9gQg9QQg9gRqIfcEIAYoArhgIfgEQYgEIfkEIPgEIPkEaiH6BEGoAiH7BCAGIPsEaiH8BCD8BCH9BCD9BCD3BCD6BBD3EyAGKAK0YCH+BEGMBiH/BCD+BCD/BGohgAVBsAQhgQUgBiCBBWohggUgggUhgwVBqAIhhAUgBiCEBWohhQUghQUhhgUggwUghgUggAUQ9xNByAohhwUgBiCHBWohiAUgiAUhiQVBwAghigUgBiCKBWohiwUgiwUhjAVBsAQhjQUgBiCNBWohjgUgjgUhjwUgiQUgjAUgjwUQ+BNBoNgAIZAFIAYgkAVqIZEFIJEFIZIFQYwGIZMFIJIFIJMFaiGUBUHICiGVBSAGIJUFaiGWBSCWBSGXBUGEAiGYBSCUBSCXBSCYBRDjGhogBigCtGAhmQUgBigCtGAhmgVBhAIhmwUgmgUgmwVqIZwFQSAhnQUgBiCdBWohngUgngUhnwUgnwUgmQUgnAUQ9xNBkNAAIaAFIAYgoAVqIaEFIKEFIaIFQYwGIaMFIKIFIKMFaiGkBUEgIaUFIAYgpQVqIaYFIKYFIacFQYQCIagFIKQFIKcFIKgFEOMaGkGg2AAhqQUgBiCpBWohqgUgqgUhqwVBkNAAIawFIAYgrAVqIa0FIK0FIa4FQRAhrwUgBiCvBWohsAUgsAUhsQUgsQUgByCrBSCuBRC0FCAGIbIFQcgrIbMFIAYgswVqIbQFILQFIbUFQYgsIbYFIAYgtgVqIbcFILcFIbgFILIFILUFILgFEKMUQRAhuQUgBiC5BWohugUgugUhuwUgBiG8BSAAILsFILwFEKQUC0HA4AAhvQUgBiC9BWohvgUgvgUkAA8LkAICG38GfiMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBRCzFCEGQQghByAEIAdqIQggCCEJIAYpAwAhHSAJIB03AwBBCCEKIAkgCmohCyAGIApqIQwgDCkDACEeIAsgHjcDACAEKAIYIQ0gDRCzFCEOIAQoAhwhDyAOKQMAIR8gDyAfNwMAQQghECAPIBBqIREgDiAQaiESIBIpAwAhICARICA3AwBBCCETIAQgE2ohFCAUIRUgFRCzFCEWIAQoAhghFyAWKQMAISEgFyAhNwMAQQghGCAXIBhqIRkgFiAYaiEaIBopAwAhIiAZICI3AwBBICEbIAQgG2ohHCAcJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwvvDwH+AX8jACEEQfAnIQUgBCAFayEGIAYkACAGIAE2AuwnIAYgAjYC6CcgBiADNgLkJyAGKALsJyEHQdAjIQggBiAIaiEJIAkhCkGIBCELIAogC2ohDCAKIQ0DQCANIQ4gDhDNDhpBhAIhDyAOIA9qIRAgECERIAwhEiARIBJGIRNBASEUIBMgFHEhFSAQIQ0gFUUNAAtBwB8hFiAGIBZqIRcgFyEYQYgEIRkgGCAZaiEaIBghGwNAIBshHCAcEM0OGkGEAiEdIBwgHWohHiAeIR8gGiEgIB8gIEYhIUEBISIgISAicSEjIB4hGyAjRQ0ACyAGKALoJyEkIAYoAuQnISVBsB8hJiAGICZqIScgJyEoICggByAkICUQlxQgBigC6CchKUGIBCEqICkgKmohKyAGKALkJyEsQYgEIS0gLCAtaiEuQaAfIS8gBiAvaiEwIDAhMSAxIAcgKyAuEJcUQbAfITIgBiAyaiEzIDMhNCA0EJ8UITVBASE2IDUgNnEhNwJAAkACQAJAIDcNAEGgHyE4IAYgOGohOSA5ITogOhCfFCE7QQEhPCA7IDxxIT0gPUUNAQtBsB8hPiAGID5qIT8gPyFAIEAQoBQhQUEBIUIgQSBCcSFDIEMNAUGgHyFEIAYgRGohRSBFIUYgRhCgFCFHQQEhSCBHIEhxIUkgSQ0BC0GwHyFKIAYgSmohSyBLIUxBoB8hTSAGIE1qIU4gTiFPIAAgTCBPEKEUDAELIAYoAugnIVAgBigC6CchUUH4FCFSIAYgUmohUyBTIVQgVCBQIFEQ9xMgBigC5CchVUGAFyFWIAYgVmohVyBXIVhB+BQhWSAGIFlqIVogWiFbIFggWyBVEPcTIAYoAugnIVxBhAIhXSBcIF1qIV4gBigC6CchX0GEAiFgIF8gYGohYUHoECFiIAYgYmohYyBjIWQgZCBeIGEQ9xMgBigC5CchZUGEAiFmIGUgZmohZ0HwEiFoIAYgaGohaSBpIWpB6BAhayAGIGtqIWwgbCFtIGogbSBnEPcTQYgZIW4gBiBuaiFvIG8hcEGAFyFxIAYgcWohciByIXNB8BIhdCAGIHRqIXUgdSF2IHAgcyB2EPoTIAYoAugnIXdBiAQheCB3IHhqIXkgBigC6CchekGIBCF7IHoge2ohfEHgDiF9IAYgfWohfiB+IX8gfyB5IHwQ9xNBkBshgAEgBiCAAWohgQEggQEhggFBiBkhgwEgBiCDAWohhAEghAEhhQFB4A4hhgEgBiCGAWohhwEghwEhiAEgggEghQEgiAEQ+BMgBigC6CchiQFBjAYhigEgiQEgigFqIYsBIAYoAugnIYwBQYwGIY0BIIwBII0BaiGOAUHICCGPASAGII8BaiGQASCQASGRASCRASCLASCOARD3EyAGKALkJyGSAUHQCiGTASAGIJMBaiGUASCUASGVAUHICCGWASAGIJYBaiGXASCXASGYASCVASCYASCSARD3EyAGKALkJyGZAUGEAiGaASCZASCaAWohmwFB2AwhnAEgBiCcAWohnQEgnQEhngFB0AohnwEgBiCfAWohoAEgoAEhoQEgngEgoQEgmwEQ9xNBmB0hogEgBiCiAWohowEgowEhpAFBkBshpQEgBiClAWohpgEgpgEhpwFB2AwhqAEgBiCoAWohqQEgqQEhqgEgpAEgpwEgqgEQ+BNB0CMhqwEgBiCrAWohrAEgrAEhrQFBmB0hrgEgBiCuAWohrwEgrwEhsAFBhAIhsQEgrQEgsAEgsQEQ4xoaQcAfIbIBIAYgsgFqIbMBILMBIbQBQQEhtQEgtAEgtQEQlhQaIAYoAugnIbYBIAYoAugnIbcBQYQCIbgBILcBILgBaiG5AUGwAiG6ASAGILoBaiG7ASC7ASG8ASC8ASC2ASC5ARD3EyAGKALoJyG9AUGIBCG+ASC9ASC+AWohvwEgBigC6CchwAFBjAYhwQEgwAEgwQFqIcIBQSghwwEgBiDDAWohxAEgxAEhxQEgxQEgvwEgwgEQ9xNBuAQhxgEgBiDGAWohxwEgxwEhyAFBsAIhyQEgBiDJAWohygEgygEhywFBKCHMASAGIMwBaiHNASDNASHOASDIASDLASDOARD4E0HABiHPASAGIM8BaiHQASDQASHRAUG4BCHSASAGINIBaiHTASDTASHUAUECIdUBINEBINQBINUBEJUUQdAjIdYBIAYg1gFqIdcBINcBIdgBQYQCIdkBINgBINkBaiHaAUHABiHbASAGINsBaiHcASDcASHdAUGEAiHeASDaASDdASDeARDjGhogBigC5Cch3wFBjAYh4AEg3wEg4AFqIeEBQcAfIeIBIAYg4gFqIeMBIOMBIeQBQYQCIeUBIOQBIOUBaiHmAUGEAiHnASDmASDhASDnARDjGhpB0CMh6AEgBiDoAWoh6QEg6QEh6gFBwB8h6wEgBiDrAWoh7AEg7AEh7QFBGCHuASAGIO4BaiHvASDvASHwASDwASAHIOoBIO0BEJcUQQgh8QEgBiDxAWoh8gEg8gEh8wFBsB8h9AEgBiD0AWoh9QEg9QEh9gFBoB8h9wEgBiD3AWoh+AEg+AEh+QEg8wEg9gEg+QEQoxRBGCH6ASAGIPoBaiH7ASD7ASH8AUEIIf0BIAYg/QFqIf4BIP4BIf8BIAAg/AEg/wEQpBQLQfAnIYACIAYggAJqIYECIIECJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEMYUIQdBECEIIAMgCGohCSAJJAAgBw8LrQEBE38jACEDQSAhBCADIARrIQUgBSQAIAUgADYCHCAFIAE2AhggBSACNgIUIAUoAhQhBkEBIQcgBiAHEMcUIQggBSAINgIQIAUoAhAhCUEAIQogCSAKNgIAIAUoAhAhCyAFKAIUIQxBCCENIAUgDWohDiAOIQ9BASEQIA8gDCAQEMgUGkEIIREgBSARaiESIBIhEyAAIAsgExDJFBpBICEUIAUgFGohFSAVJAAPC0UBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDMFCEFIAUoAgAhBkEQIQcgAyAHaiEIIAgkACAGDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIcIAUgATYCGCAFIAI2AhQgBSgCHCEGIAUoAhghByAFKAIUIQggCBDKFCEJIAYgByAJEMsUQSAhCiAFIApqIQsgCyQADws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQvA4hBUEQIQYgAyAGaiEHIAckACAFDwuXAQEOfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAYQzRQhByAFKAIIIQggCCAHNgIAIAYoAgQhCSAFKAIEIQogCiAJNgIEIAUoAgQhCyAFKAIEIQwgDCgCBCENIA0gCzYCACAFKAIIIQ4gBiAONgIEQRAhDyAFIA9qIRAgECQADwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhDOFCEHQRAhCCADIAhqIQkgCSQAIAcPC2UBC38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDPFCEFIAUoAgAhBiADIAY2AgggBBDPFCEHQQAhCCAHIAg2AgAgAygCCCEJQRAhCiADIApqIQsgCyQAIAkPC0IBB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBACEFIAQgBRDQFEEQIQYgAyAGaiEHIAckACAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LogEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAFEOIUIQcgBygCACEIIAYhCSAIIQogCSAKSSELQQEhDCALIAxxIQ0CQAJAIA1FDQAgBCgCCCEOIA4QvxQhDyAFIA8Q4xQMAQsgBCgCCCEQIBAQvxQhESAFIBEQ5BQLQRAhEiAEIBJqIRMgEyQADwtVAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQoAgAhBSAEIAUQ5xQhBiADIAY2AgggAygCCCEHQRAhCCADIAhqIQkgCSQAIAcPC1UBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBCgCBCEFIAQgBRDnFCEGIAMgBjYCCCADKAIIIQdBECEIIAMgCGohCSAJJAAgBw8LwgEBGn8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCGCAFIAE2AhBBCCEGIAUgBmohByAHIQhBGCEJIAUgCWohCiAKIQsgCygCACEMIAggDDYCACAFIQ1BECEOIAUgDmohDyAPIRAgECgCACERIA0gETYCAEEQIRIgBSASaiETIBMhFEEYIRUgBSAVaiEWIBYhFyAUIBcQ5RQhGCAFKAIIIRkgBSgCACEaIBkgGiACIBgQ5hRBICEbIAUgG2ohHCAcJAAPC1wBC38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBCgCBCEFQQghBiADIAZqIQcgByEIIAggBRCrFRogAygCCCEJQRAhCiADIApqIQsgCyQAIAkPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBC8DiEFQRAhBiADIAZqIQcgByQAIAUPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDRFCEFQRAhBiADIAZqIQcgByQAIAUPC1QBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBkEAIQcgBSAGIAcQ0hQhCEEQIQkgBCAJaiEKIAokACAIDwtOAQZ/IwAhA0EQIQQgAyAEayEFIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBiAHNgIAIAUoAgQhCCAGIAg2AgQgBg8LbAELfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgQhByAHENMUIQhBCCEJIAUgCWohCiAKIQsgBiALIAgQ1BQaQRAhDCAFIAxqIQ0gDSQAIAYPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhQgBSABNgIQIAUgAjYCDCAFKAIUIQYgBSgCECEHIAUoAgwhCCAIEMoUIQkgBiAHIAkQ2hRBICEKIAUgCmohCyALJAAPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBDbFCEFQRAhBiADIAZqIQcgByQAIAUPC0UBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBC8DiEFIAUQvQ4hBkEQIQcgAyAHaiEIIAgkACAGDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQuwghBUEQIQYgAyAGaiEHIAckACAFDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ3BQhBUEQIQYgAyAGaiEHIAckACAFDwuoAQETfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRDPFCEGIAYoAgAhByAEIAc2AgQgBCgCCCEIIAUQzxQhCSAJIAg2AgAgBCgCBCEKQQAhCyAKIQwgCyENIAwgDUchDkEBIQ8gDiAPcSEQAkAgEEUNACAFEN0UIREgBCgCBCESIBEgEhDeFAtBECETIAQgE2ohFCAUJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwufAQETfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAGENUUIQggByEJIAghCiAJIApLIQtBASEMIAsgDHEhDQJAIA1FDQBBzQohDiAOEIMBAAsgBSgCCCEPQTAhECAPIBBsIRFBCCESIBEgEhCEASETQRAhFCAFIBRqIRUgFSQAIBMPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwt8AQx/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQ1hQhCCAGIAgQ1xQaQQQhCSAGIAlqIQogBSgCBCELIAsQ2BQhDCAKIAwQ2RQaQRAhDSAFIA1qIQ4gDiQAIAYPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMQdWq1SohBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LWgEJfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQ1hQhByAHKAIAIQggBSAINgIAQRAhCSAEIAlqIQogCiQAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtcAgh/AX4jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGENgUIQcgBykCACEKIAUgCjcCAEEQIQggBCAIaiEJIAkkACAFDwvhAQIUfwV+IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHIAcQyhQhCCAIKQMAIRcgBiAXNwMAQSAhCSAGIAlqIQogCCAJaiELIAspAwAhGCAKIBg3AwBBGCEMIAYgDGohDSAIIAxqIQ4gDikDACEZIA0gGTcDAEEQIQ8gBiAPaiEQIAggD2ohESARKQMAIRogECAaNwMAQQghEiAGIBJqIRMgCCASaiEUIBQpAwAhGyATIBs3AwBBECEVIAUgFWohFiAWJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEEIQUgBCAFaiEGIAYQ3xQhB0EQIQggAyAIaiEJIAkkACAHDwtaAQl/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIAIQYgBCgCCCEHIAUoAgQhCCAGIAcgCBDgFEEQIQkgBCAJaiEKIAokAA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC1oBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBSgCBCEIIAYgByAIEOEUQRAhCSAFIAlqIQogCiQADwthAQp/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHQTAhCCAHIAhsIQlBCCEKIAYgCSAKEElBECELIAUgC2ohDCAMJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEOgUIQdBECEIIAMgCGohCSAJJAAgBw8LswEBFX8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFQQghBiAEIAZqIQcgByEIQQEhCSAIIAUgCRDpFBogBRDqFCEKIAQoAgwhCyALEOsUIQwgBCgCGCENIA0Q7BQhDiAKIAwgDhDtFCAEKAIMIQ9BBCEQIA8gEGohESAEIBE2AgxBCCESIAQgEmohEyATIRQgFBDuFBpBICEVIAQgFWohFiAWJAAPC90BARh/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAFEOoUIQYgBCAGNgIUIAUQ7xQhB0EBIQggByAIaiEJIAUgCRDwFCEKIAUQ7xQhCyAEKAIUIQwgBCENIA0gCiALIAwQ8RQaIAQoAhQhDiAEKAIIIQ8gDxDrFCEQIAQoAhghESAREOwUIRIgDiAQIBIQ7RQgBCgCCCETQQQhFCATIBRqIRUgBCAVNgIIIAQhFiAFIBYQ8hQgBCEXIBcQ8xQaQSAhGCAEIBhqIRkgGSQADwtlAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEKYVIQYgBCgCCCEHIAcQphUhCCAGIAhrIQlBAiEKIAkgCnUhC0EQIQwgBCAMaiENIA0kACALDwu6BQFhfyMAIQRBMCEFIAQgBWshBiAGJAAgBiAANgIoIAYgATYCICAGIAI2AhwgBiADNgIYIAYoAhghB0EBIQggByEJIAghCiAJIApKIQtBASEMIAsgDHEhDQJAIA1FDQAgBigCGCEOQQIhDyAOIA9rIRBBAiERIBAgEW0hEiAGIBI2AhggBigCGCETQSghFCAGIBRqIRUgFSEWIBYgExCiFSEXIAYgFzYCECAGKAIcIRhBECEZIAYgGWohGiAaIRsgGxCjFSEcQSAhHSAGIB1qIR4gHiEfIB8QpBUhICAgEKMVISEgGCAcICEQpRUhIkEBISMgIiAjcSEkAkAgJEUNAEEgISUgBiAlaiEmICYhJyAnEKMVISggKBC/FCEpQQghKiAGICpqISsgKyEsICkoAgAhLSAsIC02AgACQANAQRAhLiAGIC5qIS8gLyEwIDAQoxUhMSAxEL8UITJBICEzIAYgM2ohNCA0ITUgNRCjFSE2IDIoAgAhNyA2IDc2AgBBICE4IAYgOGohOSA5ITpBECE7IAYgO2ohPCA8IT0gPSgCACE+IDogPjYCACAGKAIYIT8CQCA/DQAMAgsgBigCGCFAQQEhQSBAIEFrIUJBAiFDIEIgQ20hRCAGIEQ2AhggBigCGCFFQSghRiAGIEZqIUcgRyFIIEggRRCiFSFJIAYgSTYCAEEQIUogBiBKaiFLIEshTCAGIU0gTSgCACFOIEwgTjYCACAGKAIcIU9BECFQIAYgUGohUSBRIVIgUhCjFSFTQQghVCAGIFRqIVUgVSFWIE8gUyBWEKUVIVdBASFYIFcgWHEhWSBZDQALC0EIIVogBiBaaiFbIFshXCBcEL8UIV1BICFeIAYgXmohXyBfIWAgYBCjFSFhIF0oAgAhYiBhIGI2AgALC0EwIWMgBiBjaiFkIGQkAA8LXAEKfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIAIQVBCCEGIAQgBmohByAHIQggCCAFEKoVGiAEKAIIIQlBECEKIAQgCmohCyALJAAgCQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEPQUIQVBECEGIAMgBmohByAHJAAgBQ8LgwEBDX8jACEDQRAhBCADIARrIQUgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAGIAc2AgAgBSgCCCEIIAgoAgQhCSAGIAk2AgQgBSgCCCEKIAooAgQhCyAFKAIEIQxBAiENIAwgDXQhDiALIA5qIQ8gBiAPNgIIIAYPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBCCEFIAQgBWohBiAGEPYUIQdBECEIIAMgCGohCSAJJAAgBw8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhwgBSABNgIYIAUgAjYCFCAFKAIcIQYgBSgCGCEHIAUoAhQhCCAIEOwUIQkgBiAHIAkQ9RRBICEKIAUgCmohCyALJAAPCzkBBn8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCgCACEGIAYgBTYCBCAEDwtEAQl/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCBCEFIAQoAgAhBiAFIAZrIQdBAiEIIAcgCHUhCSAJDwuyAgElfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIYIAQgATYCFCAEKAIYIQUgBRD5FCEGIAQgBjYCECAEKAIUIQcgBCgCECEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AIAUQtRoACyAFEPoUIQ4gBCAONgIMIAQoAgwhDyAEKAIQIRBBASERIBAgEXYhEiAPIRMgEiEUIBMgFE8hFUEBIRYgFSAWcSEXAkACQCAXRQ0AIAQoAhAhGCAEIBg2AhwMAQsgBCgCDCEZQQEhGiAZIBp0IRsgBCAbNgIIQQghHCAEIBxqIR0gHSEeQRQhHyAEIB9qISAgICEhIB4gIRBnISIgIigCACEjIAQgIzYCHAsgBCgCHCEkQSAhJSAEICVqISYgJiQAICQPC64CASB/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhggBiABNgIUIAYgAjYCECAGIAM2AgwgBigCGCEHIAYgBzYCHEEMIQggByAIaiEJQQAhCiAGIAo2AgggBigCDCELQQghDCAGIAxqIQ0gDSEOIAkgDiALEPsUGiAGKAIUIQ8CQAJAIA9FDQAgBxD8FCEQIAYoAhQhESAQIBEQ/RQhEiASIRMMAQtBACEUIBQhEwsgEyEVIAcgFTYCACAHKAIAIRYgBigCECEXQQIhGCAXIBh0IRkgFiAZaiEaIAcgGjYCCCAHIBo2AgQgBygCACEbIAYoAhQhHEECIR0gHCAddCEeIBsgHmohHyAHEP4UISAgICAfNgIAIAYoAhwhIUEgISIgBiAiaiEjICMkACAhDwv7AQEbfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRD/FCAFEOoUIQYgBSgCACEHIAUoAgQhCCAEKAIIIQlBBCEKIAkgCmohCyAGIAcgCCALEIAVIAQoAgghDEEEIQ0gDCANaiEOIAUgDhCBFUEEIQ8gBSAPaiEQIAQoAgghEUEIIRIgESASaiETIBAgExCBFSAFEOIUIRQgBCgCCCEVIBUQ/hQhFiAUIBYQgRUgBCgCCCEXIBcoAgQhGCAEKAIIIRkgGSAYNgIAIAUQ7xQhGiAFIBoQghUgBRCDFUEQIRsgBCAbaiEcIBwkAA8LlQEBEX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCCCADKAIIIQQgAyAENgIMIAQQhBUgBCgCACEFQQAhBiAFIQcgBiEIIAcgCEchCUEBIQogCSAKcSELAkAgC0UNACAEEPwUIQwgBCgCACENIAQQhRUhDiAMIA0gDhCGFQsgAygCDCEPQRAhECADIBBqIREgESQAIA8PCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhQgBSABNgIQIAUgAjYCDCAFKAIUIQYgBSgCECEHIAUoAgwhCCAIEOwUIQkgBiAHIAkQ9xRBICEKIAUgCmohCyALJAAPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBD4FCEFQRAhBiADIAZqIQcgByQAIAUPC18BCX8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQcgBxDsFCEIIAgoAgAhCSAGIAk2AgBBECEKIAUgCmohCyALJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwuEAQERfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEIcVIQUgBRCIFSEGIAMgBjYCCBB0IQcgAyAHNgIEQQghCCADIAhqIQkgCSEKQQQhCyADIAtqIQwgDCENIAogDRB1IQ4gDigCACEPQRAhECADIBBqIREgESQAIA8PCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCJFSEFQRAhBiADIAZqIQcgByQAIAUPC3sBDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxAzIQggBiAIELcOGkEEIQkgBiAJaiEKIAUoAgQhCyALEJEVIQwgCiAMEJIVGkEQIQ0gBSANaiEOIA4kACAGDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhCUFSEHQRAhCCADIAhqIQkgCSQAIAcPC1QBCX8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBkEAIQcgBSAGIAcQkxUhCEEQIQkgBCAJaiEKIAokACAIDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQwhBSAEIAVqIQYgBhCVFSEHQRAhCCADIAhqIQkgCSQAIAcPC6kBARZ/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQlxUhBSAEEJcVIQYgBBD6FCEHQQIhCCAHIAh0IQkgBiAJaiEKIAQQlxUhCyAEEO8UIQxBAiENIAwgDXQhDiALIA5qIQ8gBBCXFSEQIAQQ+hQhEUECIRIgESASdCETIBAgE2ohFCAEIAUgCiAPIBQQmBVBECEVIAMgFWohFiAWJAAPC4ECAR9/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhwgBiABNgIYIAYgAjYCFCAGIAM2AhAgBigCFCEHIAYoAhghCCAHIAhrIQlBAiEKIAkgCnUhCyAGIAs2AgwgBigCDCEMIAYoAhAhDSANKAIAIQ5BACEPIA8gDGshEEECIREgECARdCESIA4gEmohEyANIBM2AgAgBigCDCEUQQAhFSAUIRYgFSEXIBYgF0ohGEEBIRkgGCAZcSEaAkAgGkUNACAGKAIQIRsgGygCACEcIAYoAhghHSAGKAIMIR5BAiEfIB4gH3QhICAcIB0gIBDjGhoLQSAhISAGICFqISIgIiQADwufAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCZFSEGIAYoAgAhByAEIAc2AgQgBCgCCCEIIAgQmRUhCSAJKAIAIQogBCgCDCELIAsgCjYCAEEEIQwgBCAMaiENIA0hDiAOEJkVIQ8gDygCACEQIAQoAgghESARIBA2AgBBECESIAQgEmohEyATJAAPC7ABARZ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEJcVIQYgBRCXFSEHIAUQ+hQhCEECIQkgCCAJdCEKIAcgCmohCyAFEJcVIQwgBRD6FCENQQIhDiANIA50IQ8gDCAPaiEQIAUQlxUhESAEKAIIIRJBAiETIBIgE3QhFCARIBRqIRUgBSAGIAsgECAVEJgVQRAhFiAEIBZqIRcgFyQADwsbAQN/IwAhAUEQIQIgASACayEDIAMgADYCDA8LQwEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCAFEJoVQRAhBiADIAZqIQcgByQADwteAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQnBUhBSAFKAIAIQYgBCgCACEHIAYgB2shCEECIQkgCCAJdSEKQRAhCyADIAtqIQwgDCQAIAoPC1oBCH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBSgCBCEIIAYgByAIEJsVQRAhCSAFIAlqIQogCiQADwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhCLFSEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCKFSEFQRAhBiADIAZqIQcgByQAIAUPC14BDH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCOFSEFIAUoAgAhBiAEKAIAIQcgBiAHayEIQQIhCSAIIAl1IQpBECELIAMgC2ohDCAMJAAgCg8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIEIAMoAgQhBCAEEIwVIQVBECEGIAMgBmohByAHJAAgBQ8LPgEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEI0VIQVBECEGIAMgBmohByAHJAAgBQ8LJQEEfyMAIQFBECECIAEgAmshAyADIAA2AgxB/////wMhBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQjxUhB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQkBUhBUEQIQYgAyAGaiEHIAckACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC1MBCH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAGEJEVIQcgBSAHNgIAQRAhCCAEIAhqIQkgCSQAIAUPC58BARN/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAYQjBUhCCAHIQkgCCEKIAkgCkshC0EBIQwgCyAMcSENAkAgDUUNAEHNCiEOIA4QgwEACyAFKAIIIQ9BAiEQIA8gEHQhEUEEIRIgESASEIQBIRNBECEUIAUgFGohFSAVJAAgEw8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEEIQUgBCAFaiEGIAYQlhUhB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQ9BQhBUEQIQYgAyAGaiEHIAckACAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC0UBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFIAUQ6xQhBkEQIQcgAyAHaiEIIAgkACAGDws3AQN/IwAhBUEgIQYgBSAGayEHIAcgADYCHCAHIAE2AhggByACNgIUIAcgAzYCECAHIAQ2AgwPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtKAQd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEJ0VQRAhByAEIAdqIQggCCQADwthAQp/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHQQIhCCAHIAh0IQlBBCEKIAYgCSAKEElBECELIAUgC2ohDCAMJAAPC0kBCX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQRBDCEFIAQgBWohBiAGEKEVIQdBECEIIAMgCGohCSAJJAAgBw8LoAEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCBCEFAkADQCAEKAIAIQYgBSgCCCEHIAYhCCAHIQkgCCAJRyEKQQEhCyAKIAtxIQwgDEUNASAFEPwUIQ0gBSgCCCEOQXwhDyAOIA9qIRAgBSAQNgIIIBAQ6xQhESANIBEQnhUMAAsAC0EQIRIgBCASaiETIBMkAA8LSgEHfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBCgCGCEGIAUgBhCfFUEgIQcgBCAHaiEIIAgkAA8LSgEHfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBCgCACEGIAUgBhCgFUEQIQcgBCAHaiEIIAgkAA8LIgEDfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQkBUhBUEQIQYgAyAGaiEHIAckACAFDwuAAQEPfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQVBCCEGIAQgBmohByAHIQggBSgCACEJIAggCTYCACAEKAIAIQpBCCELIAQgC2ohDCAMIQ0gDSAKEKcVGiAEKAIIIQ5BECEPIAQgD2ohECAQJAAgDg8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDws9AQd/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFQXwhBiAFIAZqIQcgBCAHNgIAIAQPC3cBDX8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBxDMDyEIIAUoAgQhCSAJEMwPIQogBiAIIAoQqBUhC0EBIQwgCyAMcSENQRAhDiAFIA5qIQ8gDyQAIA0PCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBQ8LUgEJfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSgCACEHQQIhCCAGIAh0IQkgByAJaiEKIAUgCjYCACAFDwtpAQt/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCBCEHIAUoAgghCCAGIAcgCBCpFSEJQQEhCiAJIApxIQtBECEMIAUgDGohDSANJAAgCw8L9wECF38GfCMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIIIAUgATYCBCAFIAI2AgAgBSgCBCEGIAYQyA8hGiAFKAIAIQcgBxDIDyEbIBogG2IhCEEBIQkgCCAJcSEKAkACQCAKRQ0AIAUoAgQhCyALEMgPIRwgBSgCACEMIAwQyA8hHSAcIB1jIQ1BASEOIA0gDnEhDyAFIA86AA8MAQsgBSgCBCEQIBAQ9BMhHiAFKAIAIREgERD0EyEfIB4gH2MhEkEBIRMgEiATcSEUIAUgFDoADwsgBS0ADyEVQQEhFiAVIBZxIRdBECEYIAUgGGohGSAZJAAgFw8LOQEFfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGNgIAIAUPCzkBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCACAFDwt0Agh/AnwjACEDQRAhBCADIARrIQUgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAHKwMAIQsgBiALOQMAIAUoAgQhCCAIKwMAIQwgBiAMOQMIQQAhCSAGIAk2AhBBACEKIAYgCjYCFCAGDwuiAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCBCEGIAUQvBAhByAHKAIAIQggBiEJIAghCiAJIApJIQtBASEMIAsgDHEhDQJAAkAgDUUNACAEKAIIIQ4gDhCxFSEPIAUgDxCyFQwBCyAEKAIIIRAgEBCxFSERIAUgERCzFQtBECESIAQgEmohEyATJAAPCzYBB38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQVBaCEGIAUgBmohByAHDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCCCEFIAUPC2QBDH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQqRMhB0F/IQggByAIcyEJQQEhCiAJIApxIQtBECEMIAQgDGohDSANJAAgCw8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC7MBARV/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBUEIIQYgBCAGaiEHIAchCEEBIQkgCCAFIAkQtBUaIAUQgRAhCiAEKAIMIQsgCxDSECEMIAQoAhghDSANELUVIQ4gCiAMIA4QthUgBCgCDCEPQRghECAPIBBqIREgBCARNgIMQQghEiAEIBJqIRMgEyEUIBQQtxUaQSAhFSAEIBVqIRYgFiQADwvdAQEYfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBRCBECEGIAQgBjYCFCAFEIIQIQdBASEIIAcgCGohCSAFIAkQuBUhCiAFEIIQIQsgBCgCFCEMIAQhDSANIAogCyAMEIMQGiAEKAIUIQ4gBCgCCCEPIA8Q0hAhECAEKAIYIREgERC1FSESIA4gECASELYVIAQoAgghE0EYIRQgEyAUaiEVIAQgFTYCCCAEIRYgBSAWEIQQIAQhFyAXEIUQGkEgIRggBCAYaiEZIBkkAA8LgwEBDX8jACEDQRAhBCADIARrIQUgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAGIAc2AgAgBSgCCCEIIAgoAgQhCSAGIAk2AgQgBSgCCCEKIAooAgQhCyAFKAIEIQxBGCENIAwgDWwhDiALIA5qIQ8gBiAPNgIIIAYPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhwgBSABNgIYIAUgAjYCFCAFKAIcIQYgBSgCGCEHIAUoAhQhCCAIELUVIQkgBiAHIAkQuRVBICEKIAUgCmohCyALJAAPCzkBBn8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCgCACEGIAYgBTYCBCAEDwuyAgElfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIYIAQgATYCFCAEKAIYIQUgBRC7FSEGIAQgBjYCECAEKAIUIQcgBCgCECEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AIAUQtRoACyAFEIAQIQ4gBCAONgIMIAQoAgwhDyAEKAIQIRBBASERIBAgEXYhEiAPIRMgEiEUIBMgFE8hFUEBIRYgFSAWcSEXAkACQCAXRQ0AIAQoAhAhGCAEIBg2AhwMAQsgBCgCDCEZQQEhGiAZIBp0IRsgBCAbNgIIQQghHCAEIBxqIR0gHSEeQRQhHyAEIB9qISAgICEhIB4gIRBnISIgIigCACEjIAQgIzYCHAsgBCgCHCEkQSAhJSAEICVqISYgJiQAICQPC2EBCX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCFCAFIAE2AhAgBSACNgIMIAUoAhQhBiAFKAIQIQcgBSgCDCEIIAgQtRUhCSAGIAcgCRC6FUEgIQogBSAKaiELIAskAA8LoQECDn8DfiMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCCCEGIAUoAgQhByAHELUVIQggCCkDACERIAYgETcDAEEQIQkgBiAJaiEKIAggCWohCyALKQMAIRIgCiASNwMAQQghDCAGIAxqIQ0gCCAMaiEOIA4pAwAhEyANIBM3AwBBECEPIAUgD2ohECAQJAAPC4QBARF/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQvBUhBSAFEL0VIQYgAyAGNgIIEHQhByADIAc2AgRBCCEIIAMgCGohCSAJIQpBBCELIAMgC2ohDCAMIQ0gCiANEHUhDiAOKAIAIQ9BECEQIAMgEGohESARJAAgDw8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQvxUhB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQvhUhBUEQIQYgAyAGaiEHIAckACAFDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgQgAygCBCEEIAQQyxAhBUEQIQYgAyAGaiEHIAckACAFDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQwBUhBUEQIQYgAyAGaiEHIAckACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwvCAQEafyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIYIAUgATYCEEEIIQYgBSAGaiEHIAchCEEYIQkgBSAJaiEKIAohCyALKAIAIQwgCCAMNgIAIAUhDUEQIQ4gBSAOaiEPIA8hECAQKAIAIREgDSARNgIAQRAhEiAFIBJqIRMgEyEUQRghFSAFIBVqIRYgFiEXIBQgFxDlFCEYIAUoAgghGSAFKAIAIRogGSAaIAIgGBDGFUEgIRsgBSAbaiEcIBwkAA8LTgEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIEIQVBfCEGIAUgBmohByAEIAcQxxVBECEIIAMgCGohCSAJJAAPC2gBC38jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIIIQUgBSgCBCEGIAQoAgwhByAHKAIAIQggCCAGNgIEIAQoAgwhCSAJKAIAIQogBCgCCCELIAsoAgQhDCAMIAo2AgAPC0oBB38jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAQoAhghBiAFIAYQzhVBICEHIAQgB2ohCCAIJAAPC94CAS9/IwAhBEEwIQUgBCAFayEGIAYkACAGIAA2AiggBiABNgIgIAYgAjYCHCAGIAM2AhggBigCGCEHQQEhCCAHIQkgCCEKIAkgCkohC0EBIQwgCyAMcSENAkAgDUUNAEEoIQ4gBiAOaiEPIA8hECAQEKMVIRFBICESIAYgEmohEyATIRQgFBCkFSEVIBUQoxUhFiARIBYQyBVBECEXIAYgF2ohGCAYIRlBKCEaIAYgGmohGyAbIRwgHCgCACEdIBkgHTYCAEEIIR4gBiAeaiEfIB8hIEEgISEgBiAhaiEiICIhIyAjKAIAISQgICAkNgIAIAYoAhwhJSAGKAIYISZBASEnICYgJ2shKCAGISlBKCEqIAYgKmohKyArISwgLCgCACEtICkgLTYCACAGKAIQIS4gBigCCCEvIAYoAgAhMCAuIC8gJSAoIDAQyRULQTAhMSAGIDFqITIgMiQADwt0AQp/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEMsVIAUQ7xQhByAEIAc2AgQgBCgCCCEIIAUgCBDMFSAEKAIEIQkgBSAJEM0VQRAhCiAEIApqIQsgCyQADwuYAQERfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRC/FCEGIAQhByAGKAIAIQggByAINgIAIAQoAgghCSAJEL8UIQogBCgCDCELIAooAgAhDCALIAw2AgAgBCENIA0QvxQhDiAEKAIIIQ8gDigCACEQIA8gEDYCAEEQIREgBCARaiESIBIkAA8L+QsBxgF/IwAhBUHQACEGIAUgBmshByAHJAAgByAANgJIIAcgATYCQCAHIAQ2AjggByACNgI0IAcgAzYCMEE4IQggByAIaiEJIAkhCkHIACELIAcgC2ohDCAMIQ0gCiANEOUUIQ4gByAONgIsIAcoAjAhD0ECIRAgDyERIBAhEiARIBJIIRNBASEUIBMgFHEhFQJAAkACQCAVDQAgBygCMCEWQQIhFyAWIBdrIRhBAiEZIBggGW0hGiAHKAIsIRsgGiEcIBshHSAcIB1IIR5BASEfIB4gH3EhICAgRQ0BCwwBCyAHKAIsISFBASEiICEgInQhI0EBISQgIyAkaiElIAcgJTYCLCAHKAIsISZByAAhJyAHICdqISggKCEpICkgJhCiFSEqIAcgKjYCKCAHKAIsIStBASEsICsgLGohLSAHKAIwIS4gLSEvIC4hMCAvIDBIITFBACEyQQEhMyAxIDNxITQgMiE1AkAgNEUNACAHKAI0ITZBKCE3IAcgN2ohOCA4ITkgORCjFSE6QSghOyAHIDtqITwgPCE9QQEhPiA9ID4QohUhPyAHID82AiBBICFAIAcgQGohQSBBIUIgQhCjFSFDIDYgOiBDEKUVIUQgRCE1CyA1IUVBASFGIEUgRnEhRwJAIEdFDQBBKCFIIAcgSGohSSBJIUogShDKFRogBygCLCFLQQEhTCBLIExqIU0gByBNNgIsCyAHKAI0IU5BKCFPIAcgT2ohUCBQIVEgURCjFSFSQTghUyAHIFNqIVQgVCFVIFUQoxUhViBOIFIgVhClFSFXQQEhWCBXIFhxIVkCQCBZRQ0ADAELQTghWiAHIFpqIVsgWyFcIFwQoxUhXSBdEL8UIV5BGCFfIAcgX2ohYCBgIWEgXigCACFiIGEgYjYCAAJAA0BBKCFjIAcgY2ohZCBkIWUgZRCjFSFmIGYQvxQhZ0E4IWggByBoaiFpIGkhaiBqEKMVIWsgZygCACFsIGsgbDYCAEE4IW0gByBtaiFuIG4hb0EoIXAgByBwaiFxIHEhciByKAIAIXMgbyBzNgIAIAcoAjAhdEECIXUgdCB1ayF2QQIhdyB2IHdtIXggBygCLCF5IHgheiB5IXsgeiB7SCF8QQEhfSB8IH1xIX4CQCB+RQ0ADAILIAcoAiwhf0EBIYABIH8ggAF0IYEBQQEhggEggQEgggFqIYMBIAcggwE2AiwgBygCLCGEAUHIACGFASAHIIUBaiGGASCGASGHASCHASCEARCiFSGIASAHIIgBNgIQQSghiQEgByCJAWohigEgigEhiwFBECGMASAHIIwBaiGNASCNASGOASCOASgCACGPASCLASCPATYCACAHKAIsIZABQQEhkQEgkAEgkQFqIZIBIAcoAjAhkwEgkgEhlAEgkwEhlQEglAEglQFIIZYBQQAhlwFBASGYASCWASCYAXEhmQEglwEhmgECQCCZAUUNACAHKAI0IZsBQSghnAEgByCcAWohnQEgnQEhngEgngEQoxUhnwFBKCGgASAHIKABaiGhASChASGiAUEBIaMBIKIBIKMBEKIVIaQBIAcgpAE2AghBCCGlASAHIKUBaiGmASCmASGnASCnARCjFSGoASCbASCfASCoARClFSGpASCpASGaAQsgmgEhqgFBASGrASCqASCrAXEhrAECQCCsAUUNAEEoIa0BIAcgrQFqIa4BIK4BIa8BIK8BEMoVGiAHKAIsIbABQQEhsQEgsAEgsQFqIbIBIAcgsgE2AiwLIAcoAjQhswFBKCG0ASAHILQBaiG1ASC1ASG2ASC2ARCjFSG3AUEYIbgBIAcguAFqIbkBILkBIboBILMBILcBILoBEKUVIbsBQX8hvAEguwEgvAFzIb0BQQEhvgEgvQEgvgFxIb8BIL8BDQALC0EYIcABIAcgwAFqIcEBIMEBIcIBIMIBEL8UIcMBQTghxAEgByDEAWohxQEgxQEhxgEgxgEQoxUhxwEgwwEoAgAhyAEgxwEgyAE2AgALQdAAIckBIAcgyQFqIcoBIMoBJAAPCz0BB38jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQVBBCEGIAUgBmohByAEIAc2AgAgBA8LIgEDfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIDwu8AQEUfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBSgCBCEGIAQgBjYCBAJAA0AgBCgCCCEHIAQoAgQhCCAHIQkgCCEKIAkgCkchC0EBIQwgCyAMcSENIA1FDQEgBRDqFCEOIAQoAgQhD0F8IRAgDyAQaiERIAQgETYCBCAREOsUIRIgDiASEJ4VDAALAAsgBCgCCCETIAUgEzYCBEEQIRQgBCAUaiEVIBUkAA8LsAEBFn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQlxUhBiAFEJcVIQcgBRD6FCEIQQIhCSAIIAl0IQogByAKaiELIAUQlxUhDCAEKAIIIQ1BAiEOIA0gDnQhDyAMIA9qIRAgBRCXFSERIAUQ7xQhEkECIRMgEiATdCEUIBEgFGohFSAFIAYgCyAQIBUQmBVBECEWIAQgFmohFyAXJAAPCyIBA38jACECQRAhAyACIANrIQQgBCAANgIEIAQgATYCAA8L4wEBGn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBkEAIQcgBiEIIAchCSAIIAlHIQpBASELIAogC3EhDAJAIAxFDQAgBCgCCCENIA0oAgAhDiAFIA4QzxUgBCgCCCEPIA8oAgQhECAFIBAQzxUgBRCMEiERIAQgETYCBCAEKAIEIRIgBCgCCCETQRAhFCATIBRqIRUgFRCREiEWIBIgFhDIEiAEKAIEIRcgBCgCCCEYQQEhGSAXIBggGRDJEgtBECEaIAQgGmohGyAbJAAPC1wBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCACEFQQghBiAEIAZqIQcgByEIIAggBRDnFRogBCgCCCEJQRAhCiAEIApqIQsgCyQAIAkPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ2RUhBiAEKAIIIQcgBxDZFSEIIAYhCSAIIQogCSAKRiELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC0UBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCCCEFIAUQ3Q8hBkEQIQcgAyAHaiEIIAgkACAGDwtlAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEOgVIQYgBCgCCCEHIAcQ2RUhCCAGIAhrIQlBGCEKIAkgCm0hC0EQIQwgBCAMaiENIA0kACALDwtlAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEOgVIQYgBCgCCCEHIAcQ6BUhCCAGIAhrIQlBGCEKIAkgCm0hC0EQIQwgBCAMaiENIA0kACALDwtzAQx/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBhDrFSEHIAUoAgghCCAIEOsVIQkgBSgCBCEKIAoQ6xUhCyAHIAkgCxDsFSEMQRAhDSAFIA1qIQ4gDiQAIAwPC3QBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQ2BUgBRCbDCEHIAQgBzYCBCAEKAIIIQggBSAIEOkVIAQoAgQhCSAFIAkQ6hVBECEKIAQgCmohCyALJAAPCyIBA38jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCA8LKwEFfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQoAgAhBSAFDwtcAQp/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgAhBUEIIQYgBCAGaiEHIAchCCAIIAUQ7RUaIAQoAgghCUEQIQogBCAKaiELIAskACAJDwttAQ5/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEOMVIQYgBCgCCCEHIAcQ4xUhCCAGIQkgCCEKIAkgCkYhC0EBIQwgCyAMcSENQRAhDiAEIA5qIQ8gDyQAIA0PCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwtlAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEO4VIQYgBCgCCCEHIAcQ4xUhCCAGIAhrIQlBGCEKIAkgCm0hC0EQIQwgBCAMaiENIA0kACALDwtkAQx/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGEO8VIQdBfyEIIAcgCHMhCUEBIQogCSAKcSELQRAhDCAEIAxqIQ0gDSQAIAsPC2UBDH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ7hUhBiAEKAIIIQcgBxDuFSEIIAYgCGshCUEYIQogCSAKbSELQRAhDCAEIAxqIQ0gDSQAIAsPC3MBDH8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAGEPIVIQcgBSgCCCEIIAgQ8hUhCSAFKAIEIQogChDyFSELIAcgCSALEPMVIQxBECENIAUgDWohDiAOJAAgDA8LdAEKfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBhDiFSAFEIIQIQcgBCAHNgIEIAQoAgghCCAFIAgQ8BUgBCgCBCEJIAUgCRDxFUEQIQogBCAKaiELIAskAA8LIgEDfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC1wBCn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCACEFQQghBiAEIAZqIQcgByEIIAggBRD0FRogBCgCCCEJQRAhCiAEIApqIQsgCyQAIAkPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ9RUhBiAEKAIIIQcgBxD1FSEIIAYhCSAIIQogCSAKRiELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPCzkBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCACAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC7wBARR/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFKAIEIQYgBCAGNgIEAkADQCAEKAIIIQcgBCgCBCEIIAchCSAIIQogCSAKRyELQQEhDCALIAxxIQ0gDUUNASAFEIcQIQ4gBCgCBCEPQWghECAPIBBqIREgBCARNgIEIBEQ+hAhEiAOIBIQ/xAMAAsACyAEKAIIIRMgBSATNgIEQRAhFCAEIBRqIRUgFSQADwuwAQEWfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRD2ECEGIAUQ9hAhByAFEIYQIQhBGCEJIAggCWwhCiAHIApqIQsgBRD2ECEMIAQoAgghDUEYIQ4gDSAObCEPIAwgD2ohECAFEPYQIREgBRCbDCESQRghEyASIBNsIRQgESAUaiEVIAUgBiALIBAgFRD3EEEQIRYgBCAWaiEXIBckAA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC9wBARt/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCDCEHIAYgB2shCEEYIQkgCCAJbSEKIAUgCjYCACAFKAIAIQtBACEMIAshDSAMIQ4gDSAOSyEPQQEhECAPIBBxIRECQCARRQ0AIAUoAgQhEiAFKAIMIRMgBSgCACEUQRghFSAUIBVsIRYgEiATIBYQ5RoaCyAFKAIEIRcgBSgCACEYQRghGSAYIBlsIRogFyAaaiEbQRAhHCAFIBxqIR0gHSQAIBsPCzkBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCACAFDwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC20BDn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQ7hUhBiAEKAIIIQcgBxDuFSEIIAYhCSAIIQogCSAKRiELQQEhDCALIAxxIQ1BECEOIAQgDmohDyAPJAAgDQ8LvAEBFH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAEIAY2AgQCQANAIAQoAgghByAEKAIEIQggByEJIAghCiAJIApHIQtBASEMIAsgDHEhDSANRQ0BIAUQgRAhDiAEKAIEIQ9BaCEQIA8gEGohESAEIBE2AgQgERDSECESIA4gEhDXEAwACwALIAQoAgghEyAFIBM2AgRBECEUIAQgFGohFSAVJAAPC7ABARZ/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAFEM4QIQYgBRDOECEHIAUQgBAhCEEYIQkgCCAJbCEKIAcgCmohCyAFEM4QIQwgBCgCCCENQRghDiANIA5sIQ8gDCAPaiEQIAUQzhAhESAFEIIQIRJBGCETIBIgE2whFCARIBRqIRUgBSAGIAsgECAVEM8QQRAhFiAEIBZqIRcgFyQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8L3AEBG38jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIMIQcgBiAHayEIQRghCSAIIAltIQogBSAKNgIAIAUoAgAhC0EAIQwgCyENIAwhDiANIA5LIQ9BASEQIA8gEHEhEQJAIBFFDQAgBSgCBCESIAUoAgwhEyAFKAIAIRRBGCEVIBQgFWwhFiASIBMgFhDlGhoLIAUoAgQhFyAFKAIAIRhBGCEZIBggGWwhGiAXIBpqIRtBECEcIAUgHGohHSAdJAAgGw8LOQEFfyMAIQJBECEDIAIgA2shBCAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQYgBSAGNgIAIAUPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBQ8LogEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAFEJENIQcgBygCACEIIAYhCSAIIQogCSAKSSELQQEhDCALIAxxIQ0CQAJAIA1FDQAgBCgCCCEOIA4Q9xUhDyAFIA8Qwg0MAQsgBCgCCCEQIBAQ9xUhESAFIBEQ+BULQRAhEiAEIBJqIRMgEyQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8L3QEBGH8jACECQSAhAyACIANrIQQgBCQAIAQgADYCHCAEIAE2AhggBCgCHCEFIAUQ+xUhBiAEIAY2AhQgBRCSDCEHQQEhCCAHIAhqIQkgBSAJEP8VIQogBRCSDCELIAQoAhQhDCAEIQ0gDSAKIAsgDBCAFhogBCgCFCEOIAQoAgghDyAPEPwVIRAgBCgCGCERIBEQwQ0hEiAOIBAgEhD9FSAEKAIIIRNBLCEUIBMgFGohFSAEIBU2AgggBCEWIAUgFhCBFiAEIRcgFxCCFhpBICEYIAQgGGohGSAZJAAPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCDFiEFQRAhBiADIAZqIQcgByQAIAUPC4MBAQ1/IwAhA0EQIQQgAyAEayEFIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBiAHNgIAIAUoAgghCCAIKAIEIQkgBiAJNgIEIAUoAgghCiAKKAIEIQsgBSgCBCEMQSwhDSAMIA1sIQ4gCyAOaiEPIAYgDzYCCCAGDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQghBSAEIAVqIQYgBhCFFiEHQRAhCCADIAhqIQkgCSQAIAcPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhwgBSABNgIYIAUgAjYCFCAFKAIcIQYgBSgCGCEHIAUoAhQhCCAIEMENIQkgBiAHIAkQhBZBICEKIAUgCmohCyALJAAPCzkBBn8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIEIQUgBCgCACEGIAYgBTYCBCAEDwuyAgElfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIYIAQgATYCFCAEKAIYIQUgBRCIFiEGIAQgBjYCECAEKAIUIQcgBCgCECEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AIAUQtRoACyAFEIkWIQ4gBCAONgIMIAQoAgwhDyAEKAIQIRBBASERIBAgEXYhEiAPIRMgEiEUIBMgFE8hFUEBIRYgFSAWcSEXAkACQCAXRQ0AIAQoAhAhGCAEIBg2AhwMAQsgBCgCDCEZQQEhGiAZIBp0IRsgBCAbNgIIQQghHCAEIBxqIR0gHSEeQRQhHyAEIB9qISAgICEhIB4gIRBnISIgIigCACEjIAQgIzYCHAsgBCgCHCEkQSAhJSAEICVqISYgJiQAICQPC64CASB/IwAhBEEgIQUgBCAFayEGIAYkACAGIAA2AhggBiABNgIUIAYgAjYCECAGIAM2AgwgBigCGCEHIAYgBzYCHEEMIQggByAIaiEJQQAhCiAGIAo2AgggBigCDCELQQghDCAGIAxqIQ0gDSEOIAkgDiALEIoWGiAGKAIUIQ8CQAJAIA9FDQAgBxCLFiEQIAYoAhQhESAQIBEQjBYhEiASIRMMAQtBACEUIBQhEwsgEyEVIAcgFTYCACAHKAIAIRYgBigCECEXQSwhGCAXIBhsIRkgFiAZaiEaIAcgGjYCCCAHIBo2AgQgBygCACEbIAYoAhQhHEEsIR0gHCAdbCEeIBsgHmohHyAHEI0WISAgICAfNgIAIAYoAhwhIUEgISIgBiAiaiEjICMkACAhDwv7AQEbfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRDiDCAFEPsVIQYgBSgCACEHIAUoAgQhCCAEKAIIIQlBBCEKIAkgCmohCyAGIAcgCCALEI4WIAQoAgghDEEEIQ0gDCANaiEOIAUgDhCPFkEEIQ8gBSAPaiEQIAQoAgghEUEIIRIgESASaiETIBAgExCPFiAFEJENIRQgBCgCCCEVIBUQjRYhFiAUIBYQjxYgBCgCCCEXIBcoAgQhGCAEKAIIIRkgGSAYNgIAIAUQkgwhGiAFIBoQkBYgBRCRFkEQIRsgBCAbaiEcIBwkAA8LlQEBEX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCCCADKAIIIQQgAyAENgIMIAQQkhYgBCgCACEFQQAhBiAFIQcgBiEIIAcgCEchCUEBIQogCSAKcSELAkAgC0UNACAEEIsWIQwgBCgCACENIAQQkxYhDiAMIA0gDhCUFgsgAygCDCEPQRAhECADIBBqIREgESQAIA8PCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDwthAQl/IwAhA0EgIQQgAyAEayEFIAUkACAFIAA2AhQgBSABNgIQIAUgAjYCDCAFKAIUIQYgBSgCECEHIAUoAgwhCCAIEMENIQkgBiAHIAkQhhZBICEKIAUgCmohCyALJAAPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCHFiEFQRAhBiADIAZqIQcgByQAIAUPC4ECAhh/BX4jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQcgBxDBDSEIIAgpAgAhGyAGIBs3AgBBKCEJIAYgCWohCiAIIAlqIQsgCygCACEMIAogDDYCAEEgIQ0gBiANaiEOIAggDWohDyAPKQIAIRwgDiAcNwIAQRghECAGIBBqIREgCCAQaiESIBIpAgAhHSARIB03AgBBECETIAYgE2ohFCAIIBNqIRUgFSkCACEeIBQgHjcCAEEIIRYgBiAWaiEXIAggFmohGCAYKQIAIR8gFyAfNwIAQRAhGSAFIBlqIRogGiQADwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LhAEBEX8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCVFiEFIAUQlhYhBiADIAY2AggQdCEHIAMgBzYCBEEIIQggAyAIaiEJIAkhCkEEIQsgAyALaiEMIAwhDSAKIA0QdSEOIA4oAgAhD0EQIRAgAyAQaiERIBEkACAPDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQlxYhBUEQIQYgAyAGaiEHIAckACAFDwt7AQx/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAcQMyEIIAYgCBCfFhpBBCEJIAYgCWohCiAFKAIEIQsgCxCgFiEMIAogDBChFhpBECENIAUgDWohDiAOJAAgBg8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQoxYhB0EQIQggAyAIaiEJIAkkACAHDwtUAQl/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgwgBCABNgIIIAQoAgwhBSAEKAIIIQZBACEHIAUgBiAHEKIWIQhBECEJIAQgCWohCiAKJAAgCA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQpBYhB0EQIQggAyAIaiEJIAkkACAHDwuBAgEffyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIcIAYgATYCGCAGIAI2AhQgBiADNgIQIAYoAhQhByAGKAIYIQggByAIayEJQSwhCiAJIAptIQsgBiALNgIMIAYoAgwhDCAGKAIQIQ0gDSgCACEOQQAhDyAPIAxrIRBBLCERIBAgEWwhEiAOIBJqIRMgDSATNgIAIAYoAgwhFEEAIRUgFCEWIBUhFyAWIBdKIRhBASEZIBggGXEhGgJAIBpFDQAgBigCECEbIBsoAgAhHCAGKAIYIR0gBigCDCEeQSwhHyAeIB9sISAgHCAdICAQ4xoaC0EgISEgBiAhaiEiICIkAA8LnwEBEn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUQqBYhBiAGKAIAIQcgBCAHNgIEIAQoAgghCCAIEKgWIQkgCSgCACEKIAQoAgwhCyALIAo2AgBBBCEMIAQgDGohDSANIQ4gDhCoFiEPIA8oAgAhECAEKAIIIREgESAQNgIAQRAhEiAEIBJqIRMgEyQADwuwAQEWfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCmFiEGIAUQphYhByAFEIkWIQhBLCEJIAggCWwhCiAHIApqIQsgBRCmFiEMIAUQiRYhDUEsIQ4gDSAObCEPIAwgD2ohECAFEKYWIREgBCgCCCESQSwhEyASIBNsIRQgESAUaiEVIAUgBiALIBAgFRCnFkEQIRYgBCAWaiEXIBckAA8LGwEDfyMAIQFBECECIAEgAmshAyADIAA2AgwPC0MBB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCBCEFIAQgBRCpFkEQIQYgAyAGaiEHIAckAA8LXgEMfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEEKsWIQUgBSgCACEGIAQoAgAhByAGIAdrIQhBLCEJIAggCW0hCkEQIQsgAyALaiEMIAwkACAKDwtaAQh/IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIMIQYgBSgCCCEHIAUoAgQhCCAGIAcgCBCqFkEQIQkgBSAJaiEKIAokAA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQmRYhB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQmBYhBUEQIQYgAyAGaiEHIAckACAFDwteAQx/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQnBYhBSAFKAIAIQYgBCgCACEHIAYgB2shCEEsIQkgCCAJbSEKQRAhCyADIAtqIQwgDCQAIAoPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCBCADKAIEIQQgBBCaFiEFQRAhBiADIAZqIQcgByQAIAUPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCbFiEFQRAhBiADIAZqIQcgByQAIAUPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMQd3oxS4hBCAEDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEIIQUgBCAFaiEGIAYQnRYhB0EQIQggAyAIaiEJIAkkACAHDws+AQd/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEIAQQnhYhBUEQIQYgAyAGaiEHIAckACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LVQEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQMxpBACEHIAUgBzYCAEEQIQggBCAIaiEJIAkkACAFDwskAQR/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBA8LUwEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAYQoBYhByAFIAc2AgBBECEIIAQgCGohCSAJJAAgBQ8LnwEBE38jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgwhBiAFKAIIIQcgBhCaFiEIIAchCSAIIQogCSAKSyELQQEhDCALIAxxIQ0CQCANRQ0AQc0KIQ4gDhCDAQALIAUoAgghD0EsIRAgDyAQbCERQQQhEiARIBIQhAEhE0EQIRQgBSAUaiEVIBUkACATDwtJAQl/IwAhAUEQIQIgASACayEDIAMkACADIAA2AgwgAygCDCEEQQQhBSAEIAVqIQYgBhClFiEHQRAhCCADIAhqIQkgCSQAIAcPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCDFiEFQRAhBiADIAZqIQcgByQAIAUPCysBBX8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEKAIAIQUgBQ8LRQEIfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIAIQUgBRD8FSEGQRAhByADIAdqIQggCCQAIAYPCzcBA38jACEFQSAhBiAFIAZrIQcgByAANgIcIAcgATYCGCAHIAI2AhQgByADNgIQIAcgBDYCDA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQrBZBECEHIAQgB2ohCCAIJAAPC2EBCn8jACEDQRAhBCADIARrIQUgBSQAIAUgADYCDCAFIAE2AgggBSACNgIEIAUoAgghBiAFKAIEIQdBLCEIIAcgCGwhCUEEIQogBiAJIAoQSUEQIQsgBSALaiEMIAwkAA8LSQEJfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBEEMIQUgBCAFaiEGIAYQsBYhB0EQIQggAyAIaiEJIAkkACAHDwugAQESfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUCQANAIAQoAgAhBiAFKAIIIQcgBiEIIAchCSAIIAlHIQpBASELIAogC3EhDCAMRQ0BIAUQixYhDSAFKAIIIQ5BVCEPIA4gD2ohECAFIBA2AgggEBD8FSERIA0gERCtFgwACwALQRAhEiAEIBJqIRMgEyQADwtKAQd/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBSAEKAIYIQYgBSAGEK4WQSAhByAEIAdqIQggCCQADwtKAQd/IwAhAkEQIQMgAiADayEEIAQkACAEIAA2AgQgBCABNgIAIAQoAgQhBSAEKAIAIQYgBSAGEK8WQRAhByAEIAdqIQggCCQADwsiAQN/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AggPCz4BB38jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCeFiEFQRAhBiADIAZqIQcgByQAIAUPCzkBBX8jACECQRAhAyACIANrIQQgBCAANgIMIAQgATYCCCAEKAIMIQUgBCgCCCEGIAUgBjYCACAFDwuPAQENfyMAIQVBICEGIAUgBmshByAHJAAgByAANgIcIAcgATYCGCAHIAI2AhQgByADNgIQIAcgBDYCDCAHKAIcIQggBygCGCEJIAcoAhQhCiAKELECIQsgBygCECEMIAwQsQIhDSAHKAIMIQ4gDhDSCSEPIAggCSALIA0gDxCzFkEgIRAgByAQaiERIBEkAA8LjwEBDX8jACEFQSAhBiAFIAZrIQcgByQAIAcgADYCFCAHIAE2AhAgByACNgIMIAcgAzYCCCAHIAQ2AgQgBygCFCEIIAcoAhAhCSAHKAIMIQogChCxAiELIAcoAgghDCAMELECIQ0gBygCBCEOIA4Q0gkhDyAIIAkgCyANIA8QtBZBICEQIAcgEGohESARJAAPC88CAiR/An4jACEFQdAAIQYgBSAGayEHIAckACAHIAA2AkwgByABNgJIIAcgAjYCRCAHIAM2AkAgByAENgI8IAcoAkghCCAHKAJEIQkgCRCxAiEKQTAhCyAHIAtqIQwgDCENIA0gChC3DBogBygCQCEOIA4QsQIhD0EgIRAgByAQaiERIBEhEiASIA8QtwwaIAcoAjwhEyATENIJIRQgFC0AACEVQQghFkEQIRcgByAXaiEYIBggFmohGUEwIRogByAaaiEbIBsgFmohHCAcKAIAIR0gGSAdNgIAIAcpAzAhKSAHICk3AxAgByAWaiEeQSAhHyAHIB9qISAgICAWaiEhICEoAgAhIiAeICI2AgAgBykDICEqIAcgKjcDAEEBISMgFSAjcSEkQRAhJSAHICVqISYgCCAmIAcgJBC8DBpB0AAhJyAHICdqISggKCQADwsrAQV/IwAhAUEQIQIgASACayEDIAMgADYCDCADKAIMIQQgBCgCACEFIAUPC7MBARV/IwAhAkEgIQMgAiADayEEIAQkACAEIAA2AhwgBCABNgIYIAQoAhwhBUEIIQYgBCAGaiEHIAchCEEBIQkgCCAFIAkQ+hUaIAUQ+xUhCiAEKAIMIQsgCxD8FSEMIAQoAhghDSANELkWIQ4gCiAMIA4QuhYgBCgCDCEPQSwhECAPIBBqIREgBCARNgIMQQghEiAEIBJqIRMgEyEUIBQQ/hUaQSAhFSAEIBVqIRYgFiQADwvdAQEYfyMAIQJBICEDIAIgA2shBCAEJAAgBCAANgIcIAQgATYCGCAEKAIcIQUgBRD7FSEGIAQgBjYCFCAFEJIMIQdBASEIIAcgCGohCSAFIAkQ/xUhCiAFEJIMIQsgBCgCFCEMIAQhDSANIAogCyAMEIAWGiAEKAIUIQ4gBCgCCCEPIA8Q/BUhECAEKAIYIREgERC5FiESIA4gECASELoWIAQoAgghE0EsIRQgEyAUaiEVIAQgFTYCCCAEIRYgBSAWEIEWIAQhFyAXEIIWGkEgIRggBCAYaiEZIBkkAA8L2QEBFn8jACECQRAhAyACIANrIQQgBCQAIAQgADYCBCAEIAE2AgAgBCgCBCEFIAUQvRYgBCgCACEGIAUgBhC+FiAEKAIAIQcgBygCACEIIAUgCDYCACAEKAIAIQkgCSgCBCEKIAUgCjYCBCAEKAIAIQsgCxCRDSEMIAwoAgAhDSAFEJENIQ4gDiANNgIAIAQoAgAhDyAPEJENIRBBACERIBAgETYCACAEKAIAIRJBACETIBIgEzYCBCAEKAIAIRRBACEVIBQgFTYCAEEQIRYgBCAWaiEXIBckAA8LJAEEfyMAIQFBECECIAEgAmshAyADIAA2AgwgAygCDCEEIAQPC2EBCX8jACEDQSAhBCADIARrIQUgBSQAIAUgADYCHCAFIAE2AhggBSACNgIUIAUoAhwhBiAFKAIYIQcgBSgCFCEIIAgQuRYhCSAGIAcgCRC7FkEgIQogBSAKaiELIAskAA8LYQEJfyMAIQNBICEEIAMgBGshBSAFJAAgBSAANgIUIAUgATYCECAFIAI2AgwgBSgCFCEGIAUoAhAhByAFKAIMIQggCBC5FiEJIAYgByAJELwWQSAhCiAFIApqIQsgCyQADwuBAgIYfwV+IwAhA0EQIQQgAyAEayEFIAUkACAFIAA2AgwgBSABNgIIIAUgAjYCBCAFKAIIIQYgBSgCBCEHIAcQuRYhCCAIKQIAIRsgBiAbNwIAQSghCSAGIAlqIQogCCAJaiELIAsoAgAhDCAKIAw2AgBBICENIAYgDWohDiAIIA1qIQ8gDykCACEcIA4gHDcCAEEYIRAgBiAQaiERIAggEGohEiASKQIAIR0gESAdNwIAQRAhEyAGIBNqIRQgCCATaiEVIBUpAgAhHiAUIB43AgBBCCEWIAYgFmohFyAIIBZqIRggGCkCACEfIBcgHzcCAEEQIRkgBSAZaiEaIBokAA8LrQEBFH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBCgCACEFQQAhBiAFIQcgBiEIIAcgCEchCUEBIQogCSAKcSELAkAgC0UNACAEEL8WIAQQ+xUhDCAEKAIAIQ0gBBCJFiEOIAwgDSAOEJQWIAQQkQ0hD0EAIRAgDyAQNgIAQQAhESAEIBE2AgRBACESIAQgEjYCAAtBECETIAMgE2ohFCAUJAAPC0oBB38jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAYQwBZBECEHIAQgB2ohCCAIJAAPC1sBCH8jACEBQRAhAiABIAJrIQMgAyQAIAMgADYCDCADKAIMIQQgBBCSDCEFIAMgBTYCCCAEEMEWIAMoAgghBiAEIAYQwhYgBBCRFkEQIQcgAyAHaiEIIAgkAA8LVgEIfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIEIAQgATYCACAEKAIEIQUgBCgCACEGIAYQ+xUhByAHEMQWGiAFEPsVGkEQIQggBCAIaiEJIAkkAA8LQwEHfyMAIQFBECECIAEgAmshAyADJAAgAyAANgIMIAMoAgwhBCAEKAIAIQUgBCAFEMMWQRAhBiADIAZqIQcgByQADwuwAQEWfyMAIQJBECEDIAIgA2shBCAEJAAgBCAANgIMIAQgATYCCCAEKAIMIQUgBRCmFiEGIAUQphYhByAFEIkWIQhBLCEJIAggCWwhCiAHIApqIQsgBRCmFiEMIAQoAgghDUEsIQ4gDSAObCEPIAwgD2ohECAFEKYWIREgBRCSDCESQSwhEyASIBNsIRQgESAUaiEVIAUgBiALIBAgFRCnFkEQIRYgBCAWaiEXIBckAA8LvAEBFH8jACECQRAhAyACIANrIQQgBCQAIAQgADYCDCAEIAE2AgggBCgCDCEFIAUoAgQhBiAEIAY2AgQCQANAIAQoAgghByAEKAIEIQggByEJIAghCiAJIApHIQtBASEMIAsgDHEhDSANRQ0BIAUQ+xUhDiAEKAIEIQ9BVCEQIA8gEGohESAEIBE2AgQgERD8FSESIA4gEhCtFgwACwALIAQoAgghEyAFIBM2AgRBECEUIAQgFGohFSAVJAAPCyQBBH8jACEBQRAhAiABIAJrIQMgAyAANgIMIAMoAgwhBCAEDws5AQV/IwAhAkEQIQMgAiADayEEIAQgADYCDCAEIAE2AgggBCgCDCEFIAQoAgghBiAFIAY2AgAgBQ8LWgEIfyMAIQNBECEEIAMgBGshBSAFJAAgBSAANgIMIAUgATYCCCAFIAI2AgQgBSgCDCEGIAUoAgghByAFKAIEIQggBiAHIAgQxxZBECEJIAUgCWohCiAKJAAPC8QbAeMCfyMAIQNBMCEEIAMgBGshBSAFJAAgBSAANgIsIAUgATYCKCAFIAI2AiRBHiEGIAUgBjYCIANAAkACQANAIAUoAighByAFKAIsIQggByAIayEJQSwhCiAJIAptIQsgBSALNgIcIAUoAhwhDEEFIQ0gDCANSxoCQAJAAkACQAJAAkAgDA4GAAABAgMEBQsMBwsgBSgCJCEOIA4oAgAhDyAFKAIoIRBBVCERIBAgEWohEiAFIBI2AiggBSgCLCETIBIgEyAPEQEAIRRBASEVIBQgFXEhFgJAIBZFDQAgBSgCLCEXIAUoAighGCAXIBgQyBYLDAYLIAUoAiwhGSAFKAIsIRpBLCEbIBogG2ohHCAFKAIoIR1BVCEeIB0gHmohHyAFIB82AiggBSgCJCEgIBkgHCAfICAQyRYaDAULIAUoAiwhISAFKAIsISJBLCEjICIgI2ohJCAFKAIsISVB2AAhJiAlICZqIScgBSgCKCEoQVQhKSAoIClqISogBSAqNgIoIAUoAiQhKyAhICQgJyAqICsQyhYaDAQLIAUoAiwhLCAFKAIsIS1BLCEuIC0gLmohLyAFKAIsITBB2AAhMSAwIDFqITIgBSgCLCEzQYQBITQgMyA0aiE1IAUoAighNkFUITcgNiA3aiE4IAUgODYCKCAFKAIkITkgLCAvIDIgNSA4IDkQyxYaDAMLIAUoAhwhOkEeITsgOiE8IDshPSA8ID1MIT5BASE/ID4gP3EhQAJAIEBFDQAgBSgCLCFBIAUoAighQiAFKAIkIUMgQSBCIEMQzBYMAwsgBSgCLCFEIAUgRDYCGCAFKAIoIUUgBSBFNgIUIAUoAhQhRkFUIUcgRiBHaiFIIAUgSDYCFCAFKAIcIUlB6AchSiBJIUsgSiFMIEsgTE4hTUEBIU4gTSBOcSFPAkACQCBPRQ0AIAUoAhwhUEECIVEgUCBRbSFSIAUgUjYCDCAFKAIMIVMgBSgCGCFUQSwhVSBTIFVsIVYgVCBWaiFXIAUgVzYCGCAFKAIMIVhBAiFZIFggWW0hWiAFIFo2AgwgBSgCLCFbIAUoAiwhXCAFKAIMIV1BLCFeIF0gXmwhXyBcIF9qIWAgBSgCGCFhIAUoAhghYiAFKAIMIWNBLCFkIGMgZGwhZSBiIGVqIWYgBSgCFCFnIAUoAiQhaCBbIGAgYSBmIGcgaBDLFiFpIAUgaTYCEAwBCyAFKAIcIWpBAiFrIGoga20hbCAFIGw2AgwgBSgCDCFtIAUoAhghbkEsIW8gbSBvbCFwIG4gcGohcSAFIHE2AhggBSgCLCFyIAUoAhghcyAFKAIUIXQgBSgCJCF1IHIgcyB0IHUQyRYhdiAFIHY2AhALIAUoAiwhdyAFIHc2AgggBSgCFCF4IAUgeDYCBCAFKAIkIXkgeSgCACF6IAUoAggheyAFKAIYIXwgeyB8IHoRAQAhfUEBIX4gfSB+cSF/IH8NAQNAIAUoAgghgAEgBSgCBCGBAUFUIYIBIIEBIIIBaiGDASAFIIMBNgIEIIABIYQBIIMBIYUBIIQBIIUBRiGGAUEBIYcBIIYBIIcBcSGIAQJAIIgBRQ0AIAUoAgghiQFBLCGKASCJASCKAWohiwEgBSCLATYCCCAFKAIoIYwBIAUgjAE2AgQgBSgCJCGNASCNASgCACGOASAFKAIsIY8BIAUoAgQhkAFBVCGRASCQASCRAWohkgEgBSCSATYCBCCPASCSASCOAREBACGTAUEBIZQBIJMBIJQBcSGVAQJAIJUBDQADQCAFKAIIIZYBIAUoAgQhlwEglgEhmAEglwEhmQEgmAEgmQFGIZoBQQEhmwEgmgEgmwFxIZwBAkAgnAFFDQAMBwsgBSgCJCGdASCdASgCACGeASAFKAIsIZ8BIAUoAgghoAEgnwEgoAEgngERAQAhoQFBASGiASChASCiAXEhowECQAJAIKMBRQ0AIAUoAgghpAEgBSgCBCGlASCkASClARDIFiAFKAIQIaYBQQEhpwEgpgEgpwFqIagBIAUgqAE2AhAgBSgCCCGpAUEsIaoBIKkBIKoBaiGrASAFIKsBNgIIDAELIAUoAgghrAFBLCGtASCsASCtAWohrgEgBSCuATYCCAwBCwsLIAUoAgghrwEgBSgCBCGwASCvASGxASCwASGyASCxASCyAUYhswFBASG0ASCzASC0AXEhtQECQCC1AUUNAAwFCwNAAkADQCAFKAIkIbYBILYBKAIAIbcBIAUoAiwhuAEgBSgCCCG5ASC4ASC5ASC3AREBACG6AUF/IbsBILoBILsBcyG8AUEBIb0BILwBIL0BcSG+ASC+AUUNASAFKAIIIb8BQSwhwAEgvwEgwAFqIcEBIAUgwQE2AggMAAsACwJAA0AgBSgCJCHCASDCASgCACHDASAFKAIsIcQBIAUoAgQhxQFBVCHGASDFASDGAWohxwEgBSDHATYCBCDEASDHASDDAREBACHIAUEBIckBIMgBIMkBcSHKASDKAUUNAQwACwALIAUoAgghywEgBSgCBCHMASDLASHNASDMASHOASDNASDOAU8hzwFBASHQASDPASDQAXEh0QECQAJAINEBRQ0ADAELIAUoAggh0gEgBSgCBCHTASDSASDTARDIFiAFKAIQIdQBQQEh1QEg1AEg1QFqIdYBIAUg1gE2AhAgBSgCCCHXAUEsIdgBINcBINgBaiHZASAFINkBNgIIDAELCyAFKAIIIdoBIAUg2gE2AiwMAgsgBSgCJCHbASDbASgCACHcASAFKAIEId0BIAUoAhgh3gEg3QEg3gEg3AERAQAh3wFBASHgASDfASDgAXEh4QECQAJAIOEBRQ0AIAUoAggh4gEgBSgCBCHjASDiASDjARDIFiAFKAIQIeQBQQEh5QEg5AEg5QFqIeYBIAUg5gE2AhAMAQsMAQsLCwsgBSgCCCHnAUEsIegBIOcBIOgBaiHpASAFIOkBNgIIIAUoAggh6gEgBSgCBCHrASDqASHsASDrASHtASDsASDtAUkh7gFBASHvASDuASDvAXEh8AECQCDwAUUNAANAAkADQCAFKAIkIfEBIPEBKAIAIfIBIAUoAggh8wEgBSgCGCH0ASDzASD0ASDyAREBACH1AUEBIfYBIPUBIPYBcSH3ASD3AUUNASAFKAIIIfgBQSwh+QEg+AEg+QFqIfoBIAUg+gE2AggMAAsACwJAA0AgBSgCJCH7ASD7ASgCACH8ASAFKAIEIf0BQVQh/gEg/QEg/gFqIf8BIAUg/wE2AgQgBSgCGCGAAiD/ASCAAiD8AREBACGBAkF/IYICIIECIIICcyGDAkEBIYQCIIMCIIQCcSGFAiCFAkUNAQwACwALIAUoAgghhgIgBSgCBCGHAiCGAiGIAiCHAiGJAiCIAiCJAkshigJBASGLAiCKAiCLAnEhjAICQAJAIIwCRQ0ADAELIAUoAgghjQIgBSgCBCGOAiCNAiCOAhDIFiAFKAIQIY8CQQEhkAIgjwIgkAJqIZECIAUgkQI2AhAgBSgCGCGSAiAFKAIIIZMCIJICIZQCIJMCIZUCIJQCIJUCRiGWAkEBIZcCIJYCIJcCcSGYAgJAIJgCRQ0AIAUoAgQhmQIgBSCZAjYCGAsgBSgCCCGaAkEsIZsCIJoCIJsCaiGcAiAFIJwCNgIIDAELCwsgBSgCCCGdAiAFKAIYIZ4CIJ0CIZ8CIJ4CIaACIJ8CIKACRyGhAkEBIaICIKECIKICcSGjAgJAIKMCRQ0AIAUoAiQhpAIgpAIoAgAhpQIgBSgCGCGmAiAFKAIIIacCIKYCIKcCIKUCEQEAIagCQQEhqQIgqAIgqQJxIaoCIKoCRQ0AIAUoAgghqwIgBSgCGCGsAiCrAiCsAhDIFiAFKAIQIa0CQQEhrgIgrQIgrgJqIa8CIAUgrwI2AhALIAUoAhAhsAICQCCwAg0AIAUoAiwhsQIgBSgCCCGyAiAFKAIkIbMCILECILICILMCEM0WIbQCQQEhtQIgtAIgtQJxIbYCIAUgtgI6AAMgBSgCCCG3AkEsIbgCILcCILgCaiG5AiAFKAIoIboCIAUoAiQhuwIguQIgugIguwIQzRYhvAJBASG9AiC8AiC9AnEhvgICQCC+AkUNACAFLQADIb8CQQEhwAIgvwIgwAJxIcECAkAgwQJFDQAMAwsgBSgCCCHCAiAFIMICNgIoDAMLIAUtAAMhwwJBASHEAiDDAiDEAnEhxQICQCDFAkUNACAFKAIIIcYCQSwhxwIgxgIgxwJqIcgCIAUgyAI2AgggBSDIAjYCLAwDCwsgBSgCCCHJAiAFKAIsIcoCIMkCIMoCayHLAkEsIcwCIMsCIMwCbSHNAiAFKAIoIc4CIAUoAgghzwIgzgIgzwJrIdACQSwh0QIg0AIg0QJtIdICIM0CIdMCINICIdQCINMCINQCSCHVAkEBIdYCINUCINYCcSHXAgJAAkAg1wJFDQAgBSgCLCHYAiAFKAIIIdkCIAUoAiQh2gIg2AIg2QIg2gIQxxYgBSgCCCHbAkEsIdwCINsCINwCaiHdAiAFIN0CNgIIIAUg3QI2AiwMAQsgBSgCCCHeAkEsId8CIN4CIN8CaiHgAiAFKAIoIeECIAUoAiQh4gIg4AIg4QIg4gIQxxYgBSgCCCHjAiAFIOMCNgIoCwwBCwtBMCHkAiAFIOQCaiHlAiDlAiQADwuSBQJCfw9+IwAhAkHAACEDIAIgA2shBCAEJAAgBCAANgI8IAQgATYCOCAEKAI8IQUgBRD3FSEGQQghByAEIAdqIQggCCEJIAYpAgAhRCAJIEQ3AgBBKCEKIAkgCmohCyAGIApqIQwgDCgCACENIAsgDTYCAEEgIQ4gCSAOaiEPIAYgDmohECAQKQIAIUUgDyBFNwIAQRghESAJIBFqIRIgBiARaiETIBMpAgAhRiASIEY3AgBBECEUIAkgFGohFSAGIBRqIRYgFikCACFHIBUgRzcCAEEIIRcgCSAXaiEYIAYgF2ohGSAZKQIAIUggGCBINwIAIAQoAjghGiAaEPcVIRsgBCgCPCEcIBspAgAhSSAcIEk3AgBBKCEdIBwgHWohHiAbIB1qIR8gHygCACEgIB4gIDYCAEEgISEgHCAhaiEiIBsgIWohIyAjKQIAIUogIiBKNwIAQRghJCAcICRqISUgGyAkaiEmICYpAgAhSyAlIEs3AgBBECEnIBwgJ2ohKCAbICdqISkgKSkCACFMICggTDcCAEEIISogHCAqaiErIBsgKmohLCAsKQIAIU0gKyBNNwIAQQghLSAEIC1qIS4gLiEvIC8Q9xUhMCAEKAI4ITEgMCkCACFOIDEgTjcCAEEoITIgMSAyaiEzIDAgMmohNCA0KAIAITUgMyA1NgIAQSAhNiAxIDZqITcgMCA2aiE4IDgpAgAhTyA3IE83AgBBGCE5IDEgOWohOiAwIDlqITsgOykCACFQIDogUDcCAEEQITwgMSA8aiE9IDAgPGohPiA+KQIAIVEgPSBRNwIAQQghPyAxID9qIUAgMCA/aiFBIEEpAgAhUiBAIFI3AgBBwAAhQiAEIEJqIUMgQyQADwvYBAE9fyMAIQRBICEFIAQgBWshBiAGJAAgBiAANgIYIAYgATYCFCAGIAI2AhAgBiADNgIMQQAhByAGIAc2AgggBigCDCEIIAgoAgAhCSAGKAIUIQogBigCGCELIAogCyAJEQEAIQxBASENIAwgDXEhDgJAAkAgDg0AIAYoAgwhDyAPKAIAIRAgBigCECERIAYoAhQhEiARIBIgEBEBACETQQEhFCATIBRxIRUCQCAVDQAgBigCCCEWIAYgFjYCHAwCCyAGKAIUIRcgBigCECEYIBcgGBDIFkEBIRkgBiAZNgIIIAYoAgwhGiAaKAIAIRsgBigCFCEcIAYoAhghHSAcIB0gGxEBACEeQQEhHyAeIB9xISACQCAgRQ0AIAYoAhghISAGKAIUISIgISAiEMgWQQIhIyAGICM2AggLIAYoAgghJCAGICQ2AhwMAQsgBigCDCElICUoAgAhJiAGKAIQIScgBigCFCEoICcgKCAmEQEAISlBASEqICkgKnEhKwJAICtFDQAgBigCGCEsIAYoAhAhLSAsIC0QyBZBASEuIAYgLjYCCCAGKAIIIS8gBiAvNgIcDAELIAYoAhghMCAGKAIUITEgMCAxEMgWQQEhMiAGIDI2AgggBigCDCEzIDMoAgAhNCAGKAIQITUgBigCFCE2IDUgNiA0EQEAITdBASE4IDcgOHEhOQJAIDlFDQAgBigCFCE6IAYoAhAhOyA6IDsQyBZBAiE8IAYgPDYCCAsgBigCCCE9IAYgPTYCHAsgBigCHCE+QSAhPyAGID9qIUAgQCQAID4PC7sDAS9/IwAhBUEgIQYgBSAGayEHIAckACAHIAA2AhwgByABNgIYIAcgAjYCFCAHIAM2AhAgByAENgIMIAcoAhwhCCAHKAIYIQkgBygCFCEKIAcoAgwhCyAIIAkgCiALEMkWIQwgByAMNgIIIAcoAgwhDSANKAIAIQ4gBygCECEPIAcoAhQhECAPIBAgDhEBACERQQEhEiARIBJxIRMCQCATRQ0AIAcoAhQhFCAHKAIQIRUgFCAVEMgWIAcoAgghFkEBIRcgFiAXaiEYIAcgGDYCCCAHKAIMIRkgGSgCACEaIAcoAhQhGyAHKAIYIRwgGyAcIBoRAQAhHUEBIR4gHSAecSEfAkAgH0UNACAHKAIYISAgBygCFCEhICAgIRDIFiAHKAIIISJBASEjICIgI2ohJCAHICQ2AgggBygCDCElICUoAgAhJiAHKAIYIScgBygCHCEoICcgKCAmEQEAISlBASEqICkgKnEhKwJAICtFDQAgBygCHCEsIAcoAhghLSAsIC0QyBYgBygCCCEuQQEhLyAuIC9qITAgByAwNgIICwsLIAcoAgghMUEgITIgByAyaiEzIDMkACAxDwuzBAE8fyMAIQZBICEHIAYgB2shCCAIJAAgCCAANgIcIAggATYCGCAIIAI2AhQgCCADNgIQIAggBDYCDCAIIAU2AgggCCgCHCEJIAgoAhghCiAIKAIUIQsgCCgCECEMIAgoAgghDSAJIAogCyAMIA0QyhYhDiAIIA42AgQgCCgCCCEPIA8oAgAhECAIKAIMIREgCCgCECESIBEgEiAQEQEAIRNBASEUIBMgFHEhFQJAIBVFDQAgCCgCECEWIAgoAgwhFyAWIBcQyBYgCCgCBCEYQQEhGSAYIBlqIRogCCAaNgIEIAgoAgghGyAbKAIAIRwgCCgCECEdIAgoAhQhHiAdIB4gHBEBACEfQQEhICAfICBxISECQCAhRQ0AIAgoAhQhIiAIKAIQISMgIiAjEMgWIAgoAgQhJEEBISUgJCAlaiEmIAggJjYCBCAIKAIIIScgJygCACEoIAgoAhQhKSAIKAIYISogKSAqICgRAQAhK0EBISwgKyAscSEtAkAgLUUNACAIKAIYIS4gCCgCFCEvIC4gLxDIFiAIKAIEITBBASExIDAgMWohMiAIIDI2AgQgCCgCCCEzIDMoAgAhNCAIKAIYITUgCCgCHCE2IDUgNiA0EQEAITdBASE4IDcgOHEhOQJAIDlFDQAgCCgCHCE6IAgoAhghOyA6IDsQyBYgCCgCBCE8QQEhPSA8ID1qIT4gCCA+NgIECwsLCyAIKAIEIT9BICFAIAggQGohQSBBJAAgPw8L5wgCeH8PfiMAIQNB0AAhBCADIARrIQUgBSQAIAUgADYCTCAFIAE2AkggBSACNgJEIAUoAkwhBkHYACEHIAYgB2ohCCAFIAg2AkAgBSgCTCEJIAUoAkwhCkEsIQsgCiALaiEMIAUoAkAhDSAFKAJEIQ4gCSAMIA0gDhDJFhogBSgCQCEPQSwhECAPIBBqIREgBSARNgI8AkADQCAFKAI8IRIgBSgCSCETIBIhFCATIRUgFCAVRyEWQQEhFyAWIBdxIRggGEUNASAFKAJEIRkgGSgCACEaIAUoAjwhGyAFKAJAIRwgGyAcIBoRAQAhHUEBIR4gHSAecSEfAkAgH0UNACAFKAI8ISAgIBD3FSEhQRAhIiAFICJqISMgIyEkICEpAgAheyAkIHs3AgBBKCElICQgJWohJiAhICVqIScgJygCACEoICYgKDYCAEEgISkgJCApaiEqICEgKWohKyArKQIAIXwgKiB8NwIAQRghLCAkICxqIS0gISAsaiEuIC4pAgAhfSAtIH03AgBBECEvICQgL2ohMCAhIC9qITEgMSkCACF+IDAgfjcCAEEIITIgJCAyaiEzICEgMmohNCA0KQIAIX8gMyB/NwIAIAUoAkAhNSAFIDU2AgwgBSgCPCE2IAUgNjYCQANAIAUoAgwhNyA3EPcVITggBSgCQCE5IDgpAgAhgAEgOSCAATcCAEEoITogOSA6aiE7IDggOmohPCA8KAIAIT0gOyA9NgIAQSAhPiA5ID5qIT8gOCA+aiFAIEApAgAhgQEgPyCBATcCAEEYIUEgOSBBaiFCIDggQWohQyBDKQIAIYIBIEIgggE3AgBBECFEIDkgRGohRSA4IERqIUYgRikCACGDASBFIIMBNwIAQQghRyA5IEdqIUggOCBHaiFJIEkpAgAhhAEgSCCEATcCACAFKAIMIUogBSBKNgJAIAUoAkAhSyAFKAJMIUwgSyFNIEwhTiBNIE5HIU9BACFQQQEhUSBPIFFxIVIgUCFTAkAgUkUNACAFKAJEIVQgVCgCACFVIAUoAgwhVkFUIVcgViBXaiFYIAUgWDYCDEEQIVkgBSBZaiFaIFohWyBbIFggVREBACFcIFwhUwsgUyFdQQEhXiBdIF5xIV8gXw0AC0EQIWAgBSBgaiFhIGEhYiBiEPcVIWMgBSgCQCFkIGMpAgAhhQEgZCCFATcCAEEoIWUgZCBlaiFmIGMgZWohZyBnKAIAIWggZiBoNgIAQSAhaSBkIGlqIWogYyBpaiFrIGspAgAhhgEgaiCGATcCAEEYIWwgZCBsaiFtIGMgbGohbiBuKQIAIYcBIG0ghwE3AgBBECFvIGQgb2ohcCBjIG9qIXEgcSkCACGIASBwIIgBNwIAQQghciBkIHJqIXMgYyByaiF0IHQpAgAhiQEgcyCJATcCAAsgBSgCPCF1IAUgdTYCQCAFKAI8IXZBLCF3IHYgd2oheCAFIHg2AjwMAAsAC0HQACF5IAUgeWoheiB6JAAPC6gQAtMBfw9+IwAhA0HgACEEIAMgBGshBSAFJAAgBSAANgJYIAUgATYCVCAFIAI2AlAgBSgCVCEGIAUoAlghByAGIAdrIQhBLCEJIAggCW0hCkEFIQsgCiALSxoCQAJAAkACQAJAAkACQCAKDgYAAAECAwQFC0EBIQxBASENIAwgDXEhDiAFIA46AF8MBQsgBSgCUCEPIA8oAgAhECAFKAJUIRFBVCESIBEgEmohEyAFIBM2AlQgBSgCWCEUIBMgFCAQEQEAIRVBASEWIBUgFnEhFwJAIBdFDQAgBSgCWCEYIAUoAlQhGSAYIBkQyBYLQQEhGkEBIRsgGiAbcSEcIAUgHDoAXwwECyAFKAJYIR0gBSgCWCEeQSwhHyAeIB9qISAgBSgCVCEhQVQhIiAhICJqISMgBSAjNgJUIAUoAlAhJCAdICAgIyAkEMkWGkEBISVBASEmICUgJnEhJyAFICc6AF8MAwsgBSgCWCEoIAUoAlghKUEsISogKSAqaiErIAUoAlghLEHYACEtICwgLWohLiAFKAJUIS9BVCEwIC8gMGohMSAFIDE2AlQgBSgCUCEyICggKyAuIDEgMhDKFhpBASEzQQEhNCAzIDRxITUgBSA1OgBfDAILIAUoAlghNiAFKAJYITdBLCE4IDcgOGohOSAFKAJYITpB2AAhOyA6IDtqITwgBSgCWCE9QYQBIT4gPSA+aiE/IAUoAlQhQEFUIUEgQCBBaiFCIAUgQjYCVCAFKAJQIUMgNiA5IDwgPyBCIEMQyxYaQQEhREEBIUUgRCBFcSFGIAUgRjoAXwwBCyAFKAJYIUdB2AAhSCBHIEhqIUkgBSBJNgJMIAUoAlghSiAFKAJYIUtBLCFMIEsgTGohTSAFKAJMIU4gBSgCUCFPIEogTSBOIE8QyRYaQQghUCAFIFA2AkhBACFRIAUgUTYCRCAFKAJMIVJBLCFTIFIgU2ohVCAFIFQ2AkACQANAIAUoAkAhVSAFKAJUIVYgVSFXIFYhWCBXIFhHIVlBASFaIFkgWnEhWyBbRQ0BIAUoAlAhXCBcKAIAIV0gBSgCQCFeIAUoAkwhXyBeIF8gXREBACFgQQEhYSBgIGFxIWICQCBiRQ0AIAUoAkAhYyBjEPcVIWRBECFlIAUgZWohZiBmIWcgZCkCACHWASBnINYBNwIAQSghaCBnIGhqIWkgZCBoaiFqIGooAgAhayBpIGs2AgBBICFsIGcgbGohbSBkIGxqIW4gbikCACHXASBtINcBNwIAQRghbyBnIG9qIXAgZCBvaiFxIHEpAgAh2AEgcCDYATcCAEEQIXIgZyByaiFzIGQgcmohdCB0KQIAIdkBIHMg2QE3AgBBCCF1IGcgdWohdiBkIHVqIXcgdykCACHaASB2INoBNwIAIAUoAkwheCAFIHg2AgwgBSgCQCF5IAUgeTYCTANAIAUoAgwheiB6EPcVIXsgBSgCTCF8IHspAgAh2wEgfCDbATcCAEEoIX0gfCB9aiF+IHsgfWohfyB/KAIAIYABIH4ggAE2AgBBICGBASB8IIEBaiGCASB7IIEBaiGDASCDASkCACHcASCCASDcATcCAEEYIYQBIHwghAFqIYUBIHsghAFqIYYBIIYBKQIAId0BIIUBIN0BNwIAQRAhhwEgfCCHAWohiAEgeyCHAWohiQEgiQEpAgAh3gEgiAEg3gE3AgBBCCGKASB8IIoBaiGLASB7IIoBaiGMASCMASkCACHfASCLASDfATcCACAFKAIMIY0BIAUgjQE2AkwgBSgCTCGOASAFKAJYIY8BII4BIZABII8BIZEBIJABIJEBRyGSAUEAIZMBQQEhlAEgkgEglAFxIZUBIJMBIZYBAkAglQFFDQAgBSgCUCGXASCXASgCACGYASAFKAIMIZkBQVQhmgEgmQEgmgFqIZsBIAUgmwE2AgxBECGcASAFIJwBaiGdASCdASGeASCeASCbASCYAREBACGfASCfASGWAQsglgEhoAFBASGhASCgASChAXEhogEgogENAAtBECGjASAFIKMBaiGkASCkASGlASClARD3FSGmASAFKAJMIacBIKYBKQIAIeABIKcBIOABNwIAQSghqAEgpwEgqAFqIakBIKYBIKgBaiGqASCqASgCACGrASCpASCrATYCAEEgIawBIKcBIKwBaiGtASCmASCsAWohrgEgrgEpAgAh4QEgrQEg4QE3AgBBGCGvASCnASCvAWohsAEgpgEg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AAAAAADwv6AhAAwBCyAAIAOgIQAgA0QAAAAAAADgv2VBAXMNACAARAAAAAAAAPA/oCEACyAAIACaIAFCf1UbIQALIAALJAACQCAAEKIaIgCZRAAAAAAAAOBBY0UNACAAqg8LQYCAgIB4CxEBAX8gACAAQR91IgFqIAFzC+ABAgF/An5BASEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AAkAgAiAAhCAGIAWEhFBFDQBBAA8LAkAgAyABg0IAUw0AQX8hBCAAIAJUIAEgA1MgASADURsNASAAIAKFIAEgA4WEQgBSDwtBfyEEIAAgAlYgASADVSABIANRGw0AIAAgAoUgASADhYRCAFIhBAsgBAvYAQIBfwJ+QX8hBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNAAJAIAIgAIQgBiAFhIRQRQ0AQQAPCwJAIAMgAYNCAFMNACAAIAJUIAEgA1MgASADURsNASAAIAKFIAEgA4WEQgBSDwsgACACViABIANVIAEgA1EbDQAgACAChSABIAOFhEIAUiEECyAEC1MBAX4CQAJAIANBwABxRQ0AIAEgA0FAaq2GIQJCACEBDAELIANFDQAgAUHAACADa62IIAIgA60iBIaEIQIgASAEhiEBCyAAIAE3AwAgACACNwMIC48BAgJ/AX4jAEEQayICJAACQAJAIAFQRQ0AQgAhAUIAIQQMAQsgAiABIAFCP4ciBHwgBIUiBEIAIAR5pyIDQTFqEKcaIAJBCGopAwBCgICAgICAwACFQb6AASADa61CMIZ8IAFCgICAgICAgICAf4OEIQQgAikDACEBCyAAIAE3AwAgACAENwMIIAJBEGokAAsEAEEACwQAQQAL+AoCBH8EfiMAQfAAayIFJAAgBEL///////////8AgyEJAkACQAJAIAFCf3wiCkJ/USACQv///////////wCDIgsgCiABVK18Qn98IgpC////////v///AFYgCkL///////+///8AURsNACADQn98IgpCf1IgCSAKIANUrXxCf3wiCkL///////+///8AVCAKQv///////7///wBRGw0BCwJAIAFQIAtCgICAgICAwP//AFQgC0KAgICAgIDA//8AURsNACACQoCAgICAgCCEIQQgASEDDAILAkAgA1AgCUKAgICAgIDA//8AVCAJQoCAgICAgMD//wBRGw0AIARCgICAgICAIIQhBAwCCwJAIAEgC0KAgICAgIDA//8AhYRCAFINAEKAgICAgIDg//8AIAIgAyABhSAEIAKFQoCAgICAgICAgH+FhFAiBhshBEIAIAEgBhshAwwCCyADIAlCgICAgICAwP//AIWEUA0BAkAgASALhEIAUg0AIAMgCYRCAFINAiADIAGDIQMgBCACgyEEDAILIAMgCYRQRQ0AIAEhAyACIQQMAQsgAyABIAMgAVYgCSALViAJIAtRGyIHGyEJIAQgAiAHGyILQv///////z+DIQogAiAEIAcbIgJCMIinQf//AXEhCAJAIAtCMIinQf//AXEiBg0AIAVB4ABqIAkgCiAJIAogClAiBht5IAZBBnStfKciBkFxahCnGkEQIAZrIQYgBUHoAGopAwAhCiAFKQNgIQkLIAEgAyAHGyEDIAJC////////P4MhBAJAIAgNACAFQdAAaiADIAQgAyAEIARQIgcbeSAHQQZ0rXynIgdBcWoQpxpBECAHayEIIAVB2ABqKQMAIQQgBSkDUCEDCyAEQgOGIANCPYiEQoCAgICAgIAEhCEEIApCA4YgCUI9iIQhASADQgOGIQMgCyAChSEKAkAgBiAIayIHRQ0AAkAgB0H/AE0NAEIAIQRCASEDDAELIAVBwABqIAMgBEGAASAHaxCnGiAFQTBqIAMgBCAHEKwaIAUpAzAgBSkDQCAFQcAAakEIaikDAIRCAFKthCEDIAVBMGpBCGopAwAhBAsgAUKAgICAgICABIQhDCAJQgOGIQICQAJAIApCf1UNAAJAIAIgA30iASAMIAR9IAIgA1StfSIEhFBFDQBCACEDQgAhBAwDCyAEQv////////8DVg0BIAVBIGogASAEIAEgBCAEUCIHG3kgB0EGdK18p0F0aiIHEKcaIAYgB2shBiAFQShqKQMAIQQgBSkDICEBDAELIAQgDHwgAyACfCIBIANUrXwiBEKAgICAgICACINQDQAgAUIBiCAEQj+GhCABQgGDhCEBIAZBAWohBiAEQgGIIQQLIAtCgICAgICAgICAf4MhAgJAIAZB//8BSA0AIAJCgICAgICAwP//AIQhBEIAIQMMAQtBACEHAkACQCAGQQBMDQAgBiEHDAELIAVBEGogASAEIAZB/wBqEKcaIAUgASAEQQEgBmsQrBogBSkDACAFKQMQIAVBEGpBCGopAwCEQgBSrYQhASAFQQhqKQMAIQQLIAFCA4ggBEI9hoQhAyAHrUIwhiAEQgOIQv///////z+DhCAChCEEIAGnQQdxIQYCQAJAAkACQAJAEKkaDgMAAQIDCyAEIAMgBkEES618IgEgA1StfCEEAkAgBkEERg0AIAEhAwwDCyAEIAFCAYMiAiABfCIDIAJUrXwhBAwDCyAEIAMgAkIAUiAGQQBHca18IgEgA1StfCEEIAEhAwwBCyAEIAMgAlAgBkEAR3GtfCIBIANUrXwhBCABIQMLIAZFDQELEKoaGgsgACADNwMAIAAgBDcDCCAFQfAAaiQAC1MBAX4CQAJAIANBwABxRQ0AIAIgA0FAaq2IIQFCACECDAELIANFDQAgAkHAACADa62GIAEgA60iBIiEIQEgAiAEiCECCyAAIAE3AwAgACACNwMIC40BAQN/IwBBEGsiAiQAQQAhAwJAIAFCMIinQf//AXEiBEH//wBJDQACQCAEQYGAf2pBIEkNAEH/////B0GAgICAeCABQn9VGyEDDAELIAIgACABQv///////z+DQoCAgICAgMAAhEHvgAEgBGsQrBogAigCACIDQQAgA2sgAUJ/VRshAwsgAkEQaiQAIAMLjgICAn8DfiMAQRBrIgIkAAJAAkAgAb0iBEL///////////8AgyIFQoCAgICAgIB4fEL/////////7/8AVg0AIAVCPIYhBiAFQgSIQoCAgICAgICAPHwhBQwBCwJAIAVCgICAgICAgPj/AFQNACAEQjyGIQYgBEIEiEKAgICAgIDA//8AhCEFDAELAkAgBVBFDQBCACEGQgAhBQwBCyACIAVCACAEp2dBIGogBUIgiKdnIAVCgICAgBBUGyIDQTFqEKcaIAJBCGopAwBCgICAgICAwACFQYz4ACADa61CMIaEIQUgAikDACEGCyAAIAY3AwAgACAFIARCgICAgICAgICAf4OENwMIIAJBEGokAAvrCwIFfw9+IwBB4ABrIgUkACABQiCIIAJCIIaEIQogA0IRiCAEQi+GhCELIANCMYggBEL///////8/gyIMQg+GhCENIAQgAoVCgICAgICAgICAf4MhDiACQv///////z+DIg9CIIghECAMQhGIIREgBEIwiKdB//8BcSEGAkACQAJAIAJCMIinQf//AXEiB0F/akH9/wFLDQBBACEIIAZBf2pB/v8BSQ0BCwJAIAFQIAJC////////////AIMiEkKAgICAgIDA//8AVCASQoCAgICAgMD//wBRGw0AIAJCgICAgICAIIQhDgwCCwJAIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRGw0AIARCgICAgICAIIQhDiADIQEMAgsCQCABIBJCgICAgICAwP//AIWEQgBSDQACQCADIAKEUEUNAEKAgICAgIDg//8AIQ5CACEBDAMLIA5CgICAgICAwP//AIQhDkIAIQEMAgsCQCADIAJCgICAgICAwP//AIWEQgBSDQAgASAShCECQgAhAQJAIAJQRQ0AQoCAgICAgOD//wAhDgwDCyAOQoCAgICAgMD//wCEIQ4MAgsCQCABIBKEQgBSDQBCACEBDAILAkAgAyAChEIAUg0AQgAhAQwCC0EAIQgCQCASQv///////z9WDQAgBUHQAGogASAPIAEgDyAPUCIIG3kgCEEGdK18pyIIQXFqEKcaQRAgCGshCCAFKQNQIgFCIIggBUHYAGopAwAiD0IghoQhCiAPQiCIIRALIAJC////////P1YNACAFQcAAaiADIAwgAyAMIAxQIgkbeSAJQQZ0rXynIglBcWoQpxogCCAJa0EQaiEIIAUpA0AiA0IxiCAFQcgAaikDACICQg+GhCENIANCEYggAkIvhoQhCyACQhGIIRELIAtC/////w+DIgIgAUL/////D4MiBH4iEyADQg+GQoCA/v8PgyIBIApC/////w+DIgN+fCIKQiCGIgwgASAEfnwiCyAMVK0gAiADfiIUIAEgD0L/////D4MiDH58IhIgDUL/////D4MiDyAEfnwiDSAKQiCIIAogE1StQiCGhHwiEyACIAx+IhUgASAQQoCABIQiCn58IhAgDyADfnwiFiARQv////8Hg0KAgICACIQiASAEfnwiEUIghnwiF3whBCAHIAZqIAhqQYGAf2ohBgJAAkAgDyAMfiIYIAIgCn58IgIgGFStIAIgASADfnwiAyACVK18IAMgEiAUVK0gDSASVK18fCICIANUrXwgASAKfnwgASAMfiIDIA8gCn58IgEgA1StQiCGIAFCIIiEfCACIAFCIIZ8IgEgAlStfCABIBFCIIggECAVVK0gFiAQVK18IBEgFlStfEIghoR8IgMgAVStfCADIBMgDVStIBcgE1StfHwiAiADVK18IgFCgICAgICAwACDUA0AIAZBAWohBgwBCyALQj+IIQMgAUIBhiACQj+IhCEBIAJCAYYgBEI/iIQhAiALQgGGIQsgAyAEQgGGhCEECwJAIAZB//8BSA0AIA5CgICAgICAwP//AIQhDkIAIQEMAQsCQAJAIAZBAEoNAAJAQQEgBmsiB0GAAUkNAEIAIQEMAwsgBUEwaiALIAQgBkH/AGoiBhCnGiAFQSBqIAIgASAGEKcaIAVBEGogCyAEIAcQrBogBSACIAEgBxCsGiAFKQMgIAUpAxCEIAUpAzAgBUEwakEIaikDAIRCAFKthCELIAVBIGpBCGopAwAgBUEQakEIaikDAIQhBCAFQQhqKQMAIQEgBSkDACECDAELIAatQjCGIAFC////////P4OEIQELIAEgDoQhDgJAIAtQIARCf1UgBEKAgICAgICAgIB/URsNACAOIAJCAXwiASACVK18IQ4MAQsCQCALIARCgICAgICAgICAf4WEQgBRDQAgAiEBDAELIA4gAiACQgGDfCIBIAJUrXwhDgsgACABNwMAIAAgDjcDCCAFQeAAaiQAC0EBAX8jAEEQayIFJAAgBSABIAIgAyAEQoCAgICAgICAgH+FEKsaIAAgBSkDADcDACAAIAUpAwg3AwggBUEQaiQAC40BAgJ/An4jAEEQayICJAACQAJAIAENAEIAIQRCACEFDAELIAIgASABQR91IgNqIANzIgOtQgAgA2ciA0HRAGoQpxogAkEIaikDAEKAgICAgIDAAIVBnoABIANrrUIwhnwgAUGAgICAeHGtQiCGhCEFIAIpAwAhBAsgACAENwMAIAAgBTcDCCACQRBqJAALdQEBfiAAIAQgAX4gAiADfnwgA0IgiCIEIAFCIIgiAn58IANC/////w+DIgMgAUL/////D4MiAX4iBUIgiCADIAJ+fCIDQiCIfCADQv////8PgyAEIAF+fCIDQiCIfDcDCCAAIANCIIYgBUL/////D4OENwMAC58SAgV/DH4jAEHAAWsiBSQAIARC////////P4MhCiACQv///////z+DIQsgBCAChUKAgICAgICAgIB/gyEMIARCMIinQf//AXEhBgJAAkACQAJAIAJCMIinQf//AXEiB0F/akH9/wFLDQBBACEIIAZBf2pB/v8BSQ0BCwJAIAFQIAJC////////////AIMiDUKAgICAgIDA//8AVCANQoCAgICAgMD//wBRGw0AIAJCgICAgICAIIQhDAwCCwJAIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRGw0AIARCgICAgICAIIQhDCADIQEMAgsCQCABIA1CgICAgICAwP//AIWEQgBSDQACQCADIAJCgICAgICAwP//AIWEUEUNAEIAIQFCgICAgICA4P//ACEMDAMLIAxCgICAgICAwP//AIQhDEIAIQEMAgsCQCADIAJCgICAgICAwP//AIWEQgBSDQBCACEBDAILIAEgDYRCAFENAgJAIAMgAoRCAFINACAMQoCAgICAgMD//wCEIQxCACEBDAILQQAhCAJAIA1C////////P1YNACAFQbABaiABIAsgASALIAtQIggbeSAIQQZ0rXynIghBcWoQpxpBECAIayEIIAVBuAFqKQMAIQsgBSkDsAEhAQsgAkL///////8/Vg0AIAVBoAFqIAMgCiADIAogClAiCRt5IAlBBnStfKciCUFxahCnGiAJIAhqQXBqIQggBUGoAWopAwAhCiAFKQOgASEDCyAFQZABaiADQjGIIApCgICAgICAwACEIg5CD4aEIgJCAEKEyfnOv+a8gvUAIAJ9IgRCABCyGiAFQYABakIAIAVBkAFqQQhqKQMAfUIAIARCABCyGiAFQfAAaiAFKQOAAUI/iCAFQYABakEIaikDAEIBhoQiBEIAIAJCABCyGiAFQeAAaiAEQgBCACAFQfAAakEIaikDAH1CABCyGiAFQdAAaiAFKQNgQj+IIAVB4ABqQQhqKQMAQgGGhCIEQgAgAkIAELIaIAVBwABqIARCAEIAIAVB0ABqQQhqKQMAfUIAELIaIAVBMGogBSkDQEI/iCAFQcAAakEIaikDAEIBhoQiBEIAIAJCABCyGiAFQSBqIARCAEIAIAVBMGpBCGopAwB9QgAQshogBUEQaiAFKQMgQj+IIAVBIGpBCGopAwBCAYaEIgRCACACQgAQshogBSAEQgBCACAFQRBqQQhqKQMAfUIAELIaIAggByAGa2ohBgJAAkBCACAFKQMAQj+IIAVBCGopAwBCAYaEQn98Ig1C/////w+DIgQgAkIgiCIPfiIQIA1CIIgiDSACQv////8PgyIRfnwiAkIgiCACIBBUrUIghoQgDSAPfnwgAkIghiIPIAQgEX58IgIgD1StfCACIAQgA0IRiEL/////D4MiEH4iESANIANCD4ZCgID+/w+DIhJ+fCIPQiCGIhMgBCASfnwgE1StIA9CIIggDyARVK1CIIaEIA0gEH58fHwiDyACVK18IA9CAFKtfH0iAkL/////D4MiECAEfiIRIBAgDX4iEiAEIAJCIIgiE358IgJCIIZ8IhAgEVStIAJCIIggAiASVK1CIIaEIA0gE358fCAQQgAgD30iAkIgiCIPIAR+IhEgAkL/////D4MiEiANfnwiAkIghiITIBIgBH58IBNUrSACQiCIIAIgEVStQiCGhCAPIA1+fHx8IgIgEFStfCACQn58IhEgAlStfEJ/fCIPQv////8PgyICIAFCPoggC0IChoRC/////w+DIgR+IhAgAUIeiEL/////D4MiDSAPQiCIIg9+fCISIBBUrSASIBFCIIgiECALQh6IQv//7/8Pg0KAgBCEIgt+fCITIBJUrXwgCyAPfnwgAiALfiIUIAQgD358IhIgFFStQiCGIBJCIIiEfCATIBJCIIZ8IhIgE1StfCASIBAgDX4iFCARQv////8PgyIRIAR+fCITIBRUrSATIAIgAUIChkL8////D4MiFH58IhUgE1StfHwiEyASVK18IBMgFCAPfiISIBEgC358Ig8gECAEfnwiBCACIA1+fCICQiCIIA8gElStIAQgD1StfCACIARUrXxCIIaEfCIPIBNUrXwgDyAVIBAgFH4iBCARIA1+fCINQiCIIA0gBFStQiCGhHwiBCAVVK0gBCACQiCGfCAEVK18fCIEIA9UrXwiAkL/////////AFYNACABQjGGIARC/////w+DIgEgA0L/////D4MiDX4iD0IAUq19QgAgD30iESAEQiCIIg8gDX4iEiABIANCIIgiEH58IgtCIIYiE1StfSAEIA5CIIh+IAMgAkIgiH58IAIgEH58IA8gCn58QiCGIAJC/////w+DIA1+IAEgCkL/////D4N+fCAPIBB+fCALQiCIIAsgElStQiCGhHx8fSENIBEgE30hASAGQX9qIQYMAQsgBEIhiCEQIAFCMIYgBEIBiCACQj+GhCIEQv////8PgyIBIANC/////w+DIg1+Ig9CAFKtfUIAIA99IgsgASADQiCIIg9+IhEgECACQh+GhCISQv////8PgyITIA1+fCIQQiCGIhRUrX0gBCAOQiCIfiADIAJCIYh+fCACQgGIIgIgD358IBIgCn58QiCGIBMgD34gAkL/////D4MgDX58IAEgCkL/////D4N+fCAQQiCIIBAgEVStQiCGhHx8fSENIAsgFH0hASACIQILAkAgBkGAgAFIDQAgDEKAgICAgIDA//8AhCEMQgAhAQwBCyAGQf//AGohBwJAIAZBgYB/Sg0AAkAgBw0AIAJC////////P4MgBCABQgGGIANWIA1CAYYgAUI/iIQiASAOViABIA5RG618IgEgBFStfCIDQoCAgICAgMAAg1ANACADIAyEIQwMAgtCACEBDAELIAJC////////P4MgBCABQgGGIANaIA1CAYYgAUI/iIQiASAOWiABIA5RG618IgEgBFStfCAHrUIwhnwgDIQhDAsgACABNwMAIAAgDDcDCCAFQcABaiQADwsgAEIANwMAIABCgICAgICA4P//ACAMIAMgAoRQGzcDCCAFQcABaiQAC+oDAgJ/An4jAEEgayICJAACQAJAIAFC////////////AIMiBEKAgICAgIDA/0N8IARCgICAgICAwIC8f3xaDQAgAEI8iCABQgSGhCEEAkAgAEL//////////w+DIgBCgYCAgICAgIAIVA0AIARCgYCAgICAgIDAAHwhBQwCCyAEQoCAgICAgICAwAB8IQUgAEKAgICAgICAgAiFQgBSDQEgBSAEQgGDfCEFDAELAkAgAFAgBEKAgICAgIDA//8AVCAEQoCAgICAgMD//wBRGw0AIABCPIggAUIEhoRC/////////wODQoCAgICAgID8/wCEIQUMAQtCgICAgICAgPj/ACEFIARC////////v//DAFYNAEIAIQUgBEIwiKciA0GR9wBJDQAgAkEQaiAAIAFC////////P4NCgICAgICAwACEIgQgA0H/iH9qEKcaIAIgACAEQYH4ACADaxCsGiACKQMAIgRCPIggAkEIaikDAEIEhoQhBQJAIARC//////////8PgyACKQMQIAJBEGpBCGopAwCEQgBSrYQiBEKBgICAgICAgAhUDQAgBUIBfCEFDAELIARCgICAgICAgIAIhUIAUg0AIAVCAYMgBXwhBQsgAkEgaiQAIAUgAUKAgICAgICAgIB/g4S/CwkAQfAhEIMBAAszAQF/IABBASAAGyEBAkADQCABEN8aIgANAQJAEL4aIgBFDQAgABERAAwBCwsQAgALIAALBwAgABDgGgsPACAAQYgiQQhqNgIAIAALPAECfyABEIEbIgJBDWoQthoiA0EANgIIIAMgAjYCBCADIAI2AgAgACADELoaIAEgAkEBahDjGjYCACAACwcAIABBDGoLIAAgABC4GhogAEG0IkEIajYCACAAQQRqIAEQuRoaIAALBABBAQsHACAAKAIACwgAQcQsEL0aCwQAIAALBwAgABC3GgsFAEH3IQsbACAAQbwiNgIAIABBBGoQwxoaIAAQvxoaIAALKwEBfwJAIAAQvBpFDQAgACgCABDEGiIBQQhqEMUaQX9KDQAgARC3GgsgAAsHACAAQXRqCxUBAX8gACAAKAIAQX9qIgE2AgAgAQsKACAAEMIaELcaCwoAIABBBGoQyBoLBwAgACgCAAsNACAAEMIaGiAAELcaCwQAIAALWQECfyABLQAAIQICQCAALQAAIgNFDQAgAyACQf8BcUcNAANAIAEtAAEhAiAALQABIgNFDQEgAUEBaiEBIABBAWohACADIAJB/wFxRg0ACwsgAyACQf8BcWsLCgAgABDKGhogAAsCAAsCAAsNACAAEMwaGiAAELcaCw0AIAAQzBoaIAAQtxoLMAACQCACDQAgACgCBCABKAIERg8LAkAgACABRw0AQQEPCyAAENIaIAEQ0hoQyxpFCwcAIAAoAgQLrgEBAn8jAEHAAGsiAyQAQQEhBAJAIAAgAUEAENEaDQBBACEEIAFFDQBBACEEIAFB1CNBhCRBABDUGiIBRQ0AIANBCGpBBHJBAEE0EOQaGiADQQE2AjggA0F/NgIUIAMgADYCECADIAE2AgggASADQQhqIAIoAgBBASABKAIAKAIcEQYAAkAgAygCICIEQQFHDQAg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aiABNgIAIAJBdGogATYCACAEQRlJDQAgAyABNgIYIAMgATYCFCADIAE2AhAgAyABNgIMIAJBcGogATYCACACQWxqIAE2AgAgAkFoaiABNgIAIAJBZGogATYCACAEIANBBHFBGHIiBWsiAkEgSQ0AIAGtQoGAgIAQfiEGIAMgBWohAQNAIAEgBjcDGCABIAY3AxAgASAGNwMIIAEgBjcDACABQSBqIQEgAkFgaiICQR9LDQALCyAAC/gCAQF/AkAgACABRg0AAkAgASAAayACa0EAIAJBAXRrSw0AIAAgASACEOMaDwsgASAAc0EDcSEDAkACQAJAIAAgAU8NAAJAIANFDQAgACEDDAMLAkAgAEEDcQ0AIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcUUNAgwACwALAkAgAw0AAkAgACACakEDcUUNAANAIAJFDQUgACACQX9qIgJqIgMgASACai0AADoAACADQQNxDQALCyACQQNNDQADQCAAIAJBfGoiAmogASACaigCADYCACACQQNLDQALCyACRQ0CA0AgACACQX9qIgJqIAEgAmotAAA6AAAgAg0ADAMLAAsgAkEDTQ0AA0AgAyABKAIANgIAIAFBBGohASADQQRqIQMgAkF8aiICQQNLDQALCyACRQ0AA0AgAyABLQAAOgAAIANBAWohAyABQQFqIQEgAkF/aiICDQALCyAACxYAAkAgAA0AQQAPCxDeGiAANgIAQX8L2AIBB38jAEEgayIDJAAgAyAAKAIcIgQ2AhAgACgCFCEFIAMgAjYCHCADIAE2AhggAyAFIARrIgE2AhQgASACaiEGQQIhByADQRBqIQECQAJAAkACQCAAKAI8IANBEGpBAiADQQxqEAUQ5hoNAANAIAYgAygCDCIERg0CIARBf0wNAyABIAQgASgCBCIISyIFQQN0aiIJIAkoAgAgBCAIQQAgBRtrIghqNgIAIAFBDEEEIAUbaiIJIAkoAgAgCGs2AgAgBiAEayEGIAAoAjwgAUEIaiABIAUbIgEgByAFayIHIANBDGoQBRDmGkUNAAsLIAZBf0cNAQsgACAAKAIsIgE2AhwgACABNgIUIAAgASAAKAIwajYCECACIQQMAQtBACEEIABBADYCHCAAQgA3AxAgACAAKAIAQSBy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EPkaIAAgDCAPEPMaIABBICABIA4gDUGAwABzEPkaDAELC0EAIRQLIAdB0ABqJAAgFAsZAAJAIAAtAABBIHENACABIAIgABDwGhoLC0sBA39BACEBAkAgACgCACwAABDqGkUNAANAIAAoAgAiAiwAACEDIAAgAkEBajYCACADIAFBCmxqQVBqIQEgAiwAARDqGg0ACwsgAQu7AgACQCABQRRLDQACQAJAAkACQAJAAkACQAJAAkACQCABQXdqDgoAAQIDBAUGBwgJCgsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAgALCzUAAkAgAFANAANAIAFBf2oiASAAp0EPcUGAKWotAAAgAnI6AAAgAEIEiCIAQgBSDQALCyABCy4AAkAgAFANAANAIAFBf2oiASAAp0EHcUEwcjoAACAAQgOIIgBCAFINAAsLIAELiAECAX4DfwJAAkAgAEKAgICAEFoNACAAIQIMAQsDQCABQX9qIgEgACAAQgqAIgJCCn59p0EwcjoAACAAQv////+fAVYhAyACIQAgAw0ACwsCQCACpyIDRQ0AA0AgAUF/aiIBIAMgA0EKbiIEQQpsa0EwcjoAACADQQlLIQUgBCEDIAUNAAsLIAELcwEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABQf8BcSACIANrIgJBgAIgAkGAAkkiAxsQ5BoaAkAgAw0AA0AgACAFQYACEPMaIAJBgH5qIgJB/wFLDQALCyAAIAUgAhDzGgsgBUGAAmokAAsPACAAIAEgAkEbQRwQ8RoLqhgDEn8CfgF8IwBBsARrIgYkAEEAIQcgBkEANgIsAkACQCABEP0aIhhCf1UNAEEBIQhBkCkhCSABmiIB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';\\nif (!isDataURI(wasmBinaryFile)) {\\n  wasmBinaryFile = locateFile(wasmBinaryFile);\\n}\\n\\nfunction getBinary(file) {\\n  try {\\n    if (file == wasmBinaryFile && wasmBinary) {\\n      return new Uint8Array(wasmBinary);\\n    }\\n    var binary = tryParseAsDataURI(file);\\n    if (binary) {\\n      return binary;\\n    }\\n    if (readBinary) {\\n      return readBinary(file);\\n    } else {\\n      throw \\\"both async and sync fetching of the wasm failed\\\";\\n    }\\n  }\\n  catch (err) {\\n    abort(err);\\n  }\\n}\\n\\nfunction getBinaryPromise() {\\n  // If we don't have the binary yet, try to to load it asynchronously.\\n  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\\n  // See https://github.com/github/fetch/pull/92#issuecomment-140665932\\n  // Cordova or Electron apps are typically loaded from a file:// url.\\n  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.\\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\\n    if (typeof fetch === 'function'\\n    ) {\\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\\n        if (!response['ok']) {\\n          throw \\\"failed to load wasm binary file at '\\\" + wasmBinaryFile + \\\"'\\\";\\n        }\\n        return response['arrayBuffer']();\\n      }).catch(function () {\\n          return getBinary(wasmBinaryFile);\\n      });\\n    }\\n  }\\n    \\n  // Otherwise, getBinary should be able to get it synchronously\\n  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });\\n}\\n\\n// Create the wasm instance.\\n// Receives the wasm imports, returns the exports.\\nfunction createWasm() {\\n  // prepare imports\\n  var info = {\\n    'env': asmLibraryArg,\\n    'wasi_snapshot_preview1': asmLibraryArg,\\n  };\\n  // Load the wasm module and create an instance of using native support in the JS engine.\\n  // handle a generated wasm instance, receiving its exports and\\n  // performing other necessary setup\\n  /** @param {WebAssembly.Module=} module*/\\n  function receiveInstance(instance, module) {\\n    var exports = instance.exports;\\n\\n    Module['asm'] = exports;\\n\\n    wasmMemory = Module['asm']['memory'];\\n    updateGlobalBufferAndViews(wasmMemory.buffer);\\n\\n    wasmTable = Module['asm']['__indirect_function_table'];\\n\\n    removeRunDependency('wasm-instantiate');\\n  }\\n  // we can't run yet (except in a pthread, where we have a custom sync instantiator)\\n  addRunDependency('wasm-instantiate');\\n\\n  function receiveInstantiatedSource(output) {\\n    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\\n    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\\n    receiveInstance(output['instance']);\\n  }\\n\\n  function instantiateArrayBuffer(receiver) {\\n    return getBinaryPromise().then(function(binary) {\\n      return WebAssembly.instantiate(binary, info);\\n    }).then(receiver, function(reason) {\\n      err('failed to asynchronously prepare wasm: ' + reason);\\n\\n      abort(reason);\\n    });\\n  }\\n\\n  // Prefer streaming instantiation if available.\\n  function instantiateAsync() {\\n    if (!wasmBinary &&\\n        typeof WebAssembly.instantiateStreaming === 'function' &&\\n        !isDataURI(wasmBinaryFile) &&\\n        typeof fetch === 'function') {\\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {\\n        var result = WebAssembly.instantiateStreaming(response, info);\\n        return result.then(receiveInstantiatedSource, function(reason) {\\n            // We expect the most common failure cause to be a bad MIME type for the binary,\\n            // in which case falling back to ArrayBuffer instantiation should work.\\n            err('wasm streaming compile failed: ' + reason);\\n            err('falling back to ArrayBuffer instantiation');\\n            return instantiateArrayBuffer(receiveInstantiatedSource);\\n          });\\n      });\\n    } else {\\n      return instantiateArrayBuffer(receiveInstantiatedSource);\\n    }\\n  }\\n\\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\\n  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\\n  // to any other async startup actions they are performing.\\n  if (Module['instantiateWasm']) {\\n    try {\\n      var exports = Module['instantiateWasm'](info, receiveInstance);\\n      return exports;\\n    } catch(e) {\\n      err('Module.instantiateWasm callback failed with error: ' + e);\\n      return false;\\n    }\\n  }\\n\\n  instantiateAsync();\\n  return {}; // no exports yet; we'll fill them in later\\n}\\n\\n// Globals used by JS i64 conversions (see makeSetValue)\\nvar tempDouble;\\nvar tempI64;\\n\\n// === Body ===\\n\\nvar ASM_CONSTS = {\\n  \\n};\\n\\n\\n\\n\\n\\n\\n  function callRuntimeCallbacks(callbacks) {\\n      while(callbacks.length > 0) {\\n        var callback = callbacks.shift();\\n        if (typeof callback == 'function') {\\n          callback(Module); // Pass the module as the first argument.\\n          continue;\\n        }\\n        var func = callback.func;\\n        if (typeof func === 'number') {\\n          if (callback.arg === undefined) {\\n            wasmTable.get(func)();\\n          } else {\\n            wasmTable.get(func)(callback.arg);\\n          }\\n        } else {\\n          func(callback.arg === undefined ? null : callback.arg);\\n        }\\n      }\\n    }\\n\\n  function demangle(func) {\\n      return func;\\n    }\\n\\n  function demangleAll(text) {\\n      var regex =\\n        /\\\\b_Z[\\\\w\\\\d_]+/g;\\n      return text.replace(regex,\\n        function(x) {\\n          var y = demangle(x);\\n          return x === y ? x : (y + ' [' + x + ']');\\n        });\\n    }\\n\\n  function jsStackTrace() {\\n      var error = new Error();\\n      if (!error.stack) {\\n        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\\n        // so try that as a special-case.\\n        try {\\n          throw new Error();\\n        } catch(e) {\\n          error = e;\\n        }\\n        if (!error.stack) {\\n          return '(no stack trace available)';\\n        }\\n      }\\n      return error.stack.toString();\\n    }\\n\\n  function stackTrace() {\\n      var js = jsStackTrace();\\n      if (Module['extraStackTrace']) js += '\\\\n' + Module['extraStackTrace']();\\n      return demangleAll(js);\\n    }\\n\\n  var ExceptionInfoAttrs={DESTRUCTOR_OFFSET:0,REFCOUNT_OFFSET:4,TYPE_OFFSET:8,CAUGHT_OFFSET:12,RETHROWN_OFFSET:13,SIZE:16};\\n  function ___cxa_allocate_exception(size) {\\n      // Thrown object is prepended by exception metadata block\\n      return _malloc(size + ExceptionInfoAttrs.SIZE) + ExceptionInfoAttrs.SIZE;\\n    }\\n\\n  function ExceptionInfo(excPtr) {\\n      this.excPtr = excPtr;\\n      this.ptr = excPtr - ExceptionInfoAttrs.SIZE;\\n  \\n      this.set_type = function(type) {\\n        HEAP32[(((this.ptr)+(ExceptionInfoAttrs.TYPE_OFFSET))>>2)] = type;\\n      };\\n  \\n      this.get_type = function() {\\n        return HEAP32[(((this.ptr)+(ExceptionInfoAttrs.TYPE_OFFSET))>>2)];\\n      };\\n  \\n      this.set_destructor = function(destructor) {\\n        HEAP32[(((this.ptr)+(ExceptionInfoAttrs.DESTRUCTOR_OFFSET))>>2)] = destructor;\\n      };\\n  \\n      this.get_destructor = function() {\\n        return HEAP32[(((this.ptr)+(ExceptionInfoAttrs.DESTRUCTOR_OFFSET))>>2)];\\n      };\\n  \\n      this.set_refcount = function(refcount) {\\n        HEAP32[(((this.ptr)+(ExceptionInfoAttrs.REFCOUNT_OFFSET))>>2)] = refcount;\\n      };\\n  \\n      this.set_caught = function (caught) {\\n        caught = caught ? 1 : 0;\\n        HEAP8[(((this.ptr)+(ExceptionInfoAttrs.CAUGHT_OFFSET))>>0)] = caught;\\n      };\\n  \\n      this.get_caught = function () {\\n        return HEAP8[(((this.ptr)+(ExceptionInfoAttrs.CAUGHT_OFFSET))>>0)] != 0;\\n      };\\n  \\n      this.set_rethrown = function (rethrown) {\\n        rethrown = rethrown ? 1 : 0;\\n        HEAP8[(((this.ptr)+(ExceptionInfoAttrs.RETHROWN_OFFSET))>>0)] = rethrown;\\n      };\\n  \\n      this.get_rethrown = function () {\\n        return HEAP8[(((this.ptr)+(ExceptionInfoAttrs.RETHROWN_OFFSET))>>0)] != 0;\\n      };\\n  \\n      // Initialize native structure fields. Should be called once after allocated.\\n      this.init = function(type, destructor) {\\n        this.set_type(type);\\n        this.set_destructor(destructor);\\n        this.set_refcount(0);\\n        this.set_caught(false);\\n        this.set_rethrown(false);\\n      }\\n  \\n      this.add_ref = function() {\\n        var value = HEAP32[(((this.ptr)+(ExceptionInfoAttrs.REFCOUNT_OFFSET))>>2)];\\n        HEAP32[(((this.ptr)+(ExceptionInfoAttrs.REFCOUNT_OFFSET))>>2)] = value + 1;\\n      };\\n  \\n      // Returns true if last reference released.\\n      this.release_ref = function() {\\n        var prev = HEAP32[(((this.ptr)+(ExceptionInfoAttrs.REFCOUNT_OFFSET))>>2)];\\n        HEAP32[(((this.ptr)+(ExceptionInfoAttrs.REFCOUNT_OFFSET))>>2)] = prev - 1;\\n        return prev === 1;\\n      };\\n    }\\n  \\n  var exceptionLast=0;\\n  \\n  var uncaughtExceptionCount=0;\\n  function ___cxa_throw(ptr, type, destructor) {\\n      var info = new ExceptionInfo(ptr);\\n      // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.\\n      info.init(type, destructor);\\n      exceptionLast = ptr;\\n      uncaughtExceptionCount++;\\n      throw ptr;\\n    }\\n\\n  function _abort() {\\n      abort();\\n    }\\n\\n  function _emscripten_memcpy_big(dest, src, num) {\\n      HEAPU8.copyWithin(dest, src, src + num);\\n    }\\n\\n  function _emscripten_get_heap_size() {\\n      return HEAPU8.length;\\n    }\\n  \\n  function emscripten_realloc_buffer(size) {\\n      try {\\n        // round size grow request up to wasm page size (fixed 64KB per spec)\\n        wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16); // .grow() takes a delta compared to the previous size\\n        updateGlobalBufferAndViews(wasmMemory.buffer);\\n        return 1 /*success*/;\\n      } catch(e) {\\n      }\\n      // implicit 0 return to save code size (caller will cast \\\"undefined\\\" into 0\\n      // anyhow)\\n    }\\n  function _emscripten_resize_heap(requestedSize) {\\n      var oldSize = _emscripten_get_heap_size();\\n      // With pthreads, races can happen (another thread might increase the size in between), so return a failure, and let the caller retry.\\n  \\n      // Memory resize rules:\\n      // 1. Always increase heap size to at least the requested size, rounded up to next page multiple.\\n      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap geometrically: increase the heap size according to \\n      //                                         MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%),\\n      //                                         At most overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\\n      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap linearly: increase the heap size by at least MEMORY_GROWTH_LINEAR_STEP bytes.\\n      // 3. Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\\n      // 4. If we were unable to allocate as much memory, it may be due to over-eager decision to excessively reserve due to (3) above.\\n      //    Hence if an allocation fails, cut down on the amount of excess growth, in an attempt to succeed to perform a smaller allocation.\\n  \\n      // A limit was set for how much we can grow. We should not exceed that\\n      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).\\n      // In CAN_ADDRESS_2GB mode, stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate full 4GB Wasm memories, the size will wrap\\n      // back to 0 bytes in Wasm side for any code that deals with heap sizes, which would require special casing all heap size related code to treat\\n      // 0 specially.\\n      var maxHeapSize = 2147483648;\\n      if (requestedSize > maxHeapSize) {\\n        return false;\\n      }\\n  \\n      // Loop through potential heap size increases. If we attempt a too eager reservation that fails, cut down on the\\n      // attempted size and reserve a smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\\n      for(var cutDown = 1; cutDown <= 4; cutDown *= 2) {\\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth\\n        // but limit overreserving (default to capping at +96MB overgrowth at most)\\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );\\n  \\n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\\n  \\n        var replacement = emscripten_realloc_buffer(newSize);\\n        if (replacement) {\\n  \\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n\\n  function flush_NO_FILESYSTEM() {\\n      // flush anything remaining in the buffers during shutdown\\n      if (typeof _fflush !== 'undefined') _fflush(0);\\n      var buffers = SYSCALLS.buffers;\\n      if (buffers[1].length) SYSCALLS.printChar(1, 10);\\n      if (buffers[2].length) SYSCALLS.printChar(2, 10);\\n    }\\n  \\n  var SYSCALLS={mappings:{},buffers:[null,[],[]],printChar:function(stream, curr) {\\n        var buffer = SYSCALLS.buffers[stream];\\n        if (curr === 0 || curr === 10) {\\n          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\\n          buffer.length = 0;\\n        } else {\\n          buffer.push(curr);\\n        }\\n      },varargs:undefined,get:function() {\\n        SYSCALLS.varargs += 4;\\n        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\\n        return ret;\\n      },getStr:function(ptr) {\\n        var ret = UTF8ToString(ptr);\\n        return ret;\\n      },get64:function(low, high) {\\n        return low;\\n      }};\\n  function _fd_write(fd, iov, iovcnt, pnum) {\\n      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\\n      var num = 0;\\n      for (var i = 0; i < iovcnt; i++) {\\n        var ptr = HEAP32[(((iov)+(i*8))>>2)];\\n        var len = HEAP32[(((iov)+(i*8 + 4))>>2)];\\n        for (var j = 0; j < len; j++) {\\n          SYSCALLS.printChar(fd, HEAPU8[ptr+j]);\\n        }\\n        num += len;\\n      }\\n      HEAP32[((pnum)>>2)] = num\\n      return 0;\\n    }\\n\\n  function _setTempRet0($i) {\\n      setTempRet0(($i) | 0);\\n    }\\nvar ASSERTIONS = false;\\n\\n\\n\\n/** @type {function(string, boolean=, number=)} */\\nfunction intArrayFromString(stringy, dontAddNull, length) {\\n  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\\n  var u8array = new Array(len);\\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\\n  if (dontAddNull) u8array.length = numBytesWritten;\\n  return u8array;\\n}\\n\\nfunction intArrayToString(array) {\\n  var ret = [];\\n  for (var i = 0; i < array.length; i++) {\\n    var chr = array[i];\\n    if (chr > 0xFF) {\\n      if (ASSERTIONS) {\\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\\n      }\\n      chr &= 0xFF;\\n    }\\n    ret.push(String.fromCharCode(chr));\\n  }\\n  return ret.join('');\\n}\\n\\n\\n// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149\\n\\n// This code was written by Tyler Akins and has been placed in the\\n// public domain.  It would be nice if you left this header intact.\\n// Base64 code from Tyler Akins -- http://rumkin.com\\n\\n/**\\n * Decodes a base64 string.\\n * @param {string} input The string to decode.\\n */\\nvar decodeBase64 = typeof atob === 'function' ? atob : function (input) {\\n  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\\n\\n  var output = '';\\n  var chr1, chr2, chr3;\\n  var enc1, enc2, enc3, enc4;\\n  var i = 0;\\n  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\\n  input = input.replace(/[^A-Za-z0-9\\\\+\\\\/\\\\=]/g, '');\\n  do {\\n    enc1 = keyStr.indexOf(input.charAt(i++));\\n    enc2 = keyStr.indexOf(input.charAt(i++));\\n    enc3 = keyStr.indexOf(input.charAt(i++));\\n    enc4 = keyStr.indexOf(input.charAt(i++));\\n\\n    chr1 = (enc1 << 2) | (enc2 >> 4);\\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\\n    chr3 = ((enc3 & 3) << 6) | enc4;\\n\\n    output = output + String.fromCharCode(chr1);\\n\\n    if (enc3 !== 64) {\\n      output = output + String.fromCharCode(chr2);\\n    }\\n    if (enc4 !== 64) {\\n      output = output + String.fromCharCode(chr3);\\n    }\\n  } while (i < input.length);\\n  return output;\\n};\\n\\n// Converts a string of base64 into a byte array.\\n// Throws error on invalid input.\\nfunction intArrayFromBase64(s) {\\n\\n  try {\\n    var decoded = decodeBase64(s);\\n    var bytes = new Uint8Array(decoded.length);\\n    for (var i = 0 ; i < decoded.length ; ++i) {\\n      bytes[i] = decoded.charCodeAt(i);\\n    }\\n    return bytes;\\n  } catch (_) {\\n    throw new Error('Converting base64 string to bytes failed.');\\n  }\\n}\\n\\n// If filename is a base64 data URI, parses and returns data (Buffer on node,\\n// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.\\nfunction tryParseAsDataURI(filename) {\\n  if (!isDataURI(filename)) {\\n    return;\\n  }\\n\\n  return intArrayFromBase64(filename.slice(dataURIPrefix.length));\\n}\\n\\n\\nvar asmLibraryArg = {\\n  \\\"__cxa_allocate_exception\\\": ___cxa_allocate_exception,\\n  \\\"__cxa_throw\\\": ___cxa_throw,\\n  \\\"abort\\\": _abort,\\n  \\\"emscripten_memcpy_big\\\": _emscripten_memcpy_big,\\n  \\\"emscripten_resize_heap\\\": _emscripten_resize_heap,\\n  \\\"fd_write\\\": _fd_write,\\n  \\\"setTempRet0\\\": _setTempRet0\\n};\\nvar asm = createWasm();\\n/** @type {function(...*):?} */\\nvar ___wasm_call_ctors = Module[\\\"___wasm_call_ctors\\\"] = function() {\\n  return (___wasm_call_ctors = Module[\\\"___wasm_call_ctors\\\"] = Module[\\\"asm\\\"][\\\"__wasm_call_ctors\\\"]).apply(null, arguments);\\n};\\n\\n/** @type {function(...*):?} */\\nvar _malloc = Module[\\\"_malloc\\\"] = function() {\\n  return (_malloc = Module[\\\"_malloc\\\"] = Module[\\\"asm\\\"][\\\"malloc\\\"]).apply(null, arguments);\\n};\\n\\n/** @type {function(...*):?} */\\nvar _separateTabs = Module[\\\"_separateTabs\\\"] = function() {\\n  return (_separateTabs = Module[\\\"_separateTabs\\\"] = Module[\\\"asm\\\"][\\\"separateTabs\\\"]).apply(null, arguments);\\n};\\n\\n/** @type {function(...*):?} */\\nvar _vCarve = Module[\\\"_vCarve\\\"] = function() {\\n  return (_vCarve = Module[\\\"_vCarve\\\"] = Module[\\\"asm\\\"][\\\"vCarve\\\"]).apply(null, arguments);\\n};\\n\\n/** @type {function(...*):?} */\\nvar ___errno_location = Module[\\\"___errno_location\\\"] = function() {\\n  return (___errno_location = Module[\\\"___errno_location\\\"] = Module[\\\"asm\\\"][\\\"__errno_location\\\"]).apply(null, arguments);\\n};\\n\\n/** @type {function(...*):?} */\\nvar stackSave = Module[\\\"stackSave\\\"] = function() {\\n  return (stackSave = Module[\\\"stackSave\\\"] = Module[\\\"asm\\\"][\\\"stackSave\\\"]).apply(null, arguments);\\n};\\n\\n/** @type {function(...*):?} */\\nvar stackRestore = Module[\\\"stackRestore\\\"] = function() {\\n  return (stackRestore = Module[\\\"stackRestore\\\"] = Module[\\\"asm\\\"][\\\"stackRestore\\\"]).apply(null, arguments);\\n};\\n\\n/** @type {function(...*):?} */\\nvar stackAlloc = Module[\\\"stackAlloc\\\"] = function() {\\n  return (stackAlloc = Module[\\\"stackAlloc\\\"] = Module[\\\"asm\\\"][\\\"stackAlloc\\\"]).apply(null, arguments);\\n};\\n\\n/** @type {function(...*):?} */\\nvar dynCall_jiji = Module[\\\"dynCall_jiji\\\"] = function() {\\n  return (dynCall_jiji = Module[\\\"dynCall_jiji\\\"] = Module[\\\"asm\\\"][\\\"dynCall_jiji\\\"]).apply(null, arguments);\\n};\\n\\n\\n\\n\\n\\n// === Auto-generated postamble setup entry stuff ===\\n\\n\\n\\nvar calledRun;\\n\\n/**\\n * @constructor\\n * @this {ExitStatus}\\n */\\nfunction ExitStatus(status) {\\n  this.name = \\\"ExitStatus\\\";\\n  this.message = \\\"Program terminated with exit(\\\" + status + \\\")\\\";\\n  this.status = status;\\n}\\n\\nvar calledMain = false;\\n\\ndependenciesFulfilled = function runCaller() {\\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\\n  if (!calledRun) run();\\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\\n};\\n\\n/** @type {function(Array=)} */\\nfunction run(args) {\\n  args = args || arguments_;\\n\\n  if (runDependencies > 0) {\\n    return;\\n  }\\n\\n  preRun();\\n\\n  // a preRun added a dependency, run will be called later\\n  if (runDependencies > 0) {\\n    return;\\n  }\\n\\n  function doRun() {\\n    // run may have just been called through dependencies being fulfilled just in this very frame,\\n    // or while the async setStatus time below was happening\\n    if (calledRun) return;\\n    calledRun = true;\\n    Module['calledRun'] = true;\\n\\n    if (ABORT) return;\\n\\n    initRuntime();\\n\\n    preMain();\\n\\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\\n\\n    postRun();\\n  }\\n\\n  if (Module['setStatus']) {\\n    Module['setStatus']('Running...');\\n    setTimeout(function() {\\n      setTimeout(function() {\\n        Module['setStatus']('');\\n      }, 1);\\n      doRun();\\n    }, 1);\\n  } else\\n  {\\n    doRun();\\n  }\\n}\\nModule['run'] = run;\\n\\n/** @param {boolean|number=} implicit */\\nfunction exit(status, implicit) {\\n\\n  // if this is just main exit-ing implicitly, and the status is 0, then we\\n  // don't need to do anything here and can just leave. if the status is\\n  // non-zero, though, then we need to report it.\\n  // (we may have warned about this earlier, if a situation justifies doing so)\\n  if (implicit && noExitRuntime && status === 0) {\\n    return;\\n  }\\n\\n  if (noExitRuntime) {\\n  } else {\\n\\n    EXITSTATUS = status;\\n\\n    exitRuntime();\\n\\n    if (Module['onExit']) Module['onExit'](status);\\n\\n    ABORT = true;\\n  }\\n\\n  quit_(status, new ExitStatus(status));\\n}\\n\\nif (Module['preInit']) {\\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\\n  while (Module['preInit'].length > 0) {\\n    Module['preInit'].pop()();\\n  }\\n}\\n\\nrun();\\n\\n\\n\\n\\n\\n\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/raw-loader/dist/cjs.js!../~/web-cam-cpp/web-cam-cpp.js\n// module id = 26\n// module chunks = 0"],"sourceRoot":""}