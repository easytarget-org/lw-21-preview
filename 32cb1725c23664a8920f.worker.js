/******/ (function(modules) { // webpackBootstrap
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		importScripts(__webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js");
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if(typeof XMLHttpRequest === "undefined")
/******/ 				return reject(new Error("No browser support"));
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = 10000;
/******/ 				request.send(null);
/******/ 			} catch(err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if(request.readyState !== 4) return;
/******/ 				if(request.status === 0) {
/******/ 					// timeout
/******/ 					reject(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 				} else if(request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if(request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch(e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotDisposeChunk(chunkId) { //eslint-disable-line no-unused-vars
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "32cb1725c23664a8920f"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if(me.children.indexOf(request) < 0)
/******/ 					me.children.push(request);
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name) && name !== "e") {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/ 	
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if(hotStatus === "prepare") {
/******/ 					if(!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest().then(function(update) {
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if(!deferred) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate).then(function(result) {
/******/ 				deferred.resolve(result);
/******/ 			}, function(err) {
/******/ 				deferred.reject(err);
/******/ 			});
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/ 	
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/ 	
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while(queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if(module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(!parent) continue;
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 	
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn("[HMR] unexpected require(" + result.moduleId + ") to disposed module");
/******/ 		};
/******/ 	
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				var result;
/******/ 				if(hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if(result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch(result.type) {
/******/ 					case "self-declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of self decline: " + result.moduleId + chainInfo);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if(options.onDeclined)
/******/ 							options.onDeclined(result);
/******/ 						if(!options.ignoreDeclined)
/******/ 							abortError = new Error("Aborted because of declined dependency: " + result.moduleId + " in " + result.parentId + chainInfo);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if(options.onUnaccepted)
/******/ 							options.onUnaccepted(result);
/******/ 						if(!options.ignoreUnaccepted)
/******/ 							abortError = new Error("Aborted because " + moduleId + " is not accepted" + chainInfo);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if(options.onAccepted)
/******/ 							options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if(options.onDisposed)
/******/ 							options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if(abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if(doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for(moduleId in result.outdatedDependencies) {
/******/ 						if(Object.prototype.hasOwnProperty.call(result.outdatedDependencies, moduleId)) {
/******/ 							if(!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(outdatedDependencies[moduleId], result.outdatedDependencies[moduleId]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if(doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if(hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/ 	
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				if(module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for(j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if(idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				module = installedModules[moduleId];
/******/ 				moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					dependency = moduleOutdatedDependencies[i];
/******/ 					cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(i = 0; i < callbacks.length; i++) {
/******/ 					cb = callbacks[i];
/******/ 					try {
/******/ 						cb(moduleOutdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "accept-errored",
/******/ 								moduleId: moduleId,
/******/ 								dependencyId: moduleOutdatedDependencies[i],
/******/ 								error: err
/******/ 							});
/******/ 						}
/******/ 						if(!options.ignoreErrored) {
/******/ 							if(!error)
/******/ 								error = err;
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err2) {
/******/ 						if(options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								orginalError: err
/******/ 							});
/******/ 						}
/******/ 						if(!options.ignoreErrored) {
/******/ 							if(!error)
/******/ 								error = err2;
/******/ 						}
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if(options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if(!options.ignoreErrored) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(93)(__webpack_require__.s = 93);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON", function() { return EPSILON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RANDOM", function() { return RANDOM; });
/* harmony export (immutable) */ __webpack_exports__["setMatrixArrayType"] = setMatrixArrayType;
/* harmony export (immutable) */ __webpack_exports__["toRadian"] = toRadian;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

/***/ }),
/* 1 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.9' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(29)('wks');
var uid = __webpack_require__(31);
var Symbol = __webpack_require__(3).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(3);
var core = __webpack_require__(1);
var ctx = __webpack_require__(63);
var hide = __webpack_require__(6);
var has = __webpack_require__(11);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(16);
var createDesc = __webpack_require__(27);
module.exports = __webpack_require__(10) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(15);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 9 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(14)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 11 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(56);

/***/ }),
/* 13 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(8);
var IE8_DOM_DEFINE = __webpack_require__(65);
var toPrimitive = __webpack_require__(81);
var dP = Object.defineProperty;

exports.f = __webpack_require__(10) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(29)('keys');
var uid = __webpack_require__(31);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 18 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(66);
var defined = __webpack_require__(9);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */



/**
 * The following functions operate on "Point" or any "Point like" object with {x,y},
 * as defined by the {@link XY} type
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 * @module
 * @private
 */

/**
 * poly2tri.js supports using custom point class instead of {@linkcode Point}.
 * Any "Point like" object with <code>{x, y}</code> attributes is supported
 * to initialize the SweepContext polylines and points
 * ([duck typing]{@link http://en.wikipedia.org/wiki/Duck_typing}).
 *
 * poly2tri.js might add extra fields to the point objects when computing the
 * triangulation : they are prefixed with <code>_p2t_</code> to avoid collisions
 * with fields in the custom class.
 *
 * @example
 *      var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *
 * @typedef {Object} XY
 * @property {number} x - x coordinate
 * @property {number} y - y coordinate
 */


/**
 * Point pretty printing : prints x and y coordinates.
 * @example
 *      xy.toStringBase({x:5, y:42})
 *      // → "(5;42)"
 * @protected
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toStringBase(p) {
    return ("(" + p.x + ";" + p.y + ")");
}

/**
 * Point pretty printing. Delegates to the point's custom "toString()" method if exists,
 * else simply prints x and y coordinates.
 * @example
 *      xy.toString({x:5, y:42})
 *      // → "(5;42)"
 * @example
 *      xy.toString({x:5,y:42,toString:function() {return this.x+":"+this.y;}})
 *      // → "5:42"
 * @param {!XY} p - point object with {x,y}
 * @returns {string} <code>"(x;y)"</code>
 */
function toString(p) {
    // Try a custom toString first, and fallback to own implementation if none
    var s = p.toString();
    return (s === '[object Object]' ? toStringBase(p) : s);
}


/**
 * Compare two points component-wise. Ordered by y axis first, then x axis.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {number} <code>&lt; 0</code> if <code>a &lt; b</code>,
 *         <code>&gt; 0</code> if <code>a &gt; b</code>, 
 *         <code>0</code> otherwise.
 */
function compare(a, b) {
    if (a.y === b.y) {
        return a.x - b.x;
    } else {
        return a.y - b.y;
    }
}

/**
 * Test two Point objects for equality.
 * @param {!XY} a - point object with {x,y}
 * @param {!XY} b - point object with {x,y}
 * @return {boolean} <code>True</code> if <code>a == b</code>, <code>false</code> otherwise.
 */
function equals(a, b) {
    return a.x === b.x && a.y === b.y;
}


module.exports = {
    toString: toString,
    toStringBase: toStringBase,
    compare: compare,
    equals: equals
};


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(13);
var TAG = __webpack_require__(4)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(15);
var document = __webpack_require__(3).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 23 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(25);
var $export = __webpack_require__(5);
var redefine = __webpack_require__(75);
var hide = __webpack_require__(6);
var Iterators = __webpack_require__(7);
var $iterCreate = __webpack_require__(68);
var setToStringTag = __webpack_require__(28);
var getPrototypeOf = __webpack_require__(71);
var ITERATOR = __webpack_require__(4)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(8);
var dPs = __webpack_require__(70);
var enumBugKeys = __webpack_require__(23);
var IE_PROTO = __webpack_require__(17)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(22)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(64).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(16).f;
var has = __webpack_require__(11);
var TAG = __webpack_require__(4)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(1);
var global = __webpack_require__(3);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(25) ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 31 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(76)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(24)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(86);
var global = __webpack_require__(3);
var hide = __webpack_require__(6);
var Iterators = __webpack_require__(7);
var TO_STRING_TAG = __webpack_require__(4)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbstractGenerator = undefined;

var _xregexp = __webpack_require__(112);

var _xregexp2 = _interopRequireDefault(_xregexp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// AbstractDriver class
let AbstractGenerator = class AbstractGenerator {
  // Class constructor...
  constructor(settings) {
    this.settings = settings;
  }

  postProcessRaster(gcode) {
    if (this.settings.gcodeToolOn && this.settings.gcodeToolOff) {
      gcode = _xregexp2.default.replace(gcode, new _xregexp2.default("G0(.*?)G1", "gis"), 'G0$1\n' + this.settings.gcodeToolOn + '\nG1');
      gcode = _xregexp2.default.replace(gcode, new _xregexp2.default("G1(.*?)G0", "gis"), 'G1$1\n' + this.settings.gcodeToolOff + '\nG0');
      return gcode;
      //return gcode.replace(new XRegExp("G0(.*?)G1","gis"),'G0$1\n'+this.settings.gcodeToolOn+'\nG1').replace(new XRegExp("G1(.*?)G0","gis"),'G1$1\n'+this.settings.gcodeToolOff+'\nG0')
    }
    return gcode;
  }

};

// Exports

exports.AbstractGenerator = AbstractGenerator;
const _default = AbstractGenerator;
exports.default = _default;
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(AbstractGenerator, "AbstractGenerator", "/home/pi/LaserWeb4/src/lib/action2gcode/generators/abstract-generator.js");

  __REACT_HOT_LOADER__.register(_default, "default", "/home/pi/LaserWeb4/src/lib/action2gcode/generators/abstract-generator.js");
}();

;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright 2014-2016 Todd Fleming
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// TODO: pass React elements to alertFn



Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.arcTolerance = exports.cleanPolyDist = exports.clipperToCppScale = exports.mmToClipperScale = exports.inchToClipperScale = undefined;
exports.elementToRawPaths = elementToRawPaths;
exports.pathStrToRawPaths = pathStrToRawPaths;
exports.flipY = flipY;
exports.hasClosedRawPaths = hasClosedRawPaths;
exports.filterClosedRawPaths = filterClosedRawPaths;
exports.rawPathsToClipperPaths = rawPathsToClipperPaths;
exports.triangulateRawPaths = triangulateRawPaths;
exports.clipperPathsToCPaths = clipperPathsToCPaths;
exports.cPathsToClipperPaths = cPathsToClipperPaths;
exports.cPathsToCamPaths = cPathsToCamPaths;
exports.clipperBounds = clipperBounds;
exports.clip = clip;
exports.union = union;
exports.diff = diff;
exports.xor = xor;
exports.offset = offset;

var _clipperLib = __webpack_require__(36);

var _clipperLib2 = _interopRequireDefault(_clipperLib);

var _sweepcontext = __webpack_require__(102);

var _sweepcontext2 = _interopRequireDefault(_sweepcontext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const inchToClipperScale = exports.inchToClipperScale = 1270000000;
const mmToClipperScale = exports.mmToClipperScale = inchToClipperScale / 25.4; // 50000000;
const clipperToCppScale = exports.clipperToCppScale = 1 / 128; // Prevent overflow for coordinates up to ~1000 mm
const cleanPolyDist = exports.cleanPolyDist = 100;
const arcTolerance = exports.arcTolerance = 10000;

// Linearize a cubic bezier. Returns ['L', x2, y2, x3, y3, ...]. The return value doesn't
// include (p1x, p1y); it's part of the previous segment.
function linearizeCubicBezier(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, minNumSegments, minSegmentLength) {
    function bez(p0, p1, p2, p3, t) {
        return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;
    }

    if (p1x == c1x && p1y == c1y && p2x == c2x && p2y == c2y) return ['L', p2x, p2y];

    let numSegments = minNumSegments;
    while (true) {
        let x = p1x;
        let y = p1y;
        let result = ['L'];
        for (let i = 1; i <= numSegments; ++i) {
            let t = 1.0 * i / numSegments;
            let nextX = bez(p1x, c1x, c2x, p2x, t);
            let nextY = bez(p1y, c1y, c2y, p2y, t);
            if ((nextX - x) * (nextX - x) + (nextY - y) * (nextY - y) > minSegmentLength * minSegmentLength) {
                numSegments *= 2;
                result = null;
                break;
            }
            result.push(nextX, nextY);
            x = nextX;
            y = nextY;
        }
        if (result) return result;
    }
}

// Linearize a path. Both the input path and the returned path are in snap.svg's format.
// Calls alertFn with an error message and returns null if there's a problem.
function linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn) {
    if (path.length < 2 || path[0].length != 3 || path[0][0] != 'M') {
        alertFn('Path does not begin with M');
        return null;
    }
    let x = path[0][1];
    let y = path[0][2];
    let result = [path[0]];
    for (let i = 1; i < path.length; ++i) {
        let subpath = path[i];
        if (subpath[0] == 'C' && subpath.length == 7) {
            result.push(linearizeCubicBezier(x, y, subpath[1], subpath[2], subpath[3], subpath[4], subpath[5], subpath[6], minNumSegments, minSegmentLength));
            x = subpath[5];
            y = subpath[6];
        } else if (subpath[0] == 'M' && subpath.length == 3) {
            result.push(subpath);
            x = subpath[1];
            y = subpath[2];
        } else {
            alertFn('Subpath has an unknown prefix: ' + subpath[0]);
            return null;
        }
    }
    return result;
};

// Get linear paths (snap format) from an SVG element. Calls alertFn with an
// error message and returns null if there's a problem.
function elementToLinearSnapPaths(element, minNumSegments, minSegmentLength, alertFn) {
    let path = null;
    let Snap = __webpack_require__(42);
    let snapElement = Snap(element);

    if (snapElement.type == 'path') path = snapElement.attr('d');else if (snapElement.type == 'rect') {
        let x = Number(snapElement.attr('x'));
        let y = Number(snapElement.attr('y'));
        let w = Number(snapElement.attr('width'));
        let h = Number(snapElement.attr('height'));
        path = 'm' + x + ',' + y + ' ' + w + ',' + 0 + ' ' + 0 + ',' + h + ' ' + -w + ',' + 0 + ' ' + 0 + ',' + -h + ' ';
    } else {
        alertFn('<b>' + snapElement.type + "</b> is not supported; try Inkscape's <strong>Object to Path</strong> command");
        return null;
    }

    if (snapElement.attr('clip-path') != '') {
        alertFn('clip-path is not supported');
        return null;
    }

    if (snapElement.attr('mask') != '') {
        alertFn('mask is not supported');
        return null;
    }

    if (path == null) {
        alertFn('path is missing');
        return;
    }

    path = Snap.path.map(path, snapElement.transform().globalMatrix);
    path = Snap.parsePathString(path);
    path = linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn);
    return path;
};

// Convert a path in snap.svg format to [[x0, y0, x1, y1, ...], ...].
// Result is in mm. Returns multiple paths. Only supports linear paths.
// Calls alertFn with an error message and returns null if there's a problem.
function snapPathToRawPaths(snapPath, pxPerInch, alertFn) {
    let factor = 2540 / (pxPerInch * 100);
    if (snapPath.length < 2 || snapPath[0].length != 3 || snapPath[0][0] != 'M') {
        alertFn('Path does not begin with M');
        return null;
    }
    let currentPath = [snapPath[0][1] * factor, snapPath[0][2] * factor];
    let result = [currentPath];
    for (let i = 1; i < snapPath.length; ++i) {
        let subpath = snapPath[i];
        if (subpath[0] == 'M' && subpath.length == 3) {
            currentPath = [subpath[1] * factor, subpath[2] * factor];
            result.push(currentPath);
        } else if (subpath[0] == 'L') {
            for (let j = 0; j < (subpath.length - 1) / 2; ++j) currentPath.push(subpath[1 + j * 2] * factor, subpath[2 + j * 2] * factor);
        } else {
            alertFn('Subpath has a non-linear prefix: ' + subpath[0]);
            return null;
        }
    }
    return result;
};

// Convert a path in an SVG element to [[x0, y0, x1, y1, ...], ...].
// Result is in mm. Returns multiple paths. Converts curves.
// Calls alertFn with an error message and returns null if there's a problem.
function elementToRawPaths(element, pxPerInch, minNumSegments, minSegmentLength, alertFn) {
    let path = elementToLinearSnapPaths(element, minNumSegments, minSegmentLength, alertFn);
    if (path !== null) return snapPathToRawPaths(path, pxPerInch, alertFn);
    return null;
}

// Convert an SVG path string to [[x0, y0, x1, y1, ...], ...].
// Result is in mm. Returns multiple paths. Converts curves.
// Calls alertFn with an error message and returns null if there's a problem.
function pathStrToRawPaths(str, pxPerInch, minNumSegments, minSegmentLength, alertFn) {
    let Snap = __webpack_require__(42);
    let path = Snap.parsePathString(str);
    path = Snap.path.toCubic(path);
    path = linearizeSnapPath(path, minNumSegments, minSegmentLength, alertFn);
    if (path !== null) return snapPathToRawPaths(path, pxPerInch, alertFn);
    return null;
}

// [[[x0, y0, x1, y1, ...], ...], ...]
function flipY(allRawPaths, deltaY) {
    for (let rawPaths of allRawPaths) for (let rawPath of rawPaths) for (let i = 0; i < rawPath.length; i += 2) rawPath[i + 1] = deltaY - rawPath[i + 1];
}

function hasClosedRawPaths(rawPaths) {
    for (let path of rawPaths) if (path.length >= 4 && path[0] == path[path.length - 2] && path[1] == path[path.length - 1]) return true;
    return false;
}

function filterClosedRawPaths(rawPaths) {
    let result = [];
    for (let path of rawPaths) if (path.length >= 4 && path[0] == path[path.length - 2] && path[1] == path[path.length - 1]) result.push(path);
    return result;
}

function rawPathsToClipperPaths(rawPaths, transform) {
    let result = rawPaths.map(p => {
        let result = [];
        for (let i = 0; i < p.length; i += 2) {
            result.push({
                X: (transform[0] * p[i] + transform[2] * p[i + 1] + transform[4]) * mmToClipperScale,
                Y: (transform[1] * p[i] + transform[3] * p[i + 1] + transform[5]) * mmToClipperScale
            });
        }
        return result;
    });
    if (hasClosedRawPaths(rawPaths)) {
        result = _clipperLib2.default.Clipper.CleanPolygons(result, cleanPolyDist);
        result = _clipperLib2.default.Clipper.SimplifyPolygons(result, _clipperLib2.default.PolyFillType.pftEvenOdd);
    }
    return result;
}

function clipperPathsToPolyTree(paths) {
    let c = new _clipperLib2.default.Clipper();
    c.AddPaths(paths, _clipperLib2.default.PolyType.ptSubject, true);
    let polyTree = new _clipperLib2.default.PolyTree();
    c.Execute(_clipperLib2.default.ClipType.ctUnion, polyTree, _clipperLib2.default.PolyFillType.pftEvenOdd, _clipperLib2.default.PolyFillType.pftEvenOdd);
    return polyTree;
}

function triangulatePolyTree(polyTree) {
    let result = [];
    let pointToVertex = point => ({ x: point.X / mmToClipperScale, y: point.Y / mmToClipperScale });
    let contourToVertexes = path => path.map(pointToVertex);
    let nodesToVertexes = nodes => nodes.map(node => contourToVertexes(node.Contour()));
    let processNode = node => {
        let vertexes = contourToVertexes(node.Contour());
        let holes = nodesToVertexes(node.Childs());
        let context = new _sweepcontext2.default(vertexes);
        context.addHoles(holes);
        context.triangulate();
        let triangles = context.getTriangles();
        for (let t of triangles) {
            let p = t.getPoints();
            result.push(p[0].x, p[0].y, p[1].x, p[1].y, p[2].x, p[2].y);
        }
        for (let hole of node.Childs()) {
            for (let next of hole.Childs()) {
                processNode(next);
            }
        }
    };
    for (let node of polyTree.Childs()) {
        processNode(node);
    }
    return result;
}

function triangulateRawPaths(rawPaths) {
    return triangulatePolyTree(clipperPathsToPolyTree(rawPathsToClipperPaths(rawPaths, [1, 0, 0, 1, 0, 0])));
}

// Convert Clipper paths to C. Returns [double** cPaths, int cNumPaths, int* cPathSizes].
function clipperPathsToCPaths(memoryBlocks, clipperPaths) {
    let doubleSize = 8;

    let cPaths = Module._malloc(clipperPaths.length * 4);
    memoryBlocks.push(cPaths);
    let cPathsBase = cPaths >> 2;

    let cPathSizes = Module._malloc(clipperPaths.length * 4);
    memoryBlocks.push(cPathSizes);
    let cPathSizesBase = cPathSizes >> 2;

    for (let i = 0; i < clipperPaths.length; ++i) {
        let clipperPath = clipperPaths[i];

        let cPath = Module._malloc(clipperPath.length * 2 * doubleSize + 4);
        memoryBlocks.push(cPath);
        if (cPath & 4) cPath += 4;
        //console.log("-> " + cPath.toString(16));
        let pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);

        for (let j = 0; j < clipperPath.length; ++j) {
            let point = clipperPath[j];
            pathArray[j * 2] = point.X * clipperToCppScale;
            pathArray[j * 2 + 1] = point.Y * clipperToCppScale;
        }

        Module.HEAPU32[cPathsBase + i] = cPath;
        Module.HEAPU32[cPathSizesBase + i] = clipperPath.length;
    }

    return [cPaths, clipperPaths.length, cPathSizes];
}

// Convert C paths to Clipper paths. double**& cPathsRef, int& cNumPathsRef, int*& cPathSizesRef
// Each point has X, Y (stride = 2).
function cPathsToClipperPaths(memoryBlocks, cPathsRef, cNumPathsRef, cPathSizesRef) {
    let cPaths = Module.HEAPU32[cPathsRef >> 2];
    memoryBlocks.push(cPaths);
    let cPathsBase = cPaths >> 2;

    let cNumPaths = Module.HEAPU32[cNumPathsRef >> 2];

    let cPathSizes = Module.HEAPU32[cPathSizesRef >> 2];
    memoryBlocks.push(cPathSizes);
    let cPathSizesBase = cPathSizes >> 2;

    let clipperPaths = [];
    for (let i = 0; i < cNumPaths; ++i) {
        let pathSize = Module.HEAPU32[cPathSizesBase + i];
        let cPath = Module.HEAPU32[cPathsBase + i];
        // cPath contains value to pass to Module._free(). The aligned version contains the actual data.
        memoryBlocks.push(cPath);
        if (cPath & 4) cPath += 4;
        let pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);

        let clipperPath = [];
        clipperPaths.push(clipperPath);
        for (let j = 0; j < pathSize; ++j) clipperPath.push({
            X: pathArray[j * 2] / clipperToCppScale,
            Y: pathArray[j * 2 + 1] / clipperToCppScale
        });
    }

    return clipperPaths;
}

// Convert C paths to array of CamPath. double**& cPathsRef, int& cNumPathsRef, int*& cPathSizesRef
// Each point has X, Y, Z (stride = 3).
function cPathsToCamPaths(memoryBlocks, cPathsRef, cNumPathsRef, cPathSizesRef) {
    let cPaths = Module.HEAPU32[cPathsRef >> 2];
    memoryBlocks.push(cPaths);
    let cPathsBase = cPaths >> 2;

    let cNumPaths = Module.HEAPU32[cNumPathsRef >> 2];

    let cPathSizes = Module.HEAPU32[cPathSizesRef >> 2];
    memoryBlocks.push(cPathSizes);
    let cPathSizesBase = cPathSizes >> 2;

    let convertedPaths = [];
    for (let i = 0; i < cNumPaths; ++i) {
        let pathSize = Module.HEAPU32[cPathSizesBase + i];
        let cPath = Module.HEAPU32[cPathsBase + i];
        // cPath contains value to pass to Module._free(). The aligned version contains the actual data.
        memoryBlocks.push(cPath);
        if (cPath & 4) cPath += 4;
        let pathArray = new Float64Array(Module.HEAPU32.buffer, Module.HEAPU32.byteOffset + cPath);

        let convertedPath = [];
        convertedPaths.push({ path: convertedPath, safeToClose: false });
        for (let j = 0; j < pathSize; ++j) convertedPath.push({
            X: pathArray[j * 3] / clipperToCppScale,
            Y: pathArray[j * 3 + 1] / clipperToCppScale,
            Z: pathArray[j * 3 + 2] / clipperToCppScale
        });

        //console.log('got: path', i, ':', pathArray[0], pathArray[1], pathArray[2]);
    }

    return convertedPaths;
}

function clipperBounds(paths) {
    let minX = Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;
    let maxX = -Number.MAX_VALUE;
    let maxY = -Number.MAX_VALUE;
    for (let path of paths) {
        for (let pt of path) {
            minX = Math.min(minX, pt.X);
            maxX = Math.max(maxX, pt.X);
            minY = Math.min(minY, pt.Y);
            maxY = Math.max(maxY, pt.Y);
        }
    }
    return { minX, minY, maxX, maxY };
}

// Clip Clipper geometry. clipType is a ClipperLib.ClipType constant. Returns new geometry.
function clip(paths1, paths2, clipType) {
    var clipper = new _clipperLib2.default.Clipper();
    clipper.AddPaths(paths1, _clipperLib2.default.PolyType.ptSubject, true);
    clipper.AddPaths(paths2, _clipperLib2.default.PolyType.ptClip, true);
    var result = [];
    clipper.Execute(clipType, result, _clipperLib2.default.PolyFillType.pftEvenOdd, _clipperLib2.default.PolyFillType.pftEvenOdd);
    return result;
}

// Return union of two Clipper geometries. Returns new geometry.
function union(paths1, paths2) {
    return clip(paths1, paths2, _clipperLib2.default.ClipType.ctUnion);
}

// Return difference between two Clipper geometries. Returns new geometry.
function diff(paths1, paths2) {
    return clip(paths1, paths2, _clipperLib2.default.ClipType.ctDifference);
}

// Return xor of two Clipper geometries. Returns new geometry.
function xor(paths1, paths2) {
    return clip(paths1, paths2, _clipperLib2.default.ClipType.ctXor);
}

// Offset Clipper geometries by amount (positive expands, negative shrinks). Returns new geometry.
function offset(paths, amount, joinType, endType) {
    if (joinType === undefined) joinType = _clipperLib2.default.JoinType.jtRound;
    if (endType === undefined) endType = _clipperLib2.default.EndType.etClosedPolygon;

    // bug workaround: join types are swapped in ClipperLib 6.1.3.2
    if (joinType === _clipperLib2.default.JoinType.jtSquare) joinType = _clipperLib2.default.JoinType.jtMiter;else if (joinType === _clipperLib2.default.JoinType.jtMiter) joinType = _clipperLib2.default.JoinType.jtSquare;

    var co = new _clipperLib2.default.ClipperOffset(2, arcTolerance);
    co.AddPaths(paths, joinType, endType);
    var offsetted = [];
    co.Execute(offsetted, amount);
    return offsetted;
}
;

var _temp = function () {
    if (typeof __REACT_HOT_LOADER__ === 'undefined') {
        return;
    }

    __REACT_HOT_LOADER__.register(inchToClipperScale, 'inchToClipperScale', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(mmToClipperScale, 'mmToClipperScale', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(clipperToCppScale, 'clipperToCppScale', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(cleanPolyDist, 'cleanPolyDist', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(arcTolerance, 'arcTolerance', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(linearizeCubicBezier, 'linearizeCubicBezier', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(linearizeSnapPath, 'linearizeSnapPath', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(elementToLinearSnapPaths, 'elementToLinearSnapPaths', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(snapPathToRawPaths, 'snapPathToRawPaths', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(elementToRawPaths, 'elementToRawPaths', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(pathStrToRawPaths, 'pathStrToRawPaths', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(flipY, 'flipY', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(hasClosedRawPaths, 'hasClosedRawPaths', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(filterClosedRawPaths, 'filterClosedRawPaths', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(rawPathsToClipperPaths, 'rawPathsToClipperPaths', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(clipperPathsToPolyTree, 'clipperPathsToPolyTree', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(triangulatePolyTree, 'triangulatePolyTree', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(triangulateRawPaths, 'triangulateRawPaths', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(clipperPathsToCPaths, 'clipperPathsToCPaths', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(cPathsToClipperPaths, 'cPathsToClipperPaths', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(cPathsToCamPaths, 'cPathsToCamPaths', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(clipperBounds, 'clipperBounds', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(clip, 'clip', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(union, 'union', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(diff, 'diff', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(xor, 'xor', '/home/pi/LaserWeb4/src/lib/mesh.js');

    __REACT_HOT_LOADER__.register(offset, 'offset', '/home/pi/LaserWeb4/src/lib/mesh.js');
}();

;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// rev 482
/********************************************************************************
 *                                                                              *
 * Author    :  Angus Johnson                                                   *
 * Version   :  6.2.1                                                          *
 * Date      :  31 October 2014                                                 *
 * Website   :  http://www.angusj.com                                           *
 * Copyright :  Angus Johnson 2010-2014                                         *
 *                                                                              *
 * License:                                                                     *
 * Use, modification & distribution is subject to Boost Software License Ver 1. *
 * http://www.boost.org/LICENSE_1_0.txt                                         *
 *                                                                              *
 * Attributions:                                                                *
 * The code in this library is an extension of Bala Vatti's clipping algorithm: *
 * "A generic solution to polygon clipping"                                     *
 * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *
 * http://portal.acm.org/citation.cfm?id=129906                                 *
 *                                                                              *
 * Computer graphics and geometric modeling: implementation and algorithms      *
 * By Max K. Agoston                                                            *
 * Springer; 1 edition (January 4, 2005)                                        *
 * http://books.google.com/books?q=vatti+clipping+agoston                       *
 *                                                                              *
 * See also:                                                                    *
 * "Polygon Offsetting by Computing Winding Numbers"                            *
 * Paper no. DETC2005-85513 pp. 565-575                                         *
 * ASME 2005 International Design Engineering Technical Conferences             *
 * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *
 * September 24-28, 2005 , Long Beach, California, USA                          *
 * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *
 *                                                                              *
 *******************************************************************************/
/*******************************************************************************
 *                                                                              *
 * Author    :  Timo                                                            *
 * Version   :  6.2.1.0                                                         *
 * Date      :  17 June 2016                                                 *
 *                                                                              *
 * This is a translation of the C# Clipper library to Javascript.               *
 * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *
 * Because Javascript lacks support for 64-bit integers, the space              *
 * is a little more restricted than in C# version.                              *
 *                                                                              *
 * C# version has support for coordinate space:                                 *
 * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *
 * while Javascript version has support for space:                              *
 * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *
 *                                                                              *
 * Tom Wu's JSBN proved to be the fastest big integer library:                  *
 * http://jsperf.com/big-integer-library-test                                   *
 *                                                                              *
 * This class can be made simpler when (if ever) 64-bit integer support comes.  *
 *                                                                              *
 *******************************************************************************/
/*******************************************************************************
 *                                                                              *
 * Basic JavaScript BN library - subset useful for RSA encryption.              *
 * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *
 * Copyright (c) 2005  Tom Wu                                                   *
 * All Rights Reserved.                                                         *
 * See "LICENSE" for details:                                                   *
 * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *
 *                                                                              *
 *******************************************************************************/
(function ()
{
  "use strict";
  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This
  //improve performance but coordinate values are limited to the range +/- 46340
  var use_int32 = false;
  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.
  var use_xyz = false;
  //UseLines: Enables open path clipping. Adds a very minor cost to performance.
  var use_lines = true;

  var ClipperLib = {};
  var isNode = false;
  if (typeof module !== 'undefined' && module.exports)
  {
    module.exports = ClipperLib;
    isNode = true;
  }
  else
  {
    if (true) {
      !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ClipperLib),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    if (typeof (document) !== "undefined") window.ClipperLib = ClipperLib;
    else self['ClipperLib'] = ClipperLib;
  }
  var navigator_appName;
  if (!isNode)
  {
    var nav = navigator.userAgent.toString().toLowerCase();
    navigator_appName = navigator.appName;
  }
  else
  {
    var nav = "chrome"; // Node.js uses Chrome's V8 engine
    navigator_appName = "Netscape"; // Firefox, Chrome and Safari returns "Netscape", so Node.js should also
  }
  // Browser test to speedup performance critical functions
  var browser = {};
  if (nav.indexOf("chrome") != -1 && nav.indexOf("chromium") == -1) browser.chrome = 1;
  else browser.chrome = 0;
  if (nav.indexOf("chromium") != -1) browser.chromium = 1;
  else browser.chromium = 0;
  if (nav.indexOf("safari") != -1 && nav.indexOf("chrome") == -1 && nav.indexOf("chromium") == -1) browser.safari = 1;
  else browser.safari = 0;
  if (nav.indexOf("firefox") != -1) browser.firefox = 1;
  else browser.firefox = 0;
  if (nav.indexOf("firefox/17") != -1) browser.firefox17 = 1;
  else browser.firefox17 = 0;
  if (nav.indexOf("firefox/15") != -1) browser.firefox15 = 1;
  else browser.firefox15 = 0;
  if (nav.indexOf("firefox/3") != -1) browser.firefox3 = 1;
  else browser.firefox3 = 0;
  if (nav.indexOf("opera") != -1) browser.opera = 1;
  else browser.opera = 0;
  if (nav.indexOf("msie 10") != -1) browser.msie10 = 1;
  else browser.msie10 = 0;
  if (nav.indexOf("msie 9") != -1) browser.msie9 = 1;
  else browser.msie9 = 0;
  if (nav.indexOf("msie 8") != -1) browser.msie8 = 1;
  else browser.msie8 = 0;
  if (nav.indexOf("msie 7") != -1) browser.msie7 = 1;
  else browser.msie7 = 0;
  if (nav.indexOf("msie ") != -1) browser.msie = 1;
  else browser.msie = 0;
  ClipperLib.biginteger_used = null;

  // Copyright (c) 2005  Tom Wu
  // All Rights Reserved.
  // See "LICENSE" for details.
  // Basic JavaScript BN library - subset useful for RSA encryption.
  // Bits per digit
  var dbits;
  // JavaScript engine analysis
  var canary = 0xdeadbeefcafe;
  var j_lm = ((canary & 0xffffff) == 0xefcafe);
  // (public) Constructor
  function BigInteger(a, b, c)
  {
    // This test variable can be removed,
    // but at least for performance tests it is useful piece of knowledge
    // This is the only ClipperLib related variable in BigInteger library
    ClipperLib.biginteger_used = 1;
    if (a != null)
      if ("number" == typeof a && "undefined" == typeof (b)) this.fromInt(a); // faster conversion
      else if ("number" == typeof a) this.fromNumber(a, b, c);
    else if (b == null && "string" != typeof a) this.fromString(a, 256);
    else this.fromString(a, b);
  }
  // return new, unset BigInteger
  function nbi()
  {
    return new BigInteger(null,undefined,undefined);
  }
  // am: Compute w_j += (x*this_i), propagate carries,
  // c is initial carry, returns final carry.
  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
  // We need to select the fastest one that works in this environment.
  // am1: use a single mult and divide to get the high bits,
  // max digit bits should be 26 because
  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
  function am1(i, x, w, j, c, n)
  {
    while (--n >= 0)
    {
      var v = x * this[i++] + w[j] + c;
      c = Math.floor(v / 0x4000000);
      w[j++] = v & 0x3ffffff;
    }
    return c;
  }
  // am2 avoids a big mult-and-extract completely.
  // Max digit bits should be <= 30 because we do bitwise ops
  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
  function am2(i, x, w, j, c, n)
  {
    var xl = x & 0x7fff,
      xh = x >> 15;
    while (--n >= 0)
    {
      var l = this[i] & 0x7fff;
      var h = this[i++] >> 15;
      var m = xh * l + h * xl;
      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
      w[j++] = l & 0x3fffffff;
    }
    return c;
  }
  // Alternately, set max digit bits to 28 since some
  // browsers slow down when dealing with 32-bit numbers.
  function am3(i, x, w, j, c, n)
  {
    var xl = x & 0x3fff,
      xh = x >> 14;
    while (--n >= 0)
    {
      var l = this[i] & 0x3fff;
      var h = this[i++] >> 14;
      var m = xh * l + h * xl;
      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
      c = (l >> 28) + (m >> 14) + xh * h;
      w[j++] = l & 0xfffffff;
    }
    return c;
  }
  if (j_lm && (navigator_appName == "Microsoft Internet Explorer"))
  {
    BigInteger.prototype.am = am2;
    dbits = 30;
  }
  else if (j_lm && (navigator_appName != "Netscape"))
  {
    BigInteger.prototype.am = am1;
    dbits = 26;
  }
  else
  { // Mozilla/Netscape seems to prefer am3
    BigInteger.prototype.am = am3;
    dbits = 28;
  }
  BigInteger.prototype.DB = dbits;
  BigInteger.prototype.DM = ((1 << dbits) - 1);
  BigInteger.prototype.DV = (1 << dbits);
  var BI_FP = 52;
  BigInteger.prototype.FV = Math.pow(2, BI_FP);
  BigInteger.prototype.F1 = BI_FP - dbits;
  BigInteger.prototype.F2 = 2 * dbits - BI_FP;
  // Digit conversions
  var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
  var BI_RC = new Array();
  var rr, vv;
  rr = "0".charCodeAt(0);
  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
  rr = "a".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
  rr = "A".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

  function int2char(n)
  {
    return BI_RM.charAt(n);
  }

  function intAt(s, i)
  {
    var c = BI_RC[s.charCodeAt(i)];
    return (c == null) ? -1 : c;
  }
  // (protected) copy this to r
  function bnpCopyTo(r)
  {
    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
    r.t = this.t;
    r.s = this.s;
  }
  // (protected) set from integer value x, -DV <= x < DV
  function bnpFromInt(x)
  {
    this.t = 1;
    this.s = (x < 0) ? -1 : 0;
    if (x > 0) this[0] = x;
    else if (x < -1) this[0] = x + this.DV;
    else this.t = 0;
  }
  // return bigint initialized to value
  function nbv(i)
  {
    var r = nbi();
    r.fromInt(i);
    return r;
  }
  // (protected) set from string and radix
  function bnpFromString(s, b)
  {
    var k;
    if (b == 16) k = 4;
    else if (b == 8) k = 3;
    else if (b == 256) k = 8; // byte array
    else if (b == 2) k = 1;
    else if (b == 32) k = 5;
    else if (b == 4) k = 2;
    else
    {
      this.fromRadix(s, b);
      return;
    }
    this.t = 0;
    this.s = 0;
    var i = s.length,
      mi = false,
      sh = 0;
    while (--i >= 0)
    {
      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);
      if (x < 0)
      {
        if (s.charAt(i) == "-") mi = true;
        continue;
      }
      mi = false;
      if (sh == 0)
        this[this.t++] = x;
      else if (sh + k > this.DB)
      {
        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
        this[this.t++] = (x >> (this.DB - sh));
      }
      else
        this[this.t - 1] |= x << sh;
      sh += k;
      if (sh >= this.DB) sh -= this.DB;
    }
    if (k == 8 && (s[0] & 0x80) != 0)
    {
      this.s = -1;
      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
    }
    this.clamp();
    if (mi) BigInteger.ZERO.subTo(this, this);
  }
  // (protected) clamp off excess high words
  function bnpClamp()
  {
    var c = this.s & this.DM;
    while (this.t > 0 && this[this.t - 1] == c)--this.t;
  }
  // (public) return string representation in given radix
  function bnToString(b)
  {
    if (this.s < 0) return "-" + this.negate().toString(b);
    var k;
    if (b == 16) k = 4;
    else if (b == 8) k = 3;
    else if (b == 2) k = 1;
    else if (b == 32) k = 5;
    else if (b == 4) k = 2;
    else return this.toRadix(b);
    var km = (1 << k) - 1,
      d, m = false,
      r = "",
      i = this.t;
    var p = this.DB - (i * this.DB) % k;
    if (i-- > 0)
    {
      if (p < this.DB && (d = this[i] >> p) > 0)
      {
        m = true;
        r = int2char(d);
      }
      while (i >= 0)
      {
        if (p < k)
        {
          d = (this[i] & ((1 << p) - 1)) << (k - p);
          d |= this[--i] >> (p += this.DB - k);
        }
        else
        {
          d = (this[i] >> (p -= k)) & km;
          if (p <= 0)
          {
            p += this.DB;
            --i;
          }
        }
        if (d > 0) m = true;
        if (m) r += int2char(d);
      }
    }
    return m ? r : "0";
  }
  // (public) -this
  function bnNegate()
  {
    var r = nbi();
    BigInteger.ZERO.subTo(this, r);
    return r;
  }
  // (public) |this|
  function bnAbs()
  {
    return (this.s < 0) ? this.negate() : this;
  }
  // (public) return + if this > a, - if this < a, 0 if equal
  function bnCompareTo(a)
  {
    var r = this.s - a.s;
    if (r != 0) return r;
    var i = this.t;
    r = i - a.t;
    if (r != 0) return (this.s < 0) ? -r : r;
    while (--i >= 0)
      if ((r = this[i] - a[i]) != 0) return r;
    return 0;
  }
  // returns bit length of the integer x
  function nbits(x)
  {
    var r = 1,
      t;
    if ((t = x >>> 16) != 0)
    {
      x = t;
      r += 16;
    }
    if ((t = x >> 8) != 0)
    {
      x = t;
      r += 8;
    }
    if ((t = x >> 4) != 0)
    {
      x = t;
      r += 4;
    }
    if ((t = x >> 2) != 0)
    {
      x = t;
      r += 2;
    }
    if ((t = x >> 1) != 0)
    {
      x = t;
      r += 1;
    }
    return r;
  }
  // (public) return the number of bits in "this"
  function bnBitLength()
  {
    if (this.t <= 0) return 0;
    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
  }
  // (protected) r = this << n*DB
  function bnpDLShiftTo(n, r)
  {
    var i;
    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
    for (i = n - 1; i >= 0; --i) r[i] = 0;
    r.t = this.t + n;
    r.s = this.s;
  }
  // (protected) r = this >> n*DB
  function bnpDRShiftTo(n, r)
  {
    for (var i = n; i < this.t; ++i) r[i - n] = this[i];
    r.t = Math.max(this.t - n, 0);
    r.s = this.s;
  }
  // (protected) r = this << n
  function bnpLShiftTo(n, r)
  {
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << cbs) - 1;
    var ds = Math.floor(n / this.DB),
      c = (this.s << bs) & this.DM,
      i;
    for (i = this.t - 1; i >= 0; --i)
    {
      r[i + ds + 1] = (this[i] >> cbs) | c;
      c = (this[i] & bm) << bs;
    }
    for (i = ds - 1; i >= 0; --i) r[i] = 0;
    r[ds] = c;
    r.t = this.t + ds + 1;
    r.s = this.s;
    r.clamp();
  }
  // (protected) r = this >> n
  function bnpRShiftTo(n, r)
  {
    r.s = this.s;
    var ds = Math.floor(n / this.DB);
    if (ds >= this.t)
    {
      r.t = 0;
      return;
    }
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << bs) - 1;
    r[0] = this[ds] >> bs;
    for (var i = ds + 1; i < this.t; ++i)
    {
      r[i - ds - 1] |= (this[i] & bm) << cbs;
      r[i - ds] = this[i] >> bs;
    }
    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
    r.t = this.t - ds;
    r.clamp();
  }
  // (protected) r = this - a
  function bnpSubTo(a, r)
  {
    var i = 0,
      c = 0,
      m = Math.min(a.t, this.t);
    while (i < m)
    {
      c += this[i] - a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    if (a.t < this.t)
    {
      c -= a.s;
      while (i < this.t)
      {
        c += this[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else
    {
      c += this.s;
      while (i < a.t)
      {
        c -= a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c -= a.s;
    }
    r.s = (c < 0) ? -1 : 0;
    if (c < -1) r[i++] = this.DV + c;
    else if (c > 0) r[i++] = c;
    r.t = i;
    r.clamp();
  }
  // (protected) r = this * a, r != this,a (HAC 14.12)
  // "this" should be the larger one if appropriate.
  function bnpMultiplyTo(a, r)
  {
    var x = this.abs(),
      y = a.abs();
    var i = x.t;
    r.t = i + y.t;
    while (--i >= 0) r[i] = 0;
    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
    r.s = 0;
    r.clamp();
    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
  }
  // (protected) r = this^2, r != this (HAC 14.16)
  function bnpSquareTo(r)
  {
    var x = this.abs();
    var i = r.t = 2 * x.t;
    while (--i >= 0) r[i] = 0;
    for (i = 0; i < x.t - 1; ++i)
    {
      var c = x.am(i, x[i], r, 2 * i, 0, 1);
      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)
      {
        r[i + x.t] -= x.DV;
        r[i + x.t + 1] = 1;
      }
    }
    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
    r.s = 0;
    r.clamp();
  }
  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
  // r != q, this != m.  q or r may be null.
  function bnpDivRemTo(m, q, r)
  {
    var pm = m.abs();
    if (pm.t <= 0) return;
    var pt = this.abs();
    if (pt.t < pm.t)
    {
      if (q != null) q.fromInt(0);
      if (r != null) this.copyTo(r);
      return;
    }
    if (r == null) r = nbi();
    var y = nbi(),
      ts = this.s,
      ms = m.s;
    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus
    if (nsh > 0)
    {
      pm.lShiftTo(nsh, y);
      pt.lShiftTo(nsh, r);
    }
    else
    {
      pm.copyTo(y);
      pt.copyTo(r);
    }
    var ys = y.t;
    var y0 = y[ys - 1];
    if (y0 == 0) return;
    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
    var d1 = this.FV / yt,
      d2 = (1 << this.F1) / yt,
      e = 1 << this.F2;
    var i = r.t,
      j = i - ys,
      t = (q == null) ? nbi() : q;
    y.dlShiftTo(j, t);
    if (r.compareTo(t) >= 0)
    {
      r[r.t++] = 1;
      r.subTo(t, r);
    }
    BigInteger.ONE.dlShiftTo(ys, t);
    t.subTo(y, y); // "negative" y so we can replace sub with am later
    while (y.t < ys) y[y.t++] = 0;
    while (--j >= 0)
    {
      // Estimate quotient digit
      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)
      { // Try it out
        y.dlShiftTo(j, t);
        r.subTo(t, r);
        while (r[i] < --qd) r.subTo(t, r);
      }
    }
    if (q != null)
    {
      r.drShiftTo(ys, q);
      if (ts != ms) BigInteger.ZERO.subTo(q, q);
    }
    r.t = ys;
    r.clamp();
    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder
    if (ts < 0) BigInteger.ZERO.subTo(r, r);
  }
  // (public) this mod a
  function bnMod(a)
  {
    var r = nbi();
    this.abs().divRemTo(a, null, r);
    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
    return r;
  }
  // Modular reduction using "classic" algorithm
  function Classic(m)
  {
    this.m = m;
  }

  function cConvert(x)
  {
    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
    else return x;
  }

  function cRevert(x)
  {
    return x;
  }

  function cReduce(x)
  {
    x.divRemTo(this.m, null, x);
  }

  function cMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
    this.reduce(r);
  }

  function cSqrTo(x, r)
  {
    x.squareTo(r);
    this.reduce(r);
  }
  Classic.prototype.convert = cConvert;
  Classic.prototype.revert = cRevert;
  Classic.prototype.reduce = cReduce;
  Classic.prototype.mulTo = cMulTo;
  Classic.prototype.sqrTo = cSqrTo;
  // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
  // justification:
  //         xy == 1 (mod m)
  //         xy =  1+km
  //   xy(2-xy) = (1+km)(1-km)
  // x[y(2-xy)] = 1-k^2m^2
  // x[y(2-xy)] == 1 (mod m^2)
  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
  // JS multiply "overflows" differently from C/C++, so care is needed here.
  function bnpInvDigit()
  {
    if (this.t < 1) return 0;
    var x = this[0];
    if ((x & 1) == 0) return 0;
    var y = x & 3; // y == 1/x mod 2^2
    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4
    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8
    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16
    // last step - calculate inverse mod DV directly;
    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits
    // we really want the negative inverse, and -DV < y < DV
    return (y > 0) ? this.DV - y : -y;
  }
  // Montgomery reduction
  function Montgomery(m)
  {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp & 0x7fff;
    this.mph = this.mp >> 15;
    this.um = (1 << (m.DB - 15)) - 1;
    this.mt2 = 2 * m.t;
  }
  // xR mod m
  function montConvert(x)
  {
    var r = nbi();
    x.abs().dlShiftTo(this.m.t, r);
    r.divRemTo(this.m, null, r);
    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
    return r;
  }
  // x/R mod m
  function montRevert(x)
  {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }
  // x = x/R mod m (HAC 14.32)
  function montReduce(x)
  {
    while (x.t <= this.mt2) // pad x so am has enough room later
      x[x.t++] = 0;
    for (var i = 0; i < this.m.t; ++i)
    {
      // faster way of calculating u0 = x[i]*mp mod DV
      var j = x[i] & 0x7fff;
      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
      // use am to combine the multiply-shift-add into one call
      j = i + this.m.t;
      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
      // propagate carry
      while (x[j] >= x.DV)
      {
        x[j] -= x.DV;
        x[++j]++;
      }
    }
    x.clamp();
    x.drShiftTo(this.m.t, x);
    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
  }
  // r = "x^2/R mod m"; x != r
  function montSqrTo(x, r)
  {
    x.squareTo(r);
    this.reduce(r);
  }
  // r = "xy/R mod m"; x,y != r
  function montMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
    this.reduce(r);
  }
  Montgomery.prototype.convert = montConvert;
  Montgomery.prototype.revert = montRevert;
  Montgomery.prototype.reduce = montReduce;
  Montgomery.prototype.mulTo = montMulTo;
  Montgomery.prototype.sqrTo = montSqrTo;
  // (protected) true iff this is even
  function bnpIsEven()
  {
    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;
  }
  // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
  function bnpExp(e, z)
  {
    if (e > 0xffffffff || e < 1) return BigInteger.ONE;
    var r = nbi(),
      r2 = nbi(),
      g = z.convert(this),
      i = nbits(e) - 1;
    g.copyTo(r);
    while (--i >= 0)
    {
      z.sqrTo(r, r2);
      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
      else
      {
        var t = r;
        r = r2;
        r2 = t;
      }
    }
    return z.revert(r);
  }
  // (public) this^e % m, 0 <= e < 2^32
  function bnModPowInt(e, m)
  {
    var z;
    if (e < 256 || m.isEven()) z = new Classic(m);
    else z = new Montgomery(m);
    return this.exp(e, z);
  }
  // protected
  BigInteger.prototype.copyTo = bnpCopyTo;
  BigInteger.prototype.fromInt = bnpFromInt;
  BigInteger.prototype.fromString = bnpFromString;
  BigInteger.prototype.clamp = bnpClamp;
  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
  BigInteger.prototype.drShiftTo = bnpDRShiftTo;
  BigInteger.prototype.lShiftTo = bnpLShiftTo;
  BigInteger.prototype.rShiftTo = bnpRShiftTo;
  BigInteger.prototype.subTo = bnpSubTo;
  BigInteger.prototype.multiplyTo = bnpMultiplyTo;
  BigInteger.prototype.squareTo = bnpSquareTo;
  BigInteger.prototype.divRemTo = bnpDivRemTo;
  BigInteger.prototype.invDigit = bnpInvDigit;
  BigInteger.prototype.isEven = bnpIsEven;
  BigInteger.prototype.exp = bnpExp;
  // public
  BigInteger.prototype.toString = bnToString;
  BigInteger.prototype.negate = bnNegate;
  BigInteger.prototype.abs = bnAbs;
  BigInteger.prototype.compareTo = bnCompareTo;
  BigInteger.prototype.bitLength = bnBitLength;
  BigInteger.prototype.mod = bnMod;
  BigInteger.prototype.modPowInt = bnModPowInt;
  // "constants"
  BigInteger.ZERO = nbv(0);
  BigInteger.ONE = nbv(1);
  // Copyright (c) 2005-2009  Tom Wu
  // All Rights Reserved.
  // See "LICENSE" for details.
  // Extended JavaScript BN functions, required for RSA private ops.
  // Version 1.1: new BigInteger("0", 10) returns "proper" zero
  // Version 1.2: square() API, isProbablePrime fix
  // (public)
  function bnClone()
  {
    var r = nbi();
    this.copyTo(r);
    return r;
  }
  // (public) return value as integer
  function bnIntValue()
  {
    if (this.s < 0)
    {
      if (this.t == 1) return this[0] - this.DV;
      else if (this.t == 0) return -1;
    }
    else if (this.t == 1) return this[0];
    else if (this.t == 0) return 0;
    // assumes 16 < DB < 32
    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
  }
  // (public) return value as byte
  function bnByteValue()
  {
    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
  }
  // (public) return value as short (assumes DB>=16)
  function bnShortValue()
  {
    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
  }
  // (protected) return x s.t. r^x < DV
  function bnpChunkSize(r)
  {
    return Math.floor(Math.LN2 * this.DB / Math.log(r));
  }
  // (public) 0 if this == 0, 1 if this > 0
  function bnSigNum()
  {
    if (this.s < 0) return -1;
    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
    else return 1;
  }
  // (protected) convert to radix string
  function bnpToRadix(b)
  {
    if (b == null) b = 10;
    if (this.signum() == 0 || b < 2 || b > 36) return "0";
    var cs = this.chunkSize(b);
    var a = Math.pow(b, cs);
    var d = nbv(a),
      y = nbi(),
      z = nbi(),
      r = "";
    this.divRemTo(d, y, z);
    while (y.signum() > 0)
    {
      r = (a + z.intValue()).toString(b).substr(1) + r;
      y.divRemTo(d, y, z);
    }
    return z.intValue().toString(b) + r;
  }
  // (protected) convert from radix string
  function bnpFromRadix(s, b)
  {
    this.fromInt(0);
    if (b == null) b = 10;
    var cs = this.chunkSize(b);
    var d = Math.pow(b, cs),
      mi = false,
      j = 0,
      w = 0;
    for (var i = 0; i < s.length; ++i)
    {
      var x = intAt(s, i);
      if (x < 0)
      {
        if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
        continue;
      }
      w = b * w + x;
      if (++j >= cs)
      {
        this.dMultiply(d);
        this.dAddOffset(w, 0);
        j = 0;
        w = 0;
      }
    }
    if (j > 0)
    {
      this.dMultiply(Math.pow(b, j));
      this.dAddOffset(w, 0);
    }
    if (mi) BigInteger.ZERO.subTo(this, this);
  }
  // (protected) alternate constructor
  function bnpFromNumber(a, b, c)
  {
    if ("number" == typeof b)
    {
      // new BigInteger(int,int,RNG)
      if (a < 2) this.fromInt(1);
      else
      {
        this.fromNumber(a, c);
        if (!this.testBit(a - 1)) // force MSB set
          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
        if (this.isEven()) this.dAddOffset(1, 0); // force odd
        while (!this.isProbablePrime(b))
        {
          this.dAddOffset(2, 0);
          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
        }
      }
    }
    else
    {
      // new BigInteger(int,RNG)
      var x = new Array(),
        t = a & 7;
      x.length = (a >> 3) + 1;
      b.nextBytes(x);
      if (t > 0) x[0] &= ((1 << t) - 1);
      else x[0] = 0;
      this.fromString(x, 256);
    }
  }
  // (public) convert to bigendian byte array
  function bnToByteArray()
  {
    var i = this.t,
      r = new Array();
    r[0] = this.s;
    var p = this.DB - (i * this.DB) % 8,
      d, k = 0;
    if (i-- > 0)
    {
      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
        r[k++] = d | (this.s << (this.DB - p));
      while (i >= 0)
      {
        if (p < 8)
        {
          d = (this[i] & ((1 << p) - 1)) << (8 - p);
          d |= this[--i] >> (p += this.DB - 8);
        }
        else
        {
          d = (this[i] >> (p -= 8)) & 0xff;
          if (p <= 0)
          {
            p += this.DB;
            --i;
          }
        }
        if ((d & 0x80) != 0) d |= -256;
        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;
        if (k > 0 || d != this.s) r[k++] = d;
      }
    }
    return r;
  }

  function bnEquals(a)
  {
    return (this.compareTo(a) == 0);
  }

  function bnMin(a)
  {
    return (this.compareTo(a) < 0) ? this : a;
  }

  function bnMax(a)
  {
    return (this.compareTo(a) > 0) ? this : a;
  }
  // (protected) r = this op a (bitwise)
  function bnpBitwiseTo(a, op, r)
  {
    var i, f, m = Math.min(a.t, this.t);
    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
    if (a.t < this.t)
    {
      f = a.s & this.DM;
      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
      r.t = this.t;
    }
    else
    {
      f = this.s & this.DM;
      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
      r.t = a.t;
    }
    r.s = op(this.s, a.s);
    r.clamp();
  }
  // (public) this & a
  function op_and(x, y)
  {
    return x & y;
  }

  function bnAnd(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_and, r);
    return r;
  }
  // (public) this | a
  function op_or(x, y)
  {
    return x | y;
  }

  function bnOr(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_or, r);
    return r;
  }
  // (public) this ^ a
  function op_xor(x, y)
  {
    return x ^ y;
  }

  function bnXor(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_xor, r);
    return r;
  }
  // (public) this & ~a
  function op_andnot(x, y)
  {
    return x & ~y;
  }

  function bnAndNot(a)
  {
    var r = nbi();
    this.bitwiseTo(a, op_andnot, r);
    return r;
  }
  // (public) ~this
  function bnNot()
  {
    var r = nbi();
    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
    r.t = this.t;
    r.s = ~this.s;
    return r;
  }
  // (public) this << n
  function bnShiftLeft(n)
  {
    var r = nbi();
    if (n < 0) this.rShiftTo(-n, r);
    else this.lShiftTo(n, r);
    return r;
  }
  // (public) this >> n
  function bnShiftRight(n)
  {
    var r = nbi();
    if (n < 0) this.lShiftTo(-n, r);
    else this.rShiftTo(n, r);
    return r;
  }
  // return index of lowest 1-bit in x, x < 2^31
  function lbit(x)
  {
    if (x == 0) return -1;
    var r = 0;
    if ((x & 0xffff) == 0)
    {
      x >>= 16;
      r += 16;
    }
    if ((x & 0xff) == 0)
    {
      x >>= 8;
      r += 8;
    }
    if ((x & 0xf) == 0)
    {
      x >>= 4;
      r += 4;
    }
    if ((x & 3) == 0)
    {
      x >>= 2;
      r += 2;
    }
    if ((x & 1) == 0)++r;
    return r;
  }
  // (public) returns index of lowest 1-bit (or -1 if none)
  function bnGetLowestSetBit()
  {
    for (var i = 0; i < this.t; ++i)
      if (this[i] != 0) return i * this.DB + lbit(this[i]);
    if (this.s < 0) return this.t * this.DB;
    return -1;
  }
  // return number of 1 bits in x
  function cbit(x)
  {
    var r = 0;
    while (x != 0)
    {
      x &= x - 1;
      ++r;
    }
    return r;
  }
  // (public) return number of set bits
  function bnBitCount()
  {
    var r = 0,
      x = this.s & this.DM;
    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
    return r;
  }
  // (public) true iff nth bit is set
  function bnTestBit(n)
  {
    var j = Math.floor(n / this.DB);
    if (j >= this.t) return (this.s != 0);
    return ((this[j] & (1 << (n % this.DB))) != 0);
  }
  // (protected) this op (1<<n)
  function bnpChangeBit(n, op)
  {
    var r = BigInteger.ONE.shiftLeft(n);
    this.bitwiseTo(r, op, r);
    return r;
  }
  // (public) this | (1<<n)
  function bnSetBit(n)
  {
    return this.changeBit(n, op_or);
  }
  // (public) this & ~(1<<n)
  function bnClearBit(n)
  {
    return this.changeBit(n, op_andnot);
  }
  // (public) this ^ (1<<n)
  function bnFlipBit(n)
  {
    return this.changeBit(n, op_xor);
  }
  // (protected) r = this + a
  function bnpAddTo(a, r)
  {
    var i = 0,
      c = 0,
      m = Math.min(a.t, this.t);
    while (i < m)
    {
      c += this[i] + a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    if (a.t < this.t)
    {
      c += a.s;
      while (i < this.t)
      {
        c += this[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += this.s;
    }
    else
    {
      c += this.s;
      while (i < a.t)
      {
        c += a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += a.s;
    }
    r.s = (c < 0) ? -1 : 0;
    if (c > 0) r[i++] = c;
    else if (c < -1) r[i++] = this.DV + c;
    r.t = i;
    r.clamp();
  }
  // (public) this + a
  function bnAdd(a)
  {
    var r = nbi();
    this.addTo(a, r);
    return r;
  }
  // (public) this - a
  function bnSubtract(a)
  {
    var r = nbi();
    this.subTo(a, r);
    return r;
  }
  // (public) this * a
  function bnMultiply(a)
  {
    var r = nbi();
    this.multiplyTo(a, r);
    return r;
  }
  // (public) this^2
  function bnSquare()
  {
    var r = nbi();
    this.squareTo(r);
    return r;
  }
  // (public) this / a
  function bnDivide(a)
  {
    var r = nbi();
    this.divRemTo(a, r, null);
    return r;
  }
  // (public) this % a
  function bnRemainder(a)
  {
    var r = nbi();
    this.divRemTo(a, null, r);
    return r;
  }
  // (public) [this/a,this%a]
  function bnDivideAndRemainder(a)
  {
    var q = nbi(),
      r = nbi();
    this.divRemTo(a, q, r);
    return new Array(q, r);
  }
  // (protected) this *= n, this >= 0, 1 < n < DV
  function bnpDMultiply(n)
  {
    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
    ++this.t;
    this.clamp();
  }
  // (protected) this += n << w words, this >= 0
  function bnpDAddOffset(n, w)
  {
    if (n == 0) return;
    while (this.t <= w) this[this.t++] = 0;
    this[w] += n;
    while (this[w] >= this.DV)
    {
      this[w] -= this.DV;
      if (++w >= this.t) this[this.t++] = 0;
      ++this[w];
    }
  }
  // A "null" reducer
  function NullExp()
  {}

  function nNop(x)
  {
    return x;
  }

  function nMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
  }

  function nSqrTo(x, r)
  {
    x.squareTo(r);
  }
  NullExp.prototype.convert = nNop;
  NullExp.prototype.revert = nNop;
  NullExp.prototype.mulTo = nMulTo;
  NullExp.prototype.sqrTo = nSqrTo;
  // (public) this^e
  function bnPow(e)
  {
    return this.exp(e, new NullExp());
  }
  // (protected) r = lower n words of "this * a", a.t <= n
  // "this" should be the larger one if appropriate.
  function bnpMultiplyLowerTo(a, n, r)
  {
    var i = Math.min(this.t + a.t, n);
    r.s = 0; // assumes a,this >= 0
    r.t = i;
    while (i > 0) r[--i] = 0;
    var j;
    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
    r.clamp();
  }
  // (protected) r = "this * a" without lower n words, n > 0
  // "this" should be the larger one if appropriate.
  function bnpMultiplyUpperTo(a, n, r)
  {
    --n;
    var i = r.t = this.t + a.t - n;
    r.s = 0; // assumes a,this >= 0
    while (--i >= 0) r[i] = 0;
    for (i = Math.max(n - this.t, 0); i < a.t; ++i)
      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
    r.clamp();
    r.drShiftTo(1, r);
  }
  // Barrett modular reduction
  function Barrett(m)
  {
    // setup Barrett
    this.r2 = nbi();
    this.q3 = nbi();
    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
    this.mu = this.r2.divide(m);
    this.m = m;
  }

  function barrettConvert(x)
  {
    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
    else if (x.compareTo(this.m) < 0) return x;
    else
    {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
  }

  function barrettRevert(x)
  {
    return x;
  }
  // x = x mod m (HAC 14.42)
  function barrettReduce(x)
  {
    x.drShiftTo(this.m.t - 1, this.r2);
    if (x.t > this.m.t + 1)
    {
      x.t = this.m.t + 1;
      x.clamp();
    }
    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
    x.subTo(this.r2, x);
    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
  }
  // r = x^2 mod m; x != r
  function barrettSqrTo(x, r)
  {
    x.squareTo(r);
    this.reduce(r);
  }
  // r = x*y mod m; x,y != r
  function barrettMulTo(x, y, r)
  {
    x.multiplyTo(y, r);
    this.reduce(r);
  }
  Barrett.prototype.convert = barrettConvert;
  Barrett.prototype.revert = barrettRevert;
  Barrett.prototype.reduce = barrettReduce;
  Barrett.prototype.mulTo = barrettMulTo;
  Barrett.prototype.sqrTo = barrettSqrTo;
  // (public) this^e % m (HAC 14.85)
  function bnModPow(e, m)
  {
    var i = e.bitLength(),
      k, r = nbv(1),
      z;
    if (i <= 0) return r;
    else if (i < 18) k = 1;
    else if (i < 48) k = 3;
    else if (i < 144) k = 4;
    else if (i < 768) k = 5;
    else k = 6;
    if (i < 8)
      z = new Classic(m);
    else if (m.isEven())
      z = new Barrett(m);
    else
      z = new Montgomery(m);
    // precomputation
    var g = new Array(),
      n = 3,
      k1 = k - 1,
      km = (1 << k) - 1;
    g[1] = z.convert(this);
    if (k > 1)
    {
      var g2 = nbi();
      z.sqrTo(g[1], g2);
      while (n <= km)
      {
        g[n] = nbi();
        z.mulTo(g2, g[n - 2], g[n]);
        n += 2;
      }
    }
    var j = e.t - 1,
      w, is1 = true,
      r2 = nbi(),
      t;
    i = nbits(e[j]) - 1;
    while (j >= 0)
    {
      if (i >= k1) w = (e[j] >> (i - k1)) & km;
      else
      {
        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
      }
      n = k;
      while ((w & 1) == 0)
      {
        w >>= 1;
        --n;
      }
      if ((i -= n) < 0)
      {
        i += this.DB;
        --j;
      }
      if (is1)
      { // ret == 1, don't bother squaring or multiplying it
        g[w].copyTo(r);
        is1 = false;
      }
      else
      {
        while (n > 1)
        {
          z.sqrTo(r, r2);
          z.sqrTo(r2, r);
          n -= 2;
        }
        if (n > 0) z.sqrTo(r, r2);
        else
        {
          t = r;
          r = r2;
          r2 = t;
        }
        z.mulTo(r2, g[w], r);
      }
      while (j >= 0 && (e[j] & (1 << i)) == 0)
      {
        z.sqrTo(r, r2);
        t = r;
        r = r2;
        r2 = t;
        if (--i < 0)
        {
          i = this.DB - 1;
          --j;
        }
      }
    }
    return z.revert(r);
  }
  // (public) gcd(this,a) (HAC 14.54)
  function bnGCD(a)
  {
    var x = (this.s < 0) ? this.negate() : this.clone();
    var y = (a.s < 0) ? a.negate() : a.clone();
    if (x.compareTo(y) < 0)
    {
      var t = x;
      x = y;
      y = t;
    }
    var i = x.getLowestSetBit(),
      g = y.getLowestSetBit();
    if (g < 0) return x;
    if (i < g) g = i;
    if (g > 0)
    {
      x.rShiftTo(g, x);
      y.rShiftTo(g, y);
    }
    while (x.signum() > 0)
    {
      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
      if (x.compareTo(y) >= 0)
      {
        x.subTo(y, x);
        x.rShiftTo(1, x);
      }
      else
      {
        y.subTo(x, y);
        y.rShiftTo(1, y);
      }
    }
    if (g > 0) y.lShiftTo(g, y);
    return y;
  }
  // (protected) this % n, n < 2^26
  function bnpModInt(n)
  {
    if (n <= 0) return 0;
    var d = this.DV % n,
      r = (this.s < 0) ? n - 1 : 0;
    if (this.t > 0)
      if (d == 0) r = this[0] % n;
      else
        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
    return r;
  }
  // (public) 1/this % m (HAC 14.61)
  function bnModInverse(m)
  {
    var ac = m.isEven();
    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
    var u = m.clone(),
      v = this.clone();
    var a = nbv(1),
      b = nbv(0),
      c = nbv(0),
      d = nbv(1);
    while (u.signum() != 0)
    {
      while (u.isEven())
      {
        u.rShiftTo(1, u);
        if (ac)
        {
          if (!a.isEven() || !b.isEven())
          {
            a.addTo(this, a);
            b.subTo(m, b);
          }
          a.rShiftTo(1, a);
        }
        else if (!b.isEven()) b.subTo(m, b);
        b.rShiftTo(1, b);
      }
      while (v.isEven())
      {
        v.rShiftTo(1, v);
        if (ac)
        {
          if (!c.isEven() || !d.isEven())
          {
            c.addTo(this, c);
            d.subTo(m, d);
          }
          c.rShiftTo(1, c);
        }
        else if (!d.isEven()) d.subTo(m, d);
        d.rShiftTo(1, d);
      }
      if (u.compareTo(v) >= 0)
      {
        u.subTo(v, u);
        if (ac) a.subTo(c, a);
        b.subTo(d, b);
      }
      else
      {
        v.subTo(u, v);
        if (ac) c.subTo(a, c);
        d.subTo(b, d);
      }
    }
    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
    if (d.compareTo(m) >= 0) return d.subtract(m);
    if (d.signum() < 0) d.addTo(m, d);
    else return d;
    if (d.signum() < 0) return d.add(m);
    else return d;
  }
  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
  // (public) test primality with certainty >= 1-.5^t
  function bnIsProbablePrime(t)
  {
    var i, x = this.abs();
    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])
    {
      for (i = 0; i < lowprimes.length; ++i)
        if (x[0] == lowprimes[i]) return true;
      return false;
    }
    if (x.isEven()) return false;
    i = 1;
    while (i < lowprimes.length)
    {
      var m = lowprimes[i],
        j = i + 1;
      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
      m = x.modInt(m);
      while (i < j)
        if (m % lowprimes[i++] == 0) return false;
    }
    return x.millerRabin(t);
  }
  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
  function bnpMillerRabin(t)
  {
    var n1 = this.subtract(BigInteger.ONE);
    var k = n1.getLowestSetBit();
    if (k <= 0) return false;
    var r = n1.shiftRight(k);
    t = (t + 1) >> 1;
    if (t > lowprimes.length) t = lowprimes.length;
    var a = nbi();
    for (var i = 0; i < t; ++i)
    {
      //Pick bases at random, instead of starting at 2
      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
      var y = a.modPow(r, this);
      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)
      {
        var j = 1;
        while (j++ < k && y.compareTo(n1) != 0)
        {
          y = y.modPowInt(2, this);
          if (y.compareTo(BigInteger.ONE) == 0) return false;
        }
        if (y.compareTo(n1) != 0) return false;
      }
    }
    return true;
  }
  // protected
  BigInteger.prototype.chunkSize = bnpChunkSize;
  BigInteger.prototype.toRadix = bnpToRadix;
  BigInteger.prototype.fromRadix = bnpFromRadix;
  BigInteger.prototype.fromNumber = bnpFromNumber;
  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
  BigInteger.prototype.changeBit = bnpChangeBit;
  BigInteger.prototype.addTo = bnpAddTo;
  BigInteger.prototype.dMultiply = bnpDMultiply;
  BigInteger.prototype.dAddOffset = bnpDAddOffset;
  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
  BigInteger.prototype.modInt = bnpModInt;
  BigInteger.prototype.millerRabin = bnpMillerRabin;
  // public
  BigInteger.prototype.clone = bnClone;
  BigInteger.prototype.intValue = bnIntValue;
  BigInteger.prototype.byteValue = bnByteValue;
  BigInteger.prototype.shortValue = bnShortValue;
  BigInteger.prototype.signum = bnSigNum;
  BigInteger.prototype.toByteArray = bnToByteArray;
  BigInteger.prototype.equals = bnEquals;
  BigInteger.prototype.min = bnMin;
  BigInteger.prototype.max = bnMax;
  BigInteger.prototype.and = bnAnd;
  BigInteger.prototype.or = bnOr;
  BigInteger.prototype.xor = bnXor;
  BigInteger.prototype.andNot = bnAndNot;
  BigInteger.prototype.not = bnNot;
  BigInteger.prototype.shiftLeft = bnShiftLeft;
  BigInteger.prototype.shiftRight = bnShiftRight;
  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
  BigInteger.prototype.bitCount = bnBitCount;
  BigInteger.prototype.testBit = bnTestBit;
  BigInteger.prototype.setBit = bnSetBit;
  BigInteger.prototype.clearBit = bnClearBit;
  BigInteger.prototype.flipBit = bnFlipBit;
  BigInteger.prototype.add = bnAdd;
  BigInteger.prototype.subtract = bnSubtract;
  BigInteger.prototype.multiply = bnMultiply;
  BigInteger.prototype.divide = bnDivide;
  BigInteger.prototype.remainder = bnRemainder;
  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
  BigInteger.prototype.modPow = bnModPow;
  BigInteger.prototype.modInverse = bnModInverse;
  BigInteger.prototype.pow = bnPow;
  BigInteger.prototype.gcd = bnGCD;
  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  // JSBN-specific extension
  BigInteger.prototype.square = bnSquare;
  var Int128 = BigInteger;
  // BigInteger interfaces not implemented in jsbn:
  // BigInteger(int signum, byte[] magnitude)
  // double doubleValue()
  // float floatValue()
  // int hashCode()
  // long longValue()
  // static BigInteger valueOf(long val)
  // Helper functions to make BigInteger functions callable with two parameters
  // as in original C# Clipper
  Int128.prototype.IsNegative = function ()
  {
    if (this.compareTo(Int128.ZERO) == -1) return true;
    else return false;
  };
  Int128.op_Equality = function (val1, val2)
  {
    if (val1.compareTo(val2) == 0) return true;
    else return false;
  };
  Int128.op_Inequality = function (val1, val2)
  {
    if (val1.compareTo(val2) != 0) return true;
    else return false;
  };
  Int128.op_GreaterThan = function (val1, val2)
  {
    if (val1.compareTo(val2) > 0) return true;
    else return false;
  };
  Int128.op_LessThan = function (val1, val2)
  {
    if (val1.compareTo(val2) < 0) return true;
    else return false;
  };
  Int128.op_Addition = function (lhs, rhs)
  {
    return new Int128(lhs).add(new Int128(rhs));
  };
  Int128.op_Subtraction = function (lhs, rhs)
  {
    return new Int128(lhs).subtract(new Int128(rhs));
  };
  Int128.Int128Mul = function (lhs, rhs)
  {
    return new Int128(lhs).multiply(new Int128(rhs));
  };
  Int128.op_Division = function (lhs, rhs)
  {
    return lhs.divide(rhs);
  };
  Int128.prototype.ToDouble = function ()
  {
    return parseFloat(this.toString()); // This could be something faster
  };
  // end of Int128 section
  /*
  // Uncomment the following two lines if you want to use Int128 outside ClipperLib
  if (typeof(document) !== "undefined") window.Int128 = Int128;
  else self.Int128 = Int128;
  */


  // ---------------------------------------------
  // Here starts the actual Clipper library:
  // Helper function to support Inheritance in Javascript
	var Inherit = function (ce, ce2)
	{
		var p;
		if (typeof (Object.getOwnPropertyNames) == 'undefined')
		{
			for (p in ce2.prototype)
				if (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];
			for (p in ce2)
				if (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];
			ce.$baseCtor = ce2;
		}
		else
		{
			var props = Object.getOwnPropertyNames(ce2.prototype);
			for (var i = 0; i < props.length; i++)
				if (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));
			for (p in ce2)
				if (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];
			ce.$baseCtor = ce2;
		}
	};
  ClipperLib.Path = function ()
  {
    return [];
  };
  ClipperLib.Paths = function ()
  {
    return []; // Was previously [[]], but caused problems when pushed
  };
  // Preserves the calling way of original C# Clipper
  // Is essential due to compatibility, because DoublePoint is public class in original C# version
  ClipperLib.DoublePoint = function ()
  {
    var a = arguments;
    this.X = 0;
    this.Y = 0;
    // public DoublePoint(DoublePoint dp)
    // public DoublePoint(IntPoint ip)
    if (a.length == 1)
    {
      this.X = a[0].X;
      this.Y = a[0].Y;
    }
    else if (a.length == 2)
    {
      this.X = a[0];
      this.Y = a[1];
    }
  }; // This is internal faster function when called without arguments
  ClipperLib.DoublePoint0 = function ()
  {
    this.X = 0;
    this.Y = 0;
  };
  // This is internal faster function when called with 1 argument (dp or ip)
  ClipperLib.DoublePoint1 = function (dp)
  {
    this.X = dp.X;
    this.Y = dp.Y;
  };
  // This is internal faster function when called with 2 arguments (x and y)
  ClipperLib.DoublePoint2 = function (x, y)
  {
    this.X = x;
    this.Y = y;
  };
  // PolyTree & PolyNode start
  // -------------------------------
  ClipperLib.PolyNode = function ()
  {
    this.m_Parent = null;
    this.m_polygon = new ClipperLib.Path();
    this.m_Index = 0;
    this.m_jointype = 0;
    this.m_endtype = 0;
    this.m_Childs = [];
    this.IsOpen = false;
  };
  ClipperLib.PolyNode.prototype.IsHoleNode = function ()
  {
    var result = true;
    var node = this.m_Parent;
    while (node !== null)
    {
      result = !result;
      node = node.m_Parent;
    }
    return result;
  };
  ClipperLib.PolyNode.prototype.ChildCount = function ()
  {
    return this.m_Childs.length;
  };
  ClipperLib.PolyNode.prototype.Contour = function ()
  {
    return this.m_polygon;
  };
  ClipperLib.PolyNode.prototype.AddChild = function (Child)
  {
    var cnt = this.m_Childs.length;
    this.m_Childs.push(Child);
    Child.m_Parent = this;
    Child.m_Index = cnt;
  };
  ClipperLib.PolyNode.prototype.GetNext = function ()
  {
    if (this.m_Childs.length > 0)
      return this.m_Childs[0];
    else
      return this.GetNextSiblingUp();
  };
  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()
  {
    if (this.m_Parent === null)
      return null;
    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)
      return this.m_Parent.GetNextSiblingUp();
    else
      return this.m_Parent.m_Childs[this.m_Index + 1];
  };
  ClipperLib.PolyNode.prototype.Childs = function ()
  {
    return this.m_Childs;
  };
  ClipperLib.PolyNode.prototype.Parent = function ()
  {
    return this.m_Parent;
  };
  ClipperLib.PolyNode.prototype.IsHole = function ()
  {
    return this.IsHoleNode();
  };
  // PolyTree : PolyNode
  ClipperLib.PolyTree = function ()
  {
    this.m_AllPolys = [];
    ClipperLib.PolyNode.call(this);
  };
  ClipperLib.PolyTree.prototype.Clear = function ()
  {
    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)
      this.m_AllPolys[i] = null;
    this.m_AllPolys.length = 0;
    this.m_Childs.length = 0;
  };
  ClipperLib.PolyTree.prototype.GetFirst = function ()
  {
    if (this.m_Childs.length > 0)
      return this.m_Childs[0];
    else
      return null;
  };
  ClipperLib.PolyTree.prototype.Total = function ()
  {
		var result = this.m_AllPolys.length;
		//with negative offsets, ignore the hidden outer polygon ...
		if (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;
		return result;
  };
  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);
  // -------------------------------
  // PolyTree & PolyNode end
  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)
  {
    return Math.abs(a);
  };
  ClipperLib.Math_Max_Int32_Int32 = function (a, b)
  {
    return Math.max(a, b);
  };
  /*
  -----------------------------------
  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2
  -----------------------------------
  */
  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)
  {
    return a | 0;
  };
  else ClipperLib.Cast_Int32 = function (a)
  { // eg. browser.chrome || browser.chromium || browser.firefox
    return~~ a;
  };
  /*
  --------------------------
  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer
  Chrome: bitwise_not_floor
  Firefox17: toInteger (typeof test)
  IE9: bitwise_or_floor
  IE7 and IE8: to_parseint
  Chromium: to_floor_or_ceil
  Firefox3: to_floor_or_ceil
  Firefox15: to_floor_or_ceil
  Opera: to_floor_or_ceil
  Safari: to_floor_or_ceil
  --------------------------
  */
  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)
  {
    if (a < -2147483648 || a > 2147483647)
      return a < 0 ? Math.ceil(a) : Math.floor(a);
    else return~~ a;
  };
  else if (browser.firefox && typeof (Number.toInteger) == "function") ClipperLib.Cast_Int64 = function (a)
  {
    return Number.toInteger(a);
  };
  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)
  {
    return parseInt(a, 10);
  };
  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)
  {
    if (a < -2147483648 || a > 2147483647)
      return a < 0 ? Math.ceil(a) : Math.floor(a);
    return a | 0;
  };
  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari
  else ClipperLib.Cast_Int64 = function (a)
  {
    return a < 0 ? Math.ceil(a) : Math.floor(a);
  };
  ClipperLib.Clear = function (a)
  {
    a.length = 0;
  };
  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function
  ClipperLib.PI = 3.141592653589793;
  ClipperLib.PI2 = 2 * 3.141592653589793;
  ClipperLib.IntPoint = function ()
  {
    var a = arguments,
      alen = a.length;
    this.X = 0;
    this.Y = 0;
    if (use_xyz)
    {
      this.Z = 0;
      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)
      {
        this.X = a[0];
        this.Y = a[1];
        this.Z = a[2];
      }
      else if (alen == 2) // public IntPoint(cInt x, cInt y)
      {
        this.X = a[0];
        this.Y = a[1];
        this.Z = 0;
      }
      else if (alen == 1)
      {
        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)
        {
          var dp = a[0];
          this.X = ClipperLib.Clipper.Round(dp.X);
          this.Y = ClipperLib.Clipper.Round(dp.Y);
          this.Z = 0;
        }
        else // public IntPoint(IntPoint pt)
        {
          var pt = a[0];
          if (typeof (pt.Z) == "undefined") pt.Z = 0;
          this.X = pt.X;
          this.Y = pt.Y;
          this.Z = pt.Z;
        }
      }
      else // public IntPoint()
      {
        this.X = 0;
        this.Y = 0;
        this.Z = 0;
      }
    }
    else // if (!use_xyz)
    {
      if (alen == 2) // public IntPoint(cInt X, cInt Y)
      {
        this.X = a[0];
        this.Y = a[1];
      }
      else if (alen == 1)
      {
        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)
        {
          var dp = a[0];
          this.X = ClipperLib.Clipper.Round(dp.X);
          this.Y = ClipperLib.Clipper.Round(dp.Y);
        }
        else // public IntPoint(IntPoint pt)
        {
          var pt = a[0];
          this.X = pt.X;
          this.Y = pt.Y;
        }
      }
      else // public IntPoint(IntPoint pt)
      {
        this.X = 0;
        this.Y = 0;
      }
    }
  };
  ClipperLib.IntPoint.op_Equality = function (a, b)
  {
    //return a == b;
    return a.X == b.X && a.Y == b.Y;
  };
  ClipperLib.IntPoint.op_Inequality = function (a, b)
  {
    //return a != b;
    return a.X != b.X || a.Y != b.Y;
  };
  /*
  ClipperLib.IntPoint.prototype.Equals = function (obj)
  {
    if (obj === null)
        return false;
    if (obj instanceof ClipperLib.IntPoint)
    {
        var a = Cast(obj, ClipperLib.IntPoint);
        return (this.X == a.X) && (this.Y == a.Y);
    }
    else
        return false;
  };
*/
  if (use_xyz)
  {
    ClipperLib.IntPoint0 = function ()
    {
      this.X = 0;
      this.Y = 0;
      this.Z = 0;
    };
    ClipperLib.IntPoint1 = function (pt)
    {
      this.X = pt.X;
      this.Y = pt.Y;
      this.Z = pt.Z;
    };
    ClipperLib.IntPoint1dp = function (dp)
    {
      this.X = ClipperLib.Clipper.Round(dp.X);
      this.Y = ClipperLib.Clipper.Round(dp.Y);
      this.Z = 0;
    };
    ClipperLib.IntPoint2 = function (x, y)
    {
      this.X = x;
      this.Y = y;
      this.Z = 0;
    };
    ClipperLib.IntPoint3 = function (x, y, z)
    {
      this.X = x;
      this.Y = y;
      this.Z = z;
    };
  }
  else // if (!use_xyz)
  {
    ClipperLib.IntPoint0 = function ()
    {
      this.X = 0;
      this.Y = 0;
    };
    ClipperLib.IntPoint1 = function (pt)
    {
      this.X = pt.X;
      this.Y = pt.Y;
    };
    ClipperLib.IntPoint1dp = function (dp)
    {
      this.X = ClipperLib.Clipper.Round(dp.X);
      this.Y = ClipperLib.Clipper.Round(dp.Y);
    };
    ClipperLib.IntPoint2 = function (x, y)
    {
      this.X = x;
      this.Y = y;
    };
  }
  ClipperLib.IntRect = function ()
  {
    var a = arguments,
      alen = a.length;
    if (alen == 4) // function (l, t, r, b)
    {
      this.left = a[0];
      this.top = a[1];
      this.right = a[2];
      this.bottom = a[3];
    }
    else if (alen == 1) // function (ir)
    {
      this.left = ir.left;
      this.top = ir.top;
      this.right = ir.right;
      this.bottom = ir.bottom;
    }
    else // function ()
    {
      this.left = 0;
      this.top = 0;
      this.right = 0;
      this.bottom = 0;
    }
  };
  ClipperLib.IntRect0 = function ()
  {
    this.left = 0;
    this.top = 0;
    this.right = 0;
    this.bottom = 0;
  };
  ClipperLib.IntRect1 = function (ir)
  {
    this.left = ir.left;
    this.top = ir.top;
    this.right = ir.right;
    this.bottom = ir.bottom;
  };
  ClipperLib.IntRect4 = function (l, t, r, b)
  {
    this.left = l;
    this.top = t;
    this.right = r;
    this.bottom = b;
  };
  ClipperLib.ClipType = {
    ctIntersection: 0,
    ctUnion: 1,
    ctDifference: 2,
    ctXor: 3
  };
  ClipperLib.PolyType = {
    ptSubject: 0,
    ptClip: 1
  };
  ClipperLib.PolyFillType = {
    pftEvenOdd: 0,
    pftNonZero: 1,
    pftPositive: 2,
    pftNegative: 3
  };
  ClipperLib.JoinType = {
    jtSquare: 0,
    jtRound: 1,
    jtMiter: 2
  };
  ClipperLib.EndType = {
    etOpenSquare: 0,
    etOpenRound: 1,
    etOpenButt: 2,
    etClosedLine: 3,
    etClosedPolygon: 4
  };
  ClipperLib.EdgeSide = {
    esLeft: 0,
    esRight: 1
  };
  ClipperLib.Direction = {
    dRightToLeft: 0,
    dLeftToRight: 1
  };
  ClipperLib.TEdge = function ()
  {
    this.Bot = new ClipperLib.IntPoint();
    this.Curr = new ClipperLib.IntPoint();
    this.Top = new ClipperLib.IntPoint();
    this.Delta = new ClipperLib.IntPoint();
    this.Dx = 0;
    this.PolyTyp = ClipperLib.PolyType.ptSubject;
    this.Side = ClipperLib.EdgeSide.esLeft;
    this.WindDelta = 0;
    this.WindCnt = 0;
    this.WindCnt2 = 0;
    this.OutIdx = 0;
    this.Next = null;
    this.Prev = null;
    this.NextInLML = null;
    this.NextInAEL = null;
    this.PrevInAEL = null;
    this.NextInSEL = null;
    this.PrevInSEL = null;
  };
  ClipperLib.IntersectNode = function ()
  {
    this.Edge1 = null;
    this.Edge2 = null;
    this.Pt = new ClipperLib.IntPoint();
  };
  ClipperLib.MyIntersectNodeSort = function () {};
  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)
  {
    var i = node2.Pt.Y - node1.Pt.Y;
    if (i > 0) return 1;
    else if (i < 0) return -1;
    else return 0;
  };

  ClipperLib.LocalMinima = function ()
  {
    this.Y = 0;
    this.LeftBound = null;
    this.RightBound = null;
    this.Next = null;
  };
  ClipperLib.Scanbeam = function ()
  {
    this.Y = 0;
    this.Next = null;
  };
  ClipperLib.OutRec = function ()
  {
    this.Idx = 0;
    this.IsHole = false;
    this.IsOpen = false;
    this.FirstLeft = null;
    this.Pts = null;
    this.BottomPt = null;
    this.PolyNode = null;
  };
  ClipperLib.OutPt = function ()
  {
    this.Idx = 0;
    this.Pt = new ClipperLib.IntPoint();
    this.Next = null;
    this.Prev = null;
  };
  ClipperLib.Join = function ()
  {
    this.OutPt1 = null;
    this.OutPt2 = null;
    this.OffPt = new ClipperLib.IntPoint();
  };
  ClipperLib.ClipperBase = function ()
  {
    this.m_MinimaList = null;
    this.m_CurrentLM = null;
    this.m_edges = new Array();
    this.m_UseFullRange = false;
    this.m_HasOpenPaths = false;
    this.PreserveCollinear = false;
    this.m_MinimaList = null;
    this.m_CurrentLM = null;
    this.m_UseFullRange = false;
    this.m_HasOpenPaths = false;
  };
  // Ranges are in original C# too high for Javascript (in current state 2013 september):
  // protected const double horizontal = -3.4E+38;
  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2
  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2
  // So had to adjust them to more suitable for Javascript.
  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#
  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)
  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53
  ClipperLib.ClipperBase.Skip = -2;
  ClipperLib.ClipperBase.Unassigned = -1;
  ClipperLib.ClipperBase.tolerance = 1E-20;
  if (use_int32)
  {
    ClipperLib.ClipperBase.loRange = 0x7FFF;
    ClipperLib.ClipperBase.hiRange = 0x7FFF;
  }
  else
  {
    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2
    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2
  }

  ClipperLib.ClipperBase.near_zero = function (val)
  {
    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);
  };
  ClipperLib.ClipperBase.IsHorizontal = function (e)
  {
    return e.Delta.Y === 0;
  };
  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)
  {
    var pp2 = pp;
    do {
      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))
        return true;
      pp2 = pp2.Next;
    }
    while (pp2 != pp)
    return false;
  };
  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)
  {
    if (UseFullRange)
      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||
        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||
        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&
        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&
        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),
          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));
    else
      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));
  };
  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)
  {
    var pp2 = pp;
    while (true)
    {
      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))
        return true;
      pp2 = pp2.Next;
      if (pp2 == pp)
        break;
    }
    return false;
  };
  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()
  {
    var a = arguments,
      alen = a.length;
    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;
    if (alen == 3) // function (e1, e2, UseFullRange)
    {
      e1 = a[0];
      e2 = a[1];
      UseFullRange = a[2];
      if (UseFullRange)
        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));
      else
        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));
    }
    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)
    {
      pt1 = a[0];
      pt2 = a[1];
      pt3 = a[2];
      UseFullRange = a[3];
      if (UseFullRange)
        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));
      else
        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;
    }
    else // function (pt1, pt2, pt3, pt4, UseFullRange)
    {
      pt1 = a[0];
      pt2 = a[1];
      pt3 = a[2];
      pt4 = a[3];
      UseFullRange = a[4];
      if (UseFullRange)
        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));
      else
        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;
    }
  };
  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)
  {
    if (UseFullRange)
      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));
    else
      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));
  };
  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)
  {
    if (UseFullRange)
      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));
    else
      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;
  };
  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)
  {
    if (UseFullRange)
      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));
    else
      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;
  };
  ClipperLib.ClipperBase.prototype.Clear = function ()
  {
    this.DisposeLocalMinimaList();
    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)
    {
      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)
        this.m_edges[i][j] = null;
      ClipperLib.Clear(this.m_edges[i]);
    }
    ClipperLib.Clear(this.m_edges);
    this.m_UseFullRange = false;
    this.m_HasOpenPaths = false;
  };
  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()
  {
    while (this.m_MinimaList !== null)
    {
      var tmpLm = this.m_MinimaList.Next;
      this.m_MinimaList = null;
      this.m_MinimaList = tmpLm;
    }
    this.m_CurrentLM = null;
  };
  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)
  {
    if (useFullRange.Value)
    {
      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)
        ClipperLib.Error("Coordinate outside allowed range in RangeTest().");
    }
    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)
    {
      useFullRange.Value = true;
      this.RangeTest(Pt, useFullRange);
    }
  };
  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)
  {
    e.Next = eNext;
    e.Prev = ePrev;
    //e.Curr = pt;
    e.Curr.X = pt.X;
    e.Curr.Y = pt.Y;
    e.OutIdx = -1;
  };
  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)
  {
    if (e.Curr.Y >= e.Next.Curr.Y)
    {
      //e.Bot = e.Curr;
      e.Bot.X = e.Curr.X;
      e.Bot.Y = e.Curr.Y;
      //e.Top = e.Next.Curr;
      e.Top.X = e.Next.Curr.X;
      e.Top.Y = e.Next.Curr.Y;
    }
    else
    {
      //e.Top = e.Curr;
      e.Top.X = e.Curr.X;
      e.Top.Y = e.Curr.Y;
      //e.Bot = e.Next.Curr;
      e.Bot.X = e.Next.Curr.X;
      e.Bot.Y = e.Next.Curr.Y;
    }
    this.SetDx(e);
    e.PolyTyp = polyType;
  };
  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)
  {
    var E2;
    for (;;)
    {
      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))
        E = E.Next;
      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)
        break;
      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)
        E = E.Prev;
      E2 = E;
      while (E.Dx == ClipperLib.ClipperBase.horizontal)
        E = E.Next;
      if (E.Top.Y == E.Prev.Bot.Y)
        continue;
      //ie just an intermediate horz.
      if (E2.Prev.Bot.X < E.Bot.X)
        E = E2;
      break;
    }
    return E;
  };
  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)
  {
    var EStart;
    var Result = E;
    var Horz;

      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)
      {
        //check if there are edges beyond the skip edge in the bound and if so
        //create another LocMin and calling ProcessBound once more ...
        E = Result;
        if (LeftBoundIsForward)
        {
          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;
          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;
        }
        else
        {
          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;
          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;
        }
        if (E == Result)
        {
          if (LeftBoundIsForward) Result = E.Next;
          else Result = E.Prev;
        }
        else
        {
          //there are more edges in the bound beyond result starting with E
          if (LeftBoundIsForward)
            E = Result.Next;
          else
            E = Result.Prev;
          var locMin = new ClipperLib.LocalMinima();
          locMin.Next = null;
          locMin.Y = E.Bot.Y;
          locMin.LeftBound = null;
          locMin.RightBound = E;
          E.WindDelta = 0;
          Result = this.ProcessBound(E, LeftBoundIsForward);
          this.InsertLocalMinima(locMin);
        }
        return Result;
      }

      if (E.Dx == ClipperLib.ClipperBase.horizontal)
      {
        //We need to be careful with open paths because this may not be a
        //true local minima (ie E may be following a skip edge).
        //Also, consecutive horz. edges may start heading left before going right.
        if (LeftBoundIsForward) EStart = E.Prev;
        else EStart = E.Next;
        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)
        {
          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge
          {
            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)
              this.ReverseHorizontal(E);
          }
          else if (EStart.Bot.X != E.Bot.X)
            this.ReverseHorizontal(E);
        }
      }

      EStart = E;
      if (LeftBoundIsForward)
      {
        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)
          Result = Result.Next;
        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)
        {
          //nb: at the top of a bound, horizontals are added to the bound
          //only when the preceding edge attaches to the horizontal's left vertex
          //unless a Skip edge is encountered when that becomes the top divide
          Horz = Result;
          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)
            Horz = Horz.Prev;
          if (Horz.Prev.Top.X == Result.Next.Top.X)
          {
            if (!LeftBoundIsForward)
              Result = Horz.Prev;
          }
          else if (Horz.Prev.Top.X > Result.Next.Top.X)
            Result = Horz.Prev;
        }
        while (E != Result)
        {
          E.NextInLML = E.Next;
          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)
            this.ReverseHorizontal(E);
          E = E.Next;
        }
        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)
          this.ReverseHorizontal(E);
        Result = Result.Next;
        //move to the edge just beyond current bound
      }
      else
      {
        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)
          Result = Result.Prev;
        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)
        {
          Horz = Result;
          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)
            Horz = Horz.Next;
          if (Horz.Next.Top.X == Result.Prev.Top.X)
          {
            if (!LeftBoundIsForward)
              Result = Horz.Next;
          }
          else if (Horz.Next.Top.X > Result.Prev.Top.X)
            Result = Horz.Next;
        }
        while (E != Result)
        {
          E.NextInLML = E.Prev;
          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)
            this.ReverseHorizontal(E);
          E = E.Prev;
        }
        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)
          this.ReverseHorizontal(E);
        Result = Result.Prev;
        //move to the edge just beyond current bound
      }

    return Result;
  };

  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)
  {
    if (use_lines)
    {
      if (!Closed && polyType == ClipperLib.PolyType.ptClip)
        ClipperLib.Error("AddPath: Open paths must be subject.");
    }
    else
    {
      if (!Closed)
        ClipperLib.Error("AddPath: Open paths have been disabled.");
    }
    var highI = pg.length - 1;
    if (Closed)
      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))
    --highI;
    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))
    --highI;
    if ((Closed && highI < 2) || (!Closed && highI < 1))
      return false;
    //create a new edge array ...
    var edges = new Array();
    for (var i = 0; i <= highI; i++)
      edges.push(new ClipperLib.TEdge());
    var IsFlat = true;
    //1. Basic (first) edge initialization ...

    //edges[1].Curr = pg[1];
    edges[1].Curr.X = pg[1].X;
    edges[1].Curr.Y = pg[1].Y;

    var $1 = {Value: this.m_UseFullRange};
    this.RangeTest(pg[0], $1);
    this.m_UseFullRange = $1.Value;

    $1.Value = this.m_UseFullRange;
    this.RangeTest(pg[highI], $1);
    this.m_UseFullRange = $1.Value;

    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);
    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);
    for (var i = highI - 1; i >= 1; --i)
    {
      $1.Value = this.m_UseFullRange;
      this.RangeTest(pg[i], $1);
      this.m_UseFullRange = $1.Value;

      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);
    }

    var eStart = edges[0];
    //2. Remove duplicate vertices, and (when closed) collinear edges ...
    var E = eStart,
      eLoopStop = eStart;
    for (;;)
    {
    //console.log(E.Next, eStart);
    	//nb: allows matching start and end points when not Closed ...
      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))
      {
        if (E == E.Next)
          break;
        if (E == eStart)
          eStart = E.Next;
        E = this.RemoveEdge(E);
        eLoopStop = E;
        continue;
      }
      if (E.Prev == E.Next)
        break;
      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))
      {
        //Collinear edges are allowed for open paths but in closed paths
        //the default is to merge adjacent collinear edges into a single edge.
        //However, if the PreserveCollinear property is enabled, only overlapping
        //collinear edges (ie spikes) will be removed from closed paths.
        if (E == eStart)
          eStart = E.Next;
        E = this.RemoveEdge(E);
        E = E.Prev;
        eLoopStop = E;
        continue;
      }
      E = E.Next;
      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;
    }
    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))
      return false;
    if (!Closed)
    {
      this.m_HasOpenPaths = true;
      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;
    }
    //3. Do second stage of edge initialization ...
    E = eStart;
    do {
      this.InitEdge2(E, polyType);
      E = E.Next;
      if (IsFlat && E.Curr.Y != eStart.Curr.Y)
        IsFlat = false;
    }
    while (E != eStart)
    //4. Finally, add edge bounds to LocalMinima list ...
    //Totally flat paths must be handled differently when adding them
    //to LocalMinima list to avoid endless loops etc ...
    if (IsFlat)
    {
      if (Closed)
        return false;
      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;
      if (E.Prev.Bot.X < E.Prev.Top.X)
        this.ReverseHorizontal(E.Prev);
      var locMin = new ClipperLib.LocalMinima();
      locMin.Next = null;
      locMin.Y = E.Bot.Y;
      locMin.LeftBound = null;
      locMin.RightBound = E;
      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;
      locMin.RightBound.WindDelta = 0;
      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)
      {
        E.NextInLML = E.Next;
        if (E.Bot.X != E.Prev.Top.X)
          this.ReverseHorizontal(E);
        E = E.Next;
      }
      this.InsertLocalMinima(locMin);
      this.m_edges.push(edges);
      return true;
    }
    this.m_edges.push(edges);
    var leftBoundIsForward;
    var EMin = null;

		//workaround to avoid an endless loop in the while loop below when
    //open paths have matching start and end points ...
    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))
    	E = E.Next;

    for (;;)
    {
      E = this.FindNextLocMin(E);
      if (E == EMin)
        break;
      else if (EMin == null)
        EMin = E;
      //E and E.Prev now share a local minima (left aligned if horizontal).
      //Compare their slopes to find which starts which bound ...
      var locMin = new ClipperLib.LocalMinima();
      locMin.Next = null;
      locMin.Y = E.Bot.Y;
      if (E.Dx < E.Prev.Dx)
      {
        locMin.LeftBound = E.Prev;
        locMin.RightBound = E;
        leftBoundIsForward = false;
        //Q.nextInLML = Q.prev
      }
      else
      {
        locMin.LeftBound = E;
        locMin.RightBound = E.Prev;
        leftBoundIsForward = true;
        //Q.nextInLML = Q.next
      }
      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;
      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;
      if (!Closed)
        locMin.LeftBound.WindDelta = 0;
      else if (locMin.LeftBound.Next == locMin.RightBound)
        locMin.LeftBound.WindDelta = -1;
      else
        locMin.LeftBound.WindDelta = 1;
      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;
      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);
      if (E.OutIdx == ClipperLib.ClipperBase.Skip)
      	E = this.ProcessBound(E, leftBoundIsForward);
      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);
      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);
      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)
        locMin.LeftBound = null;
      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)
        locMin.RightBound = null;
      this.InsertLocalMinima(locMin);
      if (!leftBoundIsForward)
        E = E2;
    }
    return true;
  };
  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)
  {
    //  console.log("-------------------------------------------");
    //  console.log(JSON.stringify(ppg));
    var result = false;
    for (var i = 0, ilen = ppg.length; i < ilen; ++i)
      if (this.AddPath(ppg[i], polyType, closed))
        result = true;
    return result;
  };
  //------------------------------------------------------------------------------
  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)
  {
    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))

   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))
   return false;

    else if (pt1.X != pt3.X)
      return (pt2.X > pt1.X) == (pt2.X < pt3.X);
    else
      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);
  };
  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)
  {
    //removes e from double_linked_list (but without removing from memory)
    e.Prev.Next = e.Next;
    e.Next.Prev = e.Prev;
    var result = e.Next;
    e.Prev = null; //flag as removed (see ClipperBase.Clear)
    return result;
  };
  ClipperLib.ClipperBase.prototype.SetDx = function (e)
  {
    e.Delta.X = (e.Top.X - e.Bot.X);
    e.Delta.Y = (e.Top.Y - e.Bot.Y);
    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;
    else e.Dx = (e.Delta.X) / (e.Delta.Y);
  };
  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)
  {
    if (this.m_MinimaList === null)
    {
      this.m_MinimaList = newLm;
    }
    else if (newLm.Y >= this.m_MinimaList.Y)
    {
      newLm.Next = this.m_MinimaList;
      this.m_MinimaList = newLm;
    }
    else
    {
      var tmpLm = this.m_MinimaList;
      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))
        tmpLm = tmpLm.Next;
      newLm.Next = tmpLm.Next;
      tmpLm.Next = newLm;
    }
  };
  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()
  {
    if (this.m_CurrentLM === null)
      return;
    this.m_CurrentLM = this.m_CurrentLM.Next;
  };
  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)
  {
    //swap horizontal edges' top and bottom x's so they follow the natural
    //progression of the bounds - ie so their xbots will align with the
    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]
    var tmp = e.Top.X;
    e.Top.X = e.Bot.X;
    e.Bot.X = tmp;
    if (use_xyz)
    {
      tmp = e.Top.Z;
      e.Top.Z = e.Bot.Z;
      e.Bot.Z = tmp;
    }
  };
  ClipperLib.ClipperBase.prototype.Reset = function ()
  {
    this.m_CurrentLM = this.m_MinimaList;
    if (this.m_CurrentLM == null)
      return;
    //ie nothing to process
    //reset all edges ...
    var lm = this.m_MinimaList;
    while (lm != null)
    {
      var e = lm.LeftBound;
      if (e != null)
      {
        //e.Curr = e.Bot;
        e.Curr.X = e.Bot.X;
        e.Curr.Y = e.Bot.Y;
        e.Side = ClipperLib.EdgeSide.esLeft;
        e.OutIdx = ClipperLib.ClipperBase.Unassigned;
      }
      e = lm.RightBound;
      if (e != null)
      {
        //e.Curr = e.Bot;
        e.Curr.X = e.Bot.X;
        e.Curr.Y = e.Bot.Y;
        e.Side = ClipperLib.EdgeSide.esRight;
        e.OutIdx = ClipperLib.ClipperBase.Unassigned;
      }
      lm = lm.Next;
    }
  };
  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)
  {
    if (typeof (InitOptions) == "undefined") InitOptions = 0;
    this.m_PolyOuts = null;
    this.m_ClipType = ClipperLib.ClipType.ctIntersection;
    this.m_Scanbeam = null;
    this.m_ActiveEdges = null;
    this.m_SortedEdges = null;
    this.m_IntersectList = null;
    this.m_IntersectNodeComparer = null;
    this.m_ExecuteLocked = false;
    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;
    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;
    this.m_Joins = null;
    this.m_GhostJoins = null;
    this.m_UsingPolyTree = false;
    this.ReverseSolution = false;
    this.StrictlySimple = false;
    ClipperLib.ClipperBase.call(this);
    this.m_Scanbeam = null;
    this.m_ActiveEdges = null;
    this.m_SortedEdges = null;
    this.m_IntersectList = new Array();
    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;
    this.m_ExecuteLocked = false;
    this.m_UsingPolyTree = false;
    this.m_PolyOuts = new Array();
    this.m_Joins = new Array();
    this.m_GhostJoins = new Array();
    this.ReverseSolution = (1 & InitOptions) !== 0;
    this.StrictlySimple = (2 & InitOptions) !== 0;
    this.PreserveCollinear = (4 & InitOptions) !== 0;
    if (use_xyz)
    {
      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);
    }
  };
  ClipperLib.Clipper.ioReverseSolution = 1;
  ClipperLib.Clipper.ioStrictlySimple = 2;
  ClipperLib.Clipper.ioPreserveCollinear = 4;

  ClipperLib.Clipper.prototype.Clear = function ()
  {
    if (this.m_edges.length === 0)
      return;
    //avoids problems with ClipperBase destructor
    this.DisposeAllPolyPts();
    ClipperLib.ClipperBase.prototype.Clear.call(this);
  };

  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()
  {
    while (this.m_Scanbeam !== null)
    {
      var sb2 = this.m_Scanbeam.Next;
      this.m_Scanbeam = null;
      this.m_Scanbeam = sb2;
    }
  };
  ClipperLib.Clipper.prototype.Reset = function ()
  {
    ClipperLib.ClipperBase.prototype.Reset.call(this);
    this.m_Scanbeam = null;
    this.m_ActiveEdges = null;
    this.m_SortedEdges = null;

    var lm = this.m_MinimaList;
    while (lm !== null)
    {
      this.InsertScanbeam(lm.Y);
      lm = lm.Next;
    }
  };
  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)
  {
    if (this.m_Scanbeam === null)
    {
      this.m_Scanbeam = new ClipperLib.Scanbeam();
      this.m_Scanbeam.Next = null;
      this.m_Scanbeam.Y = Y;
    }
    else if (Y > this.m_Scanbeam.Y)
    {
      var newSb = new ClipperLib.Scanbeam();
      newSb.Y = Y;
      newSb.Next = this.m_Scanbeam;
      this.m_Scanbeam = newSb;
    }
    else
    {
      var sb2 = this.m_Scanbeam;
      while (sb2.Next !== null && (Y <= sb2.Next.Y))
        sb2 = sb2.Next;
      if (Y == sb2.Y)
        return;
      //ie ignores duplicates
      var newSb = new ClipperLib.Scanbeam();
      newSb.Y = Y;
      newSb.Next = sb2.Next;
      sb2.Next = newSb;
    }
  };
  // ************************************
  ClipperLib.Clipper.prototype.Execute = function ()
  {
    var a = arguments,
      alen = a.length,
      ispolytree = a[1] instanceof ClipperLib.PolyTree;
    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)
    {
      var clipType = a[0],
        solution = a[1],
        subjFillType = a[2],
        clipFillType = a[3];
      if (this.m_ExecuteLocked)
        return false;
      if (this.m_HasOpenPaths)
        ClipperLib.Error("Error: PolyTree struct is need for open path clipping.");
      this.m_ExecuteLocked = true;
      ClipperLib.Clear(solution);
      this.m_SubjFillType = subjFillType;
      this.m_ClipFillType = clipFillType;
      this.m_ClipType = clipType;
      this.m_UsingPolyTree = false;
      try
      {
        var succeeded = this.ExecuteInternal();
        //build the return polygons ...
        if (succeeded) this.BuildResult(solution);
      }
      finally
      {
        this.DisposeAllPolyPts();
        this.m_ExecuteLocked = false;
      }
      return succeeded;
    }
    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)
    {
      var clipType = a[0],
        polytree = a[1],
        subjFillType = a[2],
        clipFillType = a[3];
      if (this.m_ExecuteLocked)
        return false;
      this.m_ExecuteLocked = true;
      this.m_SubjFillType = subjFillType;
      this.m_ClipFillType = clipFillType;
      this.m_ClipType = clipType;
      this.m_UsingPolyTree = true;
      try
      {
        var succeeded = this.ExecuteInternal();
        //build the return polygons ...
        if (succeeded) this.BuildResult2(polytree);
      }
      finally
      {
        this.DisposeAllPolyPts();
        this.m_ExecuteLocked = false;
      }
      return succeeded;
    }
    else if (alen == 2 && !ispolytree) // function (clipType, solution)
    {
      var clipType = a[0],
        solution = a[1];
      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);
    }
    else if (alen == 2 && ispolytree) // function (clipType, polytree)
    {
      var clipType = a[0],
        polytree = a[1];
      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);
    }
  };
  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)
  {
    //skip if an outermost polygon or
    //already already points to the correct FirstLeft ...
    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))
      return;
    var orfl = outRec.FirstLeft;
    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))
      orfl = orfl.FirstLeft;
    outRec.FirstLeft = orfl;
  };
  ClipperLib.Clipper.prototype.ExecuteInternal = function ()
  {
    try
    {
      this.Reset();
      if (this.m_CurrentLM === null)
        return false;
      var botY = this.PopScanbeam();
      do {
        this.InsertLocalMinimaIntoAEL(botY);
        ClipperLib.Clear(this.m_GhostJoins);
        this.ProcessHorizontals(false);
        if (this.m_Scanbeam === null)
          break;
        var topY = this.PopScanbeam();
        if (!this.ProcessIntersections(topY)) return false;

        this.ProcessEdgesAtTopOfScanbeam(topY);
        botY = topY;
      }
      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)
      //fix orientations ...
      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
      {
        var outRec = this.m_PolyOuts[i];
        if (outRec.Pts === null || outRec.IsOpen)
          continue;
        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))
          this.ReversePolyPtLinks(outRec.Pts);
      }
      this.JoinCommonEdges();
      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
      {
        var outRec = this.m_PolyOuts[i];
        if (outRec.Pts !== null && !outRec.IsOpen)
          this.FixupOutPolygon(outRec);
      }
      if (this.StrictlySimple)
        this.DoSimplePolygons();
      return true;
    }
    finally
    {
      ClipperLib.Clear(this.m_Joins);
      ClipperLib.Clear(this.m_GhostJoins);
    }
  };
  ClipperLib.Clipper.prototype.PopScanbeam = function ()
  {
    var Y = this.m_Scanbeam.Y;
    this.m_Scanbeam = this.m_Scanbeam.Next;
    return Y;
  };

  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()
  {
    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)
      this.DisposeOutRec(i);
    ClipperLib.Clear(this.m_PolyOuts);
  };
  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)
  {
    var outRec = this.m_PolyOuts[index];
    outRec.Pts = null;
    outRec = null;
    this.m_PolyOuts[index] = null;
  };

  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)
  {
    var j = new ClipperLib.Join();
    j.OutPt1 = Op1;
    j.OutPt2 = Op2;
    //j.OffPt = OffPt;
    j.OffPt.X = OffPt.X;
    j.OffPt.Y = OffPt.Y;
    this.m_Joins.push(j);
  };
  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)
  {
    var j = new ClipperLib.Join();
    j.OutPt1 = Op;
    //j.OffPt = OffPt;
    j.OffPt.X = OffPt.X;
    j.OffPt.Y = OffPt.Y;
    this.m_GhostJoins.push(j);
  };
  if (use_xyz)
  {
    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)
    {
      if (this.ZFillFunction !== null)
      {
        if (pt.Z != 0 || this.ZFillFunction === null) return;
        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;
        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;
        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;
        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;
        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);
      }
    };

    //------------------------------------------------------------------------------
  }

  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)
  {
    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))
    {
      var lb = this.m_CurrentLM.LeftBound;
      var rb = this.m_CurrentLM.RightBound;
      this.PopLocalMinima();
      var Op1 = null;
      if (lb === null)
      {
        this.InsertEdgeIntoAEL(rb, null);
        this.SetWindingCount(rb);
        if (this.IsContributing(rb))
          Op1 = this.AddOutPt(rb, rb.Bot);
      }
      else if (rb == null)
      {
        this.InsertEdgeIntoAEL(lb, null);
        this.SetWindingCount(lb);
        if (this.IsContributing(lb))
          Op1 = this.AddOutPt(lb, lb.Bot);
        this.InsertScanbeam(lb.Top.Y);
      }
      else
      {
        this.InsertEdgeIntoAEL(lb, null);
        this.InsertEdgeIntoAEL(rb, lb);
        this.SetWindingCount(lb);
        rb.WindCnt = lb.WindCnt;
        rb.WindCnt2 = lb.WindCnt2;
        if (this.IsContributing(lb))
          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);
        this.InsertScanbeam(lb.Top.Y);
      }
      if (rb != null)
      {
        if (ClipperLib.ClipperBase.IsHorizontal(rb))
          this.AddEdgeToSEL(rb);
        else
          this.InsertScanbeam(rb.Top.Y);
      }
      if (lb == null || rb == null) continue;
      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...
      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)
      {
        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)
        {
          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert
          //the 'ghost' join to a real join ready for later ...
          var j = this.m_GhostJoins[i];

					if (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))
            this.AddJoin(j.OutPt1, Op1, j.OffPt);
        }
      }
      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&
        lb.PrevInAEL.Curr.X == lb.Bot.X &&
        lb.PrevInAEL.OutIdx >= 0 &&
        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&
        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)
      {
        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);
        this.AddJoin(Op1, Op2, lb.Top);
      }
      if (lb.NextInAEL != rb)
      {
        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&
          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&
          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)
        {
          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);
          this.AddJoin(Op1, Op2, rb.Top);
        }
        var e = lb.NextInAEL;
        if (e !== null)
          while (e != rb)
          {
            //nb: For calculating winding counts etc, IntersectEdges() assumes
            //that param1 will be to the right of param2 ABOVE the intersection ...
            this.IntersectEdges(rb, e, lb.Curr, false);
            //order important here
            e = e.NextInAEL;
          }
      }
    }
  };
  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)
  {
    if (this.m_ActiveEdges === null)
    {
      edge.PrevInAEL = null;
      edge.NextInAEL = null;
      this.m_ActiveEdges = edge;
    }
    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))
    {
      edge.PrevInAEL = null;
      edge.NextInAEL = this.m_ActiveEdges;
      this.m_ActiveEdges.PrevInAEL = edge;
      this.m_ActiveEdges = edge;
    }
    else
    {
      if (startEdge === null)
        startEdge = this.m_ActiveEdges;
      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))
        startEdge = startEdge.NextInAEL;
      edge.NextInAEL = startEdge.NextInAEL;
      if (startEdge.NextInAEL !== null)
        startEdge.NextInAEL.PrevInAEL = edge;
      edge.PrevInAEL = startEdge;
      startEdge.NextInAEL = edge;
    }
  };
  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)
  {
    if (e2.Curr.X == e1.Curr.X)
    {
      if (e2.Top.Y > e1.Top.Y)
        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);
      else
        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);
    }
    else
      return e2.Curr.X < e1.Curr.X;
  };
  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)
  {
    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)
      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;
    else
      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;
  };
  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)
  {
    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)
      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;
    else
      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;
  };
  ClipperLib.Clipper.prototype.IsContributing = function (edge)
  {
    var pft, pft2;
    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)
    {
      pft = this.m_SubjFillType;
      pft2 = this.m_ClipFillType;
    }
    else
    {
      pft = this.m_ClipFillType;
      pft2 = this.m_SubjFillType;
    }
    switch (pft)
    {
    case ClipperLib.PolyFillType.pftEvenOdd:
      if (edge.WindDelta === 0 && edge.WindCnt != 1)
        return false;
      break;
    case ClipperLib.PolyFillType.pftNonZero:
      if (Math.abs(edge.WindCnt) != 1)
        return false;
      break;
    case ClipperLib.PolyFillType.pftPositive:
      if (edge.WindCnt != 1)
        return false;
      break;
    default:
      if (edge.WindCnt != -1)
        return false;
      break;
    }
    switch (this.m_ClipType)
    {
    case ClipperLib.ClipType.ctIntersection:
      switch (pft2)
      {
      case ClipperLib.PolyFillType.pftEvenOdd:
      case ClipperLib.PolyFillType.pftNonZero:
        return (edge.WindCnt2 !== 0);
      case ClipperLib.PolyFillType.pftPositive:
        return (edge.WindCnt2 > 0);
      default:
        return (edge.WindCnt2 < 0);
      }
    case ClipperLib.ClipType.ctUnion:
      switch (pft2)
      {
      case ClipperLib.PolyFillType.pftEvenOdd:
      case ClipperLib.PolyFillType.pftNonZero:
        return (edge.WindCnt2 === 0);
      case ClipperLib.PolyFillType.pftPositive:
        return (edge.WindCnt2 <= 0);
      default:
        return (edge.WindCnt2 >= 0);
      }
    case ClipperLib.ClipType.ctDifference:
      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)
        switch (pft2)
        {
        case ClipperLib.PolyFillType.pftEvenOdd:
        case ClipperLib.PolyFillType.pftNonZero:
          return (edge.WindCnt2 === 0);
        case ClipperLib.PolyFillType.pftPositive:
          return (edge.WindCnt2 <= 0);
        default:
          return (edge.WindCnt2 >= 0);
        }
      else
        switch (pft2)
        {
        case ClipperLib.PolyFillType.pftEvenOdd:
        case ClipperLib.PolyFillType.pftNonZero:
          return (edge.WindCnt2 !== 0);
        case ClipperLib.PolyFillType.pftPositive:
          return (edge.WindCnt2 > 0);
        default:
          return (edge.WindCnt2 < 0);
        }
    case ClipperLib.ClipType.ctXor:
      if (edge.WindDelta === 0)
        switch (pft2)
        {
        case ClipperLib.PolyFillType.pftEvenOdd:
        case ClipperLib.PolyFillType.pftNonZero:
          return (edge.WindCnt2 === 0);
        case ClipperLib.PolyFillType.pftPositive:
          return (edge.WindCnt2 <= 0);
        default:
          return (edge.WindCnt2 >= 0);
        }
      else
        return true;
    }
    return true;
  };
  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)
  {
    var e = edge.PrevInAEL;
    //find the edge of the same polytype that immediately preceeds 'edge' in AEL
    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))
      e = e.PrevInAEL;
    if (e === null)
    {
      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);
      edge.WindCnt2 = 0;
      e = this.m_ActiveEdges;
      //ie get ready to calc WindCnt2
    }
    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)
    {
      edge.WindCnt = 1;
      edge.WindCnt2 = e.WindCnt2;
      e = e.NextInAEL;
      //ie get ready to calc WindCnt2
    }
    else if (this.IsEvenOddFillType(edge))
    {
      //EvenOdd filling ...
      if (edge.WindDelta === 0)
      {
        //are we inside a subj polygon ...
        var Inside = true;
        var e2 = e.PrevInAEL;
        while (e2 !== null)
        {
          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)
            Inside = !Inside;
          e2 = e2.PrevInAEL;
        }
        edge.WindCnt = (Inside ? 0 : 1);
      }
      else
      {
        edge.WindCnt = edge.WindDelta;
      }
      edge.WindCnt2 = e.WindCnt2;
      e = e.NextInAEL;
      //ie get ready to calc WindCnt2
    }
    else
    {
      //nonZero, Positive or Negative filling ...
      if (e.WindCnt * e.WindDelta < 0)
      {
        //prev edge is 'decreasing' WindCount (WC) toward zero
        //so we're outside the previous polygon ...
        if (Math.abs(e.WindCnt) > 1)
        {
          //outside prev poly but still inside another.
          //when reversing direction of prev poly use the same WC
          if (e.WindDelta * edge.WindDelta < 0)
            edge.WindCnt = e.WindCnt;
          else
            edge.WindCnt = e.WindCnt + edge.WindDelta;
        }
        else
          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);
      }
      else
      {
        //prev edge is 'increasing' WindCount (WC) away from zero
        //so we're inside the previous polygon ...
        if (edge.WindDelta === 0)
          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);
        else if (e.WindDelta * edge.WindDelta < 0)
          edge.WindCnt = e.WindCnt;
        else
          edge.WindCnt = e.WindCnt + edge.WindDelta;
      }
      edge.WindCnt2 = e.WindCnt2;
      e = e.NextInAEL;
      //ie get ready to calc WindCnt2
    }
    //update WindCnt2 ...
    if (this.IsEvenOddAltFillType(edge))
    {
      //EvenOdd filling ...
      while (e != edge)
      {
        if (e.WindDelta !== 0)
          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);
        e = e.NextInAEL;
      }
    }
    else
    {
      //nonZero, Positive or Negative filling ...
      while (e != edge)
      {
        edge.WindCnt2 += e.WindDelta;
        e = e.NextInAEL;
      }
    }
  };
  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)
  {
    //SEL pointers in PEdge are reused to build a list of horizontal edges.
    //However, we don't need to worry about order with horizontal edge processing.
    if (this.m_SortedEdges === null)
    {
      this.m_SortedEdges = edge;
      edge.PrevInSEL = null;
      edge.NextInSEL = null;
    }
    else
    {
      edge.NextInSEL = this.m_SortedEdges;
      edge.PrevInSEL = null;
      this.m_SortedEdges.PrevInSEL = edge;
      this.m_SortedEdges = edge;
    }
  };
  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()
  {
    var e = this.m_ActiveEdges;
    this.m_SortedEdges = e;
    while (e !== null)
    {
      e.PrevInSEL = e.PrevInAEL;
      e.NextInSEL = e.NextInAEL;
      e = e.NextInAEL;
    }
  };
  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)
  {
    //check that one or other edge hasn't already been removed from AEL ...
    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)
      return;
    if (edge1.NextInAEL == edge2)
    {
      var next = edge2.NextInAEL;
      if (next !== null)
        next.PrevInAEL = edge1;
      var prev = edge1.PrevInAEL;
      if (prev !== null)
        prev.NextInAEL = edge2;
      edge2.PrevInAEL = prev;
      edge2.NextInAEL = edge1;
      edge1.PrevInAEL = edge2;
      edge1.NextInAEL = next;
    }
    else if (edge2.NextInAEL == edge1)
    {
      var next = edge1.NextInAEL;
      if (next !== null)
        next.PrevInAEL = edge2;
      var prev = edge2.PrevInAEL;
      if (prev !== null)
        prev.NextInAEL = edge1;
      edge1.PrevInAEL = prev;
      edge1.NextInAEL = edge2;
      edge2.PrevInAEL = edge1;
      edge2.NextInAEL = next;
    }
    else
    {
      var next = edge1.NextInAEL;
      var prev = edge1.PrevInAEL;
      edge1.NextInAEL = edge2.NextInAEL;
      if (edge1.NextInAEL !== null)
        edge1.NextInAEL.PrevInAEL = edge1;
      edge1.PrevInAEL = edge2.PrevInAEL;
      if (edge1.PrevInAEL !== null)
        edge1.PrevInAEL.NextInAEL = edge1;
      edge2.NextInAEL = next;
      if (edge2.NextInAEL !== null)
        edge2.NextInAEL.PrevInAEL = edge2;
      edge2.PrevInAEL = prev;
      if (edge2.PrevInAEL !== null)
        edge2.PrevInAEL.NextInAEL = edge2;
    }
    if (edge1.PrevInAEL === null)
      this.m_ActiveEdges = edge1;
    else if (edge2.PrevInAEL === null)
      this.m_ActiveEdges = edge2;
  };
  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)
  {
    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)
      return;
    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)
      return;
    if (edge1.NextInSEL == edge2)
    {
      var next = edge2.NextInSEL;
      if (next !== null)
        next.PrevInSEL = edge1;
      var prev = edge1.PrevInSEL;
      if (prev !== null)
        prev.NextInSEL = edge2;
      edge2.PrevInSEL = prev;
      edge2.NextInSEL = edge1;
      edge1.PrevInSEL = edge2;
      edge1.NextInSEL = next;
    }
    else if (edge2.NextInSEL == edge1)
    {
      var next = edge1.NextInSEL;
      if (next !== null)
        next.PrevInSEL = edge2;
      var prev = edge2.PrevInSEL;
      if (prev !== null)
        prev.NextInSEL = edge1;
      edge1.PrevInSEL = prev;
      edge1.NextInSEL = edge2;
      edge2.PrevInSEL = edge1;
      edge2.NextInSEL = next;
    }
    else
    {
      var next = edge1.NextInSEL;
      var prev = edge1.PrevInSEL;
      edge1.NextInSEL = edge2.NextInSEL;
      if (edge1.NextInSEL !== null)
        edge1.NextInSEL.PrevInSEL = edge1;
      edge1.PrevInSEL = edge2.PrevInSEL;
      if (edge1.PrevInSEL !== null)
        edge1.PrevInSEL.NextInSEL = edge1;
      edge2.NextInSEL = next;
      if (edge2.NextInSEL !== null)
        edge2.NextInSEL.PrevInSEL = edge2;
      edge2.PrevInSEL = prev;
      if (edge2.PrevInSEL !== null)
        edge2.PrevInSEL.NextInSEL = edge2;
    }
    if (edge1.PrevInSEL === null)
      this.m_SortedEdges = edge1;
    else if (edge2.PrevInSEL === null)
      this.m_SortedEdges = edge2;
  };
  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)
  {
    this.AddOutPt(e1, pt);
    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);
    if (e1.OutIdx == e2.OutIdx)
    {
      e1.OutIdx = -1;
      e2.OutIdx = -1;
    }
    else if (e1.OutIdx < e2.OutIdx)
      this.AppendPolygon(e1, e2);
    else
      this.AppendPolygon(e2, e1);
  };
  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)
  {
    var result;
    var e, prevE;
    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))
    {
      result = this.AddOutPt(e1, pt);
      e2.OutIdx = e1.OutIdx;
      e1.Side = ClipperLib.EdgeSide.esLeft;
      e2.Side = ClipperLib.EdgeSide.esRight;
      e = e1;
      if (e.PrevInAEL == e2)
        prevE = e2.PrevInAEL;
      else
        prevE = e.PrevInAEL;
    }
    else
    {
      result = this.AddOutPt(e2, pt);
      e1.OutIdx = e2.OutIdx;
      e1.Side = ClipperLib.EdgeSide.esRight;
      e2.Side = ClipperLib.EdgeSide.esLeft;
      e = e2;
      if (e.PrevInAEL == e1)
        prevE = e1.PrevInAEL;
      else
        prevE = e.PrevInAEL;
    }
    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))
    {
      var outPt = this.AddOutPt(prevE, pt);
      this.AddJoin(result, outPt, e.Top);
    }
    return result;
  };
  ClipperLib.Clipper.prototype.CreateOutRec = function ()
  {
    var result = new ClipperLib.OutRec();
    result.Idx = -1;
    result.IsHole = false;
    result.IsOpen = false;
    result.FirstLeft = null;
    result.Pts = null;
    result.BottomPt = null;
    result.PolyNode = null;
    this.m_PolyOuts.push(result);
    result.Idx = this.m_PolyOuts.length - 1;
    return result;
  };
  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)
  {
    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);
    if (e.OutIdx < 0)
    {
      var outRec = this.CreateOutRec();
      outRec.IsOpen = (e.WindDelta === 0);
      var newOp = new ClipperLib.OutPt();
      outRec.Pts = newOp;
      newOp.Idx = outRec.Idx;
      //newOp.Pt = pt;
      newOp.Pt.X = pt.X;
      newOp.Pt.Y = pt.Y;
      newOp.Next = newOp;
      newOp.Prev = newOp;
      if (!outRec.IsOpen)
        this.SetHoleState(e, outRec);
      e.OutIdx = outRec.Idx;
      //nb: do this after SetZ !
      return newOp;
    }
    else
    {
      var outRec = this.m_PolyOuts[e.OutIdx];
      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'
      var op = outRec.Pts;
      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))
        return op;
      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))
        return op.Prev;
      var newOp = new ClipperLib.OutPt();
      newOp.Idx = outRec.Idx;
      //newOp.Pt = pt;
      newOp.Pt.X = pt.X;
      newOp.Pt.Y = pt.Y;
      newOp.Next = op;
      newOp.Prev = op.Prev;
      newOp.Prev.Next = newOp;
      op.Prev = newOp;
      if (ToFront)
        outRec.Pts = newOp;
      return newOp;
    }
  };
  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)
  {
    var tmp = new ClipperLib.IntPoint(pt1.Value);
    //pt1.Value = pt2.Value;
    pt1.Value.X = pt2.Value.X;
    pt1.Value.Y = pt2.Value.Y;
    //pt2.Value = tmp;
    pt2.Value.X = tmp.X;
    pt2.Value.Y = tmp.Y;
  };
  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)
	{
		var tmp;
		if (seg1a > seg1b)
		{
			tmp = seg1a;
			seg1a = seg1b;
			seg1b = tmp;
		}
		if (seg2a > seg2b)
		{
			tmp = seg2a;
			seg2a = seg2b;
			seg2b = tmp;
		}
		return (seg1a < seg2b) && (seg2a < seg1b);
	}

  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)
  {
    var isHole = false;
    var e2 = e.PrevInAEL;
    while (e2 !== null)
    {
      if (e2.OutIdx >= 0 && e2.WindDelta != 0)
      {
        isHole = !isHole;
        if (outRec.FirstLeft === null)
          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];
      }
      e2 = e2.PrevInAEL;
    }
    if (isHole)
      outRec.IsHole = true;
  };
  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)
  {
    if (pt1.Y == pt2.Y)
      return ClipperLib.ClipperBase.horizontal;
    else
      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);
  };
  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)
  {
    var p = btmPt1.Prev;
    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))
      p = p.Prev;
    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));
    p = btmPt1.Next;
    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))
      p = p.Next;
    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));
    p = btmPt2.Prev;
    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))
      p = p.Prev;
    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));
    p = btmPt2.Next;
    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))
      p = p.Next;
    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));
    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);
  };
  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)
  {
    var dups = null;
    var p = pp.Next;
    while (p != pp)
    {
      if (p.Pt.Y > pp.Pt.Y)
      {
        pp = p;
        dups = null;
      }
      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)
      {
        if (p.Pt.X < pp.Pt.X)
        {
          dups = null;
          pp = p;
        }
        else
        {
          if (p.Next != pp && p.Prev != pp)
            dups = p;
        }
      }
      p = p.Next;
    }
    if (dups !== null)
    {
      //there appears to be at least 2 vertices at bottomPt so ...
      while (dups != p)
      {
        if (!this.FirstIsBottomPt(p, dups))
          pp = dups;
        dups = dups.Next;
        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))
          dups = dups.Next;
      }
    }
    return pp;
  };
  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)
  {
    //work out which polygon fragment has the correct hole state ...
    if (outRec1.BottomPt === null)
      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);
    if (outRec2.BottomPt === null)
      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);
    var bPt1 = outRec1.BottomPt;
    var bPt2 = outRec2.BottomPt;
    if (bPt1.Pt.Y > bPt2.Pt.Y)
      return outRec1;
    else if (bPt1.Pt.Y < bPt2.Pt.Y)
      return outRec2;
    else if (bPt1.Pt.X < bPt2.Pt.X)
      return outRec1;
    else if (bPt1.Pt.X > bPt2.Pt.X)
      return outRec2;
    else if (bPt1.Next == bPt1)
      return outRec2;
    else if (bPt2.Next == bPt2)
      return outRec1;
    else if (this.FirstIsBottomPt(bPt1, bPt2))
      return outRec1;
    else
      return outRec2;
  };
  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)
  {
    do {
      outRec1 = outRec1.FirstLeft;
      if (outRec1 == outRec2)
        return true;
    }
    while (outRec1 !== null)
    return false;
  };
  ClipperLib.Clipper.prototype.GetOutRec = function (idx)
  {
    var outrec = this.m_PolyOuts[idx];
    while (outrec != this.m_PolyOuts[outrec.Idx])
      outrec = this.m_PolyOuts[outrec.Idx];
    return outrec;
  };
  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)
  {
    //get the start and ends of both output polygons ...
    var outRec1 = this.m_PolyOuts[e1.OutIdx];
    var outRec2 = this.m_PolyOuts[e2.OutIdx];
    var holeStateRec;
    if (this.Param1RightOfParam2(outRec1, outRec2))
      holeStateRec = outRec2;
    else if (this.Param1RightOfParam2(outRec2, outRec1))
      holeStateRec = outRec1;
    else
      holeStateRec = this.GetLowermostRec(outRec1, outRec2);
    var p1_lft = outRec1.Pts;
    var p1_rt = p1_lft.Prev;
    var p2_lft = outRec2.Pts;
    var p2_rt = p2_lft.Prev;
    var side;
    //join e2 poly onto e1 poly and delete pointers to e2 ...
    if (e1.Side == ClipperLib.EdgeSide.esLeft)
    {
      if (e2.Side == ClipperLib.EdgeSide.esLeft)
      {
        //z y x a b c
        this.ReversePolyPtLinks(p2_lft);
        p2_lft.Next = p1_lft;
        p1_lft.Prev = p2_lft;
        p1_rt.Next = p2_rt;
        p2_rt.Prev = p1_rt;
        outRec1.Pts = p2_rt;
      }
      else
      {
        //x y z a b c
        p2_rt.Next = p1_lft;
        p1_lft.Prev = p2_rt;
        p2_lft.Prev = p1_rt;
        p1_rt.Next = p2_lft;
        outRec1.Pts = p2_lft;
      }
      side = ClipperLib.EdgeSide.esLeft;
    }
    else
    {
      if (e2.Side == ClipperLib.EdgeSide.esRight)
      {
        //a b c z y x
        this.ReversePolyPtLinks(p2_lft);
        p1_rt.Next = p2_rt;
        p2_rt.Prev = p1_rt;
        p2_lft.Next = p1_lft;
        p1_lft.Prev = p2_lft;
      }
      else
      {
        //a b c x y z
        p1_rt.Next = p2_lft;
        p2_lft.Prev = p1_rt;
        p1_lft.Prev = p2_rt;
        p2_rt.Next = p1_lft;
      }
      side = ClipperLib.EdgeSide.esRight;
    }
    outRec1.BottomPt = null;
    if (holeStateRec == outRec2)
    {
      if (outRec2.FirstLeft != outRec1)
        outRec1.FirstLeft = outRec2.FirstLeft;
      outRec1.IsHole = outRec2.IsHole;
    }
    outRec2.Pts = null;
    outRec2.BottomPt = null;
    outRec2.FirstLeft = outRec1;
    var OKIdx = e1.OutIdx;
    var ObsoleteIdx = e2.OutIdx;
    e1.OutIdx = -1;
    //nb: safe because we only get here via AddLocalMaxPoly
    e2.OutIdx = -1;
    var e = this.m_ActiveEdges;
    while (e !== null)
    {
      if (e.OutIdx == ObsoleteIdx)
      {
        e.OutIdx = OKIdx;
        e.Side = side;
        break;
      }
      e = e.NextInAEL;
    }
    outRec2.Idx = outRec1.Idx;
  };
  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)
  {
    if (pp === null)
      return;
    var pp1;
    var pp2;
    pp1 = pp;
    do {
      pp2 = pp1.Next;
      pp1.Next = pp1.Prev;
      pp1.Prev = pp2;
      pp1 = pp2;
    }
    while (pp1 != pp)
  };
  ClipperLib.Clipper.SwapSides = function (edge1, edge2)
  {
    var side = edge1.Side;
    edge1.Side = edge2.Side;
    edge2.Side = side;
  };
  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)
  {
    var outIdx = edge1.OutIdx;
    edge1.OutIdx = edge2.OutIdx;
    edge2.OutIdx = outIdx;
  };
  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)
  {
    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before
    //e2 in AEL except when e1 is being inserted at the intersection point ...
    var e1Contributing = (e1.OutIdx >= 0);
    var e2Contributing = (e2.OutIdx >= 0);

    if (use_xyz)
    	this.SetZ(pt, e1, e2);

    if (use_lines)
    {
      //if either edge is on an OPEN path ...
      if (e1.WindDelta === 0 || e2.WindDelta === 0)
      {
        //ignore subject-subject open path intersections UNLESS they
        //are both open paths, AND they are both 'contributing maximas' ...
				if (e1.WindDelta == 0 && e2.WindDelta == 0) return;
        //if intersecting a subj line with a subj poly ...
        else if (e1.PolyTyp == e2.PolyTyp &&
          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)
        {
          if (e1.WindDelta === 0)
          {
            if (e2Contributing)
            {
              this.AddOutPt(e1, pt);
              if (e1Contributing)
                e1.OutIdx = -1;
            }
          }
          else
          {
            if (e1Contributing)
            {
              this.AddOutPt(e2, pt);
              if (e2Contributing)
                e2.OutIdx = -1;
            }
          }
        }
        else if (e1.PolyTyp != e2.PolyTyp)
        {
          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&
            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))
          {
            this.AddOutPt(e1, pt);
            if (e1Contributing)
              e1.OutIdx = -1;
          }
          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&
            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))
          {
            this.AddOutPt(e2, pt);
            if (e2Contributing)
              e2.OutIdx = -1;
          }
        }
        return;
      }
    }
    //update winding counts...
    //assumes that e1 will be to the Right of e2 ABOVE the intersection
    if (e1.PolyTyp == e2.PolyTyp)
    {
      if (this.IsEvenOddFillType(e1))
      {
        var oldE1WindCnt = e1.WindCnt;
        e1.WindCnt = e2.WindCnt;
        e2.WindCnt = oldE1WindCnt;
      }
      else
      {
        if (e1.WindCnt + e2.WindDelta === 0)
          e1.WindCnt = -e1.WindCnt;
        else
          e1.WindCnt += e2.WindDelta;
        if (e2.WindCnt - e1.WindDelta === 0)
          e2.WindCnt = -e2.WindCnt;
        else
          e2.WindCnt -= e1.WindDelta;
      }
    }
    else
    {
      if (!this.IsEvenOddFillType(e2))
        e1.WindCnt2 += e2.WindDelta;
      else
        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;
      if (!this.IsEvenOddFillType(e1))
        e2.WindCnt2 -= e1.WindDelta;
      else
        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;
    }
    var e1FillType, e2FillType, e1FillType2, e2FillType2;
    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)
    {
      e1FillType = this.m_SubjFillType;
      e1FillType2 = this.m_ClipFillType;
    }
    else
    {
      e1FillType = this.m_ClipFillType;
      e1FillType2 = this.m_SubjFillType;
    }
    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)
    {
      e2FillType = this.m_SubjFillType;
      e2FillType2 = this.m_ClipFillType;
    }
    else
    {
      e2FillType = this.m_ClipFillType;
      e2FillType2 = this.m_SubjFillType;
    }
    var e1Wc, e2Wc;
    switch (e1FillType)
    {
    case ClipperLib.PolyFillType.pftPositive:
      e1Wc = e1.WindCnt;
      break;
    case ClipperLib.PolyFillType.pftNegative:
      e1Wc = -e1.WindCnt;
      break;
    default:
      e1Wc = Math.abs(e1.WindCnt);
      break;
    }
    switch (e2FillType)
    {
    case ClipperLib.PolyFillType.pftPositive:
      e2Wc = e2.WindCnt;
      break;
    case ClipperLib.PolyFillType.pftNegative:
      e2Wc = -e2.WindCnt;
      break;
    default:
      e2Wc = Math.abs(e2.WindCnt);
      break;
    }
    if (e1Contributing && e2Contributing)
    {
			if ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||
			(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))
			{
				this.AddLocalMaxPoly(e1, e2, pt);
			}
      else
      {
        this.AddOutPt(e1, pt);
        this.AddOutPt(e2, pt);
        ClipperLib.Clipper.SwapSides(e1, e2);
        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);
      }
    }
    else if (e1Contributing)
    {
      if (e2Wc === 0 || e2Wc == 1)
      {
        this.AddOutPt(e1, pt);
        ClipperLib.Clipper.SwapSides(e1, e2);
        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);
      }
    }
    else if (e2Contributing)
    {
      if (e1Wc === 0 || e1Wc == 1)
      {
        this.AddOutPt(e2, pt);
        ClipperLib.Clipper.SwapSides(e1, e2);
        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);
      }
    }
		else if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))
    {
      //neither edge is currently contributing ...
      var e1Wc2, e2Wc2;
      switch (e1FillType2)
      {
      case ClipperLib.PolyFillType.pftPositive:
        e1Wc2 = e1.WindCnt2;
        break;
      case ClipperLib.PolyFillType.pftNegative:
        e1Wc2 = -e1.WindCnt2;
        break;
      default:
        e1Wc2 = Math.abs(e1.WindCnt2);
        break;
      }
      switch (e2FillType2)
      {
      case ClipperLib.PolyFillType.pftPositive:
        e2Wc2 = e2.WindCnt2;
        break;
      case ClipperLib.PolyFillType.pftNegative:
        e2Wc2 = -e2.WindCnt2;
        break;
      default:
        e2Wc2 = Math.abs(e2.WindCnt2);
        break;
      }
      if (e1.PolyTyp != e2.PolyTyp)
      {
        this.AddLocalMinPoly(e1, e2, pt);
      }
      else if (e1Wc == 1 && e2Wc == 1)
        switch (this.m_ClipType)
        {
        case ClipperLib.ClipType.ctIntersection:
          if (e1Wc2 > 0 && e2Wc2 > 0)
            this.AddLocalMinPoly(e1, e2, pt);
          break;
        case ClipperLib.ClipType.ctUnion:
          if (e1Wc2 <= 0 && e2Wc2 <= 0)
            this.AddLocalMinPoly(e1, e2, pt);
          break;
        case ClipperLib.ClipType.ctDifference:
          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||
            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))
            this.AddLocalMinPoly(e1, e2, pt);
          break;
        case ClipperLib.ClipType.ctXor:
          this.AddLocalMinPoly(e1, e2, pt);
          break;
        }
      else
        ClipperLib.Clipper.SwapSides(e1, e2);
    }
  };
  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)
  {
    var AelPrev = e.PrevInAEL;
    var AelNext = e.NextInAEL;
    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))
      return;
    //already deleted
    if (AelPrev !== null)
      AelPrev.NextInAEL = AelNext;
    else
      this.m_ActiveEdges = AelNext;
    if (AelNext !== null)
      AelNext.PrevInAEL = AelPrev;
    e.NextInAEL = null;
    e.PrevInAEL = null;
  };
  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)
  {
    var SelPrev = e.PrevInSEL;
    var SelNext = e.NextInSEL;
    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))
      return;
    //already deleted
    if (SelPrev !== null)
      SelPrev.NextInSEL = SelNext;
    else
      this.m_SortedEdges = SelNext;
    if (SelNext !== null)
      SelNext.PrevInSEL = SelPrev;
    e.NextInSEL = null;
    e.PrevInSEL = null;
  };
  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)
  {
    if (e.NextInLML === null)
      ClipperLib.Error("UpdateEdgeIntoAEL: invalid call");
    var AelPrev = e.PrevInAEL;
    var AelNext = e.NextInAEL;
    e.NextInLML.OutIdx = e.OutIdx;
    if (AelPrev !== null)
      AelPrev.NextInAEL = e.NextInLML;
    else
      this.m_ActiveEdges = e.NextInLML;
    if (AelNext !== null)
      AelNext.PrevInAEL = e.NextInLML;
    e.NextInLML.Side = e.Side;
    e.NextInLML.WindDelta = e.WindDelta;
    e.NextInLML.WindCnt = e.WindCnt;
    e.NextInLML.WindCnt2 = e.WindCnt2;
    e = e.NextInLML;
    //    e.Curr = e.Bot;
    e.Curr.X = e.Bot.X;
    e.Curr.Y = e.Bot.Y;
    e.PrevInAEL = AelPrev;
    e.NextInAEL = AelNext;
    if (!ClipperLib.ClipperBase.IsHorizontal(e))
      this.InsertScanbeam(e.Top.Y);
    return e;
  };
  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)
  {
    var horzEdge = this.m_SortedEdges;
    while (horzEdge !== null)
    {
      this.DeleteFromSEL(horzEdge);
      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);
      horzEdge = this.m_SortedEdges;
    }
  };
  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)
  {
    if (HorzEdge.Bot.X < HorzEdge.Top.X)
    {
        $var.Left = HorzEdge.Bot.X;
        $var.Right = HorzEdge.Top.X;
        $var.Dir = ClipperLib.Direction.dLeftToRight;
    }
    else
    {
        $var.Left = HorzEdge.Top.X;
        $var.Right = HorzEdge.Bot.X;
        $var.Dir = ClipperLib.Direction.dRightToLeft;
    }
  };
  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)
  {
    var $var = {Dir: null, Left: null, Right: null};
    this.GetHorzDirection(horzEdge, $var);
    var dir = $var.Dir;
    var horzLeft = $var.Left;
    var horzRight = $var.Right;

    var eLastHorz = horzEdge,
      eMaxPair = null;
    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))
      eLastHorz = eLastHorz.NextInLML;
    if (eLastHorz.NextInLML === null)
      eMaxPair = this.GetMaximaPair(eLastHorz);
    for (;;)
    {
      var IsLastHorz = (horzEdge == eLastHorz);
      var e = this.GetNextInAEL(horzEdge, dir);
      while (e !== null)
      {
        //Break if we've got to the end of an intermediate horizontal edge ...
        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.
        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)
          break;
        var eNext = this.GetNextInAEL(e, dir);
        //saves eNext for later
        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))
        {
          //so far we're still in range of the horizontal Edge  but make sure
          //we're at the last of consec. horizontals when matching with eMaxPair
          if (e == eMaxPair && IsLastHorz)
          {
						if (horzEdge.OutIdx >= 0)
						{
							var op1 = this.AddOutPt(horzEdge, horzEdge.Top);
							var eNextHorz = this.m_SortedEdges;
							while (eNextHorz !== null)
							{
								if (eNextHorz.OutIdx >= 0 &&
									this.HorzSegmentsOverlap(horzEdge.Bot.X,
									horzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))
								{
									var op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);
									this.AddJoin(op2, op1, eNextHorz.Top);
								}
								eNextHorz = eNextHorz.NextInSEL;
							}
							this.AddGhostJoin(op1, horzEdge.Bot);
							this.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);
						}
						this.DeleteFromAEL(horzEdge);
						this.DeleteFromAEL(eMaxPair);
            return;
          }
          else if (dir == ClipperLib.Direction.dLeftToRight)
          {
            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);
            this.IntersectEdges(horzEdge, e, Pt);
          }
          else
          {
            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);
            this.IntersectEdges(e, horzEdge, Pt);
          }
          this.SwapPositionsInAEL(horzEdge, e);
        }
        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))
          break;
        e = eNext;
      }
      //end while
      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))
      {
        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
        if (horzEdge.OutIdx >= 0)
          this.AddOutPt(horzEdge, horzEdge.Bot);

          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};
          this.GetHorzDirection(horzEdge, $var);
          dir = $var.Dir;
          horzLeft = $var.Left;
          horzRight = $var.Right;
      }
      else
        break;
    }
    //end for (;;)
    if (horzEdge.NextInLML !== null)
    {
      if (horzEdge.OutIdx >= 0)
      {
        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);
				if (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);
        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
        if (horzEdge.WindDelta === 0)
          return;
        //nb: HorzEdge is no longer horizontal here
        var ePrev = horzEdge.PrevInAEL;
        var eNext = horzEdge.NextInAEL;
        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&
          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&
          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&
            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))
        {
          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);
          this.AddJoin(op1, op2, horzEdge.Top);
        }
        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&
          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&
          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&
          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))
        {
          var op2 = this.AddOutPt(eNext, horzEdge.Bot);
          this.AddJoin(op1, op2, horzEdge.Top);
        }
      }
      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);
    }
  	else
    {
      if (horzEdge.OutIdx >= 0)
        this.AddOutPt(horzEdge, horzEdge.Top);
      this.DeleteFromAEL(horzEdge);
    }
  };
  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)
  {
    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;
  };
  ClipperLib.Clipper.prototype.IsMinima = function (e)
  {
    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);
  };
  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)
  {
    return (e !== null && e.Top.Y == Y && e.NextInLML === null);
  };
  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)
  {
    return (e.Top.Y == Y && e.NextInLML !== null);
  };
  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)
  {
    var result = null;
    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)
      result = e.Next;
    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)
      result = e.Prev;
    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))
      return null;
    return result;
  };

  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)
  {
    if (this.m_ActiveEdges == null)
      return true;
    try
    {
      this.BuildIntersectList(topY);
      if (this.m_IntersectList.length == 0)
        return true;
      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())
        this.ProcessIntersectList();
      else
        return false;
    }
    catch ($$e2)
    {
      this.m_SortedEdges = null;
      this.m_IntersectList.length = 0;
      ClipperLib.Error("ProcessIntersections error");
    }
    this.m_SortedEdges = null;
    return true;
  };
  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)
  {
    if (this.m_ActiveEdges === null)
      return;
    //prepare for sorting ...
    var e = this.m_ActiveEdges;
    //console.log(JSON.stringify(JSON.decycle( e )));
    this.m_SortedEdges = e;
    while (e !== null)
    {
      e.PrevInSEL = e.PrevInAEL;
      e.NextInSEL = e.NextInAEL;
      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);
      e = e.NextInAEL;
    }
    //bubblesort ...
    var isModified = true;
    while (isModified && this.m_SortedEdges !== null)
    {
      isModified = false;
      e = this.m_SortedEdges;
      while (e.NextInSEL !== null)
      {
        var eNext = e.NextInSEL;
        var pt = new ClipperLib.IntPoint();
        //console.log("e.Curr.X: " + e.Curr.X + " eNext.Curr.X" + eNext.Curr.X);
        if (e.Curr.X > eNext.Curr.X)
        {
					this.IntersectPoint(e, eNext, pt);
          var newNode = new ClipperLib.IntersectNode();
          newNode.Edge1 = e;
          newNode.Edge2 = eNext;
          //newNode.Pt = pt;
          newNode.Pt.X = pt.X;
          newNode.Pt.Y = pt.Y;
          this.m_IntersectList.push(newNode);
          this.SwapPositionsInSEL(e, eNext);
          isModified = true;
        }
        else
          e = eNext;
      }
      if (e.PrevInSEL !== null)
        e.PrevInSEL.NextInSEL = null;
      else
        break;
    }
    this.m_SortedEdges = null;
  };
  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)
  {
    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);
  };
  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)
  {
    //the following typecast is safe because the differences in Pt.Y will
    //be limited to the height of the scanbeam.
    return (node2.Pt.Y - node1.Pt.Y);
  };
  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()
  {
    //pre-condition: intersections are sorted bottom-most first.
    //Now it's crucial that intersections are made only between adjacent edges,
    //so to ensure this the order of intersections may need adjusting ...
    this.m_IntersectList.sort(this.m_IntersectNodeComparer);
    this.CopyAELToSEL();
    var cnt = this.m_IntersectList.length;
    for (var i = 0; i < cnt; i++)
    {
      if (!this.EdgesAdjacent(this.m_IntersectList[i]))
      {
        var j = i + 1;
        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))
          j++;
        if (j == cnt)
          return false;
        var tmp = this.m_IntersectList[i];
        this.m_IntersectList[i] = this.m_IntersectList[j];
        this.m_IntersectList[j] = tmp;
      }
      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);
    }
    return true;
  };
  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()
  {
    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)
    {
      var iNode = this.m_IntersectList[i];
      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);
      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);
    }
    this.m_IntersectList.length = 0;
  };
  /*
  --------------------------------
  Round speedtest: http://jsperf.com/fastest-round
  --------------------------------
  */
  var R1 = function (a)
  {
    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)
  };
  var R2 = function (a)
  {
    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)
  };
  var R3 = function (a)
  {
    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)
  };
  var R4 = function (a)
  {
    if (a < 0)
    {
      a -= 0.5;
      return a < -2147483648 ? Math.ceil(a) : a | 0;
    }
    else
    {
      a += 0.5;
      return a > 2147483647 ? Math.floor(a) : a | 0;
    }
  };
  if (browser.msie) ClipperLib.Clipper.Round = R1;
  else if (browser.chromium) ClipperLib.Clipper.Round = R3;
  else if (browser.safari) ClipperLib.Clipper.Round = R4;
  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera
  ClipperLib.Clipper.TopX = function (edge, currentY)
  {
    //if (edge.Bot == edge.Curr) alert ("edge.Bot = edge.Curr");
    //if (edge.Bot == edge.Top) alert ("edge.Bot = edge.Top");
    if (currentY == edge.Top.Y)
      return edge.Top.X;
    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));
  };
  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)
  {
    ip.X = 0;
    ip.Y = 0;
    var b1, b2;
    //nb: with very large coordinate values, it's possible for SlopesEqual() to
    //return false but for the edge.Dx value be equal due to double precision rounding.
    if (edge1.Dx == edge2.Dx)
		{
			ip.Y = edge1.Curr.Y;
			ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);
			return;
    }
    if (edge1.Delta.X === 0)
    {
      ip.X = edge1.Bot.X;
      if (ClipperLib.ClipperBase.IsHorizontal(edge2))
      {
        ip.Y = edge2.Bot.Y;
      }
      else
      {
        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);
        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);
      }
    }
    else if (edge2.Delta.X === 0)
    {
      ip.X = edge2.Bot.X;
      if (ClipperLib.ClipperBase.IsHorizontal(edge1))
      {
        ip.Y = edge1.Bot.Y;
      }
      else
      {
        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);
        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);
      }
    }
    else
    {
      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;
      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;
      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);
      ip.Y = ClipperLib.Clipper.Round(q);
      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))
        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);
      else
        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);
    }
    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)
    {
      if (edge1.Top.Y > edge2.Top.Y)
      {
        ip.Y = edge1.Top.Y;
        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);
        return ip.X < edge1.Top.X;
      }
      else
        ip.Y = edge2.Top.Y;
      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))
        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);
      else
        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);
    }
		//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...
		if (ip.Y > edge1.Curr.Y)
		{
			ip.Y = edge1.Curr.Y;
			//better to use the more vertical edge to derive X ...
			if (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))
				ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);
			else
				ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);
		}
  };

  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)
  {
    var e = this.m_ActiveEdges;
    while (e !== null)
    {
      //1. process maxima, treating them as if they're 'bent' horizontal edges,
      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.
      var IsMaximaEdge = this.IsMaxima(e, topY);
      if (IsMaximaEdge)
      {
        var eMaxPair = this.GetMaximaPair(e);
        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));
      }
      if (IsMaximaEdge)
      {
        var ePrev = e.PrevInAEL;
        this.DoMaxima(e);
        if (ePrev === null)
          e = this.m_ActiveEdges;
        else
          e = ePrev.NextInAEL;
      }
      else
      {
        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...
        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))
        {
          e = this.UpdateEdgeIntoAEL(e);
          if (e.OutIdx >= 0)
            this.AddOutPt(e, e.Bot);
          this.AddEdgeToSEL(e);
        }
        else
        {
          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);
          e.Curr.Y = topY;
        }
        if (this.StrictlySimple)
        {
          var ePrev = e.PrevInAEL;
          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&
            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&
            (ePrev.WindDelta !== 0))
          {
           	var ip = new ClipperLib.IntPoint(e.Curr);

						if(use_xyz)
						{
							this.SetZ(ip, ePrev, e);
						}

            var op = this.AddOutPt(ePrev, ip);
            var op2 = this.AddOutPt(e, ip);
            this.AddJoin(op, op2, ip);
            //StrictlySimple (type-3) join
          }
        }
        e = e.NextInAEL;
      }
    }
    //3. Process horizontals at the Top of the scanbeam ...
    this.ProcessHorizontals(true);
    //4. Promote intermediate vertices ...
    e = this.m_ActiveEdges;
    while (e !== null)
    {
      if (this.IsIntermediate(e, topY))
      {
        var op = null;
        if (e.OutIdx >= 0)
          op = this.AddOutPt(e, e.Top);
        e = this.UpdateEdgeIntoAEL(e);
        //if output polygons share an edge, they'll need joining later ...
        var ePrev = e.PrevInAEL;
        var eNext = e.NextInAEL;
        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&
          ePrev.Curr.Y == e.Bot.Y && op !== null &&
          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&
          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&
          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))
        {
          var op2 = this.AddOutPt(ePrev, e.Bot);
          this.AddJoin(op, op2, e.Top);
        }
        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&
          eNext.Curr.Y == e.Bot.Y && op !== null &&
          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&
          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&
          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))
        {
          var op2 = this.AddOutPt(eNext, e.Bot);
          this.AddJoin(op, op2, e.Top);
        }
      }
      e = e.NextInAEL;
    }
  };
  ClipperLib.Clipper.prototype.DoMaxima = function (e)
  {
    var eMaxPair = this.GetMaximaPair(e);
    if (eMaxPair === null)
    {
      if (e.OutIdx >= 0)
        this.AddOutPt(e, e.Top);
      this.DeleteFromAEL(e);
      return;
    }
    var eNext = e.NextInAEL;
    var use_lines = true;
    while (eNext !== null && eNext != eMaxPair)
    {
      this.IntersectEdges(e, eNext, e.Top);
      this.SwapPositionsInAEL(e, eNext);
      eNext = e.NextInAEL;
    }
    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)
    {
      this.DeleteFromAEL(e);
      this.DeleteFromAEL(eMaxPair);
    }
    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)
    {
    	if (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);
      this.DeleteFromAEL(e);
      this.DeleteFromAEL(eMaxPair);
    }
    else if (use_lines && e.WindDelta === 0)
    {
      if (e.OutIdx >= 0)
      {
        this.AddOutPt(e, e.Top);
        e.OutIdx = -1;
      }
      this.DeleteFromAEL(e);
      if (eMaxPair.OutIdx >= 0)
      {
        this.AddOutPt(eMaxPair, e.Top);
        eMaxPair.OutIdx = -1;
      }
      this.DeleteFromAEL(eMaxPair);
    }
    else
      ClipperLib.Error("DoMaxima error");
  };
  ClipperLib.Clipper.ReversePaths = function (polys)
  {
    for (var i = 0, len = polys.length; i < len; i++)
      polys[i].reverse();
  };
  ClipperLib.Clipper.Orientation = function (poly)
  {
    return ClipperLib.Clipper.Area(poly) >= 0;
  };
  ClipperLib.Clipper.prototype.PointCount = function (pts)
  {
    if (pts === null)
      return 0;
    var result = 0;
    var p = pts;
    do {
      result++;
      p = p.Next;
    }
    while (p != pts)
    return result;
  };
  ClipperLib.Clipper.prototype.BuildResult = function (polyg)
  {
    ClipperLib.Clear(polyg);
    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
    {
      var outRec = this.m_PolyOuts[i];
      if (outRec.Pts === null)
        continue;
      var p = outRec.Pts.Prev;
      var cnt = this.PointCount(p);
      if (cnt < 2)
        continue;
      var pg = new Array(cnt);
      for (var j = 0; j < cnt; j++)
      {
        pg[j] = p.Pt;
        p = p.Prev;
      }
      polyg.push(pg);
    }
  };
  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)
  {
    polytree.Clear();
    //add each output polygon/contour to polytree ...
    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);
    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
    {
      var outRec = this.m_PolyOuts[i];
      var cnt = this.PointCount(outRec.Pts);
      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))
        continue;
      this.FixHoleLinkage(outRec);
      var pn = new ClipperLib.PolyNode();
      polytree.m_AllPolys.push(pn);
      outRec.PolyNode = pn;
      pn.m_polygon.length = cnt;
      var op = outRec.Pts.Prev;
      for (var j = 0; j < cnt; j++)
      {
        pn.m_polygon[j] = op.Pt;
        op = op.Prev;
      }
    }
    //fixup PolyNode links etc ...
    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);
    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
    {
      var outRec = this.m_PolyOuts[i];
      if (outRec.PolyNode === null)
        continue;
      else if (outRec.IsOpen)
      {
        outRec.PolyNode.IsOpen = true;
        polytree.AddChild(outRec.PolyNode);
      }
      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)
        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);
      else
        polytree.AddChild(outRec.PolyNode);
    }
  };
  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)
  {
    //FixupOutPolygon() - removes duplicate points and simplifies consecutive
    //parallel edges by removing the middle vertex.
    var lastOK = null;
    outRec.BottomPt = null;
    var pp = outRec.Pts;
    for (;;)
    {
      if (pp.Prev == pp || pp.Prev == pp.Next)
      {
        outRec.Pts = null;
        return;
      }
      //test for duplicate points and collinear edges ...
      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||
        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&
          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))
      {
        lastOK = null;
        pp.Prev.Next = pp.Next;
        pp.Next.Prev = pp.Prev;
        pp = pp.Prev;
      }
      else if (pp == lastOK)
        break;
      else
      {
        if (lastOK === null)
          lastOK = pp;
        pp = pp.Next;
      }
    }
    outRec.Pts = pp;
  };
  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)
  {
    var result = new ClipperLib.OutPt();
    //result.Pt = outPt.Pt;
    result.Pt.X = outPt.Pt.X;
    result.Pt.Y = outPt.Pt.Y;
    result.Idx = outPt.Idx;
    if (InsertAfter)
    {
      result.Next = outPt.Next;
      result.Prev = outPt;
      outPt.Next.Prev = result;
      outPt.Next = result;
    }
    else
    {
      result.Prev = outPt.Prev;
      result.Next = outPt;
      outPt.Prev.Next = result;
      outPt.Prev = result;
    }
    return result;
  };
  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)
  {
    if (a1 < a2)
    {
      if (b1 < b2)
      {
        $val.Left = Math.max(a1, b1);
        $val.Right = Math.min(a2, b2);
      }
      else
      {
        $val.Left = Math.max(a1, b2);
        $val.Right = Math.min(a2, b1);
      }
    }
    else
    {
      if (b1 < b2)
      {
        $val.Left = Math.max(a2, b1);
        $val.Right = Math.min(a1, b2);
      }
      else
      {
        $val.Left = Math.max(a2, b2);
        $val.Right = Math.min(a1, b1);
      }
    }
    return $val.Left < $val.Right;
  };
  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)
  {
    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);
    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);
    if (Dir1 == Dir2)
      return false;
    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we
    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)
    //So, to facilitate this while inserting Op1b and Op2b ...
    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,
    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)
    if (Dir1 == ClipperLib.Direction.dLeftToRight)
    {
      while (op1.Next.Pt.X <= Pt.X &&
        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)
        op1 = op1.Next;
      if (DiscardLeft && (op1.Pt.X != Pt.X))
        op1 = op1.Next;
      op1b = this.DupOutPt(op1, !DiscardLeft);
      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))
      {
        op1 = op1b;
        //op1.Pt = Pt;
        op1.Pt.X = Pt.X;
        op1.Pt.Y = Pt.Y;
        op1b = this.DupOutPt(op1, !DiscardLeft);
      }
    }
    else
    {
      while (op1.Next.Pt.X >= Pt.X &&
        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)
        op1 = op1.Next;
      if (!DiscardLeft && (op1.Pt.X != Pt.X))
        op1 = op1.Next;
      op1b = this.DupOutPt(op1, DiscardLeft);
      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))
      {
        op1 = op1b;
        //op1.Pt = Pt;
        op1.Pt.X = Pt.X;
        op1.Pt.Y = Pt.Y;
        op1b = this.DupOutPt(op1, DiscardLeft);
      }
    }
    if (Dir2 == ClipperLib.Direction.dLeftToRight)
    {
      while (op2.Next.Pt.X <= Pt.X &&
        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)
        op2 = op2.Next;
      if (DiscardLeft && (op2.Pt.X != Pt.X))
        op2 = op2.Next;
      op2b = this.DupOutPt(op2, !DiscardLeft);
      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))
      {
        op2 = op2b;
        //op2.Pt = Pt;
        op2.Pt.X = Pt.X;
        op2.Pt.Y = Pt.Y;
        op2b = this.DupOutPt(op2, !DiscardLeft);
      }
    }
    else
    {
      while (op2.Next.Pt.X >= Pt.X &&
        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)
        op2 = op2.Next;
      if (!DiscardLeft && (op2.Pt.X != Pt.X))
        op2 = op2.Next;
      op2b = this.DupOutPt(op2, DiscardLeft);
      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))
      {
        op2 = op2b;
        //op2.Pt = Pt;
        op2.Pt.X = Pt.X;
        op2.Pt.Y = Pt.Y;
        op2b = this.DupOutPt(op2, DiscardLeft);
      }
    }
    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)
    {
      op1.Prev = op2;
      op2.Next = op1;
      op1b.Next = op2b;
      op2b.Prev = op1b;
    }
    else
    {
      op1.Next = op2;
      op2.Prev = op1;
      op1b.Prev = op2b;
      op2b.Next = op1b;
    }
    return true;
  };
  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)
  {
    var op1 = j.OutPt1,
      op1b = new ClipperLib.OutPt();
    var op2 = j.OutPt2,
      op2b = new ClipperLib.OutPt();
    //There are 3 kinds of joins for output polygons ...
    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere
    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).
    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same
    //location at the Bottom of the overlapping segment (& Join.OffPt is above).
    //3. StrictlySimple joins where edges touch but are not collinear and where
    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.
    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);
    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))
    {
      //Strictly Simple join ...
			if (outRec1 != outRec2) return false;

      op1b = j.OutPt1.Next;
      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))
        op1b = op1b.Next;
      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);
      op2b = j.OutPt2.Next;
      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))
        op2b = op2b.Next;
      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);
      if (reverse1 == reverse2)
        return false;
      if (reverse1)
      {
        op1b = this.DupOutPt(op1, false);
        op2b = this.DupOutPt(op2, true);
        op1.Prev = op2;
        op2.Next = op1;
        op1b.Next = op2b;
        op2b.Prev = op1b;
        j.OutPt1 = op1;
        j.OutPt2 = op1b;
        return true;
      }
      else
      {
        op1b = this.DupOutPt(op1, true);
        op2b = this.DupOutPt(op2, false);
        op1.Next = op2;
        op2.Prev = op1;
        op1b.Prev = op2b;
        op2b.Next = op1b;
        j.OutPt1 = op1;
        j.OutPt2 = op1b;
        return true;
      }
    }
    else if (isHorizontal)
    {
      //treat horizontal joins differently to non-horizontal joins since with
      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt
      //may be anywhere along the horizontal edge.
      op1b = op1;
      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)
        op1 = op1.Prev;
      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)
        op1b = op1b.Next;
      if (op1b.Next == op1 || op1b.Next == op2)
        return false;
      //a flat 'polygon'
      op2b = op2;
      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)
        op2 = op2.Prev;
      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)
        op2b = op2b.Next;
      if (op2b.Next == op2 || op2b.Next == op1)
        return false;
      //a flat 'polygon'
      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges

      var $val = {Left: null, Right: null};
      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))
        return false;
      var Left = $val.Left;
      var Right = $val.Right;

      //DiscardLeftSide: when overlapping edges are joined, a spike will created
      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up
      //on the discard Side as either may still be needed for other joins ...
      var Pt = new ClipperLib.IntPoint();
      var DiscardLeftSide;
      if (op1.Pt.X >= Left && op1.Pt.X <= Right)
      {
        //Pt = op1.Pt;
        Pt.X = op1.Pt.X;
        Pt.Y = op1.Pt.Y;
        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);
      }
      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)
      {
        //Pt = op2.Pt;
        Pt.X = op2.Pt.X;
        Pt.Y = op2.Pt.Y;
        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);
      }
      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)
      {
        //Pt = op1b.Pt;
        Pt.X = op1b.Pt.X;
        Pt.Y = op1b.Pt.Y;
        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;
      }
      else
      {
        //Pt = op2b.Pt;
        Pt.X = op2b.Pt.X;
        Pt.Y = op2b.Pt.Y;
        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);
      }
      j.OutPt1 = op1;
      j.OutPt2 = op2;
      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);
    }
    else
    {
      //nb: For non-horizontal joins ...
      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y
      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y
      //make sure the polygons are correctly oriented ...
      op1b = op1.Next;
      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))
        op1b = op1b.Next;
      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));
      if (Reverse1)
      {
        op1b = op1.Prev;
        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))
          op1b = op1b.Prev;
        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))
          return false;
      }
      op2b = op2.Next;
      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))
        op2b = op2b.Next;
      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));
      if (Reverse2)
      {
        op2b = op2.Prev;
        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))
          op2b = op2b.Prev;
        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))
          return false;
      }
      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||
        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))
        return false;
      if (Reverse1)
      {
        op1b = this.DupOutPt(op1, false);
        op2b = this.DupOutPt(op2, true);
        op1.Prev = op2;
        op2.Next = op1;
        op1b.Next = op2b;
        op2b.Prev = op1b;
        j.OutPt1 = op1;
        j.OutPt2 = op1b;
        return true;
      }
      else
      {
        op1b = this.DupOutPt(op1, true);
        op2b = this.DupOutPt(op2, false);
        op1.Next = op2;
        op2.Prev = op1;
        op1b.Prev = op2b;
        op2b.Next = op1b;
        j.OutPt1 = op1;
        j.OutPt2 = op1b;
        return true;
      }
    }
  };
  ClipperLib.Clipper.GetBounds = function (paths)
  {
    var i = 0,
      cnt = paths.length;
    while (i < cnt && paths[i].length == 0) i++;
    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);
    var result = new ClipperLib.IntRect();
    result.left = paths[i][0].X;
    result.right = result.left;
    result.top = paths[i][0].Y;
    result.bottom = result.top;
    for (; i < cnt; i++)
      for (var j = 0, jlen = paths[i].length; j < jlen; j++)
      {
        if (paths[i][j].X < result.left) result.left = paths[i][j].X;
        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;
        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;
        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;
      }
    return result;
  }
  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)
  {
    var opStart = ops;
    var result = new ClipperLib.IntRect();
    result.left = ops.Pt.X;
    result.right = ops.Pt.X;
    result.top = ops.Pt.Y;
    result.bottom = ops.Pt.Y;
    ops = ops.Next;
    while (ops != opStart)
    {
      if (ops.Pt.X < result.left)
        result.left = ops.Pt.X;
      if (ops.Pt.X > result.right)
        result.right = ops.Pt.X;
      if (ops.Pt.Y < result.top)
        result.top = ops.Pt.Y;
      if (ops.Pt.Y > result.bottom)
        result.bottom = ops.Pt.Y;
      ops = ops.Next;
    }
    return result;
  };

  ClipperLib.Clipper.PointInPolygon = function (pt, path)
  {
    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary
		//See "The Point in Polygon Problem for Arbitrary Polygons" by Hormann & Agathos
    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf
    var result = 0,
      cnt = path.length;
    if (cnt < 3)
      return 0;
    var ip = path[0];
    for (var i = 1; i <= cnt; ++i)
    {
      var ipNext = (i == cnt ? path[0] : path[i]);
      if (ipNext.Y == pt.Y)
      {
        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))
          return -1;
      }
      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))
      {
        if (ip.X >= pt.X)
        {
          if (ipNext.X > pt.X)
            result = 1 - result;
          else
          {
            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);
            if (d == 0)
              return -1;
            else if ((d > 0) == (ipNext.Y > ip.Y))
              result = 1 - result;
          }
        }
        else
        {
          if (ipNext.X > pt.X)
          {
            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);
            if (d == 0)
              return -1;
            else if ((d > 0) == (ipNext.Y > ip.Y))
              result = 1 - result;
          }
        }
      }
      ip = ipNext;
    }
    return result;
  };

  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)
  {
    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary
		//See "The Point in Polygon Problem for Arbitrary Polygons" by Hormann & Agathos
    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf
    var result = 0;
    var startOp = op;
		var ptx = pt.X, pty = pt.Y;
    var poly0x = op.Pt.X, poly0y = op.Pt.Y;
    do
    {
			op = op.Next;
			var poly1x = op.Pt.X, poly1y = op.Pt.Y;
      if (poly1y == pty)
      {
        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))
          return -1;
      }
      if ((poly0y < pty) != (poly1y < pty))
      {
        if (poly0x >= ptx)
        {
          if (poly1x > ptx)
            result = 1 - result;
          else
          {
            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);
            if (d == 0)
              return -1;
            if ((d > 0) == (poly1y > poly0y))
              result = 1 - result;
          }
        }
        else
        {
          if (poly1x > ptx)
          {
            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);
            if (d == 0)
              return -1;
            if ((d > 0) == (poly1y > poly0y))
              result = 1 - result;
          }
        }
      }
      poly0x = poly1x;
      poly0y = poly1y;
    } while (startOp != op);

    return result;
  };

  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)
  {
    var op = outPt1;
    do
    {
			//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon
      var res = this.PointInPolygon(op.Pt, outPt2);
      if (res >= 0)
        return res > 0;
      op = op.Next;
    }
    while (op != outPt1)
    return true;
  };
  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)
  {
    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)
    {
			var outRec = this.m_PolyOuts[i];
			if (outRec.Pts == null || outRec.FirstLeft == null)
				continue;
			var firstLeft = this.ParseFirstLeft(outRec.FirstLeft);
			if (firstLeft == OldOutRec)
			{
        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))
          outRec.FirstLeft = NewOutRec;
      }
    }
  };
  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)
  {
    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])
      if (outRec.FirstLeft == OldOutRec)
        outRec.FirstLeft = NewOutRec;
  };
  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)
  {
    while (FirstLeft != null && FirstLeft.Pts == null)
      FirstLeft = FirstLeft.FirstLeft;
    return FirstLeft;
  };
  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()
  {
    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)
    {
      var join = this.m_Joins[i];
      var outRec1 = this.GetOutRec(join.OutPt1.Idx);
      var outRec2 = this.GetOutRec(join.OutPt2.Idx);
      if (outRec1.Pts == null || outRec2.Pts == null)
        continue;
      //get the polygon fragment with the correct hole state (FirstLeft)
      //before calling JoinPoints() ...
      var holeStateRec;
      if (outRec1 == outRec2)
        holeStateRec = outRec1;
      else if (this.Param1RightOfParam2(outRec1, outRec2))
        holeStateRec = outRec2;
      else if (this.Param1RightOfParam2(outRec2, outRec1))
        holeStateRec = outRec1;
      else
        holeStateRec = this.GetLowermostRec(outRec1, outRec2);

      if (!this.JoinPoints(join, outRec1, outRec2)) continue;

      if (outRec1 == outRec2)
      {
        //instead of joining two polygons, we've just created a new one by
        //splitting one polygon into two.
        outRec1.Pts = join.OutPt1;
        outRec1.BottomPt = null;
        outRec2 = this.CreateOutRec();
        outRec2.Pts = join.OutPt2;
        //update all OutRec2.Pts Idx's ...
        this.UpdateOutPtIdxs(outRec2);
        //We now need to check every OutRec.FirstLeft pointer. If it points
        //to OutRec1 it may need to point to OutRec2 instead ...
        if (this.m_UsingPolyTree)
          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)
          {
            var oRec = this.m_PolyOuts[j];
            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)
              continue;
            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))
              oRec.FirstLeft = outRec2;
          }
        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))
        {
          //outRec2 is contained by outRec1 ...
          outRec2.IsHole = !outRec1.IsHole;
          outRec2.FirstLeft = outRec1;
          //fixup FirstLeft pointers that may need reassigning to OutRec1
          if (this.m_UsingPolyTree)
            this.FixupFirstLefts2(outRec2, outRec1);
          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))
            this.ReversePolyPtLinks(outRec2.Pts);
        }
        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))
        {
          //outRec1 is contained by outRec2 ...
          outRec2.IsHole = outRec1.IsHole;
          outRec1.IsHole = !outRec2.IsHole;
          outRec2.FirstLeft = outRec1.FirstLeft;
          outRec1.FirstLeft = outRec2;
          //fixup FirstLeft pointers that may need reassigning to OutRec1
          if (this.m_UsingPolyTree)
            this.FixupFirstLefts2(outRec1, outRec2);
          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))
            this.ReversePolyPtLinks(outRec1.Pts);
        }
        else
        {
          //the 2 polygons are completely separate ...
          outRec2.IsHole = outRec1.IsHole;
          outRec2.FirstLeft = outRec1.FirstLeft;
          //fixup FirstLeft pointers that may need reassigning to OutRec2
          if (this.m_UsingPolyTree)
            this.FixupFirstLefts1(outRec1, outRec2);
        }
      }
      else
      {
        //joined 2 polygons together ...
        outRec2.Pts = null;
        outRec2.BottomPt = null;
        outRec2.Idx = outRec1.Idx;
        outRec1.IsHole = holeStateRec.IsHole;
        if (holeStateRec == outRec2)
          outRec1.FirstLeft = outRec2.FirstLeft;
        outRec2.FirstLeft = outRec1;
        //fixup FirstLeft pointers that may need reassigning to OutRec1
        if (this.m_UsingPolyTree)
          this.FixupFirstLefts2(outRec2, outRec1);
      }
    }
  };
  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)
  {
    var op = outrec.Pts;
    do {
      op.Idx = outrec.Idx;
      op = op.Prev;
    }
    while (op != outrec.Pts)
  };
  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()
  {
    var i = 0;
    while (i < this.m_PolyOuts.length)
    {
      var outrec = this.m_PolyOuts[i++];
      var op = outrec.Pts;
			if (op == null || outrec.IsOpen)
				continue;
      do //for each Pt in Polygon until duplicate found do ...
      {
        var op2 = op.Next;
        while (op2 != outrec.Pts)
        {
          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)
          {
            //split the polygon into two ...
            var op3 = op.Prev;
            var op4 = op2.Prev;
            op.Prev = op4;
            op4.Next = op;
            op2.Prev = op3;
            op3.Next = op2;
            outrec.Pts = op;
            var outrec2 = this.CreateOutRec();
            outrec2.Pts = op2;
            this.UpdateOutPtIdxs(outrec2);
            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))
            {
              //OutRec2 is contained by OutRec1 ...
              outrec2.IsHole = !outrec.IsHole;
              outrec2.FirstLeft = outrec;
							if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);

            }
            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))
            {
              //OutRec1 is contained by OutRec2 ...
              outrec2.IsHole = outrec.IsHole;
              outrec.IsHole = !outrec2.IsHole;
              outrec2.FirstLeft = outrec.FirstLeft;
              outrec.FirstLeft = outrec2;
              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);
            }
            else
            {
              //the 2 polygons are separate ...
              outrec2.IsHole = outrec.IsHole;
              outrec2.FirstLeft = outrec.FirstLeft;
							if (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);
            }
            op2 = op;
            //ie get ready for the next iteration
          }
          op2 = op2.Next;
        }
        op = op.Next;
      }
      while (op != outrec.Pts)
    }
  };
  ClipperLib.Clipper.Area = function (poly)
  {
    var cnt = poly.length;
    if (cnt < 3)
      return 0;
    var a = 0;
    for (var i = 0, j = cnt - 1; i < cnt; ++i)
    {
      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);
      j = i;
    }
    return -a * 0.5;
  };
  ClipperLib.Clipper.prototype.Area = function (outRec)
  {
    var op = outRec.Pts;
    if (op == null)
      return 0;
    var a = 0;
    do {
      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);
      op = op.Next;
    }
    while (op != outRec.Pts)
    return a * 0.5;
  };
  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)
  {
    var result = new Array();
    var c = new ClipperLib.Clipper(0);
    c.StrictlySimple = true;
    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);
    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);
    return result;
  };
  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)
  {
    if (typeof (fillType) == "undefined") fillType = ClipperLib.PolyFillType.pftEvenOdd;
    var result = new Array();
    var c = new ClipperLib.Clipper(0);
    c.StrictlySimple = true;
    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);
    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);
    return result;
  };
  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)
  {
    var dx = (pt1.X - pt2.X);
    var dy = (pt1.Y - pt2.Y);
    return (dx * dx + dy * dy);
  };
  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)
  {
    //The equation of a line in general form (Ax + By + C = 0)
    //given 2 points (x¹,y¹) & (x²,y²) is ...
    //(y¹ - y²)x + (x² - x¹)y + (y² - y¹)x¹ - (x² - x¹)y¹ = 0
    //A = (y¹ - y²); B = (x² - x¹); C = (y² - y¹)x¹ - (x² - x¹)y¹
    //perpendicular distance of point (x³,y³) = (Ax³ + By³ + C)/Sqrt(A² + B²)
    //see http://en.wikipedia.org/wiki/Perpendicular_distance
    var A = ln1.Y - ln2.Y;
    var B = ln2.X - ln1.X;
    var C = A * ln1.X + B * ln1.Y;
    C = A * pt.X + B * pt.Y - C;
    return (C * C) / (A * A + B * B);
  };

	ClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)
	{
		//this function is more accurate when the point that's GEOMETRICALLY
		//between the other 2 points is the one that's tested for distance.
		//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts
		if (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))
		{
		if ((pt1.X > pt2.X) == (pt1.X < pt3.X))
			return ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;
		else if ((pt2.X > pt1.X) == (pt2.X < pt3.X))
			return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;
				else
				return ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;
		}
		else
		{
		if ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))
			return ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;
		else if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))
			return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;
				else
			return ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;
		}
	}

  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)
  {
    var dx = pt1.X - pt2.X;
    var dy = pt1.Y - pt2.Y;
    return ((dx * dx) + (dy * dy) <= distSqrd);
  };
  //------------------------------------------------------------------------------
  ClipperLib.Clipper.ExcludeOp = function (op)
  {
    var result = op.Prev;
    result.Next = op.Next;
    op.Next.Prev = result;
    result.Idx = 0;
    return result;
  };
  ClipperLib.Clipper.CleanPolygon = function (path, distance)
  {
    if (typeof (distance) == "undefined") distance = 1.415;
    //distance = proximity in units/pixels below which vertices will be stripped.
    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have
    //both x & y coords within 1 unit, then the second vertex will be stripped.
    var cnt = path.length;
    if (cnt == 0)
      return new Array();
    var outPts = new Array(cnt);
    for (var i = 0; i < cnt; ++i)
      outPts[i] = new ClipperLib.OutPt();
    for (var i = 0; i < cnt; ++i)
    {
      outPts[i].Pt = path[i];
      outPts[i].Next = outPts[(i + 1) % cnt];
      outPts[i].Next.Prev = outPts[i];
      outPts[i].Idx = 0;
    }
    var distSqrd = distance * distance;
    var op = outPts[0];
    while (op.Idx == 0 && op.Next != op.Prev)
    {
      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))
      {
        op = ClipperLib.Clipper.ExcludeOp(op);
        cnt--;
      }
      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))
      {
        ClipperLib.Clipper.ExcludeOp(op.Next);
        op = ClipperLib.Clipper.ExcludeOp(op);
        cnt -= 2;
      }
      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))
      {
        op = ClipperLib.Clipper.ExcludeOp(op);
        cnt--;
      }
      else
      {
        op.Idx = 1;
        op = op.Next;
      }
    }
    if (cnt < 3)
      cnt = 0;
    var result = new Array(cnt);
    for (var i = 0; i < cnt; ++i)
    {
      result[i] = new ClipperLib.IntPoint(op.Pt);
      op = op.Next;
    }
    outPts = null;
    return result;
  };
  ClipperLib.Clipper.CleanPolygons = function (polys, distance)
  {
    var result = new Array(polys.length);
    for (var i = 0, ilen = polys.length; i < ilen; i++)
      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);
    return result;
  };
  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)
  {
    var delta = (IsClosed ? 1 : 0);
    var polyCnt = pattern.length;
    var pathCnt = path.length;
    var result = new Array();
    if (IsSum)
      for (var i = 0; i < pathCnt; i++)
      {
        var p = new Array(polyCnt);
        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])
          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);
        result.push(p);
      }
    else
      for (var i = 0; i < pathCnt; i++)
      {
        var p = new Array(polyCnt);
        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])
          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);
        result.push(p);
      }
    var quads = new Array();
    for (var i = 0; i < pathCnt - 1 + delta; i++)
      for (var j = 0; j < polyCnt; j++)
      {
        var quad = new Array();
        quad.push(result[i % pathCnt][j % polyCnt]);
        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);
        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);
        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);
        if (!ClipperLib.Clipper.Orientation(quad))
          quad.reverse();
        quads.push(quad);
      }
			return quads;
  };

	ClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)
	{
		if(!(path_or_paths[0] instanceof Array))
		{
			var path = path_or_paths;
			var paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);
			var c = new ClipperLib.Clipper();
			c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);
			c.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
			return paths;
		}
		else
		{
 			var paths = path_or_paths;
			var solution = new ClipperLib.Paths();
			var c = new ClipperLib.Clipper();
			for (var i = 0; i < paths.length; ++i)
			{
				var tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);
				c.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);
				if (pathIsClosed)
				{
					var path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);
					c.AddPath(path, ClipperLib.PolyType.ptClip, true);
				}
			}
			c.Execute(ClipperLib.ClipType.ctUnion, solution,
				ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
			return solution;
		}
	}
	//------------------------------------------------------------------------------

	ClipperLib.Clipper.TranslatePath = function (path, delta)
	{
		var outPath = new ClipperLib.Path();
		for (var i = 0; i < path.length; i++)
			outPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));
		return outPath;
	}
	//------------------------------------------------------------------------------

	ClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)
	{
		var paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);
		var c = new ClipperLib.Clipper();
		c.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);
		c.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
		return paths;
	}

  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)
  {
    var result = new Array();
    //result.set_Capacity(polytree.get_Total());
    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);
    return result;
  };
  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)
  {
    var match = true;
    switch (nt)
    {
    case ClipperLib.Clipper.NodeType.ntOpen:
      return;
    case ClipperLib.Clipper.NodeType.ntClosed:
      match = !polynode.IsOpen;
      break;
    default:
      break;
    }
    if (polynode.m_polygon.length > 0 && match)
      paths.push(polynode.m_polygon);
    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])
      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);
  };
  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)
  {
    var result = new ClipperLib.Paths();
    //result.set_Capacity(polytree.ChildCount());
    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)
      if (polytree.Childs()[i].IsOpen)
        result.push(polytree.Childs()[i].m_polygon);
    return result;
  };
  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)
  {
    var result = new ClipperLib.Paths();
    //result.set_Capacity(polytree.Total());
    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);
    return result;
  };
  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);
  ClipperLib.Clipper.NodeType = {
    ntAny: 0,
    ntOpen: 1,
    ntClosed: 2
  };
  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)
  {
    if (typeof (miterLimit) == "undefined") miterLimit = 2;
    if (typeof (arcTolerance) == "undefined") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;
    this.m_destPolys = new ClipperLib.Paths();
    this.m_srcPoly = new ClipperLib.Path();
    this.m_destPoly = new ClipperLib.Path();
    this.m_normals = new Array();
    this.m_delta = 0;
    this.m_sinA = 0;
    this.m_sin = 0;
    this.m_cos = 0;
    this.m_miterLim = 0;
    this.m_StepsPerRad = 0;
    this.m_lowest = new ClipperLib.IntPoint();
    this.m_polyNodes = new ClipperLib.PolyNode();
    this.MiterLimit = miterLimit;
    this.ArcTolerance = arcTolerance;
    this.m_lowest.X = -1;
  };
  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;
  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;
  ClipperLib.ClipperOffset.prototype.Clear = function ()
  {
    ClipperLib.Clear(this.m_polyNodes.Childs());
    this.m_lowest.X = -1;
  };
  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;
  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)
  {
    var highI = path.length - 1;
    if (highI < 0)
      return;
    var newNode = new ClipperLib.PolyNode();
    newNode.m_jointype = joinType;
    newNode.m_endtype = endType;
    //strip duplicate points from path and also get index to the lowest point ...
    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)
      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))
        highI--;
    //newNode.m_polygon.set_Capacity(highI + 1);
    newNode.m_polygon.push(path[0]);
    var j = 0,
      k = 0;
    for (var i = 1; i <= highI; i++)
      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))
      {
        j++;
        newNode.m_polygon.push(path[i]);
        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))
          k = j;
      }
    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;

    this.m_polyNodes.AddChild(newNode);
    //if this path's lowest pt is lower than all the others then update m_lowest
    if (endType != ClipperLib.EndType.etClosedPolygon)
      return;
    if (this.m_lowest.X < 0)
      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);
    else
    {
      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];
      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))
        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);
    }
  };
  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)
  {
    for (var i = 0, ilen = paths.length; i < ilen; i++)
      this.AddPath(paths[i], joinType, endType);
  };
  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()
  {
    //fixup orientations of all closed paths if the orientation of the
    //closed path with the lowermost vertex is wrong ...
    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))
    {
      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
      {
        var node = this.m_polyNodes.Childs()[i];
        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))
          node.m_polygon.reverse();
      }
    }
    else
    {
      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
      {
        var node = this.m_polyNodes.Childs()[i];
        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))
          node.m_polygon.reverse();
      }
    }
  };
  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)
  {
    var dx = (pt2.X - pt1.X);
    var dy = (pt2.Y - pt1.Y);
    if ((dx == 0) && (dy == 0))
      return new ClipperLib.DoublePoint(0, 0);
    var f = 1 / Math.sqrt(dx * dx + dy * dy);
    dx *= f;
    dy *= f;
    return new ClipperLib.DoublePoint(dy, -dx);
  };
  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)
  {
    this.m_destPolys = new Array();
    this.m_delta = delta;
    //if Zero offset, just copy any CLOSED polygons to m_p and return ...
    if (ClipperLib.ClipperBase.near_zero(delta))
    {
      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);
      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
      {
        var node = this.m_polyNodes.Childs()[i];
        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)
          this.m_destPolys.push(node.m_polygon);
      }
      return;
    }
    //see offset_triginometry3.svg in the documentation folder ...
    if (this.MiterLimit > 2)
      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);
    else
      this.m_miterLim = 0.5;
    var y;
    if (this.ArcTolerance <= 0)
      y = ClipperLib.ClipperOffset.def_arc_tolerance;
    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)
      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;
    else
      y = this.ArcTolerance;
    //see offset_triginometry2.svg in the documentation folder ...
    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));
    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);
    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);
    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;
    if (delta < 0)
      this.m_sin = -this.m_sin;
    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);
    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)
    {
      var node = this.m_polyNodes.Childs()[i];
      this.m_srcPoly = node.m_polygon;
      var len = this.m_srcPoly.length;
      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))
        continue;
      this.m_destPoly = new Array();
      if (len == 1)
      {
        if (node.m_jointype == ClipperLib.JoinType.jtRound)
        {
          var X = 1,
            Y = 0;
          for (var j = 1; j <= steps; j++)
          {
            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));
            var X2 = X;
            X = X * this.m_cos - this.m_sin * Y;
            Y = X2 * this.m_sin + Y * this.m_cos;
          }
        }
        else
        {
          var X = -1,
            Y = -1;
          for (var j = 0; j < 4; ++j)
          {
            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));
            if (X < 0)
              X = 1;
            else if (Y < 0)
              Y = 1;
            else
              X = -1;
          }
        }
        this.m_destPolys.push(this.m_destPoly);
        continue;
      }
      //build m_normals ...
      this.m_normals.length = 0;
      //this.m_normals.set_Capacity(len);
      for (var j = 0; j < len - 1; j++)
        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));
      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)
        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));
      else
        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));
      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)
      {
        var k = len - 1;
        for (var j = 0; j < len; j++)
          k = this.OffsetPoint(j, k, node.m_jointype);
        this.m_destPolys.push(this.m_destPoly);
      }
      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)
      {
        var k = len - 1;
        for (var j = 0; j < len; j++)
          k = this.OffsetPoint(j, k, node.m_jointype);
        this.m_destPolys.push(this.m_destPoly);
        this.m_destPoly = new Array();
        //re-build m_normals ...
        var n = this.m_normals[len - 1];
        for (var j = len - 1; j > 0; j--)
          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);
        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);
        k = 0;
        for (var j = len - 1; j >= 0; j--)
          k = this.OffsetPoint(j, k, node.m_jointype);
        this.m_destPolys.push(this.m_destPoly);
      }
      else
      {
        var k = 0;
        for (var j = 1; j < len - 1; ++j)
          k = this.OffsetPoint(j, k, node.m_jointype);
        var pt1;
        if (node.m_endtype == ClipperLib.EndType.etOpenButt)
        {
          var j = len - 1;
          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));
          this.m_destPoly.push(pt1);
          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));
          this.m_destPoly.push(pt1);
        }
        else
        {
          var j = len - 1;
          k = len - 2;
          this.m_sinA = 0;
          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);
          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)
            this.DoSquare(j, k);
          else
            this.DoRound(j, k);
        }
        //re-build m_normals ...
        for (var j = len - 1; j > 0; j--)
          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);
        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);
        k = len - 1;
        for (var j = k - 1; j > 0; --j)
          k = this.OffsetPoint(j, k, node.m_jointype);
        if (node.m_endtype == ClipperLib.EndType.etOpenButt)
        {
          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));
          this.m_destPoly.push(pt1);
          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));
          this.m_destPoly.push(pt1);
        }
        else
        {
          k = 1;
          this.m_sinA = 0;
          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)
            this.DoSquare(0, 1);
          else
            this.DoRound(0, 1);
        }
        this.m_destPolys.push(this.m_destPoly);
      }
    }
  };
  ClipperLib.ClipperOffset.prototype.Execute = function ()
  {
    var a = arguments,
      ispolytree = a[0] instanceof ClipperLib.PolyTree;
    if (!ispolytree) // function (solution, delta)
    {
      var solution = a[0],
        delta = a[1];
      ClipperLib.Clear(solution);
      this.FixOrientations();
      this.DoOffset(delta);
      //now clean up 'corners' ...
      var clpr = new ClipperLib.Clipper(0);
      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);
      if (delta > 0)
      {
        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);
      }
      else
      {
        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);
        var outer = new ClipperLib.Path();
        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));
        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));
        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));
        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));
        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);
        clpr.ReverseSolution = true;
        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);
        if (solution.length > 0)
          solution.splice(0, 1);
      }
      //console.log(JSON.stringify(solution));
    }
    else // function (polytree, delta)
    {
      var solution = a[0],
        delta = a[1];
      solution.Clear();
      this.FixOrientations();
      this.DoOffset(delta);
      //now clean up 'corners' ...
      var clpr = new ClipperLib.Clipper(0);
      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);
      if (delta > 0)
      {
        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);
      }
      else
      {
        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);
        var outer = new ClipperLib.Path();
        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));
        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));
        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));
        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));
        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);
        clpr.ReverseSolution = true;
        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);
        //remove the outer PolyNode rectangle ...
        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)
        {
          var outerNode = solution.Childs()[0];
          //solution.Childs.set_Capacity(outerNode.ChildCount);
          solution.Childs()[0] = outerNode.Childs()[0];
          solution.Childs()[0].m_Parent = solution;
          for (var i = 1; i < outerNode.ChildCount(); i++)
            solution.AddChild(outerNode.Childs()[i]);
        }
        else
          solution.Clear();
      }
    }
  };
  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)
  {
		//cross product ...
		this.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);

		if (Math.abs(this.m_sinA * this.m_delta) < 1.0)
		{
			//dot product ...
			var cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);
			if (cosA > 0) // angle ==> 0 degrees
			{
				this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),
					ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));
				return k;
			}
			//else angle ==> 180 degrees
		}
    else if (this.m_sinA > 1)
      this.m_sinA = 1.0;
    else if (this.m_sinA < -1)
      this.m_sinA = -1.0;
    if (this.m_sinA * this.m_delta < 0)
    {
      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),
        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));
      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));
      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),
        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));
    }
    else
      switch (jointype)
      {
      case ClipperLib.JoinType.jtMiter:
        {
          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);
          if (r >= this.m_miterLim)
            this.DoMiter(j, k, r);
          else
            this.DoSquare(j, k);
          break;
        }
      case ClipperLib.JoinType.jtSquare:
        this.DoSquare(j, k);
        break;
      case ClipperLib.JoinType.jtRound:
        this.DoRound(j, k);
        break;
      }
    k = j;
    return k;
  };
  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)
  {
    var dx = Math.tan(Math.atan2(this.m_sinA,
      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);
    this.m_destPoly.push(new ClipperLib.IntPoint(
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));
    this.m_destPoly.push(new ClipperLib.IntPoint(
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));
  };
  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)
  {
    var q = this.m_delta / r;
    this.m_destPoly.push(new ClipperLib.IntPoint(
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));
  };
  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)
  {
    var a = Math.atan2(this.m_sinA,
      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);

    	var steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);

    var X = this.m_normals[k].X,
      Y = this.m_normals[k].Y,
      X2;
    for (var i = 0; i < steps; ++i)
    {
      this.m_destPoly.push(new ClipperLib.IntPoint(
        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),
        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));
      X2 = X;
      X = X * this.m_cos - this.m_sin * Y;
      Y = X2 * this.m_sin + Y * this.m_cos;
    }
    this.m_destPoly.push(new ClipperLib.IntPoint(
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),
      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));
  };
  ClipperLib.Error = function (message)
  {
    try
    {
      throw new Error(message);
    }
    catch (err)
    {
      alert(err.message);
    }
  };
  // ---------------------------------
  // JS extension by Timo 2013
  ClipperLib.JS = {};
  ClipperLib.JS.AreaOfPolygon = function (poly, scale)
  {
    if (!scale) scale = 1;
    return ClipperLib.Clipper.Area(poly) / (scale * scale);
  };
  ClipperLib.JS.AreaOfPolygons = function (poly, scale)
  {
    if (!scale) scale = 1;
    var area = 0;
    for (var i = 0; i < poly.length; i++)
    {
      area += ClipperLib.Clipper.Area(poly[i]);
    }
    return area / (scale * scale);
  };
  ClipperLib.JS.BoundsOfPath = function (path, scale)
  {
    return ClipperLib.JS.BoundsOfPaths([path], scale);
  };
  ClipperLib.JS.BoundsOfPaths = function (paths, scale)
  {
    if (!scale) scale = 1;
    var bounds = ClipperLib.Clipper.GetBounds(paths);
    bounds.left /= scale;
    bounds.bottom /= scale;
    bounds.right /= scale;
    bounds.top /= scale;
    return bounds;
  };
  // Clean() joins vertices that are too near each other
  // and causes distortion to offsetted polygons without cleaning
  ClipperLib.JS.Clean = function (polygon, delta)
  {
    if (!(polygon instanceof Array)) return [];
    var isPolygons = polygon[0] instanceof Array;
    var polygon = ClipperLib.JS.Clone(polygon);
    if (typeof delta != "number" || delta === null)
    {
      ClipperLib.Error("Delta is not a number in Clean().");
      return polygon;
    }
    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;
    if (!isPolygons) polygon = [polygon];
    var k_length = polygon.length;
    var len, poly, result, d, p, j, i;
    var results = [];
    for (var k = 0; k < k_length; k++)
    {
      poly = polygon[k];
      len = poly.length;
      if (len === 0) continue;
      else if (len < 3)
      {
        result = poly;
        results.push(result);
        continue;
      }
      result = poly;
      d = delta * delta;
      //d = Math.floor(c_delta * c_delta);
      p = poly[0];
      j = 1;
      for (i = 1; i < len; i++)
      {
        if ((poly[i].X - p.X) * (poly[i].X - p.X) +
          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)
          continue;
        result[j] = poly[i];
        p = poly[i];
        j++;
      }
      p = poly[j - 1];
      if ((poly[0].X - p.X) * (poly[0].X - p.X) +
        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)
        j--;
      if (j < len)
        result.splice(j, len - j);
      if (result.length) results.push(result);
    }
    if (!isPolygons && results.length) results = results[0];
    else if (!isPolygons && results.length === 0) results = [];
    else if (isPolygons && results.length === 0) results = [
      []
    ];
    return results;
  }
  // Make deep copy of Polygons or Polygon
  // so that also IntPoint objects are cloned and not only referenced
  // This should be the fastest way
  ClipperLib.JS.Clone = function (polygon)
  {
    if (!(polygon instanceof Array)) return [];
    if (polygon.length === 0) return [];
    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];
    var isPolygons = polygon[0] instanceof Array;
    if (!isPolygons) polygon = [polygon];
    var len = polygon.length,
      plen, i, j, result;
    var results = new Array(len);
    for (i = 0; i < len; i++)
    {
      plen = polygon[i].length;
      result = new Array(plen);
      for (j = 0; j < plen; j++)
      {
        result[j] = {
          X: polygon[i][j].X,
          Y: polygon[i][j].Y
        };
      }
      results[i] = result;
    }
    if (!isPolygons) results = results[0];
    return results;
  };
  // Removes points that doesn't affect much to the visual appearance.
  // If middle point is at or under certain distance (tolerance) of the line segment between
  // start and end point, the middle point is removed.
  ClipperLib.JS.Lighten = function (polygon, tolerance)
  {
    if (!(polygon instanceof Array)) return [];
    if (typeof tolerance != "number" || tolerance === null)
    {
      ClipperLib.Error("Tolerance is not a number in Lighten().")
      return ClipperLib.JS.Clone(polygon);
    }
    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)
    {
      return ClipperLib.JS.Clone(polygon);
    }
    if (!(polygon[0] instanceof Array)) polygon = [polygon];
    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;
    var bxax, byay, l, ax, ay;
    var len = polygon.length;
    var toleranceSq = tolerance * tolerance;
    var results = [];
    for (i = 0; i < len; i++)
    {
      poly = polygon[i];
      plen = poly.length;
      if (plen == 0) continue;
      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count
      {
        poly2 = [];
        plen = poly.length;
        // the first have to added to the end, if first and last are not the same
        // this way we ensure that also the actual last point can be removed if needed
        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)
        {
          addlast = 1;
          poly.push(
          {
            X: poly[0].X,
            Y: poly[0].Y
          });
          plen = poly.length;
        }
        else addlast = 0;
        rem = []; // Indexes of removed points
        for (j = 0; j < plen - 2; j++)
        {
          A = poly[j]; // Start point of line segment
          P = poly[j + 1]; // Middle point. This is the one to be removed.
          B = poly[j + 2]; // End point of line segment
          ax = A.X;
          ay = A.Y;
          bxax = B.X - ax;
          byay = B.Y - ay;
          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.
          {
            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);
            if (l > 1)
            {
              ax = B.X;
              ay = B.Y;
            }
            else if (l > 0)
            {
              ax += bxax * l;
              ay += byay * l;
            }
          }
          bxax = P.X - ax;
          byay = P.Y - ay;
          d = bxax * bxax + byay * byay;
          if (d <= toleranceSq)
          {
            rem[j + 1] = 1;
            j++; // when removed, transfer the pointer to the next one
          }
        }
        // add all unremoved points to poly2
        poly2.push(
        {
          X: poly[0].X,
          Y: poly[0].Y
        });
        for (j = 1; j < plen - 1; j++)
          if (!rem[j]) poly2.push(
          {
            X: poly[j].X,
            Y: poly[j].Y
          });
        poly2.push(
        {
          X: poly[plen - 1].X,
          Y: poly[plen - 1].Y
        });
        // if the first point was added to the end, remove it
        if (addlast) poly.pop();
        // break, if there was not anymore removed points
        if (!rem.length) break;
        // else continue looping using poly2, to check if there are points to remove
        else poly = poly2;
      }
      plen = poly2.length;
      // remove duplicate from end, if needed
      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)
      {
        poly2.pop();
      }
      if (poly2.length > 2) // to avoid two-point-polygons
        results.push(poly2);
    }
    if (!(polygon[0] instanceof Array)) results = results[0];
    if (typeof (results) == "undefined") results = [
      []
    ];
    return results;
  }
  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)
  {
    if (typeof (path) == "undefined") return 0;
    var sqrt = Math.sqrt;
    var perimeter = 0.0;
    var p1, p2, p1x = 0.0,
      p1y = 0.0,
      p2x = 0.0,
      p2y = 0.0;
    var j = path.length;
    if (j < 2) return 0;
    if (closed)
    {
      path[j] = path[0];
      j++;
    }
    while (--j)
    {
      p1 = path[j];
      p1x = p1.X;
      p1y = p1.Y;
      p2 = path[j - 1];
      p2x = p2.X;
      p2y = p2.Y;
      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));
    }
    if (closed) path.pop();
    return perimeter / scale;
  };
  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)
  {
    if (!scale) scale = 1;
    var perimeter = 0;
    for (var i = 0; i < paths.length; i++)
    {
      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);
    }
    return perimeter;
  };
  ClipperLib.JS.ScaleDownPath = function (path, scale)
  {
    var i, p;
    if (!scale) scale = 1;
    i = path.length;
    while (i--)
    {
      p = path[i];
      p.X = p.X / scale;
      p.Y = p.Y / scale;
    }
  };
  ClipperLib.JS.ScaleDownPaths = function (paths, scale)
  {
    var i, j, p;
    if (!scale) scale = 1;
    i = paths.length;
    while (i--)
    {
      j = paths[i].length;
      while (j--)
      {
        p = paths[i][j];
        p.X = p.X / scale;
        p.Y = p.Y / scale;
      }
    }
  };
  ClipperLib.JS.ScaleUpPath = function (path, scale)
  {
    var i, p, round = Math.round;
    if (!scale) scale = 1;
    i = path.length;
    while (i--)
    {
      p = path[i];
      p.X = round(p.X * scale);
      p.Y = round(p.Y * scale);
    }
  };
  ClipperLib.JS.ScaleUpPaths = function (paths, scale)
  {
    var i, j, p, round = Math.round;
    if (!scale) scale = 1;
    i = paths.length;
    while (i--)
    {
      j = paths[i].length;
      while (j--)
      {
        p = paths[i][j];
        p.X = round(p.X * scale);
        p.Y = round(p.Y * scale);
      }
    }
  };
  ClipperLib.ExPolygons = function ()
  {
    return [];
  }
  ClipperLib.ExPolygon = function ()
  {
    this.outer = null;
    this.holes = null;
  };
  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)
  {
    var ep = new ClipperLib.ExPolygon();
    ep.outer = polynode.Contour();
    var childs = polynode.Childs();
    var ilen = childs.length;
    ep.holes = new Array(ilen);
    var node, n, i, j, childs2, jlen;
    for (i = 0; i < ilen; i++)
    {
      node = childs[i];
      ep.holes[i] = node.Contour();
      //Add outer polygons contained by (nested within) holes ...
      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)
      {
        n = childs2[j];
        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);
      }
    }
    expolygons.push(ep);
  };
  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)
  {
    var a, i, alen, ilen;
    var paths = new ClipperLib.Paths();
    for (a = 0, alen = expolygons.length; a < alen; a++)
    {
      paths.push(expolygons[a].outer);
      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)
      {
        paths.push(expolygons[a].holes[i]);
      }
    }
    return paths;
  }
  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)
  {
    var expolygons = new ClipperLib.ExPolygons();
    var node, i, childs, ilen;
    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)
    {
      node = childs[i];
      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);
    }
    return expolygons;
  };
})();


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["fromMat4"] = fromMat4;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromMat2d"] = fromMat2d;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["normalFromMat4"] = normalFromMat4;
/* harmony export (immutable) */ __webpack_exports__["projection"] = projection;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_js__ = __webpack_require__(0);


/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](9);
  if (__WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];

  out[0] = a00;
  out[1] = a01;
  out[2] = a02;

  out[3] = a10;
  out[4] = a11;
  out[5] = a12;

  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);

  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;

  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;

  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function scale(out, a, v) {
  var x = v[0],
      y = v[1];

  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];

  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];

  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);

  out[0] = c;
  out[1] = s;
  out[2] = 0;

  out[3] = -s;
  out[4] = c;
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;

  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;

  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;

  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
var sub = subtract;

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromXRotation"] = fromXRotation;
/* harmony export (immutable) */ __webpack_exports__["fromYRotation"] = fromYRotation;
/* harmony export (immutable) */ __webpack_exports__["fromZRotation"] = fromZRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslation"] = fromRotationTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromQuat2"] = fromQuat2;
/* harmony export (immutable) */ __webpack_exports__["getTranslation"] = getTranslation;
/* harmony export (immutable) */ __webpack_exports__["getScaling"] = getScaling;
/* harmony export (immutable) */ __webpack_exports__["getRotation"] = getRotation;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScale"] = fromRotationTranslationScale;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationScaleOrigin"] = fromRotationTranslationScaleOrigin;
/* harmony export (immutable) */ __webpack_exports__["fromQuat"] = fromQuat;
/* harmony export (immutable) */ __webpack_exports__["frustum"] = frustum;
/* harmony export (immutable) */ __webpack_exports__["perspective"] = perspective;
/* harmony export (immutable) */ __webpack_exports__["perspectiveFromFieldOfView"] = perspectiveFromFieldOfView;
/* harmony export (immutable) */ __webpack_exports__["ortho"] = ortho;
/* harmony export (immutable) */ __webpack_exports__["lookAt"] = lookAt;
/* harmony export (immutable) */ __webpack_exports__["targetTo"] = targetTo;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_js__ = __webpack_require__(0);


/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](16);
  if (__WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];

    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
}

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  // Cache only the current line of the second matrix
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b[4];b1 = b[5];b2 = b[6];b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b[8];b1 = b[9];b2 = b[10];b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b[12];b1 = b[13];b2 = b[14];b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00 = void 0,
      a01 = void 0,
      a02 = void 0,
      a03 = void 0;
  var a10 = void 0,
      a11 = void 0,
      a12 = void 0,
      a13 = void 0;
  var a20 = void 0,
      a21 = void 0,
      a22 = void 0,
      a23 = void 0;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
    a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
    a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];

    out[0] = a00;out[1] = a01;out[2] = a02;out[3] = a03;
    out[4] = a10;out[5] = a11;out[6] = a12;out[7] = a13;
    out[8] = a20;out[9] = a21;out[10] = a22;out[11] = a23;

    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];

  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s = void 0,
      c = void 0,
      t = void 0;
  var a00 = void 0,
      a01 = void 0,
      a02 = void 0,
      a03 = void 0;
  var a10 = void 0,
      a11 = void 0,
      a12 = void 0,
      a13 = void 0;
  var a20 = void 0,
      a21 = void 0,
      a22 = void 0,
      a23 = void 0;
  var b00 = void 0,
      b01 = void 0,
      b02 = void 0;
  var b10 = void 0,
      b11 = void 0,
      b12 = void 0;
  var b20 = void 0,
      b21 = void 0,
      b22 = void 0;

  if (len < __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
  a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
  a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];

  // Construct the elements of the rotation matrix
  b00 = x * x * t + c;b01 = y * x * t + z * s;b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;b11 = y * y * t + c;b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;b21 = y * z * t - x * s;b22 = z * z * t + c;

  // Perform rotation-specific matrix multiplication
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s = void 0,
      c = void 0,
      t = void 0;

  if (len < __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */
function fromQuat2(out, a) {
  var translation = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];

  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  //Only scale if it makes sense
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
}

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];

  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
}

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  var sx = s[0];
  var sy = s[1];
  var sz = s[2];

  var ox = o[0];
  var oy = o[1];
  var oz = o[2];

  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;

  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;

  return out;
}

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;

  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;

  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;

  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;

  return out;
}

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf = void 0;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);

  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
  var x0 = void 0,
      x1 = void 0,
      x2 = void 0,
      y0 = void 0,
      y1 = void 0,
      y2 = void 0,
      z0 = void 0,
      z1 = void 0,
      z2 = void 0,
      len = void 0;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] && Math.abs(eyey - centery) < __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] && Math.abs(eyez - centerz) < __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"]) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;

  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;

  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;

  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;

  return out;
}

/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];

  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];

  var len = z0 * z0 + z1 * z1 + z2 * z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;

  len = x0 * x0 + x1 * x1 + x2 * x2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
}

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];

  return Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
var sub = subtract;

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["setAxisAngle"] = setAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["getAxisAngle"] = getAxisAngle;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["calculateW"] = calculateW;
/* harmony export (immutable) */ __webpack_exports__["slerp"] = slerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["conjugate"] = conjugate;
/* harmony export (immutable) */ __webpack_exports__["fromMat3"] = fromMat3;
/* harmony export (immutable) */ __webpack_exports__["fromEuler"] = fromEuler;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationTo", function() { return rotationTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqlerp", function() { return sqlerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxes", function() { return setAxes; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mat3_js__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__vec3_js__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__vec4_js__ = __webpack_require__(41);





/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](4);
  if (__WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);
  if (s > __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"]) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];

  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateX(out, a, rad) {
  rad *= 0.5;

  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);

  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateY(out, a, rad) {
  rad *= 0.5;

  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);

  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateZ(out, a, rad) {
  rad *= 0.5;

  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);

  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];

  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */
function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];

  var omega = void 0,
      cosom = void 0,
      sinom = void 0,
      scale0 = void 0,
      scale1 = void 0;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  // calculate coefficients
  if (1.0 - cosom > __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"]) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;

  return out;
}

/**
 * Generates a random quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = __WEBPACK_IMPORTED_MODULE_0__common_js__["RANDOM"]();
  var u2 = __WEBPACK_IMPORTED_MODULE_0__common_js__["RANDOM"]();
  var u3 = __WEBPACK_IMPORTED_MODULE_0__common_js__["RANDOM"]();

  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);

  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0;

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot = void 0;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;

    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}

/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;

  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);

  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;

  return out;
}

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
var clone = __WEBPACK_IMPORTED_MODULE_3__vec4_js__["clone"];

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
var fromValues = __WEBPACK_IMPORTED_MODULE_3__vec4_js__["fromValues"];

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
var copy = __WEBPACK_IMPORTED_MODULE_3__vec4_js__["copy"];

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
var set = __WEBPACK_IMPORTED_MODULE_3__vec4_js__["set"];

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
var add = __WEBPACK_IMPORTED_MODULE_3__vec4_js__["add"];

/**
 * Alias for {@link quat.multiply}
 * @function
 */
var mul = multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
var scale = __WEBPACK_IMPORTED_MODULE_3__vec4_js__["scale"];

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
var dot = __WEBPACK_IMPORTED_MODULE_3__vec4_js__["dot"];

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */
var lerp = __WEBPACK_IMPORTED_MODULE_3__vec4_js__["lerp"];

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */
var length = __WEBPACK_IMPORTED_MODULE_3__vec4_js__["length"];

/**
 * Alias for {@link quat.length}
 * @function
 */
var len = length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
var squaredLength = __WEBPACK_IMPORTED_MODULE_3__vec4_js__["squaredLength"];

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
var sqrLen = squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
var normalize = __WEBPACK_IMPORTED_MODULE_3__vec4_js__["normalize"];

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
var exactEquals = __WEBPACK_IMPORTED_MODULE_3__vec4_js__["exactEquals"];

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
var equals = __WEBPACK_IMPORTED_MODULE_3__vec4_js__["equals"];

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
var rotationTo = function () {
  var tmpvec3 = __WEBPACK_IMPORTED_MODULE_2__vec3_js__["create"]();
  var xUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3_js__["fromValues"](1, 0, 0);
  var yUnitVec3 = __WEBPACK_IMPORTED_MODULE_2__vec3_js__["fromValues"](0, 1, 0);

  return function (out, a, b) {
    var dot = __WEBPACK_IMPORTED_MODULE_2__vec3_js__["dot"](a, b);
    if (dot < -0.999999) {
      __WEBPACK_IMPORTED_MODULE_2__vec3_js__["cross"](tmpvec3, xUnitVec3, a);
      if (__WEBPACK_IMPORTED_MODULE_2__vec3_js__["len"](tmpvec3) < 0.000001) __WEBPACK_IMPORTED_MODULE_2__vec3_js__["cross"](tmpvec3, yUnitVec3, a);
      __WEBPACK_IMPORTED_MODULE_2__vec3_js__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      __WEBPACK_IMPORTED_MODULE_2__vec3_js__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */
var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();

  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
}();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
var setAxes = function () {
  var matr = __WEBPACK_IMPORTED_MODULE_1__mat3_js__["create"]();

  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];

    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];

    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];

    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["hermite"] = hermite;
/* harmony export (immutable) */ __webpack_exports__["bezier"] = bezier;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["angle"] = angle;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_js__ = __webpack_require__(0);


/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](3);
  if (__WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  var r = __WEBPACK_IMPORTED_MODULE_0__common_js__["RANDOM"]() * 2.0 * Math.PI;
  var z = __WEBPACK_IMPORTED_MODULE_0__common_js__["RANDOM"]() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;

  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2];
  // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);
  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x;
  // var uuv = vec3.cross([], qvec, uv);
  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx;
  // vec3.scale(uv, uv, 2 * w);
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  // vec3.scale(uuv, uuv, 2);
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  // return vec3.add(out, a, vec3.add(out, uv, uuv));
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);

  normalize(tempA, tempA);
  normalize(tempB, tempB);

  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
var sub = subtract;

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link vec3.divide}
 * @function
 */
var div = divide;

/**
 * Alias for {@link vec3.distance}
 * @function
 */
var dist = distance;

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
var sqrDist = squaredDistance;

/**
 * Alias for {@link vec3.length}
 * @function
 */
var len = length;

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
var sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = function () {
  var vec = create();

  return function (a, stride, offset, count, fn, arg) {
    var i = void 0,
        l = void 0;
    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["transformQuat"] = transformQuat;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_js__ = __webpack_require__(0);


/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](4);
  if (__WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
function clone(a) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function fromValues(x, y, z, w) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;
  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = __WEBPACK_IMPORTED_MODULE_0__common_js__["RANDOM"]() * 2 - 1;
    v2 = __WEBPACK_IMPORTED_MODULE_0__common_js__["RANDOM"]() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = __WEBPACK_IMPORTED_MODULE_0__common_js__["RANDOM"]() * 2 - 1;
    v4 = __WEBPACK_IMPORTED_MODULE_0__common_js__["RANDOM"]() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];

  // calculate quat * vec
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
var sub = subtract;

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link vec4.divide}
 * @function
 */
var div = divide;

/**
 * Alias for {@link vec4.distance}
 * @function
 */
var dist = distance;

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
var sqrDist = squaredDistance;

/**
 * Alias for {@link vec4.length}
 * @function
 */
var len = length;

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
var sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = function () {
  var vec = create();

  return function (a, stride, offset, count, fn, arg) {
    var i = void 0,
        l = void 0;
    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_LOCAL_MODULE_0__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/
(function() {
var fix = module.exports=0;

// Snap.svg 0.5.0
//
// Copyright (c) 2013 – 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// build: 2017-02-06

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ┌────────────────────────────────────────────────────────────┐ \\
// │ Eve 0.5.0 - JavaScript Events Library                      │ \\
// ├────────────────────────────────────────────────────────────┤ \\
// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\
// └────────────────────────────────────────────────────────────┘ \\

(function (glob) {
    var version = "0.5.0",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        comaseparator = /\s*,\s*/,
        wildcard = "*",
        fun = function () {},
        numsort = function (a, b) {
            return a - b;
        },
        current_event,
        stop,
        events = {n: {}},
        firstDefined = function () {
            for (var i = 0, ii = this.length; i < ii; i++) {
                if (typeof this[i] != "undefined") {
                    return this[i];
                }
            }
        },
        lastDefined = function () {
            var i = this.length;
            while (--i) {
                if (typeof this[i] != "undefined") {
                    return this[i];
                }
            }
        },
        objtos = Object.prototype.toString,
        Str = String,
        isArray = Array.isArray || function (ar) {
            return ar instanceof Array || objtos.call(ar) == "[object Array]";
        };
    /*\
     * eve
     [ method ]

     * Fires event with given `name`, given scope and other parameters.

     > Arguments

     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers

     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
    \*/
        eve = function (name, scope) {
            var e = events,
                oldstop = stop,
                args = Array.prototype.slice.call(arguments, 2),
                listeners = eve.listeners(name),
                z = 0,
                f = false,
                l,
                indexed = [],
                queue = {},
                out = [],
                ce = current_event,
                errors = [];
            out.firstDefined = firstDefined;
            out.lastDefined = lastDefined;
            current_event = name;
            stop = 0;
            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
            indexed.sort(numsort);
            while (indexed[z] < 0) {
                l = queue[indexed[z++]];
                out.push(l.apply(scope, args));
                if (stop) {
                    stop = oldstop;
                    return out;
                }
            }
            for (i = 0; i < ii; i++) {
                l = listeners[i];
                if ("zIndex" in l) {
                    if (l.zIndex == indexed[z]) {
                        out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                        do {
                            z++;
                            l = queue[indexed[z]];
                            l && out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        } while (l)
                    } else {
                        queue[l.zIndex] = l;
                    }
                } else {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                }
            }
            stop = oldstop;
            current_event = ce;
            return out;
        };
        // Undocumented. Debug only.
        eve._events = events;
    /*\
     * eve.listeners
     [ method ]

     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

     > Arguments

     - name (string) name of the event, dot (`.`) or slash (`/`) separated

     = (array) array of event handlers
    \*/
    eve.listeners = function (name) {
        var names = isArray(name) ? name : name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };
    /*\
     * eve.separator
     [ method ]

     * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours
     * here. Be aware that if you pass a string longer than one character it will be treated as
     * a list of characters.

     - separator (string) new separator. Empty string resets to default: `.` or `/`.
    \*/
    eve.separator = function (sep) {
        if (sep) {
            sep = Str(sep).replace(/(?=[\.\^\]\[\-])/g, "\\");
            sep = "[" + sep + "]";
            separator = new RegExp(sep);
        } else {
            separator = /[\.\/]/;
        }
    };
    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     - name (array) if you don’t want to use separators, you can use array of strings
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. 
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt` function will be called before `eatIt`.
     *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
    \*/
    eve.on = function (name, f) {
        if (typeof f != "function") {
            return function () {};
        }
        var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);
        for (var i = 0, ii = names.length; i < ii; i++) {
            (function (name) {
                var names = isArray(name) ? name : Str(name).split(separator),
                    e = events,
                    exist;
                for (var i = 0, ii = names.length; i < ii; i++) {
                    e = e.n;
                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
                }
                e.f = e.f || [];
                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
                    exist = true;
                    break;
                }
                !exist && e.f.push(f);
            }(names[i]));
        }
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
     * Arguments that will be passed to the result function will be also
     * concated to the list of final arguments.
     | el.onclick = eve.f("click", 1, 2);
     | eve.on("click", function (a, b, c) {
     |     console.log(a, b, c); // 1, 2, [event object]
     | });
     > Arguments
     - event (string) event name
     - varargs (…) and any other arguments
     = (function) possible event handler function
    \*/
    eve.f = function (event) {
        var attrs = [].slice.call(arguments, 1);
        return function () {
            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
        };
    };
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     > Arguments
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current event’s name contains `subname`
    \*/
    eve.nt = function (subname) {
        var cur = isArray(current_event) ? current_event.join(".") : current_event;
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(cur);
        }
        return cur;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/
    eve.nts = function () {
        return isArray(current_event) ? current_event : current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
     * If no arguments specified all the events will be cleared.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/
    eve.off = eve.unbind = function (name, f) {
        if (!name) {
            eve._events = events = {n: {}};
            return;
        }
        var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);
        if (names.length > 1) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                eve.off(names[i], f);
            }
            return;
        }
        names = isArray(name) ? name : Str(name).split(separator);
        var e,
            key,
            splice,
            i, ii, j, jj,
            cur = [events],
            inodes = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                        inodes.unshift({
                            n: e,
                            name: names[i]
                        });
                    }
                } else {
                    for (key in e) if (e[has](key)) {
                        splice.push(e[key]);
                        inodes.unshift({
                            n: e,
                            name: key
                        });
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        delete e.n[key].f;
                    }
                }
                e = e.n;
            }
        }
        // prune inner nodes in path
        prune: for (i = 0, ii = inodes.length; i < ii; i++) {
            e = inodes[i];
            for (key in e.n[e.name].f) {
                // not empty (has listeners)
                continue prune;
            }
            for (key in e.n[e.name].n) {
                // not empty (has children)
                continue prune;
            }
            // is empty
            delete e.n[e.name];
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/
    eve.once = function (name, f) {
        var f2 = function () {
            eve.off(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };
    (typeof module != "undefined" && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_LOCAL_MODULE_0__ = (function() { return eve; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)))) : (glob.eve = eve));
})(this);

(function (glob, factory) {
    // AMD support
    if (true) {
        // Define as an anonymous module
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__WEBPACK_LOCAL_MODULE_0__], __WEBPACK_AMD_DEFINE_RESULT__ = function (eve) {
            return factory(glob, eve);
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports != "undefined") {
        // Next for Node.js or CommonJS
        var eve = require("eve");
        module.exports = factory(glob, eve);
    } else {
        // Browser globals (glob is window)
        // Snap adds itself to window
        factory(glob, glob.eve);
    }
}(window || this, function (window, eve) {

// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var mina = (function (eve) {
    var animations = {},
    requestAnimFrame = window.requestAnimationFrame       ||
                       window.webkitRequestAnimationFrame ||
                       window.mozRequestAnimationFrame    ||
                       window.oRequestAnimationFrame      ||
                       window.msRequestAnimationFrame     ||
                       function (callback) {
                           setTimeout(callback, 16, new Date().getTime());
                           return true;
                       },
    requestID,
    isArray = Array.isArray || function (a) {
        return a instanceof Array ||
            Object.prototype.toString.call(a) == "[object Array]";
    },
    idgen = 0,
    idprefix = "M" + (+new Date).toString(36),
    ID = function () {
        return idprefix + (idgen++).toString(36);
    },
    diff = function (a, b, A, B) {
        if (isArray(a)) {
            res = [];
            for (var i = 0, ii = a.length; i < ii; i++) {
                res[i] = diff(a[i], b, A[i], B);
            }
            return res;
        }
        var dif = (A - a) / (B - b);
        return function (bb) {
            return a + dif * (bb - b);
        };
    },
    timer = Date.now || function () {
        return +new Date;
    },
    sta = function (val) {
        var a = this;
        if (val == null) {
            return a.s;
        }
        var ds = a.s - val;
        a.b += a.dur * ds;
        a.B += a.dur * ds;
        a.s = val;
    },
    speed = function (val) {
        var a = this;
        if (val == null) {
            return a.spd;
        }
        a.spd = val;
    },
    duration = function (val) {
        var a = this;
        if (val == null) {
            return a.dur;
        }
        a.s = a.s * val / a.dur;
        a.dur = val;
    },
    stopit = function () {
        var a = this;
        delete animations[a.id];
        a.update();
        eve("mina.stop." + a.id, a);
    },
    pause = function () {
        var a = this;
        if (a.pdif) {
            return;
        }
        delete animations[a.id];
        a.update();
        a.pdif = a.get() - a.b;
    },
    resume = function () {
        var a = this;
        if (!a.pdif) {
            return;
        }
        a.b = a.get() - a.pdif;
        delete a.pdif;
        animations[a.id] = a;
        frame();
    },
    update = function () {
        var a = this,
            res;
        if (isArray(a.start)) {
            res = [];
            for (var j = 0, jj = a.start.length; j < jj; j++) {
                res[j] = +a.start[j] +
                    (a.end[j] - a.start[j]) * a.easing(a.s);
            }
        } else {
            res = +a.start + (a.end - a.start) * a.easing(a.s);
        }
        a.set(res);
    },
    frame = function (timeStamp) {
        // Manual invokation?
        if (!timeStamp) {
            // Frame loop stopped?
            if (!requestID) {
                // Start frame loop...
                requestID = requestAnimFrame(frame);
            }
            return;
        }
        var len = 0;
        for (var i in animations) if (animations.hasOwnProperty(i)) {
            var a = animations[i],
                b = a.get(),
                res;
            len++;
            a.s = (b - a.b) / (a.dur / a.spd);
            if (a.s >= 1) {
                delete animations[i];
                a.s = 1;
                len--;
                (function (a) {
                    setTimeout(function () {
                        eve("mina.finish." + a.id, a);
                    });
                }(a));
            }
            a.update();
        }
        requestID = len ? requestAnimFrame(frame) : false;
    },
    /*\
     * mina
     [ method ]
     **
     * Generic animation of numbers
     **
     - a (number) start _slave_ number
     - A (number) end _slave_ number
     - b (number) start _master_ number (start time in general case)
     - B (number) end _master_ number (end time in general case)
     - get (function) getter of _master_ number (see @mina.time)
     - set (function) setter of _slave_ number
     - easing (function) #optional easing function, default is @mina.linear
     = (object) animation descriptor
     o {
     o         id (string) animation id,
     o         start (number) start _slave_ number,
     o         end (number) end _slave_ number,
     o         b (number) start _master_ number,
     o         s (number) animation status (0..1),
     o         dur (number) animation duration,
     o         spd (number) animation speed,
     o         get (function) getter of _master_ number (see @mina.time),
     o         set (function) setter of _slave_ number,
     o         easing (function) easing function, default is @mina.linear,
     o         status (function) status getter/setter,
     o         speed (function) speed getter/setter,
     o         duration (function) duration getter/setter,
     o         stop (function) animation stopper
     o         pause (function) pauses the animation
     o         resume (function) resumes the animation
     o         update (function) calles setter with the right value of the animation
     o }
    \*/
    mina = function (a, A, b, B, get, set, easing) {
        var anim = {
            id: ID(),
            start: a,
            end: A,
            b: b,
            s: 0,
            dur: B - b,
            spd: 1,
            get: get,
            set: set,
            easing: easing || mina.linear,
            status: sta,
            speed: speed,
            duration: duration,
            stop: stopit,
            pause: pause,
            resume: resume,
            update: update
        };
        animations[anim.id] = anim;
        var len = 0, i;
        for (i in animations) if (animations.hasOwnProperty(i)) {
            len++;
            if (len == 2) {
                break;
            }
        }
        len == 1 && frame();
        return anim;
    };
    /*\
     * mina.time
     [ method ]
     **
     * Returns the current time. Equivalent to:
     | function () {
     |     return (new Date).getTime();
     | }
    \*/
    mina.time = timer;
    /*\
     * mina.getById
     [ method ]
     **
     * Returns an animation by its id
     - id (string) animation's id
     = (object) See @mina
    \*/
    mina.getById = function (id) {
        return animations[id] || null;
    };

    /*\
     * mina.linear
     [ method ]
     **
     * Default linear easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.linear = function (n) {
        return n;
    };
    /*\
     * mina.easeout
     [ method ]
     **
     * Easeout easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.easeout = function (n) {
        return Math.pow(n, 1.7);
    };
    /*\
     * mina.easein
     [ method ]
     **
     * Easein easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.easein = function (n) {
        return Math.pow(n, .48);
    };
    /*\
     * mina.easeinout
     [ method ]
     **
     * Easeinout easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.easeinout = function (n) {
        if (n == 1) {
            return 1;
        }
        if (n == 0) {
            return 0;
        }
        var q = .48 - n / 1.04,
            Q = Math.sqrt(.1734 + q * q),
            x = Q - q,
            X = Math.pow(Math.abs(x), 1 / 3) * (x < 0 ? -1 : 1),
            y = -Q - q,
            Y = Math.pow(Math.abs(y), 1 / 3) * (y < 0 ? -1 : 1),
            t = X + Y + .5;
        return (1 - t) * 3 * t * t + t * t * t;
    };
    /*\
     * mina.backin
     [ method ]
     **
     * Backin easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.backin = function (n) {
        if (n == 1) {
            return 1;
        }
        var s = 1.70158;
        return n * n * ((s + 1) * n - s);
    };
    /*\
     * mina.backout
     [ method ]
     **
     * Backout easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.backout = function (n) {
        if (n == 0) {
            return 0;
        }
        n = n - 1;
        var s = 1.70158;
        return n * n * ((s + 1) * n + s) + 1;
    };
    /*\
     * mina.elastic
     [ method ]
     **
     * Elastic easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.elastic = function (n) {
        if (n == !!n) {
            return n;
        }
        return Math.pow(2, -10 * n) * Math.sin((n - .075) *
            (2 * Math.PI) / .3) + 1;
    };
    /*\
     * mina.bounce
     [ method ]
     **
     * Bounce easing
     - n (number) input 0..1
     = (number) output 0..1
    \*/
    mina.bounce = function (n) {
        var s = 7.5625,
            p = 2.75,
            l;
        if (n < 1 / p) {
            l = s * n * n;
        } else {
            if (n < 2 / p) {
                n -= 1.5 / p;
                l = s * n * n + .75;
            } else {
                if (n < 2.5 / p) {
                    n -= 2.25 / p;
                    l = s * n * n + .9375;
                } else {
                    n -= 2.625 / p;
                    l = s * n * n + .984375;
                }
            }
        }
        return l;
    };
    window.mina = mina;
    return mina;
})(typeof eve == "undefined" ? function () {} : eve);

// Copyright (c) 2013 - 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

var Snap = (function(root) {
Snap.version = "0.5.1";
/*\
 * Snap
 [ method ]
 **
 * Creates a drawing surface or wraps existing SVG element.
 **
 - width (number|string) width of surface
 - height (number|string) height of surface
 * or
 - DOM (SVGElement) element to be wrapped into Snap structure
 * or
 - array (array) array of elements (will return set of elements)
 * or
 - query (string) CSS query selector
 = (object) @Element
\*/
function Snap(w, h) {
    if (w) {
        if (w.nodeType) {
            return wrap(w);
        }
        if (is(w, "array") && Snap.set) {
            return Snap.set.apply(Snap, w);
        }
        if (w instanceof Element) {
            return w;
        }
        if (h == null) {
            // try {
                w = glob.doc.querySelector(String(w));
                return wrap(w);
            // } catch (e) {
                // return null;
            // }
        }
    }
    w = w == null ? "100%" : w;
    h = h == null ? "100%" : h;
    return new Paper(w, h);
}
Snap.toString = function () {
    return "Snap v" + this.version;
};
Snap._ = {};
var glob = {
    win: root.window,
    doc: root.window.document
};
Snap._.glob = glob;
var has = "hasOwnProperty",
    Str = String,
    toFloat = parseFloat,
    toInt = parseInt,
    math = Math,
    mmax = math.max,
    mmin = math.min,
    abs = math.abs,
    pow = math.pow,
    PI = math.PI,
    round = math.round,
    E = "",
    S = " ",
    objectToString = Object.prototype.toString,
    ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
    colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?%?)\s*\))\s*$/i,
    bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
    separator = Snap._.separator = /[,\s]+/,
    whitespace = /[\s]/g,
    commaSpaces = /[\s]*,[\s]*/,
    hsrg = {hs: 1, rg: 1},
    pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
    tCommand = /([rstm])[\s,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\s]*,?[\s]*)+)/ig,
    pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\s]*,?[\s]*/ig,
    idgen = 0,
    idprefix = "S" + (+new Date).toString(36),
    ID = function (el) {
        return (el && el.type ? el.type : E) + idprefix + (idgen++).toString(36);
    },
    xlink = "http://www.w3.org/1999/xlink",
    xmlns = "http://www.w3.org/2000/svg",
    hub = {},
    /*\
     * Snap.url
     [ method ]
     **
     * Wraps path into `"url('<path>')"`.
     - value (string) path
     = (string) wrapped path
    \*/
    URL = Snap.url = function (url) {
        return "url('#" + url + "')";
    };

function $(el, attr) {
    if (attr) {
        if (el == "#text") {
            el = glob.doc.createTextNode(attr.text || attr["#text"] || "");
        }
        if (el == "#comment") {
            el = glob.doc.createComment(attr.text || attr["#text"] || "");
        }
        if (typeof el == "string") {
            el = $(el);
        }
        if (typeof attr == "string") {
            if (el.nodeType == 1) {
                if (attr.substring(0, 6) == "xlink:") {
                    return el.getAttributeNS(xlink, attr.substring(6));
                }
                if (attr.substring(0, 4) == "xml:") {
                    return el.getAttributeNS(xmlns, attr.substring(4));
                }
                return el.getAttribute(attr);
            } else if (attr == "text") {
                return el.nodeValue;
            } else {
                return null;
            }
        }
        if (el.nodeType == 1) {
            for (var key in attr) if (attr[has](key)) {
                var val = Str(attr[key]);
                if (val) {
                    if (key.substring(0, 6) == "xlink:") {
                        el.setAttributeNS(xlink, key.substring(6), val);
                    } else if (key.substring(0, 4) == "xml:") {
                        el.setAttributeNS(xmlns, key.substring(4), val);
                    } else {
                        el.setAttribute(key, val);
                    }
                } else {
                    el.removeAttribute(key);
                }
            }
        } else if ("text" in attr) {
            el.nodeValue = attr.text;
        }
    } else {
        el = glob.doc.createElementNS(xmlns, el);
    }
    return el;
}
Snap._.$ = $;
Snap._.id = ID;
function getAttrs(el) {
    var attrs = el.attributes,
        name,
        out = {};
    for (var i = 0; i < attrs.length; i++) {
        if (attrs[i].namespaceURI == xlink) {
            name = "xlink:";
        } else {
            name = "";
        }
        name += attrs[i].name;
        out[name] = attrs[i].textContent;
    }
    return out;
}
function is(o, type) {
    type = Str.prototype.toLowerCase.call(type);
    if (type == "finite") {
        return isFinite(o);
    }
    if (type == "array" &&
        (o instanceof Array || Array.isArray && Array.isArray(o))) {
        return true;
    }
    return  type == "null" && o === null ||
            type == typeof o && o !== null ||
            type == "object" && o === Object(o) ||
            objectToString.call(o).slice(8, -1).toLowerCase() == type;
}
/*\
 * Snap.format
 [ method ]
 **
 * Replaces construction of type `{<name>}` to the corresponding argument
 **
 - token (string) string to format
 - json (object) object which properties are used as a replacement
 = (string) formatted string
 > Usage
 | // this draws a rectangular shape equivalent to "M10,20h40v50h-40z"
 | paper.path(Snap.format("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
 |     x: 10,
 |     y: 20,
 |     dim: {
 |         width: 40,
 |         height: 50,
 |         "negative width": -40
 |     }
 | }));
\*/
Snap.format = (function () {
    var tokenRegex = /\{([^\}]+)\}/g,
        objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
        replacer = function (all, key, obj) {
            var res = obj;
            key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                name = name || quotedName;
                if (res) {
                    if (name in res) {
                        res = res[name];
                    }
                    typeof res == "function" && isFunc && (res = res());
                }
            });
            res = (res == null || res == obj ? all : res) + "";
            return res;
        };
    return function (str, obj) {
        return Str(str).replace(tokenRegex, function (all, key) {
            return replacer(all, key, obj);
        });
    };
})();
function clone(obj) {
    if (typeof obj == "function" || Object(obj) !== obj) {
        return obj;
    }
    var res = new obj.constructor;
    for (var key in obj) if (obj[has](key)) {
        res[key] = clone(obj[key]);
    }
    return res;
}
Snap._.clone = clone;
function repush(array, item) {
    for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
        return array.push(array.splice(i, 1)[0]);
    }
}
function cacher(f, scope, postprocessor) {
    function newf() {
        var arg = Array.prototype.slice.call(arguments, 0),
            args = arg.join("\u2400"),
            cache = newf.cache = newf.cache || {},
            count = newf.count = newf.count || [];
        if (cache[has](args)) {
            repush(count, args);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        count.length >= 1e3 && delete cache[count.shift()];
        count.push(args);
        cache[args] = f.apply(scope, arg);
        return postprocessor ? postprocessor(cache[args]) : cache[args];
    }
    return newf;
}
Snap._.cacher = cacher;
function angle(x1, y1, x2, y2, x3, y3) {
    if (x3 == null) {
        var x = x1 - x2,
            y = y1 - y2;
        if (!x && !y) {
            return 0;
        }
        return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
    } else {
        return angle(x1, y1, x3, y3) - angle(x2, y2, x3, y3);
    }
}
function rad(deg) {
    return deg % 360 * PI / 180;
}
function deg(rad) {
    return rad * 180 / PI % 360;
}
function x_y() {
    return this.x + S + this.y;
}
function x_y_w_h() {
    return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
}

/*\
 * Snap.rad
 [ method ]
 **
 * Transform angle to radians
 - deg (number) angle in degrees
 = (number) angle in radians
\*/
Snap.rad = rad;
/*\
 * Snap.deg
 [ method ]
 **
 * Transform angle to degrees
 - rad (number) angle in radians
 = (number) angle in degrees
\*/
Snap.deg = deg;
/*\
 * Snap.sin
 [ method ]
 **
 * Equivalent to `Math.sin()` only works with degrees, not radians.
 - angle (number) angle in degrees
 = (number) sin
\*/
Snap.sin = function (angle) {
    return math.sin(Snap.rad(angle));
};
/*\
 * Snap.tan
 [ method ]
 **
 * Equivalent to `Math.tan()` only works with degrees, not radians.
 - angle (number) angle in degrees
 = (number) tan
\*/
Snap.tan = function (angle) {
    return math.tan(Snap.rad(angle));
};
/*\
 * Snap.cos
 [ method ]
 **
 * Equivalent to `Math.cos()` only works with degrees, not radians.
 - angle (number) angle in degrees
 = (number) cos
\*/
Snap.cos = function (angle) {
    return math.cos(Snap.rad(angle));
};
/*\
 * Snap.asin
 [ method ]
 **
 * Equivalent to `Math.asin()` only works with degrees, not radians.
 - num (number) value
 = (number) asin in degrees
\*/
Snap.asin = function (num) {
    return Snap.deg(math.asin(num));
};
/*\
 * Snap.acos
 [ method ]
 **
 * Equivalent to `Math.acos()` only works with degrees, not radians.
 - num (number) value
 = (number) acos in degrees
\*/
Snap.acos = function (num) {
    return Snap.deg(math.acos(num));
};
/*\
 * Snap.atan
 [ method ]
 **
 * Equivalent to `Math.atan()` only works with degrees, not radians.
 - num (number) value
 = (number) atan in degrees
\*/
Snap.atan = function (num) {
    return Snap.deg(math.atan(num));
};
/*\
 * Snap.atan2
 [ method ]
 **
 * Equivalent to `Math.atan2()` only works with degrees, not radians.
 - num (number) value
 = (number) atan2 in degrees
\*/
Snap.atan2 = function (num) {
    return Snap.deg(math.atan2(num));
};
/*\
 * Snap.angle
 [ method ]
 **
 * Returns an angle between two or three points
 - x1 (number) x coord of first point
 - y1 (number) y coord of first point
 - x2 (number) x coord of second point
 - y2 (number) y coord of second point
 - x3 (number) #optional x coord of third point
 - y3 (number) #optional y coord of third point
 = (number) angle in degrees
\*/
Snap.angle = angle;
/*\
 * Snap.len
 [ method ]
 **
 * Returns distance between two points
 - x1 (number) x coord of first point
 - y1 (number) y coord of first point
 - x2 (number) x coord of second point
 - y2 (number) y coord of second point
 = (number) distance
\*/
Snap.len = function (x1, y1, x2, y2) {
    return Math.sqrt(Snap.len2(x1, y1, x2, y2));
};
/*\
 * Snap.len2
 [ method ]
 **
 * Returns squared distance between two points
 - x1 (number) x coord of first point
 - y1 (number) y coord of first point
 - x2 (number) x coord of second point
 - y2 (number) y coord of second point
 = (number) distance
\*/
Snap.len2 = function (x1, y1, x2, y2) {
    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
};
/*\
 * Snap.closestPoint
 [ method ]
 **
 * Returns closest point to a given one on a given path.
 - path (Element) path element
 - x (number) x coord of a point
 - y (number) y coord of a point
 = (object) in format
 {
    x (number) x coord of the point on the path
    y (number) y coord of the point on the path
    length (number) length of the path to the point
    distance (number) distance from the given point to the path
 }
\*/
// Copied from http://bl.ocks.org/mbostock/8027637
Snap.closestPoint = function (path, x, y) {
    function distance2(p) {
        var dx = p.x - x,
            dy = p.y - y;
        return dx * dx + dy * dy;
    }
    var pathNode = path.node,
        pathLength = pathNode.getTotalLength(),
        precision = pathLength / pathNode.pathSegList.numberOfItems * .125,
        best,
        bestLength,
        bestDistance = Infinity;

    // linear scan for coarse approximation
    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
        if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
            best = scan;
            bestLength = scanLength;
            bestDistance = scanDistance;
        }
    }

    // binary search for precise estimate
    precision *= .5;
    while (precision > .5) {
        var before,
            after,
            beforeLength,
            afterLength,
            beforeDistance,
            afterDistance;
        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {
            best = before;
            bestLength = beforeLength;
            bestDistance = beforeDistance;
        } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {
            best = after;
            bestLength = afterLength;
            bestDistance = afterDistance;
        } else {
            precision *= .5;
        }
    }

    best = {
        x: best.x,
        y: best.y,
        length: bestLength,
        distance: Math.sqrt(bestDistance)
    };
    return best;
}
/*\
 * Snap.is
 [ method ]
 **
 * Handy replacement for the `typeof` operator
 - o (…) any object or primitive
 - type (string) name of the type, e.g., `string`, `function`, `number`, etc.
 = (boolean) `true` if given value is of given type
\*/
Snap.is = is;
/*\
 * Snap.snapTo
 [ method ]
 **
 * Snaps given value to given grid
 - values (array|number) given array of values or step of the grid
 - value (number) value to adjust
 - tolerance (number) #optional maximum distance to the target value that would trigger the snap. Default is `10`.
 = (number) adjusted value
\*/
Snap.snapTo = function (values, value, tolerance) {
    tolerance = is(tolerance, "finite") ? tolerance : 10;
    if (is(values, "array")) {
        var i = values.length;
        while (i--) if (abs(values[i] - value) <= tolerance) {
            return values[i];
        }
    } else {
        values = +values;
        var rem = value % values;
        if (rem < tolerance) {
            return value - rem;
        }
        if (rem > values - tolerance) {
            return value - rem + values;
        }
    }
    return value;
};
// Colour
/*\
 * Snap.getRGB
 [ method ]
 **
 * Parses color string as RGB object
 - color (string) color string in one of the following formats:
 # <ul>
 #     <li>Color name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
 #     <li>#••• — shortened HTML color: (<code>#000</code>, <code>#fc0</code>, etc.)</li>
 #     <li>#•••••• — full length HTML color: (<code>#000000</code>, <code>#bd2300</code>)</li>
 #     <li>rgb(•••, •••, •••) — red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
 #     <li>rgba(•••, •••, •••, •••) — also with opacity</li>
 #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
 #     <li>rgba(•••%, •••%, •••%, •••%) — also with opacity</li>
 #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
 #     <li>hsba(•••, •••, •••, •••) — also with opacity</li>
 #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
 #     <li>hsba(•••%, •••%, •••%, •••%) — also with opacity</li>
 #     <li>hsl(•••, •••, •••) — hue, saturation and luminosity values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;0.5)</code>)</li>
 #     <li>hsla(•••, •••, •••, •••) — also with opacity</li>
 #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
 #     <li>hsla(•••%, •••%, •••%, •••%) — also with opacity</li>
 # </ul>
 * Note that `%` can be used any time: `rgb(20%, 255, 50%)`.
 = (object) RGB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••,
 o     error (boolean) true if string can't be parsed
 o }
\*/
Snap.getRGB = cacher(function (colour) {
    if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
    }
    if (colour == "none") {
        return {r: -1, g: -1, b: -1, hex: "none", toString: rgbtoString};
    }
    !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
    if (!colour) {
        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
    }
    var res,
        red,
        green,
        blue,
        opacity,
        t,
        values,
        rgb = colour.match(colourRegExp);
    if (rgb) {
        if (rgb[2]) {
            blue = toInt(rgb[2].substring(5), 16);
            green = toInt(rgb[2].substring(3, 5), 16);
            red = toInt(rgb[2].substring(1, 3), 16);
        }
        if (rgb[3]) {
            blue = toInt((t = rgb[3].charAt(3)) + t, 16);
            green = toInt((t = rgb[3].charAt(2)) + t, 16);
            red = toInt((t = rgb[3].charAt(1)) + t, 16);
        }
        if (rgb[4]) {
            values = rgb[4].split(commaSpaces);
            red = toFloat(values[0]);
            values[0].slice(-1) == "%" && (red *= 2.55);
            green = toFloat(values[1]);
            values[1].slice(-1) == "%" && (green *= 2.55);
            blue = toFloat(values[2]);
            values[2].slice(-1) == "%" && (blue *= 2.55);
            rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
        }
        if (rgb[5]) {
            values = rgb[5].split(commaSpaces);
            red = toFloat(values[0]);
            values[0].slice(-1) == "%" && (red /= 100);
            green = toFloat(values[1]);
            values[1].slice(-1) == "%" && (green /= 100);
            blue = toFloat(values[2]);
            values[2].slice(-1) == "%" && (blue /= 100);
            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
            rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            return Snap.hsb2rgb(red, green, blue, opacity);
        }
        if (rgb[6]) {
            values = rgb[6].split(commaSpaces);
            red = toFloat(values[0]);
            values[0].slice(-1) == "%" && (red /= 100);
            green = toFloat(values[1]);
            values[1].slice(-1) == "%" && (green /= 100);
            blue = toFloat(values[2]);
            values[2].slice(-1) == "%" && (blue /= 100);
            (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
            rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
            values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            return Snap.hsl2rgb(red, green, blue, opacity);
        }
        red = mmin(math.round(red), 255);
        green = mmin(math.round(green), 255);
        blue = mmin(math.round(blue), 255);
        opacity = mmin(mmax(opacity, 0), 1);
        rgb = {r: red, g: green, b: blue, toString: rgbtoString};
        rgb.hex = "#" + (16777216 | blue | green << 8 | red << 16).toString(16).slice(1);
        rgb.opacity = is(opacity, "finite") ? opacity : 1;
        return rgb;
    }
    return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: rgbtoString};
}, Snap);
/*\
 * Snap.hsb
 [ method ]
 **
 * Converts HSB values to a hex representation of the color
 - h (number) hue
 - s (number) saturation
 - b (number) value or brightness
 = (string) hex representation of the color
\*/
Snap.hsb = cacher(function (h, s, b) {
    return Snap.hsb2rgb(h, s, b).hex;
});
/*\
 * Snap.hsl
 [ method ]
 **
 * Converts HSL values to a hex representation of the color
 - h (number) hue
 - s (number) saturation
 - l (number) luminosity
 = (string) hex representation of the color
\*/
Snap.hsl = cacher(function (h, s, l) {
    return Snap.hsl2rgb(h, s, l).hex;
});
/*\
 * Snap.rgb
 [ method ]
 **
 * Converts RGB values to a hex representation of the color
 - r (number) red
 - g (number) green
 - b (number) blue
 = (string) hex representation of the color
\*/
Snap.rgb = cacher(function (r, g, b, o) {
    if (is(o, "finite")) {
        var round = math.round;
        return "rgba(" + [round(r), round(g), round(b), +o.toFixed(2)] + ")";
    }
    return "#" + (16777216 | b | g << 8 | r << 16).toString(16).slice(1);
});
var toHex = function (color) {
    var i = glob.doc.getElementsByTagName("head")[0] || glob.doc.getElementsByTagName("svg")[0],
        red = "rgb(255, 0, 0)";
    toHex = cacher(function (color) {
        if (color.toLowerCase() == "red") {
            return red;
        }
        i.style.color = red;
        i.style.color = color;
        var out = glob.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
        return out == red ? null : out;
    });
    return toHex(color);
},
hsbtoString = function () {
    return "hsb(" + [this.h, this.s, this.b] + ")";
},
hsltoString = function () {
    return "hsl(" + [this.h, this.s, this.l] + ")";
},
rgbtoString = function () {
    return this.opacity == 1 || this.opacity == null ?
            this.hex :
            "rgba(" + [this.r, this.g, this.b, this.opacity] + ")";
},
prepareRGB = function (r, g, b) {
    if (g == null && is(r, "object") && "r" in r && "g" in r && "b" in r) {
        b = r.b;
        g = r.g;
        r = r.r;
    }
    if (g == null && is(r, string)) {
        var clr = Snap.getRGB(r);
        r = clr.r;
        g = clr.g;
        b = clr.b;
    }
    if (r > 1 || g > 1 || b > 1) {
        r /= 255;
        g /= 255;
        b /= 255;
    }

    return [r, g, b];
},
packageRGB = function (r, g, b, o) {
    r = math.round(r * 255);
    g = math.round(g * 255);
    b = math.round(b * 255);
    var rgb = {
        r: r,
        g: g,
        b: b,
        opacity: is(o, "finite") ? o : 1,
        hex: Snap.rgb(r, g, b),
        toString: rgbtoString
    };
    is(o, "finite") && (rgb.opacity = o);
    return rgb;
};
/*\
 * Snap.color
 [ method ]
 **
 * Parses the color string and returns an object featuring the color's component values
 - clr (string) color string in one of the supported formats (see @Snap.getRGB)
 = (object) Combined RGB/HSB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••,
 o     error (boolean) `true` if string can't be parsed,
 o     h (number) hue,
 o     s (number) saturation,
 o     v (number) value (brightness),
 o     l (number) lightness
 o }
\*/
Snap.color = function (clr) {
    var rgb;
    if (is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
        rgb = Snap.hsb2rgb(clr);
        clr.r = rgb.r;
        clr.g = rgb.g;
        clr.b = rgb.b;
        clr.opacity = 1;
        clr.hex = rgb.hex;
    } else if (is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
        rgb = Snap.hsl2rgb(clr);
        clr.r = rgb.r;
        clr.g = rgb.g;
        clr.b = rgb.b;
        clr.opacity = 1;
        clr.hex = rgb.hex;
    } else {
        if (is(clr, "string")) {
            clr = Snap.getRGB(clr);
        }
        if (is(clr, "object") && "r" in clr && "g" in clr && "b" in clr && !("error" in clr)) {
            rgb = Snap.rgb2hsl(clr);
            clr.h = rgb.h;
            clr.s = rgb.s;
            clr.l = rgb.l;
            rgb = Snap.rgb2hsb(clr);
            clr.v = rgb.b;
        } else {
            clr = {hex: "none"};
            clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            clr.error = 1;
        }
    }
    clr.toString = rgbtoString;
    return clr;
};
/*\
 * Snap.hsb2rgb
 [ method ]
 **
 * Converts HSB values to an RGB object
 - h (number) hue
 - s (number) saturation
 - v (number) value or brightness
 = (object) RGB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••
 o }
\*/
Snap.hsb2rgb = function (h, s, v, o) {
    if (is(h, "object") && "h" in h && "s" in h && "b" in h) {
        v = h.b;
        s = h.s;
        o = h.o;
        h = h.h;
    }
    h *= 360;
    var R, G, B, X, C;
    h = h % 360 / 60;
    C = v * s;
    X = C * (1 - abs(h % 2 - 1));
    R = G = B = v - C;

    h = ~~h;
    R += [C, X, 0, 0, X, C][h];
    G += [X, C, C, X, 0, 0][h];
    B += [0, 0, X, C, C, X][h];
    return packageRGB(R, G, B, o);
};
/*\
 * Snap.hsl2rgb
 [ method ]
 **
 * Converts HSL values to an RGB object
 - h (number) hue
 - s (number) saturation
 - l (number) luminosity
 = (object) RGB object in the following format:
 o {
 o     r (number) red,
 o     g (number) green,
 o     b (number) blue,
 o     hex (string) color in HTML/CSS format: #••••••
 o }
\*/
Snap.hsl2rgb = function (h, s, l, o) {
    if (is(h, "object") && "h" in h && "s" in h && "l" in h) {
        l = h.l;
        s = h.s;
        h = h.h;
    }
    if (h > 1 || s > 1 || l > 1) {
        h /= 360;
        s /= 100;
        l /= 100;
    }
    h *= 360;
    var R, G, B, X, C;
    h = h % 360 / 60;
    C = 2 * s * (l < .5 ? l : 1 - l);
    X = C * (1 - abs(h % 2 - 1));
    R = G = B = l - C / 2;

    h = ~~h;
    R += [C, X, 0, 0, X, C][h];
    G += [X, C, C, X, 0, 0][h];
    B += [0, 0, X, C, C, X][h];
    return packageRGB(R, G, B, o);
};
/*\
 * Snap.rgb2hsb
 [ method ]
 **
 * Converts RGB values to an HSB object
 - r (number) red
 - g (number) green
 - b (number) blue
 = (object) HSB object in the following format:
 o {
 o     h (number) hue,
 o     s (number) saturation,
 o     b (number) brightness
 o }
\*/
Snap.rgb2hsb = function (r, g, b) {
    b = prepareRGB(r, g, b);
    r = b[0];
    g = b[1];
    b = b[2];

    var H, S, V, C;
    V = mmax(r, g, b);
    C = V - mmin(r, g, b);
    H = C == 0 ? null :
        V == r ? (g - b) / C :
        V == g ? (b - r) / C + 2 :
                 (r - g) / C + 4;
    H = (H + 360) % 6 * 60 / 360;
    S = C == 0 ? 0 : C / V;
    return {h: H, s: S, b: V, toString: hsbtoString};
};
/*\
 * Snap.rgb2hsl
 [ method ]
 **
 * Converts RGB values to an HSL object
 - r (number) red
 - g (number) green
 - b (number) blue
 = (object) HSL object in the following format:
 o {
 o     h (number) hue,
 o     s (number) saturation,
 o     l (number) luminosity
 o }
\*/
Snap.rgb2hsl = function (r, g, b) {
    b = prepareRGB(r, g, b);
    r = b[0];
    g = b[1];
    b = b[2];

    var H, S, L, M, m, C;
    M = mmax(r, g, b);
    m = mmin(r, g, b);
    C = M - m;
    H = C == 0 ? null :
        M == r ? (g - b) / C :
        M == g ? (b - r) / C + 2 :
                 (r - g) / C + 4;
    H = (H + 360) % 6 * 60 / 360;
    L = (M + m) / 2;
    S = C == 0 ? 0 :
         L < .5 ? C / (2 * L) :
                  C / (2 - 2 * L);
    return {h: H, s: S, l: L, toString: hsltoString};
};

// Transformations
/*\
 * Snap.parsePathString
 [ method ]
 **
 * Utility method
 **
 * Parses given path string into an array of arrays of path segments
 - pathString (string|array) path string or array of segments (in the last case it is returned straight away)
 = (array) array of segments
\*/
Snap.parsePathString = function (pathString) {
    if (!pathString) {
        return null;
    }
    var pth = Snap.path(pathString);
    if (pth.arr) {
        return Snap.path.clone(pth.arr);
    }

    var paramCounts = {a: 7, c: 6, o: 2, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, u: 3, z: 0},
        data = [];
    if (is(pathString, "array") && is(pathString[0], "array")) { // rough assumption
        data = Snap.path.clone(pathString);
    }
    if (!data.length) {
        Str(pathString).replace(pathCommand, function (a, b, c) {
            var params = [],
                name = b.toLowerCase();
            c.replace(pathValues, function (a, b) {
                b && params.push(+b);
            });
            if (name == "m" && params.length > 2) {
                data.push([b].concat(params.splice(0, 2)));
                name = "l";
                b = b == "m" ? "l" : "L";
            }
            if (name == "o" && params.length == 1) {
                data.push([b, params[0]]);
            }
            if (name == "r") {
                data.push([b].concat(params));
            } else while (params.length >= paramCounts[name]) {
                data.push([b].concat(params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) {
                    break;
                }
            }
        });
    }
    data.toString = Snap.path.toString;
    pth.arr = Snap.path.clone(data);
    return data;
};
/*\
 * Snap.parseTransformString
 [ method ]
 **
 * Utility method
 **
 * Parses given transform string into an array of transformations
 - TString (string|array) transform string or array of transformations (in the last case it is returned straight away)
 = (array) array of transformations
\*/
var parseTransformString = Snap.parseTransformString = function (TString) {
    if (!TString) {
        return null;
    }
    var paramCounts = {r: 3, s: 4, t: 2, m: 6},
        data = [];
    if (is(TString, "array") && is(TString[0], "array")) { // rough assumption
        data = Snap.path.clone(TString);
    }
    if (!data.length) {
        Str(TString).replace(tCommand, function (a, b, c) {
            var params = [],
                name = b.toLowerCase();
            c.replace(pathValues, function (a, b) {
                b && params.push(+b);
            });
            data.push([b].concat(params));
        });
    }
    data.toString = Snap.path.toString;
    return data;
};
function svgTransform2string(tstr) {
    var res = [];
    tstr = tstr.replace(/(?:^|\s)(\w+)\(([^)]+)\)/g, function (all, name, params) {
        params = params.split(/\s*,\s*|\s+/);
        if (name == "rotate" && params.length == 1) {
            params.push(0, 0);
        }
        if (name == "scale") {
            if (params.length > 2) {
                params = params.slice(0, 2);
            } else if (params.length == 2) {
                params.push(0, 0);
            }
            if (params.length == 1) {
                params.push(params[0], 0, 0);
            }
        }
        if (name == "skewX") {
            res.push(["m", 1, 0, math.tan(rad(params[0])), 1, 0, 0]);
        } else if (name == "skewY") {
            res.push(["m", 1, math.tan(rad(params[0])), 0, 1, 0, 0]);
        } else {
            res.push([name.charAt(0)].concat(params));
        }
        return all;
    });
    return res;
}
Snap._.svgTransform2string = svgTransform2string;
Snap._.rgTransform = /^[a-z][\s]*-?\.?\d/i;
function transform2matrix(tstr, bbox) {
    var tdata = parseTransformString(tstr),
        m = new Snap.Matrix;
    if (tdata) {
        for (var i = 0, ii = tdata.length; i < ii; i++) {
            var t = tdata[i],
                tlen = t.length,
                command = Str(t[0]).toLowerCase(),
                absolute = t[0] != command,
                inver = absolute ? m.invert() : 0,
                x1,
                y1,
                x2,
                y2,
                bb;
            if (command == "t" && tlen == 2){
                m.translate(t[1], 0);
            } else if (command == "t" && tlen == 3) {
                if (absolute) {
                    x1 = inver.x(0, 0);
                    y1 = inver.y(0, 0);
                    x2 = inver.x(t[1], t[2]);
                    y2 = inver.y(t[1], t[2]);
                    m.translate(x2 - x1, y2 - y1);
                } else {
                    m.translate(t[1], t[2]);
                }
            } else if (command == "r") {
                if (tlen == 2) {
                    bb = bb || bbox;
                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                } else if (tlen == 4) {
                    if (absolute) {
                        x2 = inver.x(t[2], t[3]);
                        y2 = inver.y(t[2], t[3]);
                        m.rotate(t[1], x2, y2);
                    } else {
                        m.rotate(t[1], t[2], t[3]);
                    }
                }
            } else if (command == "s") {
                if (tlen == 2 || tlen == 3) {
                    bb = bb || bbox;
                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                } else if (tlen == 4) {
                    if (absolute) {
                        x2 = inver.x(t[2], t[3]);
                        y2 = inver.y(t[2], t[3]);
                        m.scale(t[1], t[1], x2, y2);
                    } else {
                        m.scale(t[1], t[1], t[2], t[3]);
                    }
                } else if (tlen == 5) {
                    if (absolute) {
                        x2 = inver.x(t[3], t[4]);
                        y2 = inver.y(t[3], t[4]);
                        m.scale(t[1], t[2], x2, y2);
                    } else {
                        m.scale(t[1], t[2], t[3], t[4]);
                    }
                }
            } else if (command == "m" && tlen == 7) {
                m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
            }
        }
    }
    return m;
}
Snap._.transform2matrix = transform2matrix;
Snap._unit2px = unit2px;
var contains = glob.doc.contains || glob.doc.compareDocumentPosition ?
    function (a, b) {
        var adown = a.nodeType == 9 ? a.documentElement : a,
            bup = b && b.parentNode;
            return a == bup || !!(bup && bup.nodeType == 1 && (
                adown.contains ?
                    adown.contains(bup) :
                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
            ));
    } :
    function (a, b) {
        if (b) {
            while (b) {
                b = b.parentNode;
                if (b == a) {
                    return true;
                }
            }
        }
        return false;
    };
function getSomeDefs(el) {
    var p = el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) ||
            el.node.parentNode && wrap(el.node.parentNode) ||
            Snap.select("svg") ||
            Snap(0, 0),
        pdefs = p.select("defs"),
        defs  = pdefs == null ? false : pdefs.node;
    if (!defs) {
        defs = make("defs", p.node).node;
    }
    return defs;
}
function getSomeSVG(el) {
    return el.node.ownerSVGElement && wrap(el.node.ownerSVGElement) || Snap.select("svg");
}
Snap._.getSomeDefs = getSomeDefs;
Snap._.getSomeSVG = getSomeSVG;
function unit2px(el, name, value) {
    var svg = getSomeSVG(el).node,
        out = {},
        mgr = svg.querySelector(".svg---mgr");
    if (!mgr) {
        mgr = $("rect");
        $(mgr, {x: -9e9, y: -9e9, width: 10, height: 10, "class": "svg---mgr", fill: "none"});
        svg.appendChild(mgr);
    }
    function getW(val) {
        if (val == null) {
            return E;
        }
        if (val == +val) {
            return val;
        }
        $(mgr, {width: val});
        try {
            return mgr.getBBox().width;
        } catch (e) {
            return 0;
        }
    }
    function getH(val) {
        if (val == null) {
            return E;
        }
        if (val == +val) {
            return val;
        }
        $(mgr, {height: val});
        try {
            return mgr.getBBox().height;
        } catch (e) {
            return 0;
        }
    }
    function set(nam, f) {
        if (name == null) {
            out[nam] = f(el.attr(nam) || 0);
        } else if (nam == name) {
            out = f(value == null ? el.attr(nam) || 0 : value);
        }
    }
    switch (el.type) {
        case "rect":
            set("rx", getW);
            set("ry", getH);
        case "image":
            set("width", getW);
            set("height", getH);
        case "text":
            set("x", getW);
            set("y", getH);
        break;
        case "circle":
            set("cx", getW);
            set("cy", getH);
            set("r", getW);
        break;
        case "ellipse":
            set("cx", getW);
            set("cy", getH);
            set("rx", getW);
            set("ry", getH);
        break;
        case "line":
            set("x1", getW);
            set("x2", getW);
            set("y1", getH);
            set("y2", getH);
        break;
        case "marker":
            set("refX", getW);
            set("markerWidth", getW);
            set("refY", getH);
            set("markerHeight", getH);
        break;
        case "radialGradient":
            set("fx", getW);
            set("fy", getH);
        break;
        case "tspan":
            set("dx", getW);
            set("dy", getH);
        break;
        default:
            set(name, getW);
    }
    svg.removeChild(mgr);
    return out;
}
/*\
 * Snap.select
 [ method ]
 **
 * Wraps a DOM element specified by CSS selector as @Element
 - query (string) CSS selector of the element
 = (Element) the current element
\*/
Snap.select = function (query) {
    query = Str(query).replace(/([^\\]):/g, "$1\\:");
    return wrap(glob.doc.querySelector(query));
};
/*\
 * Snap.selectAll
 [ method ]
 **
 * Wraps DOM elements specified by CSS selector as set or array of @Element
 - query (string) CSS selector of the element
 = (Element) the current element
\*/
Snap.selectAll = function (query) {
    var nodelist = glob.doc.querySelectorAll(query),
        set = (Snap.set || Array)();
    for (var i = 0; i < nodelist.length; i++) {
        set.push(wrap(nodelist[i]));
    }
    return set;
};

function add2group(list) {
    if (!is(list, "array")) {
        list = Array.prototype.slice.call(arguments, 0);
    }
    var i = 0,
        j = 0,
        node = this.node;
    while (this[i]) delete this[i++];
    for (i = 0; i < list.length; i++) {
        if (list[i].type == "set") {
            list[i].forEach(function (el) {
                node.appendChild(el.node);
            });
        } else {
            node.appendChild(list[i].node);
        }
    }
    var children = node.childNodes;
    for (i = 0; i < children.length; i++) {
        this[j++] = wrap(children[i]);
    }
    return this;
}
// Hub garbage collector every 10s
setInterval(function () {
    for (var key in hub) if (hub[has](key)) {
        var el = hub[key],
            node = el.node;
        if (el.type != "svg" && !node.ownerSVGElement || el.type == "svg" && (!node.parentNode || "ownerSVGElement" in node.parentNode && !node.ownerSVGElement)) {
            delete hub[key];
        }
    }
}, 1e4);
function Element(el) {
    if (el.snap in hub) {
        return hub[el.snap];
    }
    var svg;
    try {
        svg = el.ownerSVGElement;
    } catch(e) {}
    /*\
     * Element.node
     [ property (object) ]
     **
     * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
     > Usage
     | // draw a circle at coordinate 10,10 with radius of 10
     | var c = paper.circle(10, 10, 10);
     | c.node.onclick = function () {
     |     c.attr("fill", "red");
     | };
    \*/
    this.node = el;
    if (svg) {
        this.paper = new Paper(svg);
    }
    /*\
     * Element.type
     [ property (string) ]
     **
     * SVG tag name of the given element.
    \*/
    this.type = el.tagName || el.nodeName;
    var id = this.id = ID(this);
    this.anims = {};
    this._ = {
        transform: []
    };
    el.snap = id;
    hub[id] = this;
    if (this.type == "g") {
        this.add = add2group;
    }
    if (this.type in {g: 1, mask: 1, pattern: 1, symbol: 1}) {
        for (var method in Paper.prototype) if (Paper.prototype[has](method)) {
            this[method] = Paper.prototype[method];
        }
    }
}
   /*\
     * Element.attr
     [ method ]
     **
     * Gets or sets given attributes of the element.
     **
     - params (object) contains key-value pairs of attributes you want to set
     * or
     - param (string) name of the attribute
     = (Element) the current element
     * or
     = (string) value of attribute
     > Usage
     | el.attr({
     |     fill: "#fc0",
     |     stroke: "#000",
     |     strokeWidth: 2, // CamelCase...
     |     "fill-opacity": 0.5, // or dash-separated names
     |     width: "*=2" // prefixed values
     | });
     | console.log(el.attr("fill")); // #fc0
     * Prefixed values in format `"+=10"` supported. All four operations
     * (`+`, `-`, `*` and `/`) could be used. Optionally you can use units for `+`
     * and `-`: `"+=2em"`.
    \*/
    Element.prototype.attr = function (params, value) {
        var el = this,
            node = el.node;
        if (!params) {
            if (node.nodeType != 1) {
                return {
                    text: node.nodeValue
                };
            }
            var attr = node.attributes,
                out = {};
            for (var i = 0, ii = attr.length; i < ii; i++) {
                out[attr[i].nodeName] = attr[i].nodeValue;
            }
            return out;
        }
        if (is(params, "string")) {
            if (arguments.length > 1) {
                var json = {};
                json[params] = value;
                params = json;
            } else {
                return eve("snap.util.getattr." + params, el).firstDefined();
            }
        }
        for (var att in params) {
            if (params[has](att)) {
                eve("snap.util.attr." + att, el, params[att]);
            }
        }
        return el;
    };
/*\
 * Snap.parse
 [ method ]
 **
 * Parses SVG fragment and converts it into a @Fragment
 **
 - svg (string) SVG string
 = (Fragment) the @Fragment
\*/
Snap.parse = function (svg) {
    var f = glob.doc.createDocumentFragment(),
        full = true,
        div = glob.doc.createElement("div");
    svg = Str(svg);
    if (!svg.match(/^\s*<\s*svg(?:\s|>)/)) {
        svg = "<svg>" + svg + "</svg>";
        full = false;
    }
    div.innerHTML = svg;
    svg = div.getElementsByTagName("svg")[0];
    if (svg) {
        if (full) {
            f = svg;
        } else {
            while (svg.firstChild) {
                f.appendChild(svg.firstChild);
            }
        }
    }
    return new Fragment(f);
};
function Fragment(frag) {
    this.node = frag;
}
/*\
 * Snap.fragment
 [ method ]
 **
 * Creates a DOM fragment from a given list of elements or strings
 **
 - varargs (…) SVG string
 = (Fragment) the @Fragment
\*/
Snap.fragment = function () {
    var args = Array.prototype.slice.call(arguments, 0),
        f = glob.doc.createDocumentFragment();
    for (var i = 0, ii = args.length; i < ii; i++) {
        var item = args[i];
        if (item.node && item.node.nodeType) {
            f.appendChild(item.node);
        }
        if (item.nodeType) {
            f.appendChild(item);
        }
        if (typeof item == "string") {
            f.appendChild(Snap.parse(item).node);
        }
    }
    return new Fragment(f);
};

function make(name, parent) {
    var res = $(name);
    parent.appendChild(res);
    var el = wrap(res);
    return el;
}
function Paper(w, h) {
    var res,
        desc,
        defs,
        proto = Paper.prototype;
    if (w && w.tagName && w.tagName.toLowerCase() == "svg") {
        if (w.snap in hub) {
            return hub[w.snap];
        }
        var doc = w.ownerDocument;
        res = new Element(w);
        desc = w.getElementsByTagName("desc")[0];
        defs = w.getElementsByTagName("defs")[0];
        if (!desc) {
            desc = $("desc");
            desc.appendChild(doc.createTextNode("Created with Snap"));
            res.node.appendChild(desc);
        }
        if (!defs) {
            defs = $("defs");
            res.node.appendChild(defs);
        }
        res.defs = defs;
        for (var key in proto) if (proto[has](key)) {
            res[key] = proto[key];
        }
        res.paper = res.root = res;
    } else {
        res = make("svg", glob.doc.body);
        $(res.node, {
            height: h,
            version: 1.1,
            width: w,
            xmlns: xmlns
        });
    }
    return res;
}
function wrap(dom) {
    if (!dom) {
        return dom;
    }
    if (dom instanceof Element || dom instanceof Fragment) {
        return dom;
    }
    if (dom.tagName && dom.tagName.toLowerCase() == "svg") {
        return new Paper(dom);
    }
    if (dom.tagName && dom.tagName.toLowerCase() == "object" && dom.type == "image/svg+xml") {
        return new Paper(dom.contentDocument.getElementsByTagName("svg")[0]);
    }
    return new Element(dom);
}

Snap._.make = make;
Snap._.wrap = wrap;
/*\
 * Paper.el
 [ method ]
 **
 * Creates an element on paper with a given name and no attributes
 **
 - name (string) tag name
 - attr (object) attributes
 = (Element) the current element
 > Usage
 | var c = paper.circle(10, 10, 10); // is the same as...
 | var c = paper.el("circle").attr({
 |     cx: 10,
 |     cy: 10,
 |     r: 10
 | });
 | // and the same as
 | var c = paper.el("circle", {
 |     cx: 10,
 |     cy: 10,
 |     r: 10
 | });
\*/
Paper.prototype.el = function (name, attr) {
    var el = make(name, this.node);
    attr && el.attr(attr);
    return el;
};
/*\
 * Element.children
 [ method ]
 **
 * Returns array of all the children of the element.
 = (array) array of Elements
\*/
Element.prototype.children = function () {
    var out = [],
        ch = this.node.childNodes;
    for (var i = 0, ii = ch.length; i < ii; i++) {
        out[i] = Snap(ch[i]);
    }
    return out;
};
function jsonFiller(root, o) {
    for (var i = 0, ii = root.length; i < ii; i++) {
        var item = {
                type: root[i].type,
                attr: root[i].attr()
            },
            children = root[i].children();
        o.push(item);
        if (children.length) {
            jsonFiller(children, item.childNodes = []);
        }
    }
}
/*\
 * Element.toJSON
 [ method ]
 **
 * Returns object representation of the given element and all its children.
 = (object) in format
 o {
 o     type (string) this.type,
 o     attr (object) attributes map,
 o     childNodes (array) optional array of children in the same format
 o }
\*/
Element.prototype.toJSON = function () {
    var out = [];
    jsonFiller([this], out);
    return out[0];
};
// default
eve.on("snap.util.getattr", function () {
    var att = eve.nt();
    att = att.substring(att.lastIndexOf(".") + 1);
    var css = att.replace(/[A-Z]/g, function (letter) {
        return "-" + letter.toLowerCase();
    });
    if (cssAttr[has](css)) {
        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, null).getPropertyValue(css);
    } else {
        return $(this.node, att);
    }
});
var cssAttr = {
    "alignment-baseline": 0,
    "baseline-shift": 0,
    "clip": 0,
    "clip-path": 0,
    "clip-rule": 0,
    "color": 0,
    "color-interpolation": 0,
    "color-interpolation-filters": 0,
    "color-profile": 0,
    "color-rendering": 0,
    "cursor": 0,
    "direction": 0,
    "display": 0,
    "dominant-baseline": 0,
    "enable-background": 0,
    "fill": 0,
    "fill-opacity": 0,
    "fill-rule": 0,
    "filter": 0,
    "flood-color": 0,
    "flood-opacity": 0,
    "font": 0,
    "font-family": 0,
    "font-size": 0,
    "font-size-adjust": 0,
    "font-stretch": 0,
    "font-style": 0,
    "font-variant": 0,
    "font-weight": 0,
    "glyph-orientation-horizontal": 0,
    "glyph-orientation-vertical": 0,
    "image-rendering": 0,
    "kerning": 0,
    "letter-spacing": 0,
    "lighting-color": 0,
    "marker": 0,
    "marker-end": 0,
    "marker-mid": 0,
    "marker-start": 0,
    "mask": 0,
    "opacity": 0,
    "overflow": 0,
    "pointer-events": 0,
    "shape-rendering": 0,
    "stop-color": 0,
    "stop-opacity": 0,
    "stroke": 0,
    "stroke-dasharray": 0,
    "stroke-dashoffset": 0,
    "stroke-linecap": 0,
    "stroke-linejoin": 0,
    "stroke-miterlimit": 0,
    "stroke-opacity": 0,
    "stroke-width": 0,
    "text-anchor": 0,
    "text-decoration": 0,
    "text-rendering": 0,
    "unicode-bidi": 0,
    "visibility": 0,
    "word-spacing": 0,
    "writing-mode": 0
};

eve.on("snap.util.attr", function (value) {
    var att = eve.nt(),
        attr = {};
    att = att.substring(att.lastIndexOf(".") + 1);
    attr[att] = value;
    var style = att.replace(/-(\w)/gi, function (all, letter) {
            return letter.toUpperCase();
        }),
        css = att.replace(/[A-Z]/g, function (letter) {
            return "-" + letter.toLowerCase();
        });
    if (cssAttr[has](css)) {
        this.node.style[style] = value == null ? E : value;
    } else {
        $(this.node, attr);
    }
});
(function (proto) {}(Paper.prototype));

// simple ajax
/*\
 * Snap.ajax
 [ method ]
 **
 * Simple implementation of Ajax
 **
 - url (string) URL
 - postData (object|string) data for post request
 - callback (function) callback
 - scope (object) #optional scope of callback
 * or
 - url (string) URL
 - callback (function) callback
 - scope (object) #optional scope of callback
 = (XMLHttpRequest) the XMLHttpRequest object, just in case
\*/
Snap.ajax = function (url, postData, callback, scope){
    var req = new XMLHttpRequest,
        id = ID();
    if (req) {
        if (is(postData, "function")) {
            scope = callback;
            callback = postData;
            postData = null;
        } else if (is(postData, "object")) {
            var pd = [];
            for (var key in postData) if (postData.hasOwnProperty(key)) {
                pd.push(encodeURIComponent(key) + "=" + encodeURIComponent(postData[key]));
            }
            postData = pd.join("&");
        }
        req.open(postData ? "POST" : "GET", url, true);
        if (postData) {
            req.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        }
        if (callback) {
            eve.once("snap.ajax." + id + ".0", callback);
            eve.once("snap.ajax." + id + ".200", callback);
            eve.once("snap.ajax." + id + ".304", callback);
        }
        req.onreadystatechange = function() {
            if (req.readyState != 4) return;
            eve("snap.ajax." + id + "." + req.status, scope, req);
        };
        if (req.readyState == 4) {
            return req;
        }
        req.send(postData);
        return req;
    }
};
/*\
 * Snap.load
 [ method ]
 **
 * Loads external SVG file as a @Fragment (see @Snap.ajax for more advanced AJAX)
 **
 - url (string) URL
 - callback (function) callback
 - scope (object) #optional scope of callback
\*/
Snap.load = function (url, callback, scope) {
    Snap.ajax(url, function (req) {
        var f = Snap.parse(req.responseText);
        scope ? callback.call(scope, f) : callback(f);
    });
};
var getOffset = function (elem) {
    var box = elem.getBoundingClientRect(),
        doc = elem.ownerDocument,
        body = doc.body,
        docElem = doc.documentElement,
        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
        top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
    return {
        y: top,
        x: left
    };
};
/*\
 * Snap.getElementByPoint
 [ method ]
 **
 * Returns you topmost element under given point.
 **
 = (object) Snap element object
 - x (number) x coordinate from the top left corner of the window
 - y (number) y coordinate from the top left corner of the window
 > Usage
 | Snap.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
\*/
Snap.getElementByPoint = function (x, y) {
    var paper = this,
        svg = paper.canvas,
        target = glob.doc.elementFromPoint(x, y);
    if (glob.win.opera && target.tagName == "svg") {
        var so = getOffset(target),
            sr = target.createSVGRect();
        sr.x = x - so.x;
        sr.y = y - so.y;
        sr.width = sr.height = 1;
        var hits = target.getIntersectionList(sr, null);
        if (hits.length) {
            target = hits[hits.length - 1];
        }
    }
    if (!target) {
        return null;
    }
    return wrap(target);
};
/*\
 * Snap.plugin
 [ method ]
 **
 * Let you write plugins. You pass in a function with five arguments, like this:
 | Snap.plugin(function (Snap, Element, Paper, global, Fragment) {
 |     Snap.newmethod = function () {};
 |     Element.prototype.newmethod = function () {};
 |     Paper.prototype.newmethod = function () {};
 | });
 * Inside the function you have access to all main objects (and their
 * prototypes). This allow you to extend anything you want.
 **
 - f (function) your plugin body
\*/
Snap.plugin = function (f) {
    f(Snap, Element, Paper, glob, Fragment);
};
glob.win.Snap = Snap;
return Snap;
}(window || this));

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var elproto = Element.prototype,
        is = Snap.is,
        Str = String,
        unit2px = Snap._unit2px,
        $ = Snap._.$,
        make = Snap._.make,
        getSomeDefs = Snap._.getSomeDefs,
        has = "hasOwnProperty",
        wrap = Snap._.wrap;
    /*\
     * Element.getBBox
     [ method ]
     **
     * Returns the bounding box descriptor for the given element
     **
     = (object) bounding box descriptor:
     o {
     o     cx: (number) x of the center,
     o     cy: (number) x of the center,
     o     h: (number) height,
     o     height: (number) height,
     o     path: (string) path command for the box,
     o     r0: (number) radius of a circle that fully encloses the box,
     o     r1: (number) radius of the smallest circle that can be enclosed,
     o     r2: (number) radius of the largest circle that can be enclosed,
     o     vb: (string) box as a viewbox command,
     o     w: (number) width,
     o     width: (number) width,
     o     x2: (number) x of the right side,
     o     x: (number) x of the left side,
     o     y2: (number) y of the bottom edge,
     o     y: (number) y of the top edge
     o }
    \*/
    elproto.getBBox = function (isWithoutTransform) {
        if (this.type == "tspan") {
            return Snap._.box(this.node.getClientRects().item(0));
        }
        if (!Snap.Matrix || !Snap.path) {
            return this.node.getBBox();
        }
        var el = this,
            m = new Snap.Matrix;
        if (el.removed) {
            return Snap._.box();
        }
        while (el.type == "use") {
            if (!isWithoutTransform) {
                m = m.add(el.transform().localMatrix.translate(el.attr("x") || 0, el.attr("y") || 0));
            }
            if (el.original) {
                el = el.original;
            } else {
                var href = el.attr("xlink:href");
                el = el.original = el.node.ownerDocument.getElementById(href.substring(href.indexOf("#") + 1));
            }
        }
        var _ = el._,
            pathfinder = Snap.path.get[el.type] || Snap.path.get.deflt;
        try {
            if (isWithoutTransform) {
                _.bboxwt = pathfinder ? Snap.path.getBBox(el.realPath = pathfinder(el)) : Snap._.box(el.node.getBBox());
                return Snap._.box(_.bboxwt);
            } else {
                el.realPath = pathfinder(el);
                el.matrix = el.transform().localMatrix;
                _.bbox = Snap.path.getBBox(Snap.path.map(el.realPath, m.add(el.matrix)));
                return Snap._.box(_.bbox);
            }
        } catch (e) {
            // Firefox doesn’t give you bbox of hidden element
            return Snap._.box();
        }
    };
    var propString = function () {
        return this.string;
    };
    function extractTransform(el, tstr) {
        if (tstr == null) {
            var doReturn = true;
            if (el.type == "linearGradient" || el.type == "radialGradient") {
                tstr = el.node.getAttribute("gradientTransform");
            } else if (el.type == "pattern") {
                tstr = el.node.getAttribute("patternTransform");
            } else {
                tstr = el.node.getAttribute("transform");
            }
            if (!tstr) {
                return new Snap.Matrix;
            }
            tstr = Snap._.svgTransform2string(tstr);
        } else {
            if (!Snap._.rgTransform.test(tstr)) {
                tstr = Snap._.svgTransform2string(tstr);
            } else {
                tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || "");
            }
            if (is(tstr, "array")) {
                tstr = Snap.path ? Snap.path.toString.call(tstr) : Str(tstr);
            }
            el._.transform = tstr;
        }
        var m = Snap._.transform2matrix(tstr, el.getBBox(1));
        if (doReturn) {
            return m;
        } else {
            el.matrix = m;
        }
    }
    /*\
     * Element.transform
     [ method ]
     **
     * Gets or sets transformation of the element
     **
     - tstr (string) transform string in Snap or SVG format
     = (Element) the current element
     * or
     = (object) transformation descriptor:
     o {
     o     string (string) transform string,
     o     globalMatrix (Matrix) matrix of all transformations applied to element or its parents,
     o     localMatrix (Matrix) matrix of transformations applied only to the element,
     o     diffMatrix (Matrix) matrix of difference between global and local transformations,
     o     global (string) global transformation as string,
     o     local (string) local transformation as string,
     o     toString (function) returns `string` property
     o }
    \*/
    elproto.transform = function (tstr) {
        var _ = this._;
        if (tstr == null) {
            var papa = this,
                global = new Snap.Matrix(this.node.getCTM()),
                local = extractTransform(this),
                ms = [local],
                m = new Snap.Matrix,
                i,
                localString = local.toTransformString(),
                string = Str(local) == Str(this.matrix) ?
                            Str(_.transform) : localString;
            while (papa.type != "svg" && (papa = papa.parent())) {
                ms.push(extractTransform(papa));
            }
            i = ms.length;
            while (i--) {
                m.add(ms[i]);
            }
            return {
                string: string,
                globalMatrix: global,
                totalMatrix: m,
                localMatrix: local,
                diffMatrix: global.clone().add(local.invert()),
                global: global.toTransformString(),
                total: m.toTransformString(),
                local: localString,
                toString: propString
            };
        }
        if (tstr instanceof Snap.Matrix) {
            this.matrix = tstr;
            this._.transform = tstr.toTransformString();
        } else {
            extractTransform(this, tstr);
        }

        if (this.node) {
            if (this.type == "linearGradient" || this.type == "radialGradient") {
                $(this.node, {gradientTransform: this.matrix});
            } else if (this.type == "pattern") {
                $(this.node, {patternTransform: this.matrix});
            } else {
                $(this.node, {transform: this.matrix});
            }
        }

        return this;
    };
    /*\
     * Element.parent
     [ method ]
     **
     * Returns the element's parent
     **
     = (Element) the parent element
    \*/
    elproto.parent = function () {
        return wrap(this.node.parentNode);
    };
    /*\
     * Element.append
     [ method ]
     **
     * Appends the given element to current one
     **
     - el (Element|Set) element to append
     = (Element) the parent element
    \*/
    /*\
     * Element.add
     [ method ]
     **
     * See @Element.append
    \*/
    elproto.append = elproto.add = function (el) {
        if (el) {
            if (el.type == "set") {
                var it = this;
                el.forEach(function (el) {
                    it.add(el);
                });
                return this;
            }
            el = wrap(el);
            this.node.appendChild(el.node);
            el.paper = this.paper;
        }
        return this;
    };
    /*\
     * Element.appendTo
     [ method ]
     **
     * Appends the current element to the given one
     **
     - el (Element) parent element to append to
     = (Element) the child element
    \*/
    elproto.appendTo = function (el) {
        if (el) {
            el = wrap(el);
            el.append(this);
        }
        return this;
    };
    /*\
     * Element.prepend
     [ method ]
     **
     * Prepends the given element to the current one
     **
     - el (Element) element to prepend
     = (Element) the parent element
    \*/
    elproto.prepend = function (el) {
        if (el) {
            if (el.type == "set") {
                var it = this,
                    first;
                el.forEach(function (el) {
                    if (first) {
                        first.after(el);
                    } else {
                        it.prepend(el);
                    }
                    first = el;
                });
                return this;
            }
            el = wrap(el);
            var parent = el.parent();
            this.node.insertBefore(el.node, this.node.firstChild);
            this.add && this.add();
            el.paper = this.paper;
            this.parent() && this.parent().add();
            parent && parent.add();
        }
        return this;
    };
    /*\
     * Element.prependTo
     [ method ]
     **
     * Prepends the current element to the given one
     **
     - el (Element) parent element to prepend to
     = (Element) the child element
    \*/
    elproto.prependTo = function (el) {
        el = wrap(el);
        el.prepend(this);
        return this;
    };
    /*\
     * Element.before
     [ method ]
     **
     * Inserts given element before the current one
     **
     - el (Element) element to insert
     = (Element) the parent element
    \*/
    elproto.before = function (el) {
        if (el.type == "set") {
            var it = this;
            el.forEach(function (el) {
                var parent = el.parent();
                it.node.parentNode.insertBefore(el.node, it.node);
                parent && parent.add();
            });
            this.parent().add();
            return this;
        }
        el = wrap(el);
        var parent = el.parent();
        this.node.parentNode.insertBefore(el.node, this.node);
        this.parent() && this.parent().add();
        parent && parent.add();
        el.paper = this.paper;
        return this;
    };
    /*\
     * Element.after
     [ method ]
     **
     * Inserts given element after the current one
     **
     - el (Element) element to insert
     = (Element) the parent element
    \*/
    elproto.after = function (el) {
        el = wrap(el);
        var parent = el.parent();
        if (this.node.nextSibling) {
            this.node.parentNode.insertBefore(el.node, this.node.nextSibling);
        } else {
            this.node.parentNode.appendChild(el.node);
        }
        this.parent() && this.parent().add();
        parent && parent.add();
        el.paper = this.paper;
        return this;
    };
    /*\
     * Element.insertBefore
     [ method ]
     **
     * Inserts the element after the given one
     **
     - el (Element) element next to whom insert to
     = (Element) the parent element
    \*/
    elproto.insertBefore = function (el) {
        el = wrap(el);
        var parent = this.parent();
        el.node.parentNode.insertBefore(this.node, el.node);
        this.paper = el.paper;
        parent && parent.add();
        el.parent() && el.parent().add();
        return this;
    };
    /*\
     * Element.insertAfter
     [ method ]
     **
     * Inserts the element after the given one
     **
     - el (Element) element next to whom insert to
     = (Element) the parent element
    \*/
    elproto.insertAfter = function (el) {
        el = wrap(el);
        var parent = this.parent();
        el.node.parentNode.insertBefore(this.node, el.node.nextSibling);
        this.paper = el.paper;
        parent && parent.add();
        el.parent() && el.parent().add();
        return this;
    };
    /*\
     * Element.remove
     [ method ]
     **
     * Removes element from the DOM
     = (Element) the detached element
    \*/
    elproto.remove = function () {
        var parent = this.parent();
        this.node.parentNode && this.node.parentNode.removeChild(this.node);
        delete this.paper;
        this.removed = true;
        parent && parent.add();
        return this;
    };
    /*\
     * Element.select
     [ method ]
     **
     * Gathers the nested @Element matching the given set of CSS selectors
     **
     - query (string) CSS selector
     = (Element) result of query selection
    \*/
    elproto.select = function (query) {
        return wrap(this.node.querySelector(query));
    };
    /*\
     * Element.selectAll
     [ method ]
     **
     * Gathers nested @Element objects matching the given set of CSS selectors
     **
     - query (string) CSS selector
     = (Set|array) result of query selection
    \*/
    elproto.selectAll = function (query) {
        var nodelist = this.node.querySelectorAll(query),
            set = (Snap.set || Array)();
        for (var i = 0; i < nodelist.length; i++) {
            set.push(wrap(nodelist[i]));
        }
        return set;
    };
    /*\
     * Element.asPX
     [ method ]
     **
     * Returns given attribute of the element as a `px` value (not %, em, etc.)
     **
     - attr (string) attribute name
     - value (string) #optional attribute value
     = (Element) result of query selection
    \*/
    elproto.asPX = function (attr, value) {
        if (value == null) {
            value = this.attr(attr);
        }
        return +unit2px(this, attr, value);
    };
    // SIERRA Element.use(): I suggest adding a note about how to access the original element the returned <use> instantiates. It's a part of SVG with which ordinary web developers may be least familiar.
    /*\
     * Element.use
     [ method ]
     **
     * Creates a `<use>` element linked to the current element
     **
     = (Element) the `<use>` element
    \*/
    elproto.use = function () {
        var use,
            id = this.node.id;
        if (!id) {
            id = this.id;
            $(this.node, {
                id: id
            });
        }
        if (this.type == "linearGradient" || this.type == "radialGradient" ||
            this.type == "pattern") {
            use = make(this.type, this.node.parentNode);
        } else {
            use = make("use", this.node.parentNode);
        }
        $(use.node, {
            "xlink:href": "#" + id
        });
        use.original = this;
        return use;
    };
    function fixids(el) {
        var els = el.selectAll("*"),
            it,
            url = /^\s*url\(("|'|)(.*)\1\)\s*$/,
            ids = [],
            uses = {};
        function urltest(it, name) {
            var val = $(it.node, name);
            val = val && val.match(url);
            val = val && val[2];
            if (val && val.charAt() == "#") {
                val = val.substring(1);
            } else {
                return;
            }
            if (val) {
                uses[val] = (uses[val] || []).concat(function (id) {
                    var attr = {};
                    attr[name] = Snap.url(id);
                    $(it.node, attr);
                });
            }
        }
        function linktest(it) {
            var val = $(it.node, "xlink:href");
            if (val && val.charAt() == "#") {
                val = val.substring(1);
            } else {
                return;
            }
            if (val) {
                uses[val] = (uses[val] || []).concat(function (id) {
                    it.attr("xlink:href", "#" + id);
                });
            }
        }
        for (var i = 0, ii = els.length; i < ii; i++) {
            it = els[i];
            urltest(it, "fill");
            urltest(it, "stroke");
            urltest(it, "filter");
            urltest(it, "mask");
            urltest(it, "clip-path");
            linktest(it);
            var oldid = $(it.node, "id");
            if (oldid) {
                $(it.node, {id: it.id});
                ids.push({
                    old: oldid,
                    id: it.id
                });
            }
        }
        for (i = 0, ii = ids.length; i < ii; i++) {
            var fs = uses[ids[i].old];
            if (fs) {
                for (var j = 0, jj = fs.length; j < jj; j++) {
                    fs[j](ids[i].id);
                }
            }
        }
    }
    /*\
     * Element.clone
     [ method ]
     **
     * Creates a clone of the element and inserts it after the element
     **
     = (Element) the clone
    \*/
    elproto.clone = function () {
        var clone = wrap(this.node.cloneNode(true));
        if ($(clone.node, "id")) {
            $(clone.node, {id: clone.id});
        }
        fixids(clone);
        clone.insertAfter(this);
        return clone;
    };
    /*\
     * Element.toDefs
     [ method ]
     **
     * Moves element to the shared `<defs>` area
     **
     = (Element) the element
    \*/
    elproto.toDefs = function () {
        var defs = getSomeDefs(this);
        defs.appendChild(this.node);
        return this;
    };
    /*\
     * Element.toPattern
     [ method ]
     **
     * Creates a `<pattern>` element from the current element
     **
     * To create a pattern you have to specify the pattern rect:
     - x (string|number)
     - y (string|number)
     - width (string|number)
     - height (string|number)
     = (Element) the `<pattern>` element
     * You can use pattern later on as an argument for `fill` attribute:
     | var p = paper.path("M10-5-10,15M15,0,0,15M0-5-20,15").attr({
     |         fill: "none",
     |         stroke: "#bada55",
     |         strokeWidth: 5
     |     }).pattern(0, 0, 10, 10),
     |     c = paper.circle(200, 200, 100);
     | c.attr({
     |     fill: p
     | });
    \*/
    elproto.pattern = elproto.toPattern = function (x, y, width, height) {
        var p = make("pattern", getSomeDefs(this));
        if (x == null) {
            x = this.getBBox();
        }
        if (is(x, "object") && "x" in x) {
            y = x.y;
            width = x.width;
            height = x.height;
            x = x.x;
        }
        $(p.node, {
            x: x,
            y: y,
            width: width,
            height: height,
            patternUnits: "userSpaceOnUse",
            id: p.id,
            viewBox: [x, y, width, height].join(" ")
        });
        p.node.appendChild(this.node);
        return p;
    };
// SIERRA Element.marker(): clarify what a reference point is. E.g., helps you offset the object from its edge such as when centering it over a path.
// SIERRA Element.marker(): I suggest the method should accept default reference point values.  Perhaps centered with (refX = width/2) and (refY = height/2)? Also, couldn't it assume the element's current _width_ and _height_? And please specify what _x_ and _y_ mean: offsets? If so, from where?  Couldn't they also be assigned default values?
    /*\
     * Element.marker
     [ method ]
     **
     * Creates a `<marker>` element from the current element
     **
     * To create a marker you have to specify the bounding rect and reference point:
     - x (number)
     - y (number)
     - width (number)
     - height (number)
     - refX (number)
     - refY (number)
     = (Element) the `<marker>` element
     * You can specify the marker later as an argument for `marker-start`, `marker-end`, `marker-mid`, and `marker` attributes. The `marker` attribute places the marker at every point along the path, and `marker-mid` places them at every point except the start and end.
    \*/
    // TODO add usage for markers
    elproto.marker = function (x, y, width, height, refX, refY) {
        var p = make("marker", getSomeDefs(this));
        if (x == null) {
            x = this.getBBox();
        }
        if (is(x, "object") && "x" in x) {
            y = x.y;
            width = x.width;
            height = x.height;
            refX = x.refX || x.cx;
            refY = x.refY || x.cy;
            x = x.x;
        }
        $(p.node, {
            viewBox: [x, y, width, height].join(" "),
            markerWidth: width,
            markerHeight: height,
            orient: "auto",
            refX: refX || 0,
            refY: refY || 0,
            id: p.id
        });
        p.node.appendChild(this.node);
        return p;
    };
    var eldata = {};
    /*\
     * Element.data
     [ method ]
     **
     * Adds or retrieves given value associated with given key. (Don’t confuse
     * with `data-` attributes)
     *
     * See also @Element.removeData
     - key (string) key to store data
     - value (any) #optional value to store
     = (object) @Element
     * or, if value is not specified:
     = (any) value
     > Usage
     | for (var i = 0, i < 5, i++) {
     |     paper.circle(10 + 15 * i, 10, 10)
     |          .attr({fill: "#000"})
     |          .data("i", i)
     |          .click(function () {
     |             alert(this.data("i"));
     |          });
     | }
    \*/
    elproto.data = function (key, value) {
        var data = eldata[this.id] = eldata[this.id] || {};
        if (arguments.length == 0){
            eve("snap.data.get." + this.id, this, data, null);
            return data;
        }
        if (arguments.length == 1) {
            if (Snap.is(key, "object")) {
                for (var i in key) if (key[has](i)) {
                    this.data(i, key[i]);
                }
                return this;
            }
            eve("snap.data.get." + this.id, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        eve("snap.data.set." + this.id, this, value, key);
        return this;
    };
    /*\
     * Element.removeData
     [ method ]
     **
     * Removes value associated with an element by given key.
     * If key is not provided, removes all the data of the element.
     - key (string) #optional key
     = (object) @Element
    \*/
    elproto.removeData = function (key) {
        if (key == null) {
            eldata[this.id] = {};
        } else {
            eldata[this.id] && delete eldata[this.id][key];
        }
        return this;
    };
    /*\
     * Element.outerSVG
     [ method ]
     **
     * Returns SVG code for the element, equivalent to HTML's `outerHTML`.
     *
     * See also @Element.innerSVG
     = (string) SVG code for the element
    \*/
    /*\
     * Element.toString
     [ method ]
     **
     * See @Element.outerSVG
    \*/
    elproto.outerSVG = elproto.toString = toString(1);
    /*\
     * Element.innerSVG
     [ method ]
     **
     * Returns SVG code for the element's contents, equivalent to HTML's `innerHTML`
     = (string) SVG code for the element
    \*/
    elproto.innerSVG = toString();
    function toString(type) {
        return function () {
            var res = type ? "<" + this.type : "",
                attr = this.node.attributes,
                chld = this.node.childNodes;
            if (type) {
                for (var i = 0, ii = attr.length; i < ii; i++) {
                    res += " " + attr[i].name + '="' +
                            attr[i].value.replace(/"/g, '\\"') + '"';
                }
            }
            if (chld.length) {
                type && (res += ">");
                for (i = 0, ii = chld.length; i < ii; i++) {
                    if (chld[i].nodeType == 3) {
                        res += chld[i].nodeValue;
                    } else if (chld[i].nodeType == 1) {
                        res += wrap(chld[i]).toString();
                    }
                }
                type && (res += "</" + this.type + ">");
            } else {
                type && (res += "/>");
            }
            return res;
        };
    }
    elproto.toDataURL = function () {
        if (window && window.btoa) {
            var bb = this.getBBox(),
                svg = Snap.format('<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="{width}" height="{height}" viewBox="{x} {y} {width} {height}">{contents}</svg>', {
                x: +bb.x.toFixed(3),
                y: +bb.y.toFixed(3),
                width: +bb.width.toFixed(3),
                height: +bb.height.toFixed(3),
                contents: this.outerSVG()
            });
            return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
        }
    };
    /*\
     * Fragment.select
     [ method ]
     **
     * See @Element.select
    \*/
    Fragment.prototype.select = elproto.select;
    /*\
     * Fragment.selectAll
     [ method ]
     **
     * See @Element.selectAll
    \*/
    Fragment.prototype.selectAll = elproto.selectAll;
});

// Copyright (c) 2016 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var elproto = Element.prototype,
        is = Snap.is,
        Str = String,
        has = "hasOwnProperty";
    function slice(from, to, f) {
        return function (arr) {
            var res = arr.slice(from, to);
            if (res.length == 1) {
                res = res[0];
            }
            return f ? f(res) : res;
        };
    }
    var Animation = function (attr, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        this.attr = attr;
        this.dur = ms;
        easing && (this.easing = easing);
        callback && (this.callback = callback);
    };
    Snap._.Animation = Animation;
    /*\
     * Snap.animation
     [ method ]
     **
     * Creates an animation object
     **
     - attr (object) attributes of final destination
     - duration (number) duration of the animation, in milliseconds
     - easing (function) #optional one of easing functions of @mina or custom one
     - callback (function) #optional callback function that fires when animation ends
     = (object) animation object
    \*/
    Snap.animation = function (attr, ms, easing, callback) {
        return new Animation(attr, ms, easing, callback);
    };
    /*\
     * Element.inAnim
     [ method ]
     **
     * Returns a set of animations that may be able to manipulate the current element
     **
     = (object) in format:
     o {
     o     anim (object) animation object,
     o     mina (object) @mina object,
     o     curStatus (number) 0..1 — status of the animation: 0 — just started, 1 — just finished,
     o     status (function) gets or sets the status of the animation,
     o     stop (function) stops the animation
     o }
    \*/
    elproto.inAnim = function () {
        var el = this,
            res = [];
        for (var id in el.anims) if (el.anims[has](id)) {
            (function (a) {
                res.push({
                    anim: new Animation(a._attrs, a.dur, a.easing, a._callback),
                    mina: a,
                    curStatus: a.status(),
                    status: function (val) {
                        return a.status(val);
                    },
                    stop: function () {
                        a.stop();
                    }
                });
            }(el.anims[id]));
        }
        return res;
    };
    /*\
     * Snap.animate
     [ method ]
     **
     * Runs generic animation of one number into another with a caring function
     **
     - from (number|array) number or array of numbers
     - to (number|array) number or array of numbers
     - setter (function) caring function that accepts one number argument
     - duration (number) duration, in milliseconds
     - easing (function) #optional easing function from @mina or custom
     - callback (function) #optional callback function to execute when animation ends
     = (object) animation object in @mina format
     o {
     o     id (string) animation id, consider it read-only,
     o     duration (function) gets or sets the duration of the animation,
     o     easing (function) easing,
     o     speed (function) gets or sets the speed of the animation,
     o     status (function) gets or sets the status of the animation,
     o     stop (function) stops the animation
     o }
     | var rect = Snap().rect(0, 0, 10, 10);
     | Snap.animate(0, 10, function (val) {
     |     rect.attr({
     |         x: val
     |     });
     | }, 1000);
     | // in given context is equivalent to
     | rect.animate({x: 10}, 1000);
    \*/
    Snap.animate = function (from, to, setter, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        var now = mina.time(),
            anim = mina(from, to, now, now + ms, mina.time, setter, easing);
        callback && eve.once("mina.finish." + anim.id, callback);
        return anim;
    };
    /*\
     * Element.stop
     [ method ]
     **
     * Stops all the animations for the current element
     **
     = (Element) the current element
    \*/
    elproto.stop = function () {
        var anims = this.inAnim();
        for (var i = 0, ii = anims.length; i < ii; i++) {
            anims[i].stop();
        }
        return this;
    };
    /*\
     * Element.animate
     [ method ]
     **
     * Animates the given attributes of the element
     **
     - attrs (object) key-value pairs of destination attributes
     - duration (number) duration of the animation in milliseconds
     - easing (function) #optional easing function from @mina or custom
     - callback (function) #optional callback function that executes when the animation ends
     = (Element) the current element
    \*/
    elproto.animate = function (attrs, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        if (attrs instanceof Animation) {
            callback = attrs.callback;
            easing = attrs.easing;
            ms = attrs.dur;
            attrs = attrs.attr;
        }
        var fkeys = [], tkeys = [], keys = {}, from, to, f, eq,
            el = this;
        for (var key in attrs) if (attrs[has](key)) {
            if (el.equal) {
                eq = el.equal(key, Str(attrs[key]));
                from = eq.from;
                to = eq.to;
                f = eq.f;
            } else {
                from = +el.attr(key);
                to = +attrs[key];
            }
            var len = is(from, "array") ? from.length : 1;
            keys[key] = slice(fkeys.length, fkeys.length + len, f);
            fkeys = fkeys.concat(from);
            tkeys = tkeys.concat(to);
        }
        var now = mina.time(),
            anim = mina(fkeys, tkeys, now, now + ms, mina.time, function (val) {
                var attr = {};
                for (var key in keys) if (keys[has](key)) {
                    attr[key] = keys[key](val);
                }
                el.attr(attr);
            }, easing);
        el.anims[anim.id] = anim;
        anim._attrs = attrs;
        anim._callback = callback;
        eve("snap.animcreated." + el.id, anim);
        eve.once("mina.finish." + anim.id, function () {
            eve.off("mina.*." + anim.id);
            delete el.anims[anim.id];
            callback && callback.call(el);
        });
        eve.once("mina.stop." + anim.id, function () {
            eve.off("mina.*." + anim.id);
            delete el.anims[anim.id];
        });
        return el;
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var objectToString = Object.prototype.toString,
        Str = String,
        math = Math,
        E = "";
    function Matrix(a, b, c, d, e, f) {
        if (b == null && objectToString.call(a) == "[object SVGMatrix]") {
            this.a = a.a;
            this.b = a.b;
            this.c = a.c;
            this.d = a.d;
            this.e = a.e;
            this.f = a.f;
            return;
        }
        if (a != null) {
            this.a = +a;
            this.b = +b;
            this.c = +c;
            this.d = +d;
            this.e = +e;
            this.f = +f;
        } else {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
    }
    (function (matrixproto) {
        /*\
         * Matrix.add
         [ method ]
         **
         * Adds the given matrix to existing one
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         * or
         - matrix (object) @Matrix
        \*/
        matrixproto.add = function (a, b, c, d, e, f) {
            if (a && a instanceof Matrix) {
                return this.add(a.a, a.b, a.c, a.d, a.e, a.f);
            }
            var aNew = a * this.a + b * this.c,
                bNew = a * this.b + b * this.d;
            this.e += e * this.a + f * this.c;
            this.f += e * this.b + f * this.d;
            this.c = c * this.a + d * this.c;
            this.d = c * this.b + d * this.d;

            this.a = aNew;
            this.b = bNew;
            return this;
        };
        /*\
         * Matrix.multLeft
         [ method ]
         **
         * Multiplies a passed affine transform to the left: M * this.
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         * or
         - matrix (object) @Matrix
        \*/
        Matrix.prototype.multLeft = function (a, b, c, d, e, f) {
            if (a && a instanceof Matrix) {
                return this.multLeft(a.a, a.b, a.c, a.d, a.e, a.f);
            }
            var aNew = a * this.a + c * this.b,
                cNew = a * this.c + c * this.d,
                eNew = a * this.e + c * this.f + e;
            this.b = b * this.a + d * this.b;
            this.d = b * this.c + d * this.d;
            this.f = b * this.e + d * this.f + f;

            this.a = aNew;
            this.c = cNew;
            this.e = eNew;
            return this;
        };
        /*\
         * Matrix.invert
         [ method ]
         **
         * Returns an inverted version of the matrix
         = (object) @Matrix
        \*/
        matrixproto.invert = function () {
            var me = this,
                x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };
        /*\
         * Matrix.clone
         [ method ]
         **
         * Returns a copy of the matrix
         = (object) @Matrix
        \*/
        matrixproto.clone = function () {
            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
        };
        /*\
         * Matrix.translate
         [ method ]
         **
         * Translate the matrix
         - x (number) horizontal offset distance
         - y (number) vertical offset distance
        \*/
        matrixproto.translate = function (x, y) {
            this.e += x * this.a + y * this.c;
            this.f += x * this.b + y * this.d;
            return this;
        };
        /*\
         * Matrix.scale
         [ method ]
         **
         * Scales the matrix
         - x (number) amount to be scaled, with `1` resulting in no change
         - y (number) #optional amount to scale along the vertical axis. (Otherwise `x` applies to both axes.)
         - cx (number) #optional horizontal origin point from which to scale
         - cy (number) #optional vertical origin point from which to scale
         * Default cx, cy is the middle point of the element.
        \*/
        matrixproto.scale = function (x, y, cx, cy) {
            y == null && (y = x);
            (cx || cy) && this.translate(cx, cy);
            this.a *= x;
            this.b *= x;
            this.c *= y;
            this.d *= y;
            (cx || cy) && this.translate(-cx, -cy);
            return this;
        };
        /*\
         * Matrix.rotate
         [ method ]
         **
         * Rotates the matrix
         - a (number) angle of rotation, in degrees
         - x (number) horizontal origin point from which to rotate
         - y (number) vertical origin point from which to rotate
        \*/
        matrixproto.rotate = function (a, x, y) {
            a = Snap.rad(a);
            x = x || 0;
            y = y || 0;
            var cos = +math.cos(a).toFixed(9),
                sin = +math.sin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            return this.add(1, 0, 0, 1, -x, -y);
        };
        /*\
         * Matrix.skewX
         [ method ]
         **
         * Skews the matrix along the x-axis
         - x (number) Angle to skew along the x-axis (in degrees).
        \*/
        matrixproto.skewX = function (x) {
            return this.skew(x, 0);
        };
        /*\
         * Matrix.skewY
         [ method ]
         **
         * Skews the matrix along the y-axis
         - y (number) Angle to skew along the y-axis (in degrees).
        \*/
        matrixproto.skewY = function (y) {
            return this.skew(0, y);
        };
        /*\
         * Matrix.skew
         [ method ]
         **
         * Skews the matrix
         - y (number) Angle to skew along the y-axis (in degrees).
         - x (number) Angle to skew along the x-axis (in degrees).
        \*/
        matrixproto.skew = function (x, y) {
            x = x || 0;
            y = y || 0;
            x = Snap.rad(x);
            y = Snap.rad(y);
            var c = math.tan(x).toFixed(9);
            var b = math.tan(y).toFixed(9);
            return this.add(1, b, c, 1, 0, 0);
        };
        /*\
         * Matrix.x
         [ method ]
         **
         * Returns x coordinate for given point after transformation described by the matrix. See also @Matrix.y
         - x (number)
         - y (number)
         = (number) x
        \*/
        matrixproto.x = function (x, y) {
            return x * this.a + y * this.c + this.e;
        };
        /*\
         * Matrix.y
         [ method ]
         **
         * Returns y coordinate for given point after transformation described by the matrix. See also @Matrix.x
         - x (number)
         - y (number)
         = (number) y
        \*/
        matrixproto.y = function (x, y) {
            return x * this.b + y * this.d + this.f;
        };
        matrixproto.get = function (i) {
            return +this[Str.fromCharCode(97 + i)].toFixed(4);
        };
        matrixproto.toString = function () {
            return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")";
        };
        matrixproto.offset = function () {
            return [this.e.toFixed(4), this.f.toFixed(4)];
        };
        function norm(a) {
            return a[0] * a[0] + a[1] * a[1];
        }
        function normalize(a) {
            var mag = math.sqrt(norm(a));
            a[0] && (a[0] /= mag);
            a[1] && (a[1] /= mag);
        }
        /*\
         * Matrix.determinant
         [ method ]
         **
         * Finds determinant of the given matrix.
         = (number) determinant
        \*/
        matrixproto.determinant = function () {
            return this.a * this.d - this.b * this.c;
        };
        /*\
         * Matrix.split
         [ method ]
         **
         * Splits matrix into primitive transformations
         = (object) in format:
         o dx (number) translation by x
         o dy (number) translation by y
         o scalex (number) scale by x
         o scaley (number) scale by y
         o shear (number) shear
         o rotate (number) rotation in deg
         o isSimple (boolean) could it be represented via simple transformations
        \*/
        matrixproto.split = function () {
            var out = {};
            // translation
            out.dx = this.e;
            out.dy = this.f;

            // scale and shear
            var row = [[this.a, this.b], [this.c, this.d]];
            out.scalex = math.sqrt(norm(row[0]));
            normalize(row[0]);

            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

            out.scaley = math.sqrt(norm(row[1]));
            normalize(row[1]);
            out.shear /= out.scaley;

            if (this.determinant() < 0) {
                out.scalex = -out.scalex;
            }

            // rotation
            var sin = row[0][1],
                cos = row[1][1];
            if (cos < 0) {
                out.rotate = Snap.deg(math.acos(cos));
                if (sin < 0) {
                    out.rotate = 360 - out.rotate;
                }
            } else {
                out.rotate = Snap.deg(math.asin(sin));
            }

            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
            return out;
        };
        /*\
         * Matrix.toTransformString
         [ method ]
         **
         * Returns transform string that represents given matrix
         = (string) transform string
        \*/
        matrixproto.toTransformString = function (shorter) {
            var s = shorter || this.split();
            if (!+s.shear.toFixed(9)) {
                s.scalex = +s.scalex.toFixed(4);
                s.scaley = +s.scaley.toFixed(4);
                s.rotate = +s.rotate.toFixed(4);
                return  (s.dx || s.dy ? "t" + [+s.dx.toFixed(4), +s.dy.toFixed(4)] : E) +
                        (s.rotate ? "r" + [+s.rotate.toFixed(4), 0, 0] : E) +
                        (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E);
            } else {
                return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
            }
        };
    })(Matrix.prototype);
    /*\
     * Snap.Matrix
     [ method ]
     **
     * Matrix constructor, extend on your own risk.
     * To create matrices use @Snap.matrix.
    \*/
    Snap.Matrix = Matrix;
    /*\
     * Snap.matrix
     [ method ]
     **
     * Utility method
     **
     * Returns a matrix based on the given parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     * or
     - svgMatrix (SVGMatrix)
     = (object) @Matrix
    \*/
    Snap.matrix = function (a, b, c, d, e, f) {
        return new Matrix(a, b, c, d, e, f);
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var has = "hasOwnProperty",
        make = Snap._.make,
        wrap = Snap._.wrap,
        is = Snap.is,
        getSomeDefs = Snap._.getSomeDefs,
        reURLValue = /^url\((['"]?)([^)]+)\1\)$/,
        $ = Snap._.$,
        URL = Snap.url,
        Str = String,
        separator = Snap._.separator,
        E = "";
    /*\
     * Snap.deurl
     [ method ]
     **
     * Unwraps path from `"url(<path>)"`.
     - value (string) url path
     = (string) unwrapped path
    \*/
    Snap.deurl = function (value) {
        var res = String(value).match(reURLValue);
        return res ? res[2] : value;
    }
    // Attributes event handlers
    eve.on("snap.util.attr.mask", function (value) {
        if (value instanceof Element || value instanceof Fragment) {
            eve.stop();
            if (value instanceof Fragment && value.node.childNodes.length == 1) {
                value = value.node.firstChild;
                getSomeDefs(this).appendChild(value);
                value = wrap(value);
            }
            if (value.type == "mask") {
                var mask = value;
            } else {
                mask = make("mask", getSomeDefs(this));
                mask.node.appendChild(value.node);
            }
            !mask.node.id && $(mask.node, {
                id: mask.id
            });
            $(this.node, {
                mask: URL(mask.id)
            });
        }
    });
    (function (clipIt) {
        eve.on("snap.util.attr.clip", clipIt);
        eve.on("snap.util.attr.clip-path", clipIt);
        eve.on("snap.util.attr.clipPath", clipIt);
    }(function (value) {
        if (value instanceof Element || value instanceof Fragment) {
            eve.stop();
            var clip,
                node = value.node;
            while (node) {
                if (node.nodeName === "clipPath") {
                    clip = new Element(node);
                    break;
                }
                if (node.nodeName === "svg") {
                    clip = undefined;
                    break;
                }
                node = node.parentNode;
            }
            if (!clip) {
                clip = make("clipPath", getSomeDefs(this));
                clip.node.appendChild(value.node);
                !clip.node.id && $(clip.node, {
                    id: clip.id
                });
            }
            $(this.node, {
                "clip-path": URL(clip.node.id || clip.id)
            });
        }
    }));
    function fillStroke(name) {
        return function (value) {
            eve.stop();
            if (value instanceof Fragment && value.node.childNodes.length == 1 &&
                (value.node.firstChild.tagName == "radialGradient" ||
                value.node.firstChild.tagName == "linearGradient" ||
                value.node.firstChild.tagName == "pattern")) {
                value = value.node.firstChild;
                getSomeDefs(this).appendChild(value);
                value = wrap(value);
            }
            if (value instanceof Element) {
                if (value.type == "radialGradient" || value.type == "linearGradient"
                   || value.type == "pattern") {
                    if (!value.node.id) {
                        $(value.node, {
                            id: value.id
                        });
                    }
                    var fill = URL(value.node.id);
                } else {
                    fill = value.attr(name);
                }
            } else {
                fill = Snap.color(value);
                if (fill.error) {
                    var grad = Snap(getSomeDefs(this).ownerSVGElement).gradient(value);
                    if (grad) {
                        if (!grad.node.id) {
                            $(grad.node, {
                                id: grad.id
                            });
                        }
                        fill = URL(grad.node.id);
                    } else {
                        fill = value;
                    }
                } else {
                    fill = Str(fill);
                }
            }
            var attrs = {};
            attrs[name] = fill;
            $(this.node, attrs);
            this.node.style[name] = E;
        };
    }
    eve.on("snap.util.attr.fill", fillStroke("fill"));
    eve.on("snap.util.attr.stroke", fillStroke("stroke"));
    var gradrg = /^([lr])(?:\(([^)]*)\))?(.*)$/i;
    eve.on("snap.util.grad.parse", function parseGrad(string) {
        string = Str(string);
        var tokens = string.match(gradrg);
        if (!tokens) {
            return null;
        }
        var type = tokens[1],
            params = tokens[2],
            stops = tokens[3];
        params = params.split(/\s*,\s*/).map(function (el) {
            return +el == el ? +el : el;
        });
        if (params.length == 1 && params[0] == 0) {
            params = [];
        }
        stops = stops.split("-");
        stops = stops.map(function (el) {
            el = el.split(":");
            var out = {
                color: el[0]
            };
            if (el[1]) {
                out.offset = parseFloat(el[1]);
            }
            return out;
        });
        var len = stops.length,
            start = 0,
            j = 0;
        function seed(i, end) {
            var step = (end - start) / (i - j);
            for (var k = j; k < i; k++) {
                stops[k].offset = +(+start + step * (k - j)).toFixed(2);
            }
            j = i;
            start = end;
        }
        len--;
        for (var i = 0; i < len; i++) if ("offset" in stops[i]) {
            seed(i, stops[i].offset);
        }
        stops[len].offset = stops[len].offset || 100;
        seed(len, stops[len].offset);
        return {
            type: type,
            params: params,
            stops: stops
        };
    });

    eve.on("snap.util.attr.d", function (value) {
        eve.stop();
        if (is(value, "array") && is(value[0], "array")) {
            value = Snap.path.toString.call(value);
        }
        value = Str(value);
        if (value.match(/[ruo]/i)) {
            value = Snap.path.toAbsolute(value);
        }
        $(this.node, {d: value});
    })(-1);
    eve.on("snap.util.attr.#text", function (value) {
        eve.stop();
        value = Str(value);
        var txt = glob.doc.createTextNode(value);
        while (this.node.firstChild) {
            this.node.removeChild(this.node.firstChild);
        }
        this.node.appendChild(txt);
    })(-1);
    eve.on("snap.util.attr.path", function (value) {
        eve.stop();
        this.attr({d: value});
    })(-1);
    eve.on("snap.util.attr.class", function (value) {
        eve.stop();
        this.node.className.baseVal = value;
    })(-1);
    eve.on("snap.util.attr.viewBox", function (value) {
        var vb;
        if (is(value, "object") && "x" in value) {
            vb = [value.x, value.y, value.width, value.height].join(" ");
        } else if (is(value, "array")) {
            vb = value.join(" ");
        } else {
            vb = value;
        }
        $(this.node, {
            viewBox: vb
        });
        eve.stop();
    })(-1);
    eve.on("snap.util.attr.transform", function (value) {
        this.transform(value);
        eve.stop();
    })(-1);
    eve.on("snap.util.attr.r", function (value) {
        if (this.type == "rect") {
            eve.stop();
            $(this.node, {
                rx: value,
                ry: value
            });
        }
    })(-1);
    eve.on("snap.util.attr.textpath", function (value) {
        eve.stop();
        if (this.type == "text") {
            var id, tp, node;
            if (!value && this.textPath) {
                tp = this.textPath;
                while (tp.node.firstChild) {
                    this.node.appendChild(tp.node.firstChild);
                }
                tp.remove();
                delete this.textPath;
                return;
            }
            if (is(value, "string")) {
                var defs = getSomeDefs(this),
                    path = wrap(defs.parentNode).path(value);
                defs.appendChild(path.node);
                id = path.id;
                path.attr({id: id});
            } else {
                value = wrap(value);
                if (value instanceof Element) {
                    id = value.attr("id");
                    if (!id) {
                        id = value.id;
                        value.attr({id: id});
                    }
                }
            }
            if (id) {
                tp = this.textPath;
                node = this.node;
                if (tp) {
                    tp.attr({"xlink:href": "#" + id});
                } else {
                    tp = $("textPath", {
                        "xlink:href": "#" + id
                    });
                    while (node.firstChild) {
                        tp.appendChild(node.firstChild);
                    }
                    node.appendChild(tp);
                    this.textPath = wrap(tp);
                }
            }
        }
    })(-1);
    eve.on("snap.util.attr.text", function (value) {
        if (this.type == "text") {
            var i = 0,
                node = this.node,
                tuner = function (chunk) {
                    var out = $("tspan");
                    if (is(chunk, "array")) {
                        for (var i = 0; i < chunk.length; i++) {
                            out.appendChild(tuner(chunk[i]));
                        }
                    } else {
                        out.appendChild(glob.doc.createTextNode(chunk));
                    }
                    out.normalize && out.normalize();
                    return out;
                };
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }
            var tuned = tuner(value);
            while (tuned.firstChild) {
                node.appendChild(tuned.firstChild);
            }
        }
        eve.stop();
    })(-1);
    function setFontSize(value) {
        eve.stop();
        if (value == +value) {
            value += "px";
        }
        this.node.style.fontSize = value;
    }
    eve.on("snap.util.attr.fontSize", setFontSize)(-1);
    eve.on("snap.util.attr.font-size", setFontSize)(-1);


    eve.on("snap.util.getattr.transform", function () {
        eve.stop();
        return this.transform();
    })(-1);
    eve.on("snap.util.getattr.textpath", function () {
        eve.stop();
        return this.textPath;
    })(-1);
    // Markers
    (function () {
        function getter(end) {
            return function () {
                eve.stop();
                var style = glob.doc.defaultView.getComputedStyle(this.node, null).getPropertyValue("marker-" + end);
                if (style == "none") {
                    return style;
                } else {
                    return Snap(glob.doc.getElementById(style.match(reURLValue)[1]));
                }
            };
        }
        function setter(end) {
            return function (value) {
                eve.stop();
                var name = "marker" + end.charAt(0).toUpperCase() + end.substring(1);
                if (value == "" || !value) {
                    this.node.style[name] = "none";
                    return;
                }
                if (value.type == "marker") {
                    var id = value.node.id;
                    if (!id) {
                        $(value.node, {id: value.id});
                    }
                    this.node.style[name] = URL(id);
                    return;
                }
            };
        }
        eve.on("snap.util.getattr.marker-end", getter("end"))(-1);
        eve.on("snap.util.getattr.markerEnd", getter("end"))(-1);
        eve.on("snap.util.getattr.marker-start", getter("start"))(-1);
        eve.on("snap.util.getattr.markerStart", getter("start"))(-1);
        eve.on("snap.util.getattr.marker-mid", getter("mid"))(-1);
        eve.on("snap.util.getattr.markerMid", getter("mid"))(-1);
        eve.on("snap.util.attr.marker-end", setter("end"))(-1);
        eve.on("snap.util.attr.markerEnd", setter("end"))(-1);
        eve.on("snap.util.attr.marker-start", setter("start"))(-1);
        eve.on("snap.util.attr.markerStart", setter("start"))(-1);
        eve.on("snap.util.attr.marker-mid", setter("mid"))(-1);
        eve.on("snap.util.attr.markerMid", setter("mid"))(-1);
    }());
    eve.on("snap.util.getattr.r", function () {
        if (this.type == "rect" && $(this.node, "rx") == $(this.node, "ry")) {
            eve.stop();
            return $(this.node, "rx");
        }
    })(-1);
    function textExtract(node) {
        var out = [];
        var children = node.childNodes;
        for (var i = 0, ii = children.length; i < ii; i++) {
            var chi = children[i];
            if (chi.nodeType == 3) {
                out.push(chi.nodeValue);
            }
            if (chi.tagName == "tspan") {
                if (chi.childNodes.length == 1 && chi.firstChild.nodeType == 3) {
                    out.push(chi.firstChild.nodeValue);
                } else {
                    out.push(textExtract(chi));
                }
            }
        }
        return out;
    }
    eve.on("snap.util.getattr.text", function () {
        if (this.type == "text" || this.type == "tspan") {
            eve.stop();
            var out = textExtract(this.node);
            return out.length == 1 ? out[0] : out;
        }
    })(-1);
    eve.on("snap.util.getattr.#text", function () {
        return this.node.textContent;
    })(-1);
    eve.on("snap.util.getattr.fill", function (internal) {
        if (internal) {
            return;
        }
        eve.stop();
        var value = eve("snap.util.getattr.fill", this, true).firstDefined();
        return Snap(Snap.deurl(value)) || value;
    })(-1);
    eve.on("snap.util.getattr.stroke", function (internal) {
        if (internal) {
            return;
        }
        eve.stop();
        var value = eve("snap.util.getattr.stroke", this, true).firstDefined();
        return Snap(Snap.deurl(value)) || value;
    })(-1);
    eve.on("snap.util.getattr.viewBox", function () {
        eve.stop();
        var vb = $(this.node, "viewBox");
        if (vb) {
            vb = vb.split(separator);
            return Snap._.box(+vb[0], +vb[1], +vb[2], +vb[3]);
        } else {
            return;
        }
    })(-1);
    eve.on("snap.util.getattr.points", function () {
        var p = $(this.node, "points");
        eve.stop();
        if (p) {
            return p.split(separator);
        } else {
            return;
        }
    })(-1);
    eve.on("snap.util.getattr.path", function () {
        var p = $(this.node, "d");
        eve.stop();
        return p;
    })(-1);
    eve.on("snap.util.getattr.class", function () {
        return this.node.className.baseVal;
    })(-1);
    function getFontSize() {
        eve.stop();
        return this.node.style.fontSize;
    }
    eve.on("snap.util.getattr.fontSize", getFontSize)(-1);
    eve.on("snap.util.getattr.font-size", getFontSize)(-1);
});

// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var rgNotSpace = /\S+/g,
        rgBadSpace = /[\t\r\n\f]/g,
        rgTrim = /(^\s+|\s+$)/g,
        Str = String,
        elproto = Element.prototype;
    /*\
     * Element.addClass
     [ method ]
     **
     * Adds given class name or list of class names to the element.
     - value (string) class name or space separated list of class names
     **
     = (Element) original element.
    \*/
    elproto.addClass = function (value) {
        var classes = Str(value || "").match(rgNotSpace) || [],
            elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [],
            j,
            pos,
            clazz,
            finalValue;

        if (classes.length) {
            j = 0;
            while (clazz = classes[j++]) {
                pos = curClasses.indexOf(clazz);
                if (!~pos) {
                    curClasses.push(clazz);
                }
            }

            finalValue = curClasses.join(" ");
            if (className != finalValue) {
                elem.className.baseVal = finalValue;
            }
        }
        return this;
    };
    /*\
     * Element.removeClass
     [ method ]
     **
     * Removes given class name or list of class names from the element.
     - value (string) class name or space separated list of class names
     **
     = (Element) original element.
    \*/
    elproto.removeClass = function (value) {
        var classes = Str(value || "").match(rgNotSpace) || [],
            elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [],
            j,
            pos,
            clazz,
            finalValue;
        if (curClasses.length) {
            j = 0;
            while (clazz = classes[j++]) {
                pos = curClasses.indexOf(clazz);
                if (~pos) {
                    curClasses.splice(pos, 1);
                }
            }

            finalValue = curClasses.join(" ");
            if (className != finalValue) {
                elem.className.baseVal = finalValue;
            }
        }
        return this;
    };
    /*\
     * Element.hasClass
     [ method ]
     **
     * Checks if the element has a given class name in the list of class names applied to it.
     - value (string) class name
     **
     = (boolean) `true` if the element has given class
    \*/
    elproto.hasClass = function (value) {
        var elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [];
        return !!~curClasses.indexOf(value);
    };
    /*\
     * Element.toggleClass
     [ method ]
     **
     * Add or remove one or more classes from the element, depending on either
     * the class’s presence or the value of the `flag` argument.
     - value (string) class name or space separated list of class names
     - flag (boolean) value to determine whether the class should be added or removed
     **
     = (Element) original element.
    \*/
    elproto.toggleClass = function (value, flag) {
        if (flag != null) {
            if (flag) {
                return this.addClass(value);
            } else {
                return this.removeClass(value);
            }
        }
        var classes = (value || "").match(rgNotSpace) || [],
            elem = this.node,
            className = elem.className.baseVal,
            curClasses = className.match(rgNotSpace) || [],
            j,
            pos,
            clazz,
            finalValue;
        j = 0;
        while (clazz = classes[j++]) {
            pos = curClasses.indexOf(clazz);
            if (~pos) {
                curClasses.splice(pos, 1);
            } else {
                curClasses.push(clazz);
            }
        }

        finalValue = curClasses.join(" ");
        if (className != finalValue) {
            elem.className.baseVal = finalValue;
        }
        return this;
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var operators = {
            "+": function (x, y) {
                    return x + y;
                },
            "-": function (x, y) {
                    return x - y;
                },
            "/": function (x, y) {
                    return x / y;
                },
            "*": function (x, y) {
                    return x * y;
                }
        },
        Str = String,
        reUnit = /[a-z]+$/i,
        reAddon = /^\s*([+\-\/*])\s*=\s*([\d.eE+\-]+)\s*([^\d\s]+)?\s*$/;
    function getNumber(val) {
        return val;
    }
    function getUnit(unit) {
        return function (val) {
            return +val.toFixed(3) + unit;
        };
    }
    eve.on("snap.util.attr", function (val) {
        var plus = Str(val).match(reAddon);
        if (plus) {
            var evnt = eve.nt(),
                name = evnt.substring(evnt.lastIndexOf(".") + 1),
                a = this.attr(name),
                atr = {};
            eve.stop();
            var unit = plus[3] || "",
                aUnit = a.match(reUnit),
                op = operators[plus[1]];
            if (aUnit && aUnit == unit) {
                val = op(parseFloat(a), +plus[2]);
            } else {
                a = this.asPX(name);
                val = op(this.asPX(name), this.asPX(name, plus[2] + unit));
            }
            if (isNaN(a) || isNaN(val)) {
                return;
            }
            atr[name] = val;
            this.attr(atr);
        }
    })(-10);
    eve.on("snap.util.equal", function (name, b) {
        var A, B, a = Str(this.attr(name) || ""),
            el = this,
            bplus = Str(b).match(reAddon);
        if (bplus) {
            eve.stop();
            var unit = bplus[3] || "",
                aUnit = a.match(reUnit),
                op = operators[bplus[1]];
            if (aUnit && aUnit == unit) {
                return {
                    from: parseFloat(a),
                    to: op(parseFloat(a), +bplus[2]),
                    f: getUnit(aUnit)
                };
            } else {
                a = this.asPX(name);
                return {
                    from: a,
                    to: op(a, this.asPX(name, bplus[2] + unit)),
                    f: getNumber
                };
            }
        }
    })(-10);
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var proto = Paper.prototype,
        is = Snap.is;
    /*\
     * Paper.rect
     [ method ]
     *
     * Draws a rectangle
     **
     - x (number) x coordinate of the top left corner
     - y (number) y coordinate of the top left corner
     - width (number) width
     - height (number) height
     - rx (number) #optional horizontal radius for rounded corners, default is 0
     - ry (number) #optional vertical radius for rounded corners, default is rx or 0
     = (object) the `rect` element
     **
     > Usage
     | // regular rectangle
     | var c = paper.rect(10, 10, 50, 50);
     | // rectangle with rounded corners
     | var c = paper.rect(40, 40, 50, 50, 10);
    \*/
    proto.rect = function (x, y, w, h, rx, ry) {
        var attr;
        if (ry == null) {
            ry = rx;
        }
        if (is(x, "object") && x == "[object Object]") {
            attr = x;
        } else if (x != null) {
            attr = {
                x: x,
                y: y,
                width: w,
                height: h
            };
            if (rx != null) {
                attr.rx = rx;
                attr.ry = ry;
            }
        }
        return this.el("rect", attr);
    };
    /*\
     * Paper.circle
     [ method ]
     **
     * Draws a circle
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - r (number) radius
     = (object) the `circle` element
     **
     > Usage
     | var c = paper.circle(50, 50, 40);
    \*/
    proto.circle = function (cx, cy, r) {
        var attr;
        if (is(cx, "object") && cx == "[object Object]") {
            attr = cx;
        } else if (cx != null) {
            attr = {
                cx: cx,
                cy: cy,
                r: r
            };
        }
        return this.el("circle", attr);
    };

    var preload = (function () {
        function onerror() {
            this.parentNode.removeChild(this);
        }
        return function (src, f) {
            var img = glob.doc.createElement("img"),
                body = glob.doc.body;
            img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
            img.onload = function () {
                f.call(img);
                img.onload = img.onerror = null;
                body.removeChild(img);
            };
            img.onerror = onerror;
            body.appendChild(img);
            img.src = src;
        };
    }());

    /*\
     * Paper.image
     [ method ]
     **
     * Places an image on the surface
     **
     - src (string) URI of the source image
     - x (number) x offset position
     - y (number) y offset position
     - width (number) width of the image
     - height (number) height of the image
     = (object) the `image` element
     * or
     = (object) Snap element object with type `image`
     **
     > Usage
     | var c = paper.image("apple.png", 10, 10, 80, 80);
    \*/
    proto.image = function (src, x, y, width, height) {
        var el = this.el("image");
        if (is(src, "object") && "src" in src) {
            el.attr(src);
        } else if (src != null) {
            var set = {
                "xlink:href": src,
                preserveAspectRatio: "none"
            };
            if (x != null && y != null) {
                set.x = x;
                set.y = y;
            }
            if (width != null && height != null) {
                set.width = width;
                set.height = height;
            } else {
                preload(src, function () {
                    Snap._.$(el.node, {
                        width: this.offsetWidth,
                        height: this.offsetHeight
                    });
                });
            }
            Snap._.$(el.node, set);
        }
        return el;
    };
    /*\
     * Paper.ellipse
     [ method ]
     **
     * Draws an ellipse
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - rx (number) horizontal radius
     - ry (number) vertical radius
     = (object) the `ellipse` element
     **
     > Usage
     | var c = paper.ellipse(50, 50, 40, 20);
    \*/
    proto.ellipse = function (cx, cy, rx, ry) {
        var attr;
        if (is(cx, "object") && cx == "[object Object]") {
            attr = cx;
        } else if (cx != null) {
            attr ={
                cx: cx,
                cy: cy,
                rx: rx,
                ry: ry
            };
        }
        return this.el("ellipse", attr);
    };
    // SIERRA Paper.path(): Unclear from the link what a Catmull-Rom curveto is, and why it would make life any easier.
    /*\
     * Paper.path
     [ method ]
     **
     * Creates a `<path>` element using the given string as the path's definition
     - pathString (string) #optional path string in SVG format
     * Path string consists of one-letter commands, followed by comma seprarated arguments in numerical form. Example:
     | "M10,20L30,40"
     * This example features two commands: `M`, with arguments `(10, 20)` and `L` with arguments `(30, 40)`. Uppercase letter commands express coordinates in absolute terms, while lowercase commands express them in relative terms from the most recently declared coordinates.
     *
     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a> or <a href="https://developer.mozilla.org/en/SVG/Tutorial/Paths">article about path strings at MDN</a>.</p>
     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
     # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
     # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
     * * _Catmull-Rom curveto_ is a not standard SVG command and added to make life easier.
     * Note: there is a special case when a path consists of only three commands: `M10,10R…z`. In this case the path connects back to its starting point.
     > Usage
     | var c = paper.path("M10 10L90 90");
     | // draw a diagonal line:
     | // move to 10,10, line to 90,90
    \*/
    proto.path = function (d) {
        var attr;
        if (is(d, "object") && !is(d, "array")) {
            attr = d;
        } else if (d) {
            attr = {d: d};
        }
        return this.el("path", attr);
    };
    /*\
     * Paper.g
     [ method ]
     **
     * Creates a group element
     **
     - varargs (…) #optional elements to nest within the group
     = (object) the `g` element
     **
     > Usage
     | var c1 = paper.circle(),
     |     c2 = paper.rect(),
     |     g = paper.g(c2, c1); // note that the order of elements is different
     * or
     | var c1 = paper.circle(),
     |     c2 = paper.rect(),
     |     g = paper.g();
     | g.add(c2, c1);
    \*/
    /*\
     * Paper.group
     [ method ]
     **
     * See @Paper.g
    \*/
    proto.group = proto.g = function (first) {
        var attr,
            el = this.el("g");
        if (arguments.length == 1 && first && !first.type) {
            el.attr(first);
        } else if (arguments.length) {
            el.add(Array.prototype.slice.call(arguments, 0));
        }
        return el;
    };
    /*\
     * Paper.svg
     [ method ]
     **
     * Creates a nested SVG element.
     - x (number) @optional X of the element
     - y (number) @optional Y of the element
     - width (number) @optional width of the element
     - height (number) @optional height of the element
     - vbx (number) @optional viewbox X
     - vby (number) @optional viewbox Y
     - vbw (number) @optional viewbox width
     - vbh (number) @optional viewbox height
     **
     = (object) the `svg` element
     **
    \*/
    proto.svg = function (x, y, width, height, vbx, vby, vbw, vbh) {
        var attrs = {};
        if (is(x, "object") && y == null) {
            attrs = x;
        } else {
            if (x != null) {
                attrs.x = x;
            }
            if (y != null) {
                attrs.y = y;
            }
            if (width != null) {
                attrs.width = width;
            }
            if (height != null) {
                attrs.height = height;
            }
            if (vbx != null && vby != null && vbw != null && vbh != null) {
                attrs.viewBox = [vbx, vby, vbw, vbh];
            }
        }
        return this.el("svg", attrs);
    };
    /*\
     * Paper.mask
     [ method ]
     **
     * Equivalent in behaviour to @Paper.g, except it’s a mask.
     **
     = (object) the `mask` element
     **
    \*/
    proto.mask = function (first) {
        var attr,
            el = this.el("mask");
        if (arguments.length == 1 && first && !first.type) {
            el.attr(first);
        } else if (arguments.length) {
            el.add(Array.prototype.slice.call(arguments, 0));
        }
        return el;
    };
    /*\
     * Paper.ptrn
     [ method ]
     **
     * Equivalent in behaviour to @Paper.g, except it’s a pattern.
     - x (number) @optional X of the element
     - y (number) @optional Y of the element
     - width (number) @optional width of the element
     - height (number) @optional height of the element
     - vbx (number) @optional viewbox X
     - vby (number) @optional viewbox Y
     - vbw (number) @optional viewbox width
     - vbh (number) @optional viewbox height
     **
     = (object) the `pattern` element
     **
    \*/
    proto.ptrn = function (x, y, width, height, vx, vy, vw, vh) {
        if (is(x, "object")) {
            var attr = x;
        } else {
            attr = {patternUnits: "userSpaceOnUse"};
            if (x) {
                attr.x = x;
            }
            if (y) {
                attr.y = y;
            }
            if (width != null) {
                attr.width = width;
            }
            if (height != null) {
                attr.height = height;
            }
            if (vx != null && vy != null && vw != null && vh != null) {
                attr.viewBox = [vx, vy, vw, vh];
            } else {
                attr.viewBox = [x || 0, y || 0, width || 0, height || 0];
            }
        }
        return this.el("pattern", attr);
    };
    /*\
     * Paper.use
     [ method ]
     **
     * Creates a <use> element.
     - id (string) @optional id of element to link
     * or
     - id (Element) @optional element to link
     **
     = (object) the `use` element
     **
    \*/
    proto.use = function (id) {
        if (id != null) {
            if (id instanceof Element) {
                if (!id.attr("id")) {
                    id.attr({id: Snap._.id(id)});
                }
                id = id.attr("id");
            }
            if (String(id).charAt() == "#") {
                id = id.substring(1);
            }
            return this.el("use", {"xlink:href": "#" + id});
        } else {
            return Element.prototype.use.call(this);
        }
    };
    /*\
     * Paper.symbol
     [ method ]
     **
     * Creates a <symbol> element.
     - vbx (number) @optional viewbox X
     - vby (number) @optional viewbox Y
     - vbw (number) @optional viewbox width
     - vbh (number) @optional viewbox height
     = (object) the `symbol` element
     **
    \*/
    proto.symbol = function (vx, vy, vw, vh) {
        var attr = {};
        if (vx != null && vy != null && vw != null && vh != null) {
            attr.viewBox = [vx, vy, vw, vh];
        }

        return this.el("symbol", attr);
    };
    /*\
     * Paper.text
     [ method ]
     **
     * Draws a text string
     **
     - x (number) x coordinate position
     - y (number) y coordinate position
     - text (string|array) The text string to draw or array of strings to nest within separate `<tspan>` elements
     = (object) the `text` element
     **
     > Usage
     | var t1 = paper.text(50, 50, "Snap");
     | var t2 = paper.text(50, 50, ["S","n","a","p"]);
     | // Text path usage
     | t1.attr({textpath: "M10,10L100,100"});
     | // or
     | var pth = paper.path("M10,10L100,100");
     | t1.attr({textpath: pth});
    \*/
    proto.text = function (x, y, text) {
        var attr = {};
        if (is(x, "object")) {
            attr = x;
        } else if (x != null) {
            attr = {
                x: x,
                y: y,
                text: text || ""
            };
        }
        return this.el("text", attr);
    };
    /*\
     * Paper.line
     [ method ]
     **
     * Draws a line
     **
     - x1 (number) x coordinate position of the start
     - y1 (number) y coordinate position of the start
     - x2 (number) x coordinate position of the end
     - y2 (number) y coordinate position of the end
     = (object) the `line` element
     **
     > Usage
     | var t1 = paper.line(50, 50, 100, 100);
    \*/
    proto.line = function (x1, y1, x2, y2) {
        var attr = {};
        if (is(x1, "object")) {
            attr = x1;
        } else if (x1 != null) {
            attr = {
                x1: x1,
                x2: x2,
                y1: y1,
                y2: y2
            };
        }
        return this.el("line", attr);
    };
    /*\
     * Paper.polyline
     [ method ]
     **
     * Draws a polyline
     **
     - points (array) array of points
     * or
     - varargs (…) points
     = (object) the `polyline` element
     **
     > Usage
     | var p1 = paper.polyline([10, 10, 100, 100]);
     | var p2 = paper.polyline(10, 10, 100, 100);
    \*/
    proto.polyline = function (points) {
        if (arguments.length > 1) {
            points = Array.prototype.slice.call(arguments, 0);
        }
        var attr = {};
        if (is(points, "object") && !is(points, "array")) {
            attr = points;
        } else if (points != null) {
            attr = {points: points};
        }
        return this.el("polyline", attr);
    };
    /*\
     * Paper.polygon
     [ method ]
     **
     * Draws a polygon. See @Paper.polyline
    \*/
    proto.polygon = function (points) {
        if (arguments.length > 1) {
            points = Array.prototype.slice.call(arguments, 0);
        }
        var attr = {};
        if (is(points, "object") && !is(points, "array")) {
            attr = points;
        } else if (points != null) {
            attr = {points: points};
        }
        return this.el("polygon", attr);
    };
    // gradients
    (function () {
        var $ = Snap._.$;
        // gradients' helpers
        /*\
         * Element.stops
         [ method ]
         **
         * Only for gradients!
         * Returns array of gradient stops elements.
         = (array) the stops array.
        \*/
        function Gstops() {
            return this.selectAll("stop");
        }
        /*\
         * Element.addStop
         [ method ]
         **
         * Only for gradients!
         * Adds another stop to the gradient.
         - color (string) stops color
         - offset (number) stops offset 0..100
         = (object) gradient element
        \*/
        function GaddStop(color, offset) {
            var stop = $("stop"),
                attr = {
                    offset: +offset + "%"
                };
            color = Snap.color(color);
            attr["stop-color"] = color.hex;
            if (color.opacity < 1) {
                attr["stop-opacity"] = color.opacity;
            }
            $(stop, attr);
            var stops = this.stops(),
                inserted;
            for (var i = 0; i < stops.length; i++) {
                var stopOffset = parseFloat(stops[i].attr("offset"));
                if (stopOffset > offset) {
                    this.node.insertBefore(stop, stops[i].node);
                    inserted = true;
                    break;
                }
            }
            if (!inserted) {
                this.node.appendChild(stop);
            }
            return this;
        }
        function GgetBBox() {
            if (this.type == "linearGradient") {
                var x1 = $(this.node, "x1") || 0,
                    x2 = $(this.node, "x2") || 1,
                    y1 = $(this.node, "y1") || 0,
                    y2 = $(this.node, "y2") || 0;
                return Snap._.box(x1, y1, math.abs(x2 - x1), math.abs(y2 - y1));
            } else {
                var cx = this.node.cx || .5,
                    cy = this.node.cy || .5,
                    r = this.node.r || 0;
                return Snap._.box(cx - r, cy - r, r * 2, r * 2);
            }
        }
        /*\
         * Element.setStops
         [ method ]
         **
         * Only for gradients!
         * Updates stops of the gradient based on passed gradient descriptor. See @Ppaer.gradient
         - str (string) gradient descriptor part after `()`.
         = (object) gradient element
         | var g = paper.gradient("l(0, 0, 1, 1)#000-#f00-#fff");
         | g.setStops("#fff-#000-#f00-#fc0");
        \*/
        function GsetStops(str) {
            var grad = str,
                stops = this.stops();
            if (typeof str == "string") {
                grad = eve("snap.util.grad.parse", null, "l(0,0,0,1)" + str).firstDefined().stops;
            }
            if (!Snap.is(grad, "array")) {
                return;
            }
            for (var i = 0; i < stops.length; i++) {
                if (grad[i]) {
                    var color = Snap.color(grad[i].color),
                        attr = {"offset": grad[i].offset + "%"};
                    attr["stop-color"] = color.hex;
                    if (color.opacity < 1) {
                        attr["stop-opacity"] = color.opacity;
                    }
                    stops[i].attr(attr);
                } else {
                    stops[i].remove();
                }
            }
            for (i = stops.length; i < grad.length; i++) {
                this.addStop(grad[i].color, grad[i].offset);
            }
            return this;
        }
        function gradient(defs, str) {
            var grad = eve("snap.util.grad.parse", null, str).firstDefined(),
                el;
            if (!grad) {
                return null;
            }
            grad.params.unshift(defs);
            if (grad.type.toLowerCase() == "l") {
                el = gradientLinear.apply(0, grad.params);
            } else {
                el = gradientRadial.apply(0, grad.params);
            }
            if (grad.type != grad.type.toLowerCase()) {
                $(el.node, {
                    gradientUnits: "userSpaceOnUse"
                });
            }
            var stops = grad.stops,
                len = stops.length;
            for (var i = 0; i < len; i++) {
                var stop = stops[i];
                el.addStop(stop.color, stop.offset);
            }
            return el;
        }
        function gradientLinear(defs, x1, y1, x2, y2) {
            var el = Snap._.make("linearGradient", defs);
            el.stops = Gstops;
            el.addStop = GaddStop;
            el.getBBox = GgetBBox;
            el.setStops = GsetStops;
            if (x1 != null) {
                $(el.node, {
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2
                });
            }
            return el;
        }
        function gradientRadial(defs, cx, cy, r, fx, fy) {
            var el = Snap._.make("radialGradient", defs);
            el.stops = Gstops;
            el.addStop = GaddStop;
            el.getBBox = GgetBBox;
            if (cx != null) {
                $(el.node, {
                    cx: cx,
                    cy: cy,
                    r: r
                });
            }
            if (fx != null && fy != null) {
                $(el.node, {
                    fx: fx,
                    fy: fy
                });
            }
            return el;
        }
        /*\
         * Paper.gradient
         [ method ]
         **
         * Creates a gradient element
         **
         - gradient (string) gradient descriptor
         > Gradient Descriptor
         * The gradient descriptor is an expression formatted as
         * follows: `<type>(<coords>)<colors>`.  The `<type>` can be
         * either linear or radial.  The uppercase `L` or `R` letters
         * indicate absolute coordinates offset from the SVG surface.
         * Lowercase `l` or `r` letters indicate coordinates
         * calculated relative to the element to which the gradient is
         * applied.  Coordinates specify a linear gradient vector as
         * `x1`, `y1`, `x2`, `y2`, or a radial gradient as `cx`, `cy`,
         * `r` and optional `fx`, `fy` specifying a focal point away
         * from the center of the circle. Specify `<colors>` as a list
         * of dash-separated CSS color values.  Each color may be
         * followed by a custom offset value, separated with a colon
         * character.
         > Examples
         * Linear gradient, relative from top-left corner to bottom-right
         * corner, from black through red to white:
         | var g = paper.gradient("l(0, 0, 1, 1)#000-#f00-#fff");
         * Linear gradient, absolute from (0, 0) to (100, 100), from black
         * through red at 25% to white:
         | var g = paper.gradient("L(0, 0, 100, 100)#000-#f00:25-#fff");
         * Radial gradient, relative from the center of the element with radius
         * half the width, from black to white:
         | var g = paper.gradient("r(0.5, 0.5, 0.5)#000-#fff");
         * To apply the gradient:
         | paper.circle(50, 50, 40).attr({
         |     fill: g
         | });
         = (object) the `gradient` element
        \*/
        proto.gradient = function (str) {
            return gradient(this.defs, str);
        };
        proto.gradientLinear = function (x1, y1, x2, y2) {
            return gradientLinear(this.defs, x1, y1, x2, y2);
        };
        proto.gradientRadial = function (cx, cy, r, fx, fy) {
            return gradientRadial(this.defs, cx, cy, r, fx, fy);
        };
        /*\
         * Paper.toString
         [ method ]
         **
         * Returns SVG code for the @Paper
         = (string) SVG code for the @Paper
        \*/
        proto.toString = function () {
            var doc = this.node.ownerDocument,
                f = doc.createDocumentFragment(),
                d = doc.createElement("div"),
                svg = this.node.cloneNode(true),
                res;
            f.appendChild(d);
            d.appendChild(svg);
            Snap._.$(svg, {xmlns: "http://www.w3.org/2000/svg"});
            res = d.innerHTML;
            f.removeChild(f.firstChild);
            return res;
        };
        /*\
         * Paper.toDataURL
         [ method ]
         **
         * Returns SVG code for the @Paper as Data URI string.
         = (string) Data URI string
        \*/
        proto.toDataURL = function () {
            if (window && window.btoa) {
                return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(this)));
            }
        };
        /*\
         * Paper.clear
         [ method ]
         **
         * Removes all child nodes of the paper, except <defs>.
        \*/
        proto.clear = function () {
            var node = this.node.firstChild,
                next;
            while (node) {
                next = node.nextSibling;
                if (node.tagName != "defs") {
                    node.parentNode.removeChild(node);
                } else {
                    proto.clear.call({node: node});
                }
                node = next;
            }
        };
    }());
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var elproto = Element.prototype,
        is = Snap.is,
        clone = Snap._.clone,
        has = "hasOwnProperty",
        p2s = /,?([a-z]),?/gi,
        toFloat = parseFloat,
        math = Math,
        PI = math.PI,
        mmin = math.min,
        mmax = math.max,
        pow = math.pow,
        abs = math.abs;
    function paths(ps) {
        var p = paths.ps = paths.ps || {};
        if (p[ps]) {
            p[ps].sleep = 100;
        } else {
            p[ps] = {
                sleep: 100
            };
        }
        setTimeout(function () {
            for (var key in p) if (p[has](key) && key != ps) {
                p[key].sleep--;
                !p[key].sleep && delete p[key];
            }
        });
        return p[ps];
    }
    function box(x, y, width, height) {
        if (x == null) {
            x = y = width = height = 0;
        }
        if (y == null) {
            y = x.y;
            width = x.width;
            height = x.height;
            x = x.x;
        }
        return {
            x: x,
            y: y,
            width: width,
            w: width,
            height: height,
            h: height,
            x2: x + width,
            y2: y + height,
            cx: x + width / 2,
            cy: y + height / 2,
            r1: math.min(width, height) / 2,
            r2: math.max(width, height) / 2,
            r0: math.sqrt(width * width + height * height) / 2,
            path: rectPath(x, y, width, height),
            vb: [x, y, width, height].join(" ")
        };
    }
    function toString() {
        return this.join(",").replace(p2s, "$1");
    }
    function pathClone(pathArray) {
        var res = clone(pathArray);
        res.toString = toString;
        return res;
    }
    function getPointAtSegmentLength(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
        if (length == null) {
            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        } else {
            return findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y,
                getTotLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
        }
    }
    function getLengthFactory(istotal, subpath) {
        function O(val) {
            return +(+val).toFixed(3);
        }
        return Snap._.cacher(function (path, length, onlystart) {
            if (path instanceof Element) {
                path = path.attr("d");
            }
            path = path2curve(path);
            var x, y, p, l, sp = "", subpaths = {}, point,
                len = 0;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = +p[1];
                    y = +p[2];
                } else {
                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    if (len + l > length) {
                        if (subpath && !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            sp += [
                                "C" + O(point.start.x),
                                O(point.start.y),
                                O(point.m.x),
                                O(point.m.y),
                                O(point.x),
                                O(point.y)
                            ];
                            if (onlystart) {return sp;}
                            subpaths.start = sp;
                            sp = [
                                "M" + O(point.x),
                                O(point.y) + "C" + O(point.n.x),
                                O(point.n.y),
                                O(point.end.x),
                                O(point.end.y),
                                O(p[5]),
                                O(p[6])
                            ].join();
                            len += l;
                            x = +p[5];
                            y = +p[6];
                            continue;
                        }
                        if (!istotal && !subpath) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            return point;
                        }
                    }
                    len += l;
                    x = +p[5];
                    y = +p[6];
                }
                sp += p.shift() + p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
            return point;
        }, null, Snap._.clone);
    }
    var getTotalLength = getLengthFactory(1),
        getPointAtLength = getLengthFactory(),
        getSubpathsAtLength = getLengthFactory(0, 1);
    function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t,
            t13 = pow(t1, 3),
            t12 = pow(t1, 2),
            t2 = t * t,
            t3 = t2 * t,
            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
            ax = t1 * p1x + t * c1x,
            ay = t1 * p1y + t * c1y,
            cx = t1 * c2x + t * p2x,
            cy = t1 * c2y + t * p2y,
            alpha = 90 - math.atan2(mx - nx, my - ny) * 180 / PI;
        // (mx > nx || my < ny) && (alpha += 180);
        return {
            x: x,
            y: y,
            m: {x: mx, y: my},
            n: {x: nx, y: ny},
            start: {x: ax, y: ay},
            end: {x: cx, y: cy},
            alpha: alpha
        };
    }
    function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!Snap.is(p1x, "array")) {
            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }
        var bbox = curveDim.apply(null, p1x);
        return box(
            bbox.min.x,
            bbox.min.y,
            bbox.max.x - bbox.min.x,
            bbox.max.y - bbox.min.y
        );
    }
    function isPointInsideBBox(bbox, x, y) {
        return  x >= bbox.x &&
                x <= bbox.x + bbox.width &&
                y >= bbox.y &&
                y <= bbox.y + bbox.height;
    }
    function isBBoxIntersect(bbox1, bbox2) {
        bbox1 = box(bbox1);
        bbox2 = box(bbox2);
        return isPointInsideBBox(bbox2, bbox1.x, bbox1.y)
            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y)
            || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2)
            || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2)
            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y)
            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y)
            || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2)
            || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2)
            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x
                || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y
                || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    }
    function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
    }
    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z == null) {
            z = 1;
        }
        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2,
            n = 12,
            Tvalues = [-.1252,.1252,-.3678,.3678,-.5873,.5873,-.7699,.7699,-.9041,.9041,-.9816,.9816],
            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
            sum = 0;
        for (var i = 0; i < n; i++) {
            var ct = z2 * Tvalues[i] + z2,
                xbase = base3(ct, x1, x2, x3, x4),
                ybase = base3(ct, y1, y2, y3, y4),
                comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * math.sqrt(comb);
        }
        return z2 * sum;
    }
    function getTotLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
            return;
        }
        var t = 1,
            step = t / 2,
            t2 = t - step,
            l,
            e = .01;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        while (abs(l - ll) > e) {
            step /= 2;
            t2 += (l < ll ? 1 : -1) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        return t2;
    }
    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (
            mmax(x1, x2) < mmin(x3, x4) ||
            mmin(x1, x2) > mmax(x3, x4) ||
            mmax(y1, y2) < mmin(y3, y4) ||
            mmin(y1, y2) > mmax(y3, y4)
        ) {
            return;
        }
        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (!denominator) {
            return;
        }
        var px = nx / denominator,
            py = ny / denominator,
            px2 = +px.toFixed(2),
            py2 = +py.toFixed(2);
        if (
            px2 < +mmin(x1, x2).toFixed(2) ||
            px2 > +mmax(x1, x2).toFixed(2) ||
            px2 < +mmin(x3, x4).toFixed(2) ||
            px2 > +mmax(x3, x4).toFixed(2) ||
            py2 < +mmin(y1, y2).toFixed(2) ||
            py2 > +mmax(y1, y2).toFixed(2) ||
            py2 < +mmin(y3, y4).toFixed(2) ||
            py2 > +mmax(y3, y4).toFixed(2)
        ) {
            return;
        }
        return {x: px, y: py};
    }
    function inter(bez1, bez2) {
        return interHelper(bez1, bez2);
    }
    function interCount(bez1, bez2) {
        return interHelper(bez1, bez2, 1);
    }
    function interHelper(bez1, bez2, justCount) {
        var bbox1 = bezierBBox(bez1),
            bbox2 = bezierBBox(bez2);
        if (!isBBoxIntersect(bbox1, bbox2)) {
            return justCount ? 0 : [];
        }
        var l1 = bezlen.apply(0, bez1),
            l2 = bezlen.apply(0, bez2),
            n1 = ~~(l1 / 8),
            n2 = ~~(l2 / 8),
            dots1 = [],
            dots2 = [],
            xy = {},
            res = justCount ? 0 : [];
        for (var i = 0; i < n1 + 1; i++) {
            var p = findDotsAtSegment.apply(0, bez1.concat(i / n1));
            dots1.push({x: p.x, y: p.y, t: i / n1});
        }
        for (i = 0; i < n2 + 1; i++) {
            p = findDotsAtSegment.apply(0, bez2.concat(i / n2));
            dots2.push({x: p.x, y: p.y, t: i / n2});
        }
        for (i = 0; i < n1; i++) {
            for (var j = 0; j < n2; j++) {
                var di = dots1[i],
                    di1 = dots1[i + 1],
                    dj = dots2[j],
                    dj1 = dots2[j + 1],
                    ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                    cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                if (is) {
                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                        continue;
                    }
                    xy[is.x.toFixed(4)] = is.y.toFixed(4);
                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                    if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
                        if (justCount) {
                            res++;
                        } else {
                            res.push({
                                x: is.x,
                                y: is.y,
                                t1: t1,
                                t2: t2
                            });
                        }
                    }
                }
            }
        }
        return res;
    }
    function pathIntersection(path1, path2) {
        return interPathHelper(path1, path2);
    }
    function pathIntersectionNumber(path1, path2) {
        return interPathHelper(path1, path2, 1);
    }
    function interPathHelper(path1, path2, justCount) {
        path1 = path2curve(path1);
        path2 = path2curve(path2);
        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
            res = justCount ? 0 : [];
        for (var i = 0, ii = path1.length; i < ii; i++) {
            var pi = path1[i];
            if (pi[0] == "M") {
                x1 = x1m = pi[1];
                y1 = y1m = pi[2];
            } else {
                if (pi[0] == "C") {
                    bez1 = [x1, y1].concat(pi.slice(1));
                    x1 = bez1[6];
                    y1 = bez1[7];
                } else {
                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                    x1 = x1m;
                    y1 = y1m;
                }
                for (var j = 0, jj = path2.length; j < jj; j++) {
                    var pj = path2[j];
                    if (pj[0] == "M") {
                        x2 = x2m = pj[1];
                        y2 = y2m = pj[2];
                    } else {
                        if (pj[0] == "C") {
                            bez2 = [x2, y2].concat(pj.slice(1));
                            x2 = bez2[6];
                            y2 = bez2[7];
                        } else {
                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        var intr = interHelper(bez1, bez2, justCount);
                        if (justCount) {
                            res += intr;
                        } else {
                            for (var k = 0, kk = intr.length; k < kk; k++) {
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        return res;
    }
    function isPointInsidePath(path, x, y) {
        var bbox = pathBBox(path);
        return isPointInsideBBox(bbox, x, y) &&
               interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
    }
    function pathBBox(path) {
        var pth = paths(path);
        if (pth.bbox) {
            return clone(pth.bbox);
        }
        if (!path) {
            return box();
        }
        path = path2curve(path);
        var x = 0,
            y = 0,
            X = [],
            Y = [],
            p;
        for (var i = 0, ii = path.length; i < ii; i++) {
            p = path[i];
            if (p[0] == "M") {
                x = p[1];
                y = p[2];
                X.push(x);
                Y.push(y);
            } else {
                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X.concat(dim.min.x, dim.max.x);
                Y = Y.concat(dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        var xmin = mmin.apply(0, X),
            ymin = mmin.apply(0, Y),
            xmax = mmax.apply(0, X),
            ymax = mmax.apply(0, Y),
            bb = box(xmin, ymin, xmax - xmin, ymax - ymin);
        pth.bbox = clone(bb);
        return bb;
    }
    function rectPath(x, y, w, h, r) {
        if (r) {
            return [
                ["M", +x + +r, y],
                ["l", w - r * 2, 0],
                ["a", r, r, 0, 0, 1, r, r],
                ["l", 0, h - r * 2],
                ["a", r, r, 0, 0, 1, -r, r],
                ["l", r * 2 - w, 0],
                ["a", r, r, 0, 0, 1, -r, -r],
                ["l", 0, r * 2 - h],
                ["a", r, r, 0, 0, 1, r, -r],
                ["z"]
            ];
        }
        var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
        res.toString = toString;
        return res;
    }
    function ellipsePath(x, y, rx, ry, a) {
        if (a == null && ry == null) {
            ry = rx;
        }
        x = +x;
        y = +y;
        rx = +rx;
        ry = +ry;
        if (a != null) {
            var rad = Math.PI / 180,
                x1 = x + rx * Math.cos(-ry * rad),
                x2 = x + rx * Math.cos(-a * rad),
                y1 = y + rx * Math.sin(-ry * rad),
                y2 = y + rx * Math.sin(-a * rad),
                res = [["M", x1, y1], ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
        } else {
            res = [
                ["M", x, y],
                ["m", 0, -ry],
                ["a", rx, ry, 0, 1, 1, 0, 2 * ry],
                ["a", rx, ry, 0, 1, 1, 0, -2 * ry],
                ["z"]
            ];
        }
        res.toString = toString;
        return res;
    }
    var unit2px = Snap._unit2px,
        getPath = {
        path: function (el) {
            return el.attr("path");
        },
        circle: function (el) {
            var attr = unit2px(el);
            return ellipsePath(attr.cx, attr.cy, attr.r);
        },
        ellipse: function (el) {
            var attr = unit2px(el);
            return ellipsePath(attr.cx || 0, attr.cy || 0, attr.rx, attr.ry);
        },
        rect: function (el) {
            var attr = unit2px(el);
            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height, attr.rx, attr.ry);
        },
        image: function (el) {
            var attr = unit2px(el);
            return rectPath(attr.x || 0, attr.y || 0, attr.width, attr.height);
        },
        line: function (el) {
            return "M" + [el.attr("x1") || 0, el.attr("y1") || 0, el.attr("x2"), el.attr("y2")];
        },
        polyline: function (el) {
            return "M" + el.attr("points");
        },
        polygon: function (el) {
            return "M" + el.attr("points") + "z";
        },
        deflt: function (el) {
            var bbox = el.node.getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        }
    };
    function pathToRelative(pathArray) {
        var pth = paths(pathArray),
            lowerCase = String.prototype.toLowerCase;
        if (pth.rel) {
            return pathClone(pth.rel);
        }
        if (!Snap.is(pathArray, "array") || !Snap.is(pathArray && pathArray[0], "array")) {
            pathArray = Snap.parsePathString(pathArray);
        }
        var res = [],
            x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0;
        if (pathArray[0][0] == "M") {
            x = pathArray[0][1];
            y = pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res.push(["M", x, y]);
        }
        for (var i = start, ii = pathArray.length; i < ii; i++) {
            var r = res[i] = [],
                pa = pathArray[i];
            if (pa[0] != lowerCase.call(pa[0])) {
                r[0] = lowerCase.call(pa[0]);
                switch (r[0]) {
                    case "a":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] - x).toFixed(3);
                        r[7] = +(pa[7] - y).toFixed(3);
                        break;
                    case "v":
                        r[1] = +(pa[1] - y).toFixed(3);
                        break;
                    case "m":
                        mx = pa[1];
                        my = pa[2];
                    default:
                        for (var j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
                        }
                }
            } else {
                r = res[i] = [];
                if (pa[0] == "m") {
                    mx = pa[1] + x;
                    my = pa[2] + y;
                }
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    res[i][k] = pa[k];
                }
            }
            var len = res[i].length;
            switch (res[i][0]) {
                case "z":
                    x = mx;
                    y = my;
                    break;
                case "h":
                    x += +res[i][len - 1];
                    break;
                case "v":
                    y += +res[i][len - 1];
                    break;
                default:
                    x += +res[i][len - 2];
                    y += +res[i][len - 1];
            }
        }
        res.toString = toString;
        pth.rel = pathClone(res);
        return res;
    }
    function pathToAbsolute(pathArray) {
        var pth = paths(pathArray);
        if (pth.abs) {
            return pathClone(pth.abs);
        }
        if (!is(pathArray, "array") || !is(pathArray && pathArray[0], "array")) { // rough assumption
            pathArray = Snap.parsePathString(pathArray);
        }
        if (!pathArray || !pathArray.length) {
            return [["M", 0, 0]];
        }
        var res = [],
            x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0,
            pa0;
        if (pathArray[0][0] == "M") {
            x = +pathArray[0][1];
            y = +pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res[0] = ["M", x, y];
        }
        var crz = pathArray.length == 3 &&
            pathArray[0][0] == "M" &&
            pathArray[1][0].toUpperCase() == "R" &&
            pathArray[2][0].toUpperCase() == "Z";
        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
            res.push(r = []);
            pa = pathArray[i];
            pa0 = pa[0];
            if (pa0 != pa0.toUpperCase()) {
                r[0] = pa0.toUpperCase();
                switch (r[0]) {
                    case "A":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +pa[6] + x;
                        r[7] = +pa[7] + y;
                        break;
                    case "V":
                        r[1] = +pa[1] + y;
                        break;
                    case "H":
                        r[1] = +pa[1] + x;
                        break;
                    case "R":
                        var dots = [x, y].concat(pa.slice(1));
                        for (var j = 2, jj = dots.length; j < jj; j++) {
                            dots[j] = +dots[j] + x;
                            dots[++j] = +dots[j] + y;
                        }
                        res.pop();
                        res = res.concat(catmullRom2bezier(dots, crz));
                        break;
                    case "O":
                        res.pop();
                        dots = ellipsePath(x, y, pa[1], pa[2]);
                        dots.push(dots[0]);
                        res = res.concat(dots);
                        break;
                    case "U":
                        res.pop();
                        res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                        r = ["U"].concat(res[res.length - 1].slice(-2));
                        break;
                    case "M":
                        mx = +pa[1] + x;
                        my = +pa[2] + y;
                    default:
                        for (j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +pa[j] + (j % 2 ? x : y);
                        }
                }
            } else if (pa0 == "R") {
                dots = [x, y].concat(pa.slice(1));
                res.pop();
                res = res.concat(catmullRom2bezier(dots, crz));
                r = ["R"].concat(pa.slice(-2));
            } else if (pa0 == "O") {
                res.pop();
                dots = ellipsePath(x, y, pa[1], pa[2]);
                dots.push(dots[0]);
                res = res.concat(dots);
            } else if (pa0 == "U") {
                res.pop();
                res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
                r = ["U"].concat(res[res.length - 1].slice(-2));
            } else {
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    r[k] = pa[k];
                }
            }
            pa0 = pa0.toUpperCase();
            if (pa0 != "O") {
                switch (r[0]) {
                    case "Z":
                        x = +mx;
                        y = +my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = r[r.length - 2];
                        my = r[r.length - 1];
                    default:
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                }
            }
        }
        res.toString = toString;
        pth.abs = pathClone(res);
        return res;
    }
    function l2c(x1, y1, x2, y2) {
        return [x1, y1, x2, y2, x2, y2];
    }
    function q2c(x1, y1, ax, ay, x2, y2) {
        var _13 = 1 / 3,
            _23 = 2 / 3;
        return [
                _13 * x1 + _23 * ax,
                _13 * y1 + _23 * ay,
                _13 * x2 + _23 * ax,
                _13 * y2 + _23 * ay,
                x2,
                y2
            ];
    }
    function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        var _120 = PI * 120 / 180,
            rad = PI / 180 * (+angle || 0),
            res = [],
            xy,
            rotate = Snap._.cacher(function (x, y, rad) {
                var X = x * math.cos(rad) - y * math.sin(rad),
                    Y = x * math.sin(rad) + y * math.cos(rad);
                return {x: X, y: Y};
            });
        if (!rx || !ry) {
            return [x1, y1, x2, y2, x2, y2];
        }
        if (!recursive) {
            xy = rotate(x1, y1, -rad);
            x1 = xy.x;
            y1 = xy.y;
            xy = rotate(x2, y2, -rad);
            x2 = xy.x;
            y2 = xy.y;
            var cos = math.cos(PI / 180 * angle),
                sin = math.sin(PI / 180 * angle),
                x = (x1 - x2) / 2,
                y = (y1 - y2) / 2;
            var h = x * x / (rx * rx) + y * y / (ry * ry);
            if (h > 1) {
                h = math.sqrt(h);
                rx = h * rx;
                ry = h * ry;
            }
            var rx2 = rx * rx,
                ry2 = ry * ry,
                k = (large_arc_flag == sweep_flag ? -1 : 1) *
                    math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                cx = k * rx * y / ry + (x1 + x2) / 2,
                cy = k * -ry * x / rx + (y1 + y2) / 2,
                f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                f2 = math.asin(((y2 - cy) / ry).toFixed(9));

            f1 = x1 < cx ? PI - f1 : f1;
            f2 = x2 < cx ? PI - f2 : f2;
            f1 < 0 && (f1 = PI * 2 + f1);
            f2 < 0 && (f2 = PI * 2 + f2);
            if (sweep_flag && f1 > f2) {
                f1 = f1 - PI * 2;
            }
            if (!sweep_flag && f2 > f1) {
                f2 = f2 - PI * 2;
            }
        } else {
            f1 = recursive[0];
            f2 = recursive[1];
            cx = recursive[2];
            cy = recursive[3];
        }
        var df = f2 - f1;
        if (abs(df) > _120) {
            var f2old = f2,
                x2old = x2,
                y2old = y2;
            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
            x2 = cx + rx * math.cos(f2);
            y2 = cy + ry * math.sin(f2);
            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
        }
        df = f2 - f1;
        var c1 = math.cos(f1),
            s1 = math.sin(f1),
            c2 = math.cos(f2),
            s2 = math.sin(f2),
            t = math.tan(df / 4),
            hx = 4 / 3 * rx * t,
            hy = 4 / 3 * ry * t,
            m1 = [x1, y1],
            m2 = [x1 + hx * s1, y1 - hy * c1],
            m3 = [x2 + hx * s2, y2 - hy * c2],
            m4 = [x2, y2];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];
        if (recursive) {
            return [m2, m3, m4].concat(res);
        } else {
            res = [m2, m3, m4].concat(res).join().split(",");
            var newres = [];
            for (var i = 0, ii = res.length; i < ii; i++) {
                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
            }
            return newres;
        }
    }
    function findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t;
        return {
            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
        };
    }

    // Returns bounding box of cubic bezier curve.
    // Source: http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
    // Original version: NISHIO Hirokazu
    // Modifications: https://github.com/timo22345
    function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
        var tvalues = [],
            bounds = [[], []],
            a, b, c, t, t1, t2, b2ac, sqrtb2ac;
        for (var i = 0; i < 2; ++i) {
            if (i == 0) {
                b = 6 * x0 - 12 * x1 + 6 * x2;
                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                c = 3 * x1 - 3 * x0;
            } else {
                b = 6 * y0 - 12 * y1 + 6 * y2;
                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                c = 3 * y1 - 3 * y0;
            }
            if (abs(a) < 1e-12) {
                if (abs(b) < 1e-12) {
                    continue;
                }
                t = -c / b;
                if (0 < t && t < 1) {
                    tvalues.push(t);
                }
                continue;
            }
            b2ac = b * b - 4 * c * a;
            sqrtb2ac = math.sqrt(b2ac);
            if (b2ac < 0) {
                continue;
            }
            t1 = (-b + sqrtb2ac) / (2 * a);
            if (0 < t1 && t1 < 1) {
                tvalues.push(t1);
            }
            t2 = (-b - sqrtb2ac) / (2 * a);
            if (0 < t2 && t2 < 1) {
                tvalues.push(t2);
            }
        }

        var x, y, j = tvalues.length,
            jlen = j,
            mt;
        while (j--) {
            t = tvalues[j];
            mt = 1 - t;
            bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
            bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
        }

        bounds[0][jlen] = x0;
        bounds[1][jlen] = y0;
        bounds[0][jlen + 1] = x3;
        bounds[1][jlen + 1] = y3;
        bounds[0].length = bounds[1].length = jlen + 2;


        return {
          min: {x: mmin.apply(0, bounds[0]), y: mmin.apply(0, bounds[1])},
          max: {x: mmax.apply(0, bounds[0]), y: mmax.apply(0, bounds[1])}
        };
    }

    function path2curve(path, path2) {
        var pth = !path2 && paths(path);
        if (!path2 && pth.curve) {
            return pathClone(pth.curve);
        }
        var p = pathToAbsolute(path),
            p2 = path2 && pathToAbsolute(path2),
            attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
            processPath = function (path, d, pcom) {
                var nx, ny;
                if (!path) {
                    return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                }
                !(path[0] in {T: 1, Q: 1}) && (d.qx = d.qy = null);
                switch (path[0]) {
                    case "M":
                        d.X = path[1];
                        d.Y = path[2];
                        break;
                    case "A":
                        path = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
                        break;
                    case "S":
                        if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                            nx = d.x * 2 - d.bx;          // And reflect the previous
                            ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                        }
                        else {                            // or some else or nothing
                            nx = d.x;
                            ny = d.y;
                        }
                        path = ["C", nx, ny].concat(path.slice(1));
                        break;
                    case "T":
                        if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                            d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                            d.qy = d.y * 2 - d.qy;        // to case "S".
                        }
                        else {                            // or something else or nothing
                            d.qx = d.x;
                            d.qy = d.y;
                        }
                        path = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                        break;
                    case "Q":
                        d.qx = path[1];
                        d.qy = path[2];
                        path = ["C"].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                        break;
                    case "L":
                        path = ["C"].concat(l2c(d.x, d.y, path[1], path[2]));
                        break;
                    case "H":
                        path = ["C"].concat(l2c(d.x, d.y, path[1], d.y));
                        break;
                    case "V":
                        path = ["C"].concat(l2c(d.x, d.y, d.x, path[1]));
                        break;
                    case "Z":
                        path = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
                        break;
                }
                return path;
            },
            fixArc = function (pp, i) {
                if (pp[i].length > 7) {
                    pp[i].shift();
                    var pi = pp[i];
                    while (pi.length) {
                        pcoms1[i] = "A"; // if created multiple C:s, their original seg is saved
                        p2 && (pcoms2[i] = "A"); // the same as above
                        pp.splice(i++, 0, ["C"].concat(pi.splice(0, 6)));
                    }
                    pp.splice(i, 1);
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            fixM = function (path1, path2, a1, a2, i) {
                if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                    path2.splice(i, 0, ["M", a2.x, a2.y]);
                    a1.bx = 0;
                    a1.by = 0;
                    a1.x = path1[i][1];
                    a1.y = path1[i][2];
                    ii = mmax(p.length, p2 && p2.length || 0);
                }
            },
            pcoms1 = [], // path commands of original path p
            pcoms2 = [], // path commands of original path p2
            pfirst = "", // temporary holder for original path command
            pcom = ""; // holder for previous path command of original path
        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
            p[i] && (pfirst = p[i][0]); // save current path command

            if (pfirst != "C") // C is not saved yet, because it may be result of conversion
            {
                pcoms1[i] = pfirst; // Save current path command
                i && ( pcom = pcoms1[i - 1]); // Get previous path command pcom
            }
            p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

            if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
            // which may produce multiple C:s
            // so we have to make sure that C is also C in original path

            fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

            if (p2) { // the same procedures is done to p2
                p2[i] && (pfirst = p2[i][0]);
                if (pfirst != "C") {
                    pcoms2[i] = pfirst;
                    i && (pcom = pcoms2[i - 1]);
                }
                p2[i] = processPath(p2[i], attrs2, pcom);

                if (pcoms2[i] != "A" && pfirst == "C") {
                    pcoms2[i] = "C";
                }

                fixArc(p2, i);
            }
            fixM(p, p2, attrs, attrs2, i);
            fixM(p2, p, attrs2, attrs, i);
            var seg = p[i],
                seg2 = p2 && p2[i],
                seglen = seg.length,
                seg2len = p2 && seg2.length;
            attrs.x = seg[seglen - 2];
            attrs.y = seg[seglen - 1];
            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
            attrs2.x = p2 && seg2[seg2len - 2];
            attrs2.y = p2 && seg2[seg2len - 1];
        }
        if (!p2) {
            pth.curve = pathClone(p);
        }
        return p2 ? [p, p2] : p;
    }
    function mapPath(path, matrix) {
        if (!matrix) {
            return path;
        }
        var x, y, i, j, ii, jj, pathi;
        path = path2curve(path);
        for (i = 0, ii = path.length; i < ii; i++) {
            pathi = path[i];
            for (j = 1, jj = pathi.length; j < jj; j += 2) {
                x = matrix.x(pathi[j], pathi[j + 1]);
                y = matrix.y(pathi[j], pathi[j + 1]);
                pathi[j] = x;
                pathi[j + 1] = y;
            }
        }
        return path;
    }

    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
                        {x: +crp[i - 2], y: +crp[i - 1]},
                        {x: +crp[i],     y: +crp[i + 1]},
                        {x: +crp[i + 2], y: +crp[i + 3]},
                        {x: +crp[i + 4], y: +crp[i + 5]}
                    ];
            if (z) {
                if (!i) {
                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                } else if (iLen - 4 == i) {
                    p[3] = {x: +crp[0], y: +crp[1]};
                } else if (iLen - 2 == i) {
                    p[2] = {x: +crp[0], y: +crp[1]};
                    p[3] = {x: +crp[2], y: +crp[3]};
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = {x: +crp[i], y: +crp[i + 1]};
                }
            }
            d.push(["C",
                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                  (p[1].x + 6 * p[2].x - p[3].x) / 6,
                  (p[1].y + 6*p[2].y - p[3].y) / 6,
                  p[2].x,
                  p[2].y
            ]);
        }

        return d;
    }

    // export
    Snap.path = paths;

    /*\
     * Snap.path.getTotalLength
     [ method ]
     **
     * Returns the length of the given path in pixels
     **
     - path (string) SVG path string
     **
     = (number) length
    \*/
    Snap.path.getTotalLength = getTotalLength;
    /*\
     * Snap.path.getPointAtLength
     [ method ]
     **
     * Returns the coordinates of the point located at the given length along the given path
     **
     - path (string) SVG path string
     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate,
     o     y: (number) y coordinate,
     o     alpha: (number) angle of derivative
     o }
    \*/
    Snap.path.getPointAtLength = getPointAtLength;
    /*\
     * Snap.path.getSubpath
     [ method ]
     **
     * Returns the subpath of a given path between given start and end lengths
     **
     - path (string) SVG path string
     - from (number) length, in pixels, from the start of the path to the start of the segment
     - to (number) length, in pixels, from the start of the path to the end of the segment
     **
     = (string) path string definition for the segment
    \*/
    Snap.path.getSubpath = function (path, from, to) {
        if (this.getTotalLength(path) - to < 1e-6) {
            return getSubpathsAtLength(path, from).end;
        }
        var a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };
    /*\
     * Element.getTotalLength
     [ method ]
     **
     * Returns the length of the path in pixels (only works for `path` elements)
     = (number) length
    \*/
    elproto.getTotalLength = function () {
        if (this.node.getTotalLength) {
            return this.node.getTotalLength();
        }
    };
    // SIERRA Element.getPointAtLength()/Element.getTotalLength(): If a <path> is broken into different segments, is the jump distance to the new coordinates set by the _M_ or _m_ commands calculated as part of the path's total length?
    /*\
     * Element.getPointAtLength
     [ method ]
     **
     * Returns coordinates of the point located at the given length on the given path (only works for `path` elements)
     **
     - length (number) length, in pixels, from the start of the path, excluding non-rendering jumps
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate,
     o     y: (number) y coordinate,
     o     alpha: (number) angle of derivative
     o }
    \*/
    elproto.getPointAtLength = function (length) {
        return getPointAtLength(this.attr("d"), length);
    };
    // SIERRA Element.getSubpath(): Similar to the problem for Element.getPointAtLength(). Unclear how this would work for a segmented path. Overall, the concept of _subpath_ and what I'm calling a _segment_ (series of non-_M_ or _Z_ commands) is unclear.
    /*\
     * Element.getSubpath
     [ method ]
     **
     * Returns subpath of a given element from given start and end lengths (only works for `path` elements)
     **
     - from (number) length, in pixels, from the start of the path to the start of the segment
     - to (number) length, in pixels, from the start of the path to the end of the segment
     **
     = (string) path string definition for the segment
    \*/
    elproto.getSubpath = function (from, to) {
        return Snap.path.getSubpath(this.attr("d"), from, to);
    };
    Snap._.box = box;
    /*\
     * Snap.path.findDotsAtSegment
     [ method ]
     **
     * Utility method
     **
     * Finds dot coordinates on the given cubic beziér curve at the given t
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     - t (number) position on the curve (0..1)
     = (object) point information in format:
     o {
     o     x: (number) x coordinate of the point,
     o     y: (number) y coordinate of the point,
     o     m: {
     o         x: (number) x coordinate of the left anchor,
     o         y: (number) y coordinate of the left anchor
     o     },
     o     n: {
     o         x: (number) x coordinate of the right anchor,
     o         y: (number) y coordinate of the right anchor
     o     },
     o     start: {
     o         x: (number) x coordinate of the start of the curve,
     o         y: (number) y coordinate of the start of the curve
     o     },
     o     end: {
     o         x: (number) x coordinate of the end of the curve,
     o         y: (number) y coordinate of the end of the curve
     o     },
     o     alpha: (number) angle of the curve derivative at the point
     o }
    \*/
    Snap.path.findDotsAtSegment = findDotsAtSegment;
    /*\
     * Snap.path.bezierBBox
     [ method ]
     **
     * Utility method
     **
     * Returns the bounding box of a given cubic beziér curve
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     * or
     - bez (array) array of six points for beziér curve
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box,
     o     y: (number) y coordinate of the left top point of the box,
     o     x2: (number) x coordinate of the right bottom point of the box,
     o     y2: (number) y coordinate of the right bottom point of the box,
     o     width: (number) width of the box,
     o     height: (number) height of the box
     o }
    \*/
    Snap.path.bezierBBox = bezierBBox;
    /*\
     * Snap.path.isPointInsideBBox
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside bounding box
     - bbox (string) bounding box
     - x (string) x coordinate of the point
     - y (string) y coordinate of the point
     = (boolean) `true` if point is inside
    \*/
    Snap.path.isPointInsideBBox = isPointInsideBBox;
    Snap.closest = function (x, y, X, Y) {
        var r = 100,
            b = box(x - r / 2, y - r / 2, r, r),
            inside = [],
            getter = X[0].hasOwnProperty("x") ? function (i) {
                return {
                    x: X[i].x,
                    y: X[i].y
                };
            } : function (i) {
                return {
                    x: X[i],
                    y: Y[i]
                };
            },
            found = 0;
        while (r <= 1e6 && !found) {
            for (var i = 0, ii = X.length; i < ii; i++) {
                var xy = getter(i);
                if (isPointInsideBBox(b, xy.x, xy.y)) {
                    found++;
                    inside.push(xy);
                    break;
                }
            }
            if (!found) {
                r *= 2;
                b = box(x - r / 2, y - r / 2, r, r)
            }
        }
        if (r == 1e6) {
            return;
        }
        var len = Infinity,
            res;
        for (i = 0, ii = inside.length; i < ii; i++) {
            var l = Snap.len(x, y, inside[i].x, inside[i].y);
            if (len > l) {
                len = l;
                inside[i].len = l;
                res = inside[i];
            }
        }
        return res;
    };
    /*\
     * Snap.path.isBBoxIntersect
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if two bounding boxes intersect
     - bbox1 (string) first bounding box
     - bbox2 (string) second bounding box
     = (boolean) `true` if bounding boxes intersect
    \*/
    Snap.path.isBBoxIntersect = isBBoxIntersect;
    /*\
     * Snap.path.intersection
     [ method ]
     **
     * Utility method
     **
     * Finds intersections of two paths
     - path1 (string) path string
     - path2 (string) path string
     = (array) dots of intersection
     o [
     o     {
     o         x: (number) x coordinate of the point,
     o         y: (number) y coordinate of the point,
     o         t1: (number) t value for segment of path1,
     o         t2: (number) t value for segment of path2,
     o         segment1: (number) order number for segment of path1,
     o         segment2: (number) order number for segment of path2,
     o         bez1: (array) eight coordinates representing beziér curve for the segment of path1,
     o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
     o     }
     o ]
    \*/
    Snap.path.intersection = pathIntersection;
    Snap.path.intersectionNumber = pathIntersectionNumber;
    /*\
     * Snap.path.isPointInside
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside a given closed path.
     *
     * Note: fill mode doesn’t affect the result of this method.
     - path (string) path string
     - x (number) x of the point
     - y (number) y of the point
     = (boolean) `true` if point is inside the path
    \*/
    Snap.path.isPointInside = isPointInsidePath;
    /*\
     * Snap.path.getBBox
     [ method ]
     **
     * Utility method
     **
     * Returns the bounding box of a given path
     - path (string) path string
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box,
     o     y: (number) y coordinate of the left top point of the box,
     o     x2: (number) x coordinate of the right bottom point of the box,
     o     y2: (number) y coordinate of the right bottom point of the box,
     o     width: (number) width of the box,
     o     height: (number) height of the box
     o }
    \*/
    Snap.path.getBBox = pathBBox;
    Snap.path.get = getPath;
    /*\
     * Snap.path.toRelative
     [ method ]
     **
     * Utility method
     **
     * Converts path coordinates into relative values
     - path (string) path string
     = (array) path string
    \*/
    Snap.path.toRelative = pathToRelative;
    /*\
     * Snap.path.toAbsolute
     [ method ]
     **
     * Utility method
     **
     * Converts path coordinates into absolute values
     - path (string) path string
     = (array) path string
    \*/
    Snap.path.toAbsolute = pathToAbsolute;
    /*\
     * Snap.path.toCubic
     [ method ]
     **
     * Utility method
     **
     * Converts path to a new path where all segments are cubic beziér curves
     - pathString (string|array) path string or array of segments
     = (array) array of segments
    \*/
    Snap.path.toCubic = path2curve;
    /*\
     * Snap.path.map
     [ method ]
     **
     * Transform the path string with the given matrix
     - path (string) path string
     - matrix (object) see @Matrix
     = (string) transformed path string
    \*/
    Snap.path.map = mapPath;
    Snap.path.toString = toString;
    Snap.path.clone = pathClone;
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var mmax = Math.max,
        mmin = Math.min;

    // Set
    var Set = function (items) {
        this.items = [];
	this.bindings = {};
        this.length = 0;
        this.type = "set";
        if (items) {
            for (var i = 0, ii = items.length; i < ii; i++) {
                if (items[i]) {
                    this[this.items.length] = this.items[this.items.length] = items[i];
                    this.length++;
                }
            }
        }
    },
    setproto = Set.prototype;
    /*\
     * Set.push
     [ method ]
     **
     * Adds each argument to the current set
     = (object) original element
    \*/
    setproto.push = function () {
        var item,
            len;
        for (var i = 0, ii = arguments.length; i < ii; i++) {
            item = arguments[i];
            if (item) {
                len = this.items.length;
                this[len] = this.items[len] = item;
                this.length++;
            }
        }
        return this;
    };
    /*\
     * Set.pop
     [ method ]
     **
     * Removes last element and returns it
     = (object) element
    \*/
    setproto.pop = function () {
        this.length && delete this[this.length--];
        return this.items.pop();
    };
    /*\
     * Set.forEach
     [ method ]
     **
     * Executes given function for each element in the set
     *
     * If the function returns `false`, the loop stops running.
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Set object
    \*/
    setproto.forEach = function (callback, thisArg) {
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            if (callback.call(thisArg, this.items[i], i) === false) {
                return this;
            }
        }
        return this;
    };
    /*\
     * Set.animate
     [ method ]
     **
     * Animates each element in set in sync.
     *
     **
     - attrs (object) key-value pairs of destination attributes
     - duration (number) duration of the animation in milliseconds
     - easing (function) #optional easing function from @mina or custom
     - callback (function) #optional callback function that executes when the animation ends
     * or
     - animation (array) array of animation parameter for each element in set in format `[attrs, duration, easing, callback]`
     > Usage
     | // animate all elements in set to radius 10
     | set.animate({r: 10}, 500, mina.easein);
     | // or
     | // animate first element to radius 10, but second to radius 20 and in different time
     | set.animate([{r: 10}, 500, mina.easein], [{r: 20}, 1500, mina.easein]);
     = (Element) the current element
    \*/
    setproto.animate = function (attrs, ms, easing, callback) {
        if (typeof easing == "function" && !easing.length) {
            callback = easing;
            easing = mina.linear;
        }
        if (attrs instanceof Snap._.Animation) {
            callback = attrs.callback;
            easing = attrs.easing;
            ms = easing.dur;
            attrs = attrs.attr;
        }
        var args = arguments;
        if (Snap.is(attrs, "array") && Snap.is(args[args.length - 1], "array")) {
            var each = true;
        }
        var begin,
            handler = function () {
                if (begin) {
                    this.b = begin;
                } else {
                    begin = this.b;
                }
            },
            cb = 0,
            set = this,
            callbacker = callback && function () {
                if (++cb == set.length) {
                    callback.call(this);
                }
            };
        return this.forEach(function (el, i) {
            eve.once("snap.animcreated." + el.id, handler);
            if (each) {
                args[i] && el.animate.apply(el, args[i]);
            } else {
                el.animate(attrs, ms, easing, callbacker);
            }
        });
    };
    /*\
     * Set.remove
     [ method ]
     **
     * Removes all children of the set.
     *
     = (object) Set object
    \*/
    setproto.remove = function () {
        while (this.length) {
            this.pop().remove();
        }
        return this;
    };
    /*\
     * Set.bind
     [ method ]
     **
     * Specifies how to handle a specific attribute when applied
     * to a set.
     *
     **
     - attr (string) attribute name
     - callback (function) function to run
     * or
     - attr (string) attribute name
     - element (Element) specific element in the set to apply the attribute to
     * or
     - attr (string) attribute name
     - element (Element) specific element in the set to apply the attribute to
     - eattr (string) attribute on the element to bind the attribute to
     = (object) Set object
    \*/
    setproto.bind = function (attr, a, b) {
        var data = {};
        if (typeof a == "function") {
            this.bindings[attr] = a;
        } else {
            var aname = b || attr;
            this.bindings[attr] = function (v) {
                data[aname] = v;
                a.attr(data);
            };
        }
        return this;
    };
    /*\
     * Set.attr
     [ method ]
     **
     * Equivalent of @Element.attr.
     = (object) Set object
    \*/
    setproto.attr = function (value) {
        var unbound = {};
        for (var k in value) {
            if (this.bindings[k]) {
                this.bindings[k](value[k]);
            } else {
                unbound[k] = value[k];
            }
        }
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            this.items[i].attr(unbound);
        }
        return this;
    };
    /*\
     * Set.clear
     [ method ]
     **
     * Removes all elements from the set
    \*/
    setproto.clear = function () {
        while (this.length) {
            this.pop();
        }
    };
    /*\
     * Set.splice
     [ method ]
     **
     * Removes range of elements from the set
     **
     - index (number) position of the deletion
     - count (number) number of element to remove
     - insertion… (object) #optional elements to insert
     = (object) set elements that were deleted
    \*/
    setproto.splice = function (index, count, insertion) {
        index = index < 0 ? mmax(this.length + index, 0) : index;
        count = mmax(0, mmin(this.length - index, count));
        var tail = [],
            todel = [],
            args = [],
            i;
        for (i = 2; i < arguments.length; i++) {
            args.push(arguments[i]);
        }
        for (i = 0; i < count; i++) {
            todel.push(this[index + i]);
        }
        for (; i < this.length - index; i++) {
            tail.push(this[index + i]);
        }
        var arglen = args.length;
        for (i = 0; i < arglen + tail.length; i++) {
            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
        }
        i = this.items.length = this.length -= count - arglen;
        while (this[i]) {
            delete this[i++];
        }
        return new Set(todel);
    };
    /*\
     * Set.exclude
     [ method ]
     **
     * Removes given element from the set
     **
     - element (object) element to remove
     = (boolean) `true` if object was found and removed from the set
    \*/
    setproto.exclude = function (el) {
        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
            this.splice(i, 1);
            return true;
        }
        return false;
    };
    /*\
     * Set.insertAfter
     [ method ]
     **
     * Inserts set elements after given element.
     **
     - element (object) set will be inserted after this element
     = (object) Set object
    \*/
    setproto.insertAfter = function (el) {
        var i = this.items.length;
        while (i--) {
            this.items[i].insertAfter(el);
        }
        return this;
    };
    /*\
     * Set.getBBox
     [ method ]
     **
     * Union of all bboxes of the set. See @Element.getBBox.
     = (object) bounding box descriptor. See @Element.getBBox.
    \*/
    setproto.getBBox = function () {
        var x = [],
            y = [],
            x2 = [],
            y2 = [];
        for (var i = this.items.length; i--;) if (!this.items[i].removed) {
            var box = this.items[i].getBBox();
            x.push(box.x);
            y.push(box.y);
            x2.push(box.x + box.width);
            y2.push(box.y + box.height);
        }
        x = mmin.apply(0, x);
        y = mmin.apply(0, y);
        x2 = mmax.apply(0, x2);
        y2 = mmax.apply(0, y2);
        return {
            x: x,
            y: y,
            x2: x2,
            y2: y2,
            width: x2 - x,
            height: y2 - y,
            cx: x + (x2 - x) / 2,
            cy: y + (y2 - y) / 2
        };
    };
    /*\
     * Set.insertAfter
     [ method ]
     **
     * Creates a clone of the set.
     **
     = (object) New Set object
    \*/
    setproto.clone = function (s) {
        s = new Set;
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            s.push(this.items[i].clone());
        }
        return s;
    };
    setproto.toString = function () {
        return "Snap\u2018s set";
    };
    setproto.type = "set";
    // export
    /*\
     * Snap.Set
     [ property ]
     **
     * Set constructor.
    \*/
    Snap.Set = Set;
    /*\
     * Snap.set
     [ method ]
     **
     * Creates a set and fills it with list of arguments.
     **
     = (object) New Set object
     | var r = paper.rect(0, 0, 10, 10),
     |     s1 = Snap.set(), // empty set
     |     s2 = Snap.set(r, paper.circle(100, 100, 20)); // prefilled set
    \*/
    Snap.set = function () {
        var set = new Set;
        if (arguments.length) {
            set.push.apply(set, Array.prototype.slice.call(arguments, 0));
        }
        return set;
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var names = {},
        reUnit = /[%a-z]+$/i,
        Str = String;
    names.stroke = names.fill = "colour";
    function getEmpty(item) {
        var l = item[0];
        switch (l.toLowerCase()) {
            case "t": return [l, 0, 0];
            case "m": return [l, 1, 0, 0, 1, 0, 0];
            case "r": if (item.length == 4) {
                return [l, 0, item[2], item[3]];
            } else {
                return [l, 0];
            }
            case "s": if (item.length == 5) {
                return [l, 1, 1, item[3], item[4]];
            } else if (item.length == 3) {
                return [l, 1, 1];
            } else {
                return [l, 1];
            }
        }
    }
    function equaliseTransform(t1, t2, getBBox) {
        t1 = t1 || new Snap.Matrix;
        t2 = t2 || new Snap.Matrix;
        t1 = Snap.parseTransformString(t1.toTransformString()) || [];
        t2 = Snap.parseTransformString(t2.toTransformString()) || [];
        var maxlength = Math.max(t1.length, t2.length),
            from = [],
            to = [],
            i = 0, j, jj,
            tt1, tt2;
        for (; i < maxlength; i++) {
            tt1 = t1[i] || getEmpty(t2[i]);
            tt2 = t2[i] || getEmpty(tt1);
            if (tt1[0] != tt2[0] ||
                tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3]) ||
                tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4])
                ) {
                    t1 = Snap._.transform2matrix(t1, getBBox());
                    t2 = Snap._.transform2matrix(t2, getBBox());
                    from = [["m", t1.a, t1.b, t1.c, t1.d, t1.e, t1.f]];
                    to = [["m", t2.a, t2.b, t2.c, t2.d, t2.e, t2.f]];
                    break;
            }
            from[i] = [];
            to[i] = [];
            for (j = 0, jj = Math.max(tt1.length, tt2.length); j < jj; j++) {
                j in tt1 && (from[i][j] = tt1[j]);
                j in tt2 && (to[i][j] = tt2[j]);
            }
        }
        return {
            from: path2array(from),
            to: path2array(to),
            f: getPath(from)
        };
    }
    function getNumber(val) {
        return val;
    }
    function getUnit(unit) {
        return function (val) {
            return +val.toFixed(3) + unit;
        };
    }
    function getViewBox(val) {
        return val.join(" ");
    }
    function getColour(clr) {
        return Snap.rgb(clr[0], clr[1], clr[2], clr[3]);
    }
    function getPath(path) {
        var k = 0, i, ii, j, jj, out, a, b = [];
        for (i = 0, ii = path.length; i < ii; i++) {
            out = "[";
            a = ['"' + path[i][0] + '"'];
            for (j = 1, jj = path[i].length; j < jj; j++) {
                a[j] = "val[" + k++ + "]";
            }
            out += a + "]";
            b[i] = out;
        }
        return Function("val", "return Snap.path.toString.call([" + b + "])");
    }
    function path2array(path) {
        var out = [];
        for (var i = 0, ii = path.length; i < ii; i++) {
            for (var j = 1, jj = path[i].length; j < jj; j++) {
                out.push(path[i][j]);
            }
        }
        return out;
    }
    function isNumeric(obj) {
        return isFinite(obj);
    }
    function arrayEqual(arr1, arr2) {
        if (!Snap.is(arr1, "array") || !Snap.is(arr2, "array")) {
            return false;
        }
        return arr1.toString() == arr2.toString();
    }
    Element.prototype.equal = function (name, b) {
        return eve("snap.util.equal", this, name, b).firstDefined();
    };
    eve.on("snap.util.equal", function (name, b) {
        var A, B, a = Str(this.attr(name) || ""),
            el = this;
        if (names[name] == "colour") {
            A = Snap.color(a);
            B = Snap.color(b);
            return {
                from: [A.r, A.g, A.b, A.opacity],
                to: [B.r, B.g, B.b, B.opacity],
                f: getColour
            };
        }
        if (name == "viewBox") {
            A = this.attr(name).vb.split(" ").map(Number);
            B = b.split(" ").map(Number);
            return {
                from: A,
                to: B,
                f: getViewBox
            };
        }
        if (name == "transform" || name == "gradientTransform" || name == "patternTransform") {
            if (typeof b == "string") {
                b = Str(b).replace(/\.{3}|\u2026/g, a);
            }
            a = this.matrix;
            if (!Snap._.rgTransform.test(b)) {
                b = Snap._.transform2matrix(Snap._.svgTransform2string(b), this.getBBox());
            } else {
                b = Snap._.transform2matrix(b, this.getBBox());
            }
            return equaliseTransform(a, b, function () {
                return el.getBBox(1);
            });
        }
        if (name == "d" || name == "path") {
            A = Snap.path.toCubic(a, b);
            return {
                from: path2array(A[0]),
                to: path2array(A[1]),
                f: getPath(A[0])
            };
        }
        if (name == "points") {
            A = Str(a).split(Snap._.separator);
            B = Str(b).split(Snap._.separator);
            return {
                from: A,
                to: B,
                f: function (val) { return val; }
            };
        }
        if (isNumeric(a) && isNumeric(b)) {
            return {
                from: parseFloat(a),
                to: parseFloat(b),
                f: getNumber
            };
        }
        var aUnit = a.match(reUnit),
            bUnit = Str(b).match(reUnit);
        if (aUnit && arrayEqual(aUnit, bUnit)) {
            return {
                from: parseFloat(a),
                to: parseFloat(b),
                f: getUnit(aUnit)
            };
        } else {
            return {
                from: this.asPX(name),
                to: this.asPX(name, b),
                f: getNumber
            };
        }
    });
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var elproto = Element.prototype,
    has = "hasOwnProperty",
    supportsTouch = "createTouch" in glob.doc,
    events = [
        "click", "dblclick", "mousedown", "mousemove", "mouseout",
        "mouseover", "mouseup", "touchstart", "touchmove", "touchend",
        "touchcancel"
    ],
    touchMap = {
        mousedown: "touchstart",
        mousemove: "touchmove",
        mouseup: "touchend"
    },
    getScroll = function (xy, el) {
        var name = xy == "y" ? "scrollTop" : "scrollLeft",
            doc = el && el.node ? el.node.ownerDocument : glob.doc;
        return doc[name in doc.documentElement ? "documentElement" : "body"][name];
    },
    preventDefault = function () {
        this.returnValue = false;
    },
    preventTouch = function () {
        return this.originalEvent.preventDefault();
    },
    stopPropagation = function () {
        this.cancelBubble = true;
    },
    stopTouch = function () {
        return this.originalEvent.stopPropagation();
    },
    addEvent = function (obj, type, fn, element) {
        var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
            f = function (e) {
                var scrollY = getScroll("y", element),
                    scrollX = getScroll("x", element);
                if (supportsTouch && touchMap[has](type)) {
                    for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                        if (e.targetTouches[i].target == obj || obj.contains(e.targetTouches[i].target)) {
                            var olde = e;
                            e = e.targetTouches[i];
                            e.originalEvent = olde;
                            e.preventDefault = preventTouch;
                            e.stopPropagation = stopTouch;
                            break;
                        }
                    }
                }
                var x = e.clientX + scrollX,
                    y = e.clientY + scrollY;
                return fn.call(element, e, x, y);
            };

        if (type !== realName) {
            obj.addEventListener(type, f, false);
        }

        obj.addEventListener(realName, f, false);

        return function () {
            if (type !== realName) {
                obj.removeEventListener(type, f, false);
            }

            obj.removeEventListener(realName, f, false);
            return true;
        };
    },
    drag = [],
    dragMove = function (e) {
        var x = e.clientX,
            y = e.clientY,
            scrollY = getScroll("y"),
            scrollX = getScroll("x"),
            dragi,
            j = drag.length;
        while (j--) {
            dragi = drag[j];
            if (supportsTouch) {
                var i = e.touches && e.touches.length,
                    touch;
                while (i--) {
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id || dragi.el.node.contains(touch.target)) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else {
                e.preventDefault();
            }
            var node = dragi.el.node,
                o,
                next = node.nextSibling,
                parent = node.parentNode,
                display = node.style.display;
            // glob.win.opera && parent.removeChild(node);
            // node.style.display = "none";
            // o = dragi.el.paper.getElementByPoint(x, y);
            // node.style.display = display;
            // glob.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
            // o && eve("snap.drag.over." + dragi.el.id, dragi.el, o);
            x += scrollX;
            y += scrollY;
            eve("snap.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    },
    dragUp = function (e) {
        Snap.unmousemove(dragMove).unmouseup(dragUp);
        var i = drag.length,
            dragi;
        while (i--) {
            dragi = drag[i];
            dragi.el._drag = {};
            eve("snap.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
            eve.off("snap.drag.*." + dragi.el.id);
        }
        drag = [];
    };
    /*\
     * Element.click
     [ method ]
     **
     * Adds a click event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unclick
     [ method ]
     **
     * Removes a click event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.dblclick
     [ method ]
     **
     * Adds a double click event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.undblclick
     [ method ]
     **
     * Removes a double click event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.mousedown
     [ method ]
     **
     * Adds a mousedown event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousedown
     [ method ]
     **
     * Removes a mousedown event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.mousemove
     [ method ]
     **
     * Adds a mousemove event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousemove
     [ method ]
     **
     * Removes a mousemove event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.mouseout
     [ method ]
     **
     * Adds a mouseout event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseout
     [ method ]
     **
     * Removes a mouseout event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.mouseover
     [ method ]
     **
     * Adds a mouseover event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseover
     [ method ]
     **
     * Removes a mouseover event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.mouseup
     [ method ]
     **
     * Adds a mouseup event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseup
     [ method ]
     **
     * Removes a mouseup event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.touchstart
     [ method ]
     **
     * Adds a touchstart event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchstart
     [ method ]
     **
     * Removes a touchstart event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.touchmove
     [ method ]
     **
     * Adds a touchmove event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchmove
     [ method ]
     **
     * Removes a touchmove event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.touchend
     [ method ]
     **
     * Adds a touchend event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchend
     [ method ]
     **
     * Removes a touchend event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    
    /*\
     * Element.touchcancel
     [ method ]
     **
     * Adds a touchcancel event handler to the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchcancel
     [ method ]
     **
     * Removes a touchcancel event handler from the element
     - handler (function) handler for the event
     = (object) @Element
    \*/
    for (var i = events.length; i--;) {
        (function (eventName) {
            Snap[eventName] = elproto[eventName] = function (fn, scope) {
                if (Snap.is(fn, "function")) {
                    this.events = this.events || [];
                    this.events.push({
                        name: eventName,
                        f: fn,
                        unbind: addEvent(this.node || document, eventName, fn, scope || this)
                    });
                } else {
                    for (var i = 0, ii = this.events.length; i < ii; i++) if (this.events[i].name == eventName) {
                        try {
                            this.events[i].f.call(this);
                        } catch (e) {}
                    }
                }
                return this;
            };
            Snap["un" + eventName] =
            elproto["un" + eventName] = function (fn) {
                var events = this.events || [],
                    l = events.length;
                while (l--) if (events[l].name == eventName &&
                               (events[l].f == fn || !fn)) {
                    events[l].unbind();
                    events.splice(l, 1);
                    !events.length && delete this.events;
                    return this;
                }
                return this;
            };
        })(events[i]);
    }
    /*\
     * Element.hover
     [ method ]
     **
     * Adds hover event handlers to the element
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     - icontext (object) #optional context for hover in handler
     - ocontext (object) #optional context for hover out handler
     = (object) @Element
    \*/
    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    /*\
     * Element.unhover
     [ method ]
     **
     * Removes hover event handlers from the element
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     = (object) @Element
    \*/
    elproto.unhover = function (f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    var draggable = [];
    // SIERRA unclear what _context_ refers to for starting, ending, moving the drag gesture.
    // SIERRA Element.drag(): _x position of the mouse_: Where are the x/y values offset from?
    // SIERRA Element.drag(): much of this member's doc appears to be duplicated for some reason.
    // SIERRA Unclear about this sentence: _Additionally following drag events will be triggered: drag.start.<id> on start, drag.end.<id> on end and drag.move.<id> on every move._ Is there a global _drag_ object to which you can assign handlers keyed by an element's ID?
    /*\
     * Element.drag
     [ method ]
     **
     * Adds event handlers for an element's drag gesture
     **
     - onmove (function) handler for moving
     - onstart (function) handler for drag start
     - onend (function) handler for drag end
     - mcontext (object) #optional context for moving handler
     - scontext (object) #optional context for drag start handler
     - econtext (object) #optional context for drag end handler
     * Additionaly following `drag` events are triggered: `drag.start.<id>` on start, 
     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element is dragged over another element 
     * `drag.over.<id>` fires as well.
     *
     * Start event and start handler are called in specified context or in context of the element with following parameters:
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * Move event and move handler are called in specified context or in context of the element with following parameters:
     o dx (number) shift by x from the start point
     o dy (number) shift by y from the start point
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * End event and end handler are called in specified context or in context of the element with following parameters:
     o event (object) DOM event object
     = (object) @Element
    \*/
    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
        var el = this;
        if (!arguments.length) {
            var origTransform;
            return el.drag(function (dx, dy) {
                this.attr({
                    transform: origTransform + (origTransform ? "T" : "t") + [dx, dy]
                });
            }, function () {
                origTransform = this.transform().local;
            });
        }
        function start(e, x, y) {
            (e.originalEvent || e).preventDefault();
            el._drag.x = x;
            el._drag.y = y;
            el._drag.id = e.identifier;
            !drag.length && Snap.mousemove(dragMove).mouseup(dragUp);
            drag.push({el: el, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
            onstart && eve.on("snap.drag.start." + el.id, onstart);
            onmove && eve.on("snap.drag.move." + el.id, onmove);
            onend && eve.on("snap.drag.end." + el.id, onend);
            eve("snap.drag.start." + el.id, start_scope || move_scope || el, x, y, e);
        }
        function init(e, x, y) {
            eve("snap.draginit." + el.id, el, e, x, y);
        }
        eve.on("snap.draginit." + el.id, start);
        el._drag = {};
        draggable.push({el: el, start: start, init: init});
        el.mousedown(init);
        return el;
    };
    /*
     * Element.onDragOver
     [ method ]
     **
     * Shortcut to assign event handler for `drag.over.<id>` event, where `id` is the element's `id` (see @Element.id)
     - f (function) handler for event, first argument would be the element you are dragging over
    \*/
    // elproto.onDragOver = function (f) {
    //     f ? eve.on("snap.drag.over." + this.id, f) : eve.unbind("snap.drag.over." + this.id);
    // };
    /*\
     * Element.undrag
     [ method ]
     **
     * Removes all drag event handlers from the given element
    \*/
    elproto.undrag = function () {
        var i = draggable.length;
        while (i--) if (draggable[i].el == this) {
            this.unmousedown(draggable[i].init);
            draggable.splice(i, 1);
            eve.unbind("snap.drag.*." + this.id);
            eve.unbind("snap.draginit." + this.id);
        }
        !draggable.length && Snap.unmousemove(dragMove).unmouseup(dragUp);
        return this;
    };
});

// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    var elproto = Element.prototype,
        pproto = Paper.prototype,
        rgurl = /^\s*url\((.+)\)/,
        Str = String,
        $ = Snap._.$;
    Snap.filter = {};
    /*\
     * Paper.filter
     [ method ]
     **
     * Creates a `<filter>` element
     **
     - filstr (string) SVG fragment of filter provided as a string
     = (object) @Element
     * Note: It is recommended to use filters embedded into the page inside an empty SVG element.
     > Usage
     | var f = paper.filter('<feGaussianBlur stdDeviation="2"/>'),
     |     c = paper.circle(10, 10, 10).attr({
     |         filter: f
     |     });
    \*/
    pproto.filter = function (filstr) {
        var paper = this;
        if (paper.type != "svg") {
            paper = paper.paper;
        }
        var f = Snap.parse(Str(filstr)),
            id = Snap._.id(),
            width = paper.node.offsetWidth,
            height = paper.node.offsetHeight,
            filter = $("filter");
        $(filter, {
            id: id,
            filterUnits: "userSpaceOnUse"
        });
        filter.appendChild(f.node);
        paper.defs.appendChild(filter);
        return new Element(filter);
    };

    eve.on("snap.util.getattr.filter", function () {
        eve.stop();
        var p = $(this.node, "filter");
        if (p) {
            var match = Str(p).match(rgurl);
            return match && Snap.select(match[1]);
        }
    });
    eve.on("snap.util.attr.filter", function (value) {
        if (value instanceof Element && value.type == "filter") {
            eve.stop();
            var id = value.node.id;
            if (!id) {
                $(value.node, {id: value.id});
                id = value.id;
            }
            $(this.node, {
                filter: Snap.url(id)
            });
        }
        if (!value || value == "none") {
            eve.stop();
            this.node.removeAttribute("filter");
        }
    });
    /*\
     * Snap.filter.blur
     [ method ]
     **
     * Returns an SVG markup string for the blur filter
     **
     - x (number) amount of horizontal blur, in pixels
     - y (number) #optional amount of vertical blur, in pixels
     = (string) filter representation
     > Usage
     | var f = paper.filter(Snap.filter.blur(5, 10)),
     |     c = paper.circle(10, 10, 10).attr({
     |         filter: f
     |     });
    \*/
    Snap.filter.blur = function (x, y) {
        if (x == null) {
            x = 2;
        }
        var def = y == null ? x : [x, y];
        return Snap.format('\<feGaussianBlur stdDeviation="{def}"/>', {
            def: def
        });
    };
    Snap.filter.blur.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.shadow
     [ method ]
     **
     * Returns an SVG markup string for the shadow filter
     **
     - dx (number) #optional horizontal shift of the shadow, in pixels
     - dy (number) #optional vertical shift of the shadow, in pixels
     - blur (number) #optional amount of blur
     - color (string) #optional color of the shadow
     - opacity (number) #optional `0..1` opacity of the shadow
     * or
     - dx (number) #optional horizontal shift of the shadow, in pixels
     - dy (number) #optional vertical shift of the shadow, in pixels
     - color (string) #optional color of the shadow
     - opacity (number) #optional `0..1` opacity of the shadow
     * which makes blur default to `4`. Or
     - dx (number) #optional horizontal shift of the shadow, in pixels
     - dy (number) #optional vertical shift of the shadow, in pixels
     - opacity (number) #optional `0..1` opacity of the shadow
     = (string) filter representation
     > Usage
     | var f = paper.filter(Snap.filter.shadow(0, 2, .3)),
     |     c = paper.circle(10, 10, 10).attr({
     |         filter: f
     |     });
    \*/
    Snap.filter.shadow = function (dx, dy, blur, color, opacity) {
        if (opacity == null) {
            if (color == null) {
                opacity = blur;
                blur = 4;
                color = "#000";
            } else {
                opacity = color;
                color = blur;
                blur = 4;
            }
        }
        if (blur == null) {
            blur = 4;
        }
        if (opacity == null) {
            opacity = 1;
        }
        if (dx == null) {
            dx = 0;
            dy = 2;
        }
        if (dy == null) {
            dy = dx;
        }
        color = Snap.color(color);
        return Snap.format('<feGaussianBlur in="SourceAlpha" stdDeviation="{blur}"/><feOffset dx="{dx}" dy="{dy}" result="offsetblur"/><feFlood flood-color="{color}"/><feComposite in2="offsetblur" operator="in"/><feComponentTransfer><feFuncA type="linear" slope="{opacity}"/></feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge>', {
            color: color,
            dx: dx,
            dy: dy,
            blur: blur,
            opacity: opacity
        });
    };
    Snap.filter.shadow.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.grayscale
     [ method ]
     **
     * Returns an SVG markup string for the grayscale filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.grayscale = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {b} {h} 0 0 0 0 0 1 0"/>', {
            a: 0.2126 + 0.7874 * (1 - amount),
            b: 0.7152 - 0.7152 * (1 - amount),
            c: 0.0722 - 0.0722 * (1 - amount),
            d: 0.2126 - 0.2126 * (1 - amount),
            e: 0.7152 + 0.2848 * (1 - amount),
            f: 0.0722 - 0.0722 * (1 - amount),
            g: 0.2126 - 0.2126 * (1 - amount),
            h: 0.0722 + 0.9278 * (1 - amount)
        });
    };
    Snap.filter.grayscale.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.sepia
     [ method ]
     **
     * Returns an SVG markup string for the sepia filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.sepia = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feColorMatrix type="matrix" values="{a} {b} {c} 0 0 {d} {e} {f} 0 0 {g} {h} {i} 0 0 0 0 0 1 0"/>', {
            a: 0.393 + 0.607 * (1 - amount),
            b: 0.769 - 0.769 * (1 - amount),
            c: 0.189 - 0.189 * (1 - amount),
            d: 0.349 - 0.349 * (1 - amount),
            e: 0.686 + 0.314 * (1 - amount),
            f: 0.168 - 0.168 * (1 - amount),
            g: 0.272 - 0.272 * (1 - amount),
            h: 0.534 - 0.534 * (1 - amount),
            i: 0.131 + 0.869 * (1 - amount)
        });
    };
    Snap.filter.sepia.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.saturate
     [ method ]
     **
     * Returns an SVG markup string for the saturate filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.saturate = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feColorMatrix type="saturate" values="{amount}"/>', {
            amount: 1 - amount
        });
    };
    Snap.filter.saturate.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.hueRotate
     [ method ]
     **
     * Returns an SVG markup string for the hue-rotate filter
     **
     - angle (number) angle of rotation
     = (string) filter representation
    \*/
    Snap.filter.hueRotate = function (angle) {
        angle = angle || 0;
        return Snap.format('<feColorMatrix type="hueRotate" values="{angle}"/>', {
            angle: angle
        });
    };
    Snap.filter.hueRotate.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.invert
     [ method ]
     **
     * Returns an SVG markup string for the invert filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.invert = function (amount) {
        if (amount == null) {
            amount = 1;
        }
//        <feColorMatrix type="matrix" values="-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0" color-interpolation-filters="sRGB"/>
        return Snap.format('<feComponentTransfer><feFuncR type="table" tableValues="{amount} {amount2}"/><feFuncG type="table" tableValues="{amount} {amount2}"/><feFuncB type="table" tableValues="{amount} {amount2}"/></feComponentTransfer>', {
            amount: amount,
            amount2: 1 - amount
        });
    };
    Snap.filter.invert.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.brightness
     [ method ]
     **
     * Returns an SVG markup string for the brightness filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.brightness = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}"/><feFuncG type="linear" slope="{amount}"/><feFuncB type="linear" slope="{amount}"/></feComponentTransfer>', {
            amount: amount
        });
    };
    Snap.filter.brightness.toString = function () {
        return this();
    };
    /*\
     * Snap.filter.contrast
     [ method ]
     **
     * Returns an SVG markup string for the contrast filter
     **
     - amount (number) amount of filter (`0..1`)
     = (string) filter representation
    \*/
    Snap.filter.contrast = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return Snap.format('<feComponentTransfer><feFuncR type="linear" slope="{amount}" intercept="{amount2}"/><feFuncG type="linear" slope="{amount}" intercept="{amount2}"/><feFuncB type="linear" slope="{amount}" intercept="{amount2}"/></feComponentTransfer>', {
            amount: amount,
            amount2: .5 - amount / 2
        });
    };
    Snap.filter.contrast.toString = function () {
        return this();
    };
});

// Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob, Fragment) {
    var box = Snap._.box,
        is = Snap.is,
        firstLetter = /^[^a-z]*([tbmlrc])/i,
        toString = function () {
            return "T" + this.dx + "," + this.dy;
        };
    /*\
     * Element.getAlign
     [ method ]
     **
     * Returns shift needed to align the element relatively to given element.
     * If no elements specified, parent `<svg>` container will be used.
     - el (object) @optional alignment element
     - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
     = (object|string) Object in format `{dx: , dy: }` also has a string representation as a transformation string
     > Usage
     | el.transform(el.getAlign(el2, "top"));
     * or
     | var dy = el.getAlign(el2, "top").dy;
    \*/
    Element.prototype.getAlign = function (el, way) {
        if (way == null && is(el, "string")) {
            way = el;
            el = null;
        }
        el = el || this.paper;
        var bx = el.getBBox ? el.getBBox() : box(el),
            bb = this.getBBox(),
            out = {};
        way = way && way.match(firstLetter);
        way = way ? way[1].toLowerCase() : "c";
        switch (way) {
            case "t":
                out.dx = 0;
                out.dy = bx.y - bb.y;
            break;
            case "b":
                out.dx = 0;
                out.dy = bx.y2 - bb.y2;
            break;
            case "m":
                out.dx = 0;
                out.dy = bx.cy - bb.cy;
            break;
            case "l":
                out.dx = bx.x - bb.x;
                out.dy = 0;
            break;
            case "r":
                out.dx = bx.x2 - bb.x2;
                out.dy = 0;
            break;
            default:
                out.dx = bx.cx - bb.cx;
                out.dy = 0;
            break;
        }
        out.toString = toString;
        return out;
    };
    /*\
     * Element.align
     [ method ]
     **
     * Aligns the element relatively to given one via transformation.
     * If no elements specified, parent `<svg>` container will be used.
     - el (object) @optional alignment element
     - way (string) one of six values: `"top"`, `"middle"`, `"bottom"`, `"left"`, `"center"`, `"right"`
     = (object) this element
     > Usage
     | el.align(el2, "top");
     * or
     | el.align("middle");
    \*/
    Element.prototype.align = function (el, way) {
        return this.transform("..." + this.getAlign(el, way));
    };
});

// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Snap.plugin(function (Snap, Element, Paper, glob) {
    // Colours are from https://www.materialui.co
    var red         = "#ffebee#ffcdd2#ef9a9a#e57373#ef5350#f44336#e53935#d32f2f#c62828#b71c1c#ff8a80#ff5252#ff1744#d50000",
        pink        = "#FCE4EC#F8BBD0#F48FB1#F06292#EC407A#E91E63#D81B60#C2185B#AD1457#880E4F#FF80AB#FF4081#F50057#C51162",
        purple      = "#F3E5F5#E1BEE7#CE93D8#BA68C8#AB47BC#9C27B0#8E24AA#7B1FA2#6A1B9A#4A148C#EA80FC#E040FB#D500F9#AA00FF",
        deeppurple  = "#EDE7F6#D1C4E9#B39DDB#9575CD#7E57C2#673AB7#5E35B1#512DA8#4527A0#311B92#B388FF#7C4DFF#651FFF#6200EA",
        indigo      = "#E8EAF6#C5CAE9#9FA8DA#7986CB#5C6BC0#3F51B5#3949AB#303F9F#283593#1A237E#8C9EFF#536DFE#3D5AFE#304FFE",
        blue        = "#E3F2FD#BBDEFB#90CAF9#64B5F6#64B5F6#2196F3#1E88E5#1976D2#1565C0#0D47A1#82B1FF#448AFF#2979FF#2962FF",
        lightblue   = "#E1F5FE#B3E5FC#81D4FA#4FC3F7#29B6F6#03A9F4#039BE5#0288D1#0277BD#01579B#80D8FF#40C4FF#00B0FF#0091EA",
        cyan        = "#E0F7FA#B2EBF2#80DEEA#4DD0E1#26C6DA#00BCD4#00ACC1#0097A7#00838F#006064#84FFFF#18FFFF#00E5FF#00B8D4",
        teal        = "#E0F2F1#B2DFDB#80CBC4#4DB6AC#26A69A#009688#00897B#00796B#00695C#004D40#A7FFEB#64FFDA#1DE9B6#00BFA5",
        green       = "#E8F5E9#C8E6C9#A5D6A7#81C784#66BB6A#4CAF50#43A047#388E3C#2E7D32#1B5E20#B9F6CA#69F0AE#00E676#00C853",
        lightgreen  = "#F1F8E9#DCEDC8#C5E1A5#AED581#9CCC65#8BC34A#7CB342#689F38#558B2F#33691E#CCFF90#B2FF59#76FF03#64DD17",
        lime        = "#F9FBE7#F0F4C3#E6EE9C#DCE775#D4E157#CDDC39#C0CA33#AFB42B#9E9D24#827717#F4FF81#EEFF41#C6FF00#AEEA00",
        yellow      = "#FFFDE7#FFF9C4#FFF59D#FFF176#FFEE58#FFEB3B#FDD835#FBC02D#F9A825#F57F17#FFFF8D#FFFF00#FFEA00#FFD600",
        amber       = "#FFF8E1#FFECB3#FFE082#FFD54F#FFCA28#FFC107#FFB300#FFA000#FF8F00#FF6F00#FFE57F#FFD740#FFC400#FFAB00",
        orange      = "#FFF3E0#FFE0B2#FFCC80#FFB74D#FFA726#FF9800#FB8C00#F57C00#EF6C00#E65100#FFD180#FFAB40#FF9100#FF6D00",
        deeporange  = "#FBE9E7#FFCCBC#FFAB91#FF8A65#FF7043#FF5722#F4511E#E64A19#D84315#BF360C#FF9E80#FF6E40#FF3D00#DD2C00",
        brown       = "#EFEBE9#D7CCC8#BCAAA4#A1887F#8D6E63#795548#6D4C41#5D4037#4E342E#3E2723",
        grey        = "#FAFAFA#F5F5F5#EEEEEE#E0E0E0#BDBDBD#9E9E9E#757575#616161#424242#212121",
        bluegrey    = "#ECEFF1#CFD8DC#B0BEC5#90A4AE#78909C#607D8B#546E7A#455A64#37474F#263238";
    /*\
     * Snap.mui
     [ property ]
     **
     * Contain Material UI colours.
     | Snap().rect(0, 0, 10, 10).attr({fill: Snap.mui.deeppurple, stroke: Snap.mui.amber[600]});
     # For colour reference: <a href="https://www.materialui.co">https://www.materialui.co</a>.
    \*/
    Snap.mui = {};
    /*\
     * Snap.flat
     [ property ]
     **
     * Contain Flat UI colours.
     | Snap().rect(0, 0, 10, 10).attr({fill: Snap.flat.carrot, stroke: Snap.flat.wetasphalt});
     # For colour reference: <a href="https://www.materialui.co">https://www.materialui.co</a>.
    \*/
    Snap.flat = {};
    function saveColor(colors) {
        colors = colors.split(/(?=#)/);
        var color = new String(colors[5]);
        color[50] = colors[0];
        color[100] = colors[1];
        color[200] = colors[2];
        color[300] = colors[3];
        color[400] = colors[4];
        color[500] = colors[5];
        color[600] = colors[6];
        color[700] = colors[7];
        color[800] = colors[8];
        color[900] = colors[9];
        if (colors[10]) {
            color.A100 = colors[10];
            color.A200 = colors[11];
            color.A400 = colors[12];
            color.A700 = colors[13];
        }
        return color;
    }
    Snap.mui.red = saveColor(red);
    Snap.mui.pink = saveColor(pink);
    Snap.mui.purple = saveColor(purple);
    Snap.mui.deeppurple = saveColor(deeppurple);
    Snap.mui.indigo = saveColor(indigo);
    Snap.mui.blue = saveColor(blue);
    Snap.mui.lightblue = saveColor(lightblue);
    Snap.mui.cyan = saveColor(cyan);
    Snap.mui.teal = saveColor(teal);
    Snap.mui.green = saveColor(green);
    Snap.mui.lightgreen = saveColor(lightgreen);
    Snap.mui.lime = saveColor(lime);
    Snap.mui.yellow = saveColor(yellow);
    Snap.mui.amber = saveColor(amber);
    Snap.mui.orange = saveColor(orange);
    Snap.mui.deeporange = saveColor(deeporange);
    Snap.mui.brown = saveColor(brown);
    Snap.mui.grey = saveColor(grey);
    Snap.mui.bluegrey = saveColor(bluegrey);
    Snap.flat.turquoise = "#1abc9c";
    Snap.flat.greensea = "#16a085";
    Snap.flat.sunflower = "#f1c40f";
    Snap.flat.orange = "#f39c12";
    Snap.flat.emerland = "#2ecc71";
    Snap.flat.nephritis = "#27ae60";
    Snap.flat.carrot = "#e67e22";
    Snap.flat.pumpkin = "#d35400";
    Snap.flat.peterriver = "#3498db";
    Snap.flat.belizehole = "#2980b9";
    Snap.flat.alizarin = "#e74c3c";
    Snap.flat.pomegranate = "#c0392b";
    Snap.flat.amethyst = "#9b59b6";
    Snap.flat.wisteria = "#8e44ad";
    Snap.flat.clouds = "#ecf0f1";
    Snap.flat.silver = "#bdc3c7";
    Snap.flat.wetasphalt = "#34495e";
    Snap.flat.midnightblue = "#2c3e50";
    Snap.flat.concrete = "#95a5a6";
    Snap.flat.asbestos = "#7f8c8d";
    /*\
     * Snap.importMUIColors
     [ method ]
     **
     * Imports Material UI colours into global object.
     | Snap.importMUIColors();
     | Snap().rect(0, 0, 10, 10).attr({fill: deeppurple, stroke: amber[600]});
     # For colour reference: <a href="https://www.materialui.co">https://www.materialui.co</a>.
    \*/
    Snap.importMUIColors = function () {
        for (var color in Snap.mui) {
            if (Snap.mui.hasOwnProperty(color)) {
                window[color] = Snap.mui[color];
            }
        }
    };
});

return Snap;
}));
}.call(window));

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:11 */




/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */


// -------------------------------------------------------------------------Node

/**
 * Advancing front node
 * @constructor
 * @private
 * @struct
 * @param {!XY} p - Point
 * @param {Triangle=} t triangle (optional)
 */
var Node = function(p, t) {
    /** @type {XY} */
    this.point = p;

    /** @type {Triangle|null} */
    this.triangle = t || null;

    /** @type {Node|null} */
    this.next = null;
    /** @type {Node|null} */
    this.prev = null;

    /** @type {number} */
    this.value = p.x;
};

// ---------------------------------------------------------------AdvancingFront
/**
 * @constructor
 * @private
 * @struct
 * @param {Node} head
 * @param {Node} tail
 */
var AdvancingFront = function(head, tail) {
    /** @type {Node} */
    this.head_ = head;
    /** @type {Node} */
    this.tail_ = tail;
    /** @type {Node} */
    this.search_node_ = head;
};

/** @return {Node} */
AdvancingFront.prototype.head = function() {
    return this.head_;
};

/** @param {Node} node */
AdvancingFront.prototype.setHead = function(node) {
    this.head_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.tail = function() {
    return this.tail_;
};

/** @param {Node} node */
AdvancingFront.prototype.setTail = function(node) {
    this.tail_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.search = function() {
    return this.search_node_;
};

/** @param {Node} node */
AdvancingFront.prototype.setSearch = function(node) {
    this.search_node_ = node;
};

/** @return {Node} */
AdvancingFront.prototype.findSearchNode = function(/*x*/) {
    // TODO: implement BST index
    return this.search_node_;
};

/**
 * @param {number} x value
 * @return {Node}
 */
AdvancingFront.prototype.locateNode = function(x) {
    var node = this.search_node_;

    /* jshint boss:true */
    if (x < node.value) {
        while (node = node.prev) {
            if (x >= node.value) {
                this.search_node_ = node;
                return node;
            }
        }
    } else {
        while (node = node.next) {
            if (x < node.value) {
                this.search_node_ = node.prev;
                return node.prev;
            }
        }
    }
    return null;
};

/**
 * @param {!XY} point - Point
 * @return {Node}
 */
AdvancingFront.prototype.locatePoint = function(point) {
    var px = point.x;
    var node = this.findSearchNode(px);
    var nx = node.point.x;

    if (px === nx) {
        // Here we are comparing point references, not values
        if (point !== node.point) {
            // We might have two nodes with same x value for a short time
            if (point === node.prev.point) {
                node = node.prev;
            } else if (point === node.next.point) {
                node = node.next;
            } else {
                throw new Error('poly2tri Invalid AdvancingFront.locatePoint() call');
            }
        }
    } else if (px < nx) {
        /* jshint boss:true */
        while (node = node.prev) {
            if (point === node.point) {
                break;
            }
        }
    } else {
        while (node = node.next) {
            if (point === node.point) {
                break;
            }
        }
    }

    if (node) {
        this.search_node_ = node;
    }
    return node;
};


// ----------------------------------------------------------------------Exports

module.exports = AdvancingFront;
module.exports.Node = Node;



/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */



/*
 * Class added in the JavaScript version (was not present in the c++ version)
 */

var xy = __webpack_require__(20);

/**
 * Custom exception class to indicate invalid Point values
 * @constructor
 * @public
 * @extends Error
 * @struct
 * @param {string=} message - error message
 * @param {Array.<XY>=} points - invalid points
 */
var PointError = function(message, points) {
    this.name = "PointError";
    /**
     * Invalid points
     * @public
     * @type {Array.<XY>}
     */
    this.points = points = points || [];
    /**
     * Error message
     * @public
     * @type {string}
     */
    this.message = message || "Invalid Points!";
    for (var i = 0; i < points.length; i++) {
        this.message += " " + xy.toString(points[i]);
    }
};
PointError.prototype = new Error();
PointError.prototype.constructor = PointError;


module.exports = PointError;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:10 */




/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = __webpack_require__(20);


// ---------------------------------------------------------------------Triangle
/**
 * Triangle class.<br>
 * Triangle-based data structures are known to have better performance than
 * quad-edge structures.
 * See: J. Shewchuk, "Triangle: Engineering a 2D Quality Mesh Generator and
 * Delaunay Triangulator", "Triangulations in CGAL"
 *
 * @constructor
 * @struct
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 */
var Triangle = function(a, b, c) {
    /**
     * Triangle points
     * @private
     * @type {Array.<XY>}
     */
    this.points_ = [a, b, c];

    /**
     * Neighbor list
     * @private
     * @type {Array.<Triangle>}
     */
    this.neighbors_ = [null, null, null];

    /**
     * Has this triangle been marked as an interior triangle?
     * @private
     * @type {boolean}
     */
    this.interior_ = false;

    /**
     * Flags to determine if an edge is a Constrained edge
     * @private
     * @type {Array.<boolean>}
     */
    this.constrained_edge = [false, false, false];

    /**
     * Flags to determine if an edge is a Delauney edge
     * @private
     * @type {Array.<boolean>}
     */
    this.delaunay_edge = [false, false, false];
};

var p2s = xy.toString;
/**
 * For pretty printing ex. <code>"[(5;42)(10;20)(21;30)]"</code>.
 * @public
 * @return {string}
 */
Triangle.prototype.toString = function() {
    return ("[" + p2s(this.points_[0]) + p2s(this.points_[1]) + p2s(this.points_[2]) + "]");
};

/**
 * Get one vertice of the triangle.
 * The output triangles of a triangulation have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      // → "number"
 * @param {number} index - vertice index: 0, 1 or 2
 * @public
 * @returns {XY}
 */
Triangle.prototype.getPoint = function(index) {
    return this.points_[index];
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode Triangle#getPoint} instead
 */
Triangle.prototype.GetPoint = Triangle.prototype.getPoint;

/**
 * Get all 3 vertices of the triangle as an array
 * @public
 * @return {Array.<XY>}
 */
// Method added in the JavaScript version (was not present in the c++ version)
Triangle.prototype.getPoints = function() {
    return this.points_;
};

/**
 * @private
 * @param {number} index
 * @returns {?Triangle}
 */
Triangle.prototype.getNeighbor = function(index) {
    return this.neighbors_[index];
};

/**
 * Test if this Triangle contains the Point object given as parameter as one of its vertices.
 * Only point references are compared, not values.
 * @public
 * @param {XY} point - point object with {x,y}
 * @return {boolean} <code>True</code> if the Point object is of the Triangle's vertices,
 *         <code>false</code> otherwise.
 */
Triangle.prototype.containsPoint = function(point) {
    var points = this.points_;
    // Here we are comparing point references, not values
    return (point === points[0] || point === points[1] || point === points[2]);
};

/**
 * Test if this Triangle contains the Edge object given as parameter as its
 * bounding edges. Only point references are compared, not values.
 * @private
 * @param {Edge} edge
 * @return {boolean} <code>True</code> if the Edge object is of the Triangle's bounding
 *         edges, <code>false</code> otherwise.
 */
Triangle.prototype.containsEdge = function(edge) {
    return this.containsPoint(edge.p) && this.containsPoint(edge.q);
};

/**
 * Test if this Triangle contains the two Point objects given as parameters among its vertices.
 * Only point references are compared, not values.
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {boolean}
 */
Triangle.prototype.containsPoints = function(p1, p2) {
    return this.containsPoint(p1) && this.containsPoint(p2);
};

/**
 * Has this triangle been marked as an interior triangle?
 * @returns {boolean}
 */
Triangle.prototype.isInterior = function() {
    return this.interior_;
};

/**
 * Mark this triangle as an interior triangle
 * @private
 * @param {boolean} interior
 * @returns {Triangle} this
 */
Triangle.prototype.setInterior = function(interior) {
    this.interior_ = interior;
    return this;
};

/**
 * Update neighbor pointers.
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @param {Triangle} t Triangle object.
 * @throws {Error} if can't find objects
 */
Triangle.prototype.markNeighborPointers = function(p1, p2, t) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if ((p1 === points[2] && p2 === points[1]) || (p1 === points[1] && p2 === points[2])) {
        this.neighbors_[0] = t;
    } else if ((p1 === points[0] && p2 === points[2]) || (p1 === points[2] && p2 === points[0])) {
        this.neighbors_[1] = t;
    } else if ((p1 === points[0] && p2 === points[1]) || (p1 === points[1] && p2 === points[0])) {
        this.neighbors_[2] = t;
    } else {
        throw new Error('poly2tri Invalid Triangle.markNeighborPointers() call');
    }
};

/**
 * Exhaustive search to update neighbor pointers
 * @private
 * @param {!Triangle} t
 */
Triangle.prototype.markNeighbor = function(t) {
    var points = this.points_;
    if (t.containsPoints(points[1], points[2])) {
        this.neighbors_[0] = t;
        t.markNeighborPointers(points[1], points[2], this);
    } else if (t.containsPoints(points[0], points[2])) {
        this.neighbors_[1] = t;
        t.markNeighborPointers(points[0], points[2], this);
    } else if (t.containsPoints(points[0], points[1])) {
        this.neighbors_[2] = t;
        t.markNeighborPointers(points[0], points[1], this);
    }
};


Triangle.prototype.clearNeighbors = function() {
    this.neighbors_[0] = null;
    this.neighbors_[1] = null;
    this.neighbors_[2] = null;
};

Triangle.prototype.clearDelaunayEdges = function() {
    this.delaunay_edge[0] = false;
    this.delaunay_edge[1] = false;
    this.delaunay_edge[2] = false;
};

/**
 * Returns the point clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[2];
    } else if (p === points[1]) {
        return points[0];
    } else if (p === points[2]) {
        return points[1];
    } else {
        return null;
    }
};

/**
 * Returns the point counter-clockwise to the given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.pointCCW = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return points[1];
    } else if (p === points[1]) {
        return points[2];
    } else if (p === points[2]) {
        return points[0];
    } else {
        return null;
    }
};

/**
 * Returns the neighbor clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[1];
    } else if (p === this.points_[1]) {
        return this.neighbors_[2];
    } else {
        return this.neighbors_[0];
    }
};

/**
 * Returns the neighbor counter-clockwise to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.neighborCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[2];
    } else if (p === this.points_[1]) {
        return this.neighbors_[0];
    } else {
        return this.neighbors_[1];
    }
};

Triangle.prototype.getConstrainedEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[1];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[2];
    } else {
        return this.constrained_edge[0];
    }
};

Triangle.prototype.getConstrainedEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[2];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[0];
    } else {
        return this.constrained_edge[1];
    }
};

// Additional check from Java version (see issue #88)
Triangle.prototype.getConstrainedEdgeAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.constrained_edge[0];
    } else if (p === this.points_[1]) {
        return this.constrained_edge[1];
    } else {
        return this.constrained_edge[2];
    }
};

Triangle.prototype.setConstrainedEdgeCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[1] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[2] = ce;
    } else {
        this.constrained_edge[0] = ce;
    }
};

Triangle.prototype.setConstrainedEdgeCCW = function(p, ce) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.constrained_edge[2] = ce;
    } else if (p === this.points_[1]) {
        this.constrained_edge[0] = ce;
    } else {
        this.constrained_edge[1] = ce;
    }
};

Triangle.prototype.getDelaunayEdgeCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[1];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[2];
    } else {
        return this.delaunay_edge[0];
    }
};

Triangle.prototype.getDelaunayEdgeCCW = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.delaunay_edge[2];
    } else if (p === this.points_[1]) {
        return this.delaunay_edge[0];
    } else {
        return this.delaunay_edge[1];
    }
};

Triangle.prototype.setDelaunayEdgeCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[1] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[2] = e;
    } else {
        this.delaunay_edge[0] = e;
    }
};

Triangle.prototype.setDelaunayEdgeCCW = function(p, e) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        this.delaunay_edge[2] = e;
    } else if (p === this.points_[1]) {
        this.delaunay_edge[0] = e;
    } else {
        this.delaunay_edge[1] = e;
    }
};

/**
 * The neighbor across to given point.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {Triangle}
 */
Triangle.prototype.neighborAcross = function(p) {
    // Here we are comparing point references, not values
    if (p === this.points_[0]) {
        return this.neighbors_[0];
    } else if (p === this.points_[1]) {
        return this.neighbors_[1];
    } else {
        return this.neighbors_[2];
    }
};

/**
 * @private
 * @param {!Triangle} t Triangle object.
 * @param {XY} p - point object with {x,y}
 */
Triangle.prototype.oppositePoint = function(t, p) {
    var cw = t.pointCW(p);
    return this.pointCW(cw);
};

/**
 * Legalize triangle by rotating clockwise around oPoint
 * @private
 * @param {XY} opoint - point object with {x,y}
 * @param {XY} npoint - point object with {x,y}
 * @throws {Error} if oPoint can not be found
 */
Triangle.prototype.legalize = function(opoint, npoint) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (opoint === points[0]) {
        points[1] = points[0];
        points[0] = points[2];
        points[2] = npoint;
    } else if (opoint === points[1]) {
        points[2] = points[1];
        points[1] = points[0];
        points[0] = npoint;
    } else if (opoint === points[2]) {
        points[0] = points[2];
        points[2] = points[1];
        points[1] = npoint;
    } else {
        throw new Error('poly2tri Invalid Triangle.legalize() call');
    }
};

/**
 * Returns the index of a point in the triangle. 
 * The point *must* be a reference to one of the triangle's vertices.
 * @private
 * @param {XY} p - point object with {x,y}
 * @returns {number} index 0, 1 or 2
 * @throws {Error} if p can not be found
 */
Triangle.prototype.index = function(p) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p === points[0]) {
        return 0;
    } else if (p === points[1]) {
        return 1;
    } else if (p === points[2]) {
        return 2;
    } else {
        throw new Error('poly2tri Invalid Triangle.index() call');
    }
};

/**
 * @private
 * @param {XY} p1 - point object with {x,y}
 * @param {XY} p2 - point object with {x,y}
 * @return {number} index 0, 1 or 2, or -1 if errror
 */
Triangle.prototype.edgeIndex = function(p1, p2) {
    var points = this.points_;
    // Here we are comparing point references, not values
    if (p1 === points[0]) {
        if (p2 === points[1]) {
            return 2;
        } else if (p2 === points[2]) {
            return 1;
        }
    } else if (p1 === points[1]) {
        if (p2 === points[2]) {
            return 0;
        } else if (p2 === points[0]) {
            return 2;
        }
    } else if (p1 === points[2]) {
        if (p2 === points[0]) {
            return 1;
        } else if (p2 === points[1]) {
            return 0;
        }
    }
    return -1;
};

/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {number} index - edge index
 */
Triangle.prototype.markConstrainedEdgeByIndex = function(index) {
    this.constrained_edge[index] = true;
};
/**
 * Mark an edge of this triangle as constrained.
 * @private
 * @param {Edge} edge instance
 */
Triangle.prototype.markConstrainedEdgeByEdge = function(edge) {
    this.markConstrainedEdgeByPoints(edge.p, edge.q);
};
/**
 * Mark an edge of this triangle as constrained.
 * This method takes two Point instances defining the edge of the triangle.
 * @private
 * @param {XY} p - point object with {x,y}
 * @param {XY} q - point object with {x,y}
 */
Triangle.prototype.markConstrainedEdgeByPoints = function(p, q) {
    var points = this.points_;
    // Here we are comparing point references, not values        
    if ((q === points[0] && p === points[1]) || (q === points[1] && p === points[0])) {
        this.constrained_edge[2] = true;
    } else if ((q === points[0] && p === points[2]) || (q === points[2] && p === points[0])) {
        this.constrained_edge[1] = true;
    } else if ((q === points[1] && p === points[2]) || (q === points[2] && p === points[1])) {
        this.constrained_edge[0] = true;
    }
};


// ---------------------------------------------------------Exports (public API)

module.exports = Triangle;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright 2016 Todd Fleming
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
// 
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.



Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getLaserCutGcode = getLaserCutGcode;
exports.getLaserCutGcodeFromOp = getLaserCutGcodeFromOp;

var _cam = __webpack_require__(92);

var _mesh = __webpack_require__(35);

var _gcodeGenerator = __webpack_require__(89);

// Convert laser cut paths to gcode.
//      paths:          Array of CamPath
//      scale:          Factor to convert Clipper units to gcode units
//      offsetX:        Offset X (gcode units)
//      offsetY:        Offset Y (gcode units)
//      decimal:        Number of decimal places to keep in gcode
//      cutFeed:        Feedrate for horizontal cuts (gcode units)
//      laserPower:     [0, 100]
//      passes:         Number of passes
//      tabGeometry:    Tab geometry
//      gcodeToolOn:   Laser on (may be empty)
//      gcodeToolOff:  Laser off (may be empty)
//      gcodeSMaxValue: Max S value
function getLaserCutGcode(props) {
    let paths = props.paths,
        generator = props.generator,
        scale = props.scale,
        offsetX = props.offsetX,
        offsetY = props.offsetY,
        decimal = props.decimal,
        cutFeed = props.cutFeed,
        laserPower = props.laserPower,
        passes = props.passes,
        useA = props.useA,
        aAxisDiameter = props.aAxisDiameter,
        tabGeometry = props.tabGeometry,
        gcodeToolOn = props.gcodeToolOn,
        gcodeToolOff = props.gcodeToolOff,
        gcodeLaserIntensity = props.gcodeLaserIntensity,
        gcodeLaserIntensitySeparateLine = props.gcodeLaserIntensitySeparateLine,
        gcodeSMinValue = props.gcodeSMinValue,
        gcodeSMaxValue = props.gcodeSMaxValue,
        useZ = props.useZ,
        useBlower = props.useBlower,
        hookPassStart = props.hookPassStart,
        hookPassEnd = props.hookPassEnd;


    if (gcodeToolOn) gcodeToolOn += '\r\n';
    if (gcodeToolOff) gcodeToolOff += '\r\n';
    let laserOnS = gcodeLaserIntensity + (gcodeSMinValue + (gcodeSMaxValue - gcodeSMinValue) * laserPower / 100).toFixed(decimal);

    let lastX = 0,
        lastY = 0,
        lastA = 0;
    function convertPoint(p, rapid) {
        let x = p.X * scale + offsetX;
        let y = p.Y * scale + offsetY;
        if (useA) {
            let a = y * 360 / aAxisDiameter / Math.PI;
            let roundedX = Number(x.toFixed(decimal));
            let roundedA = Number(a.toFixed(decimal));
            let adjustedY = roundedA * aAxisDiameter * Math.PI / 360;
            if (rapid) {
                lastX = roundedX;
                lastY = adjustedY;
                lastA = roundedA;
                //return 'G0 X' + x.toFixed(decimal) + ' A' + a.toFixed(decimal);
                return { x: x.toFixed(decimal), a: a.toFixed(decimal) };
            } else {
                let dx = roundedX - lastX,
                    dy = adjustedY - lastY,
                    da = roundedA - lastA;
                let travelTime = Math.sqrt(dx * dx + dy * dy) / cutFeed;
                let f = 0;
                if (dx) f = Math.abs(dx) / travelTime;else if (da) f = Math.abs(da) / travelTime;else return null;
                //return '';
                lastX = roundedX;
                lastY = adjustedY;
                lastA = roundedA;
                return { x: x.toFixed(decimal), a: a.toFixed(decimal), f: f.toFixed(decimal) };
                //return 'G1 X' + x.toFixed(decimal) + ' A' + a.toFixed(decimal) + ' F' + f.toFixed(decimal);
            }
        } else {
            return { x: x.toFixed(decimal), y: y.toFixed(decimal) };
            /*if (rapid)
                return 'G0 X' + x.toFixed(decimal) + ' Y' + y.toFixed(decimal);
            else
                return 'G1 X' + x.toFixed(decimal) + ' Y' + y.toFixed(decimal);*/
        }
    }

    let gcode = '';

    for (let pass = 0; pass < passes; ++pass) {

        if (hookPassStart) gcode += hookPassStart;

        gcode += '\n\n; Pass ' + pass + '\r\n';

        if (useBlower) {
            if (useBlower.blowerOn) {
                gcode += `${useBlower.blowerOn}; Enable Air assist\r\n`;
            }
        }

        let usedZposition = false;
        for (let pathIndex = 0; pathIndex < paths.length; ++pathIndex) {
            let path = paths[pathIndex].path;
            if (path.length === 0) continue;
            gcode += '\r\n; Pass ' + pass + ' Path ' + pathIndex + '\r\n';

            let separatedPaths = (0, _cam.separateTabs)(path, tabGeometry);
            for (let selectedIndex = 0; selectedIndex < separatedPaths.length; ++selectedIndex) {
                let selectedPath = separatedPaths[selectedIndex];
                if (selectedPath.length === 0) continue;
                if (selectedIndex & 1) {
                    gcode += '; Skip tab\r\n';
                    continue;
                }
                gcode += generator.moveRapid(convertPoint(selectedPath[0], true)) + '\r\n';

                if (useZ && !usedZposition) {
                    usedZposition = true;
                    let zHeight = useZ.startZ + useZ.offsetZ - useZ.passDepth * pass;
                    gcode += `; Pass Z Height ${zHeight}mm (Offset: ${useZ.offsetZ}mm)\r\n`;
                    gcode += 'G0 Z' + zHeight.toFixed(decimal) + '\r\n\r\n';
                }

                gcode += generator.toolOn(gcodeToolOn, { i: laserOnS });

                for (let i = 1; i < selectedPath.length; ++i) {
                    if (i == 1 && gcodeLaserIntensitySeparateLine) gcode += laserOnS + '\n';
                    let action = convertPoint(selectedPath[i], false);
                    //gcode += convertPoint(selectedPath[i], false);
                    if (i == 1 && !gcodeLaserIntensitySeparateLine) action.i = laserOnS;
                    //gcode += ' ' + laserOnS;
                    if (i == 1 && !useA) action.f = cutFeed;
                    //gcode += ' F' + cutFeed;
                    gcode += generator.moveTool(action);
                    gcode += '\r\n';
                }

                gcode += generator.toolOff(gcodeToolOff, { i: laserOnS });
            }
        }

        if (useBlower) {
            if (useBlower.blowerOff) {
                gcode += `${useBlower.blowerOff}; Disable Air assist\r\n`;
            }
        }

        if (hookPassEnd) gcode += hookPassEnd;
    }

    return gcode;
}; // getLaserCutGcode

function getLaserCutGcodeFromOp(settings, opIndex, op, geometry, openGeometry, tabGeometry, showAlert, done, progress) {
    let ok = true;

    if (op.type !== 'Laser Cut' && op.type !== 'Laser Fill Path') {
        if (op.laserDiameter <= 0) {
            showAlert("Laser Diameter must be greater than 0", "danger");
            ok = false;
        }
    }
    if (op.type === 'Laser Fill Path') {
        if (op.lineDistance <= 0) {
            showAlert("Line Distance must be greater than 0", "danger");
            ok = false;
        }
    }
    if (op.laserPower < 0 || op.laserPower > 100) {
        showAlert("Laser Power must be in range [0, 100]", "danger");
        ok = false;
    }
    if (op.passes <= 0 || (op.passes | 0) !== +op.passes) {
        showAlert("Passes must be integer > 0", "danger");
        ok = false;
    }
    if (op.cutRate <= 0) {
        showAlert("Cut Rate must be greater than 0", "danger");
        ok = false;
    }
    if (op.useA) {
        if (op.aAxisDiameter <= 0) {
            showAlert("A axis diameter must be greater than 0", "danger");
            ok = false;
        }
    }

    if (settings.machineZEnabled) {
        if (op.startHeight === "" || isNaN(op.startHeight)) {
            showAlert("Start Height must be a valid number", "danger");
            ok = false;
        }
    }

    if (!ok) {
        done(false);
    }

    let camPaths = [];
    if (op.type === 'Laser Cut') {
        camPaths = (0, _cam.cut)(geometry, openGeometry, false);
    } else if (op.type === 'Laser Cut Inside') {
        if (op.margin) geometry = (0, _mesh.offset)(geometry, -op.margin * _mesh.mmToClipperScale);
        camPaths = (0, _cam.insideOutside)(geometry, op.laserDiameter * _mesh.mmToClipperScale, true, op.cutWidth * _mesh.mmToClipperScale, op.stepOver, op.direction === 'Climb', false);
    } else if (op.type === 'Laser Cut Outside') {
        if (op.margin) geometry = (0, _mesh.offset)(geometry, op.margin * _mesh.mmToClipperScale);
        camPaths = (0, _cam.insideOutside)(geometry, op.laserDiameter * _mesh.mmToClipperScale, false, op.cutWidth * _mesh.mmToClipperScale, op.stepOver, op.direction === 'Climb', false);
    } else if (op.type === 'Laser Fill Path') {
        if (op.margin) geometry = (0, _mesh.offset)(geometry, -op.margin * _mesh.mmToClipperScale);
        camPaths = (0, _cam.fillPath)(geometry, op.lineDistance * _mesh.mmToClipperScale, op.lineAngle);
    }

    (0, _cam.reduceCamPaths)(camPaths, op.segmentLength * _mesh.mmToClipperScale);

    let feedScale = 1;
    if (settings.toolFeedUnits === 'mm/s') feedScale = 60;

    let gcode = "\r\n;" + "\r\n; Operation:    " + opIndex + "\r\n; Type:         " + op.type + "\r\n; Paths:        " + camPaths.length + "\r\n; Passes:       " + op.passes + "\r\n; Cut rate:     " + op.cutRate + ' ' + settings.toolFeedUnits + "\r\n;\r\n";

    if (op.hookOperationStart.length) gcode += op.hookOperationStart;

    let generator = (0, _gcodeGenerator.getGenerator)(settings.gcodeGenerator, settings);

    gcode += getLaserCutGcode({
        generator: generator,
        paths: camPaths,
        scale: 1 / _mesh.mmToClipperScale,
        offsetX: 0,
        offsetY: 0,
        decimal: 2,
        cutFeed: op.cutRate * feedScale,
        laserPower: op.laserPower,
        passes: op.passes,
        useA: op.useA,
        useZ: settings.machineZEnabled ? {
            startZ: Number(op.startHeight),
            offsetZ: settings.machineZToolOffset,
            passDepth: op.passDepth
        } : false,
        useBlower: op.useBlower ? {
            blowerOn: settings.machineBlowerGcodeOn,
            blowerOff: settings.machineBlowerGcodeOff
        } : false,
        aAxisDiameter: op.aAxisDiameter,
        tabGeometry: tabGeometry,
        gcodeToolOn: settings.gcodeToolOn,
        gcodeToolOff: settings.gcodeToolOff,
        gcodeLaserIntensity: settings.gcodeLaserIntensity,
        gcodeLaserIntensitySeparateLine: settings.gcodeLaserIntensitySeparateLine,
        gcodeSMinValue: settings.gcodeSMinValue,
        gcodeSMaxValue: settings.gcodeSMaxValue,

        hookPassStart: op.hookPassStart,
        hookPassEnd: op.hookPassEnd
    });

    if (op.hookOperationEnd.length) gcode += op.hookOperationEnd;

    done(gcode);
} // getLaserCutGcodeFromOp

;

var _temp = function () {
    if (typeof __REACT_HOT_LOADER__ === 'undefined') {
        return;
    }

    __REACT_HOT_LOADER__.register(getLaserCutGcode, 'getLaserCutGcode', '/home/pi/LaserWeb4/src/lib/cam-gcode-laser-cut.js');

    __REACT_HOT_LOADER__.register(getLaserCutGcodeFromOp, 'getLaserCutGcodeFromOp', '/home/pi/LaserWeb4/src/lib/cam-gcode-laser-cut.js');
}();

;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(55);

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(57);

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(58);

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(59);

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var _Array$isArray = __webpack_require__(47);

function _arrayWithHoles(arr) {
  if (_Array$isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

var _getIterator = __webpack_require__(12);

var _isIterable = __webpack_require__(48);

function _iterableToArrayLimit(arr, i) {
  if (!(_isIterable(Object(arr)) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = _getIterator(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),
/* 53 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

module.exports = _nonIterableRest;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(51);

var iterableToArrayLimit = __webpack_require__(52);

var nonIterableRest = __webpack_require__(53);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(85);
module.exports = __webpack_require__(1).Array.isArray;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(33);
__webpack_require__(32);
module.exports = __webpack_require__(83);


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(33);
__webpack_require__(32);
module.exports = __webpack_require__(84);


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(87);
var $Object = __webpack_require__(1).Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(88);
module.exports = __webpack_require__(1).parseInt;


/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(19);
var toLength = __webpack_require__(79);
var toAbsoluteIndex = __webpack_require__(78);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(60);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(3).document;
module.exports = document && document.documentElement;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(10) && !__webpack_require__(14)(function () {
  return Object.defineProperty(__webpack_require__(22)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(13);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(13);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(26);
var descriptor = __webpack_require__(27);
var setToStringTag = __webpack_require__(28);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(6)(IteratorPrototype, __webpack_require__(4)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 69 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(16);
var anObject = __webpack_require__(8);
var getKeys = __webpack_require__(73);

module.exports = __webpack_require__(10) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(11);
var toObject = __webpack_require__(80);
var IE_PROTO = __webpack_require__(17)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(11);
var toIObject = __webpack_require__(19);
var arrayIndexOf = __webpack_require__(62)(false);
var IE_PROTO = __webpack_require__(17)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(72);
var enumBugKeys = __webpack_require__(23);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(3).parseInt;
var $trim = __webpack_require__(77).trim;
var ws = __webpack_require__(30);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(6);


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(18);
var defined = __webpack_require__(9);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(5);
var defined = __webpack_require__(9);
var fails = __webpack_require__(14);
var spaces = __webpack_require__(30);
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(18);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(18);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(9);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(15);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(21);
var ITERATOR = __webpack_require__(4)('iterator');
var Iterators = __webpack_require__(7);
module.exports = __webpack_require__(1).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(8);
var get = __webpack_require__(82);
module.exports = __webpack_require__(1).getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(21);
var ITERATOR = __webpack_require__(4)('iterator');
var Iterators = __webpack_require__(7);
module.exports = __webpack_require__(1).isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(5);

$export($export.S, 'Array', { isArray: __webpack_require__(67) });


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(61);
var step = __webpack_require__(69);
var Iterators = __webpack_require__(7);
var toIObject = __webpack_require__(19);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(24)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(5);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(26) });


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(5);
var $parseInt = __webpack_require__(74);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getGenerator = getGenerator;

var _defaultGenerator = __webpack_require__(90);

var _defaultGenerator2 = _interopRequireDefault(_defaultGenerator);

var _marlinGenerator = __webpack_require__(91);

var _marlinGenerator2 = _interopRequireDefault(_marlinGenerator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getGenerator(gcodeGenerator, settings) {
  switch (gcodeGenerator) {
    case "marlin":
      return new _marlinGenerator2.default(settings);
    case "default":
    default:
      return new _defaultGenerator2.default(settings);
  }
}
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(getGenerator, "getGenerator", "/home/pi/LaserWeb4/src/lib/action2gcode/gcode-generator.js");
}();

;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DefaultGenerator = undefined;

var _abstractGenerator = __webpack_require__(34);

var _abstractGenerator2 = _interopRequireDefault(_abstractGenerator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// AbstractDriver class
let DefaultGenerator = class DefaultGenerator extends _abstractGenerator2.default {
  // Class constructor...
  constructor(settings) {
    super(settings);
  }

  moveRapid(params) {
    let optimized = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (params == null) return "";

    let gcode = "";
    if (!optimized) gcode += "G0 ";
    gcode += this.move(params);
    return gcode;
  }

  moveTool(params) {
    let optimized = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (params == null) return "";

    let gcode = "";
    if (!optimized) gcode += "G1 ";
    gcode += this.move(params);
    return gcode;
  }

  toolOn(gcode, params) {
    if (gcode == null) return "";

    if (params.hasOwnProperty("i")) gcode = gcode.split("$INTENSITY").join(params.i);
    return gcode;
  }

  toolOff(gcode, params) {
    if (gcode == null) return "";

    if (params.hasOwnProperty("i")) gcode = gcode.split("$INTENSITY").join(params.i);
    return gcode;
  }

  move(params) {
    let gcode = "";
    if (params.hasOwnProperty("x")) gcode += ` X${params.x}`;

    if (params.hasOwnProperty("y")) gcode += ` Y${params.y}`;

    if (params.hasOwnProperty("a")) gcode += ` A${params.a}`;

    if (params.hasOwnProperty("i")) gcode += ` ${params.i}`;

    if (params.hasOwnProperty("s")) gcode += ` S${params.s}`;

    if (params.hasOwnProperty("f")) gcode += ` F${params.f}`;

    return gcode.trim();
  }

};

// Exports

exports.DefaultGenerator = DefaultGenerator;
const _default = DefaultGenerator;
exports.default = _default;
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(DefaultGenerator, "DefaultGenerator", "/home/pi/LaserWeb4/src/lib/action2gcode/generators/default-generator.js");

  __REACT_HOT_LOADER__.register(_default, "default", "/home/pi/LaserWeb4/src/lib/action2gcode/generators/default-generator.js");
}();

;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarlinGenerator = undefined;

var _abstractGenerator = __webpack_require__(34);

var _abstractGenerator2 = _interopRequireDefault(_abstractGenerator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// AbstractDriver class
let MarlinGenerator = class MarlinGenerator extends _abstractGenerator2.default {
  // Class constructor...
  constructor(settings) {
    super(settings);
  }

  moveRapid(params) {
    let optimized = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (params == null) return "";

    return this.move("G0", params);
  }

  moveTool(params) {
    let optimized = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (params == null) return "";

    return this.move("G1", params);
  }

  toolOn(gcode, params) {
    if (gcode == null) return "";

    if (params.hasOwnProperty("i")) gcode = gcode.split("$INTENSITY").join(params.i);
    return gcode;
  }

  toolOff(gcode, params) {
    if (gcode == null) return "";

    if (params.hasOwnProperty("i")) gcode = gcode.split("$INTENSITY").join(params.i);
    return gcode;
  }

  move(prefix, params) {
    let gcode = "";

    if (params.hasOwnProperty("s")) {
      if (this.settings.gcodeToolOn.indexOf("$INTENSITY") > -1) {
        gcode += `${this.settings.gcodeToolOn.split("$INTENSITY").join(this.settings.gcodeLaserIntensity + params.s)}\r\n`;
      } else {
        gcode += `${this.settings.gcodeToolOn} S${params.s}\r\n`;
      }
    }

    if (params.hasOwnProperty("i")) {
      if (this.settings.gcodeToolOn.indexOf("$INTENSITY") > -1) {
        gcode += `${this.settings.gcodeToolOn.split("$INTENSITY").join(params.i)}\r\n`;
      } else {
        gcode += `${this.settings.gcodeToolOn} ${params.i}\r\n`;
      }
    }

    gcode += prefix;

    if (params.hasOwnProperty("x")) gcode += ` X${params.x}`;

    if (params.hasOwnProperty("y")) gcode += ` Y${params.y}`;

    if (params.hasOwnProperty("a")) gcode += ` A${params.a}`;

    if (params.hasOwnProperty("f")) gcode += ` F${params.f}`;

    return gcode.trim();
  }

};

// Exports

exports.MarlinGenerator = MarlinGenerator;
const _default = MarlinGenerator;
exports.default = _default;
;

var _temp = function () {
  if (typeof __REACT_HOT_LOADER__ === 'undefined') {
    return;
  }

  __REACT_HOT_LOADER__.register(MarlinGenerator, "MarlinGenerator", "/home/pi/LaserWeb4/src/lib/action2gcode/generators/marlin-generator.js");

  __REACT_HOT_LOADER__.register(_default, "default", "/home/pi/LaserWeb4/src/lib/action2gcode/generators/marlin-generator.js");
}();

;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright 2014, 2016 Todd Fleming
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.



Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dist = dist;
exports.pocket = pocket;
exports.insideOutside = insideOutside;
exports.cut = cut;
exports.fillPath = fillPath;
exports.vCarve = vCarve;
exports.reduceCamPaths = reduceCamPaths;
exports.getClipperPathsFromCamPaths = getClipperPathsFromCamPaths;
exports.separateTabs = separateTabs;

var _clipperLib = __webpack_require__(36);

var _clipperLib2 = _interopRequireDefault(_clipperLib);

var _glMatrix = __webpack_require__(94);

var _mesh = __webpack_require__(35);

var _rawLoaderWebCamCpp = __webpack_require__(104);

var _rawLoaderWebCamCpp2 = _interopRequireDefault(_rawLoaderWebCamCpp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function dist(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
}

// Does the line from p1 to p2 cross outside of bounds?


//const Module = require('raw-loader!web-cam-cpp');
function crosses(bounds, p1, p2) {
    if (bounds === null) return true;
    if (p1.X === p2.X && p1.Y === p2.Y) return false;
    let clipper = new _clipperLib2.default.Clipper();
    clipper.AddPath([p1, p2], _clipperLib2.default.PolyType.ptSubject, false);
    clipper.AddPaths(bounds, _clipperLib2.default.PolyType.ptClip, true);
    let result = new _clipperLib2.default.PolyTree();
    clipper.Execute(_clipperLib2.default.ClipType.ctIntersection, result, _clipperLib2.default.PolyFillType.pftEvenOdd, _clipperLib2.default.PolyFillType.pftEvenOdd);
    if (result.ChildCount() === 1) {
        let child = result.Childs()[0];
        let points = child.Contour();
        if (points.length === 2) {
            if (points[0].X === p1.X && points[1].X === p2.X && points[0].Y === p1.Y && points[1].Y === p2.Y) return false;
            if (points[0].X === p2.X && points[1].X === p1.X && points[0].Y === p2.Y && points[1].Y === p1.Y) return false;
        }
    }
    return true;
}

function pathIsClosed(clipperPath) {
    return clipperPath.length >= 2 && clipperPath[0].X === clipperPath[clipperPath.length - 1].X && clipperPath[0].Y === clipperPath[clipperPath.length - 1].Y;
}

// Close all paths
function closeClipperPaths(paths) {
    for (let path of paths) path.push(path[0]);
}

// CamPath has this format: {
//      path:               Clipper path
//      safeToClose:        Is it safe to close the path without retracting?
// }

// Try to merge paths. A merged path doesn't cross outside of bounds. Returns array of CamPath.
// If paths contains both open and closed paths, then the closed paths must be before the open
// paths within the array.
function mergePaths(bounds, paths) {
    if (paths.length === 0) return [];

    let currentPath = paths[0];
    if (pathIsClosed(currentPath)) currentPath.push(currentPath[0]);
    let currentPoint = currentPath[currentPath.length - 1];
    paths[0] = [];

    let mergedPaths = [];
    let numLeft = paths.length - 1;
    while (numLeft > 0) {
        let closestPathIndex = null;
        let closestPointIndex = null;
        let closestPointDist = null;
        let closestReverse = false;
        for (let pathIndex = 0; pathIndex < paths.length; ++pathIndex) {
            let path = paths[pathIndex];
            function check(pointIndex) {
                let point = path[pointIndex];
                let dist = (currentPoint.X - point.X) * (currentPoint.X - point.X) + (currentPoint.Y - point.Y) * (currentPoint.Y - point.Y);
                if (closestPointDist === null || dist < closestPointDist) {
                    closestPathIndex = pathIndex;
                    closestPointIndex = pointIndex;
                    closestPointDist = dist;
                    closestReverse = false;
                    return true;
                } else return false;
            }
            if (pathIsClosed(path)) {
                for (let pointIndex = 0; pointIndex < path.length; ++pointIndex) check(pointIndex);
            } else if (path.length) {
                check(0);
                if (check(path.length - 1)) closestReverse = true;
            }
        }

        let path = paths[closestPathIndex];
        paths[closestPathIndex] = [];
        numLeft -= 1;
        let needNew;
        if (pathIsClosed(path)) {
            needNew = crosses(bounds, currentPoint, path[closestPointIndex]);
            path = path.slice(closestPointIndex, path.length).concat(path.slice(1, closestPointIndex));
            path.push(path[0]);
        } else {
            needNew = true;
            if (closestReverse) {
                path = path.slice();
                path.reverse();
            }
        }
        if (needNew) {
            mergedPaths.push(currentPath);
            currentPath = path;
            currentPoint = currentPath[currentPath.length - 1];
        } else {
            currentPath = currentPath.concat(path);
            currentPoint = currentPath[currentPath.length - 1];
        }
    }
    mergedPaths.push(currentPath);

    let camPaths = [];
    for (let i = 0; i < mergedPaths.length; ++i) {
        let path = mergedPaths[i];
        camPaths.push({
            path: path,
            safeToClose: !crosses(bounds, path[0], path[path.length - 1])
        });
    }

    return camPaths;
}

// Compute paths for pocket operation on Clipper geometry. Returns array
// of CamPath. cutterDia is in Clipper units. stepover is in the range (0, 100).
function pocket(geometry, cutterDia, stepover, climb) {
    stepover = stepover / 100;
    let current = (0, _mesh.offset)(geometry, -cutterDia / 2);
    let bounds = current.slice(0);
    let allPaths = [];
    while (current.length !== 0) {
        if (!climb) for (let i = 0; i < current.length; ++i) current[i].reverse();
        allPaths = current.concat(allPaths);
        current = (0, _mesh.offset)(current, -cutterDia * stepover);
    }
    closeClipperPaths(allPaths);
    return mergePaths(bounds, allPaths);
};

// Compute paths for inside/outside operation on Clipper geometry. Returns array
// of CamPath. cutterDia and width are in Clipper units. stepover is in the
// range (0, 100].
function insideOutside(geometry, cutterDia, isInside, width, stepover, climb, allowRecutInBounds) {

    stepover = stepover / 100;
    width = Math.max(width, cutterDia);

    let currentWidth = cutterDia;
    let allPaths = [];
    let eachWidth = cutterDia * stepover;

    let current;
    let bounds = null;
    let eachOffset;
    let needReverse;

    if (isInside) {
        current = (0, _mesh.offset)(geometry, -cutterDia / 2);
        if (allowRecutInBounds) bounds = (0, _mesh.diff)(current, (0, _mesh.offset)(geometry, -(width - cutterDia / 2)));
        eachOffset = -eachWidth;
        needReverse = !climb;
    } else {
        current = (0, _mesh.offset)(geometry, cutterDia / 2);
        if (allowRecutInBounds) bounds = (0, _mesh.diff)((0, _mesh.offset)(geometry, width - cutterDia / 2), current);
        eachOffset = eachWidth;
        needReverse = climb;
    }

    while (currentWidth <= width) {
        if (needReverse) for (let i = 0; i < current.length; ++i) current[i].reverse();
        allPaths = current.concat(allPaths);
        let nextWidth = currentWidth + eachWidth;
        if (nextWidth > width && width - currentWidth > 0) {
            current = (0, _mesh.offset)(current, width - currentWidth);
            if (needReverse) for (let i = 0; i < current.length; ++i) current[i].reverse();
            allPaths = current.concat(allPaths);
            break;
        }
        currentWidth = nextWidth;
        if (currentWidth <= width) current = (0, _mesh.offset)(current, eachOffset);
    }
    closeClipperPaths(allPaths);
    return mergePaths(bounds, allPaths);
};

// Compute paths for cut operation on Clipper geometry. Returns array
// of CamPath.
function cut(geometry, openGeometry, climb) {
    let allPaths = [];
    for (let i = 0; i < geometry.length; ++i) {
        let path = geometry[i].slice(0);
        if (climb) path.reverse();
        path.push(path[0]);
        allPaths.push(path);
    }
    for (let path of openGeometry) allPaths.push(path.slice());
    let result = mergePaths(null, allPaths);
    for (let i = 0; i < result.length; ++i) result[i].safeToClose = pathIsClosed(result[i].path);
    return result;
};

function fillPath(geometry, lineDistance, angle) {
    if (!geometry.length || !geometry[0].length) return [];
    let bounds = (0, _mesh.clipperBounds)(geometry);
    let cx = (bounds.minX + bounds.maxX) / 2;
    let cy = (bounds.minY + bounds.maxY) / 2;
    let r = dist(cx, cy, bounds.minX, bounds.minY) + lineDistance;

    let m = _glMatrix.mat3.fromTranslation([], [cx, cy]);
    m = _glMatrix.mat3.rotate([], m, angle * Math.PI / 180);
    m = _glMatrix.mat3.translate([], m, [-cx, -cy]);
    let makePoint = (x, y) => {
        let p = _glMatrix.vec2.transformMat3([], [x, y], m);
        return { X: p[0], Y: p[1] };
    };

    let scan = [];
    for (let y = cy - r; y < cy + r; y += lineDistance * 2) {
        scan.push(makePoint(cx - r, y), makePoint(cx + r, y), makePoint(cx + r, y + lineDistance), makePoint(cx - r, y + lineDistance));
    }

    let allPaths = [];
    let separated = separateTabs(scan, geometry);
    for (let i = 1; i < separated.length; i += 2) allPaths.push(separated[i]);
    return mergePaths(null, allPaths);
};

function vCarve(geometry, cutterAngle, passDepth) {
    if (cutterAngle <= 0 || cutterAngle >= 180) return [];

    let memoryBlocks = [];
    let resultPathsRef = _rawLoaderWebCamCpp2.default._malloc(4);
    let resultNumPathsRef = _rawLoaderWebCamCpp2.default._malloc(4);
    let resultPathSizesRef = _rawLoaderWebCamCpp2.default._malloc(4);
    let cGeometry = (0, _mesh.clipperPathsToCPaths)(memoryBlocks, geometry);
    memoryBlocks.push(resultPathsRef);
    memoryBlocks.push(resultNumPathsRef);
    memoryBlocks.push(resultPathSizesRef);

    let debugArg0 = 0,
        debugArg1 = 0;

    //extern "C" void vCarve(
    //    int debugArg0, int debugArg1,
    //    double** paths, int numPaths, int* pathSizes,
    //    double cutterAngle, double passDepth,
    //    double**& resultPaths, int& resultNumPaths, int*& resultPathSizes)
    _rawLoaderWebCamCpp2.default.ccall('vCarve', 'void', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number'], [debugArg0, debugArg1, cGeometry[0], cGeometry[1], cGeometry[2], cutterAngle, passDepth * _mesh.clipperToCppScale, resultPathsRef, resultNumPathsRef, resultPathSizesRef]);

    let result = (0, _mesh.cPathsToCamPaths)(memoryBlocks, resultPathsRef, resultNumPathsRef, resultPathSizesRef);

    for (let i = 0; i < memoryBlocks.length; ++i) _rawLoaderWebCamCpp2.default._free(memoryBlocks[i]);

    return result;
};

function reduceCamPaths(camPaths, minDist) {
    let minDistSqr = minDist * minDist;
    let distSqr = (p1, p2) => (p1.X - p2.X) * (p1.X - p2.X) + (p1.Y - p2.Y) * (p1.Y - p2.Y);
    for (let camPath of camPaths) {
        let path = camPath.path;
        let newPath = [path[0]];
        for (let i = 1; i < path.length - 1; ++i) {
            let sq = distSqr(path[i], newPath[newPath.length - 1]);
            if (sq > 0 && sq >= minDistSqr) newPath.push(path[i]);
        }
        newPath.push(path[path.length - 1]);
        camPath.path = newPath;
    }
}

// Convert array of CamPath to array of Clipper path
function getClipperPathsFromCamPaths(paths) {
    let result = [];
    if (paths !== null) for (let i = 0; i < paths.length; ++i) result.push(paths[i].path);
    return result;
}

let displayedCppTabError1 = false;
let displayedCppTabError2 = false;

function separateTabs(cutterPath, tabGeometry) {
    if (tabGeometry.length === 0) return [cutterPath];
    if (typeof _rawLoaderWebCamCpp2.default === 'undefined') {
        if (!displayedCppTabError1) {
            showAlert("Failed to load cam-cpp.js; tabs will be missing. This message will not repeat.", "danger", false);
            displayedCppTabError1 = true;
        }
        return cutterPath;
    }

    let memoryBlocks = [];

    let cCutterPath = (0, _mesh.clipperPathsToCPaths)(memoryBlocks, [cutterPath]);
    let cTabGeometry = (0, _mesh.clipperPathsToCPaths)(memoryBlocks, tabGeometry);

    let errorRef = _rawLoaderWebCamCpp2.default._malloc(4);
    let resultPathsRef = _rawLoaderWebCamCpp2.default._malloc(4);
    let resultNumPathsRef = _rawLoaderWebCamCpp2.default._malloc(4);
    let resultPathSizesRef = _rawLoaderWebCamCpp2.default._malloc(4);
    memoryBlocks.push(errorRef);
    memoryBlocks.push(resultPathsRef);
    memoryBlocks.push(resultNumPathsRef);
    memoryBlocks.push(resultPathSizesRef);

    //extern "C" void separateTabs(
    //    double** pathPolygons, int numPaths, int* pathSizes,
    //    double** tabPolygons, int numTabPolygons, int* tabPolygonSizes,
    //    bool& error,
    //    double**& resultPaths, int& resultNumPaths, int*& resultPathSizes)
    _rawLoaderWebCamCpp2.default.ccall('separateTabs', 'void', ['number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number'], [cCutterPath[0], cCutterPath[1], cCutterPath[2], cTabGeometry[0], cTabGeometry[1], cTabGeometry[2], errorRef, resultPathsRef, resultNumPathsRef, resultPathSizesRef]);

    if (_rawLoaderWebCamCpp2.default.HEAPU32[errorRef >> 2] && !displayedCppTabError2) {
        showAlert("Internal error processing tabs; tabs will be missing. This message will not repeat.", "danger", false);
        displayedCppTabError2 = true;
    }

    let result = (0, _mesh.cPathsToClipperPaths)(memoryBlocks, resultPathsRef, resultNumPathsRef, resultPathSizesRef);

    for (let i = 0; i < memoryBlocks.length; ++i) _rawLoaderWebCamCpp2.default._free(memoryBlocks[i]);

    return result;
}
;

var _temp = function () {
    if (typeof __REACT_HOT_LOADER__ === 'undefined') {
        return;
    }

    __REACT_HOT_LOADER__.register(dist, 'dist', '/home/pi/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(crosses, 'crosses', '/home/pi/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(pathIsClosed, 'pathIsClosed', '/home/pi/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(closeClipperPaths, 'closeClipperPaths', '/home/pi/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(mergePaths, 'mergePaths', '/home/pi/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(pocket, 'pocket', '/home/pi/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(insideOutside, 'insideOutside', '/home/pi/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(cut, 'cut', '/home/pi/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(fillPath, 'fillPath', '/home/pi/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(vCarve, 'vCarve', '/home/pi/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(reduceCamPaths, 'reduceCamPaths', '/home/pi/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(getClipperPathsFromCamPaths, 'getClipperPathsFromCamPaths', '/home/pi/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(displayedCppTabError1, 'displayedCppTabError1', '/home/pi/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(displayedCppTabError2, 'displayedCppTabError2', '/home/pi/LaserWeb4/src/lib/cam.js');

    __REACT_HOT_LOADER__.register(separateTabs, 'separateTabs', '/home/pi/LaserWeb4/src/lib/cam.js');
}();

;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _camGcodeLaserCut = __webpack_require__(46);

onmessage = event => {
    var _event$data = event.data;
    let settings = _event$data.settings,
        opIndex = _event$data.opIndex,
        op = _event$data.op;
    var _event$data$geometry = _event$data.geometry;
    let geometry = _event$data$geometry === undefined ? [] : _event$data$geometry;
    var _event$data$openGeome = _event$data.openGeometry;
    let openGeometry = _event$data$openGeome === undefined ? [] : _event$data$openGeome;
    var _event$data$tabGeomet = _event$data.tabGeometry;
    let tabGeometry = _event$data$tabGeomet === undefined ? [] : _event$data$tabGeomet;


    const errors = [];

    const showAlert = (message, level) => {
        errors.push({ message, level });
    };
    const progress = () => {
        postMessage(JSON.stringify({ event: "onProgress", gcode, errors }));
    };
    const done = gcode => {
        if (gcode === false && errors.length) {
            postMessage(JSON.stringify({ event: "onError", errors }));
        } else {
            postMessage(JSON.stringify({ event: "onDone", gcode }));
        }
        self.close();
    };

    try {
        _camGcodeLaserCut.getLaserCutGcodeFromOp.apply(undefined, [settings, opIndex, op, geometry, openGeometry, tabGeometry, showAlert, done, progress]);
    } catch (e) {
        console.error(e);
        postMessage(JSON.stringify({ event: "onError", errors: [{ message: e, level: 10 }] }));
    }
};
;

var _temp = function () {
    if (typeof __REACT_HOT_LOADER__ === 'undefined') {
        return;
    }
}();

;

/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2_js__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d_js__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3_js__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4_js__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat_js__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__gl_matrix_quat2_js__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec2_js__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec3_js__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__gl_matrix_vec4_js__ = __webpack_require__(41);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return __WEBPACK_IMPORTED_MODULE_0__gl_matrix_common_js__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return __WEBPACK_IMPORTED_MODULE_1__gl_matrix_mat2_js__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return __WEBPACK_IMPORTED_MODULE_2__gl_matrix_mat2d_js__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return __WEBPACK_IMPORTED_MODULE_3__gl_matrix_mat3_js__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return __WEBPACK_IMPORTED_MODULE_4__gl_matrix_mat4_js__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return __WEBPACK_IMPORTED_MODULE_5__gl_matrix_quat_js__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat2", function() { return __WEBPACK_IMPORTED_MODULE_6__gl_matrix_quat2_js__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return __WEBPACK_IMPORTED_MODULE_7__gl_matrix_vec2_js__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return __WEBPACK_IMPORTED_MODULE_8__gl_matrix_vec3_js__; });
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return __WEBPACK_IMPORTED_MODULE_9__gl_matrix_vec4_js__; });













/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["transpose"] = transpose;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["adjoint"] = adjoint;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["LDU"] = LDU;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_js__ = __webpack_require__(0);


/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](4);
  if (__WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
function clone(a) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues(m00, m01, m10, m11) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];

  // Calculate the determinant
  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;

  return out;
}

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;

  return out;
}

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
var sub = subtract;

/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["determinant"] = determinant;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromScaling"] = fromScaling;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["frob"] = frob;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalar"] = multiplyScalar;
/* harmony export (immutable) */ __webpack_exports__["multiplyScalarAndAdd"] = multiplyScalarAndAdd;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_js__ = __webpack_require__(0);


/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](6);
  if (__WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
function clone(a) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
function fromValues(a, b, c, d, tx, ty) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];

  var det = aa * ad - ab * ac;
  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
}

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
var sub = subtract;

/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslationValues"] = fromRotationTranslationValues;
/* harmony export (immutable) */ __webpack_exports__["fromRotationTranslation"] = fromRotationTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromTranslation"] = fromTranslation;
/* harmony export (immutable) */ __webpack_exports__["fromRotation"] = fromRotation;
/* harmony export (immutable) */ __webpack_exports__["fromMat4"] = fromMat4;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["identity"] = identity;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getReal", function() { return getReal; });
/* harmony export (immutable) */ __webpack_exports__["getDual"] = getDual;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setReal", function() { return setReal; });
/* harmony export (immutable) */ __webpack_exports__["setDual"] = setDual;
/* harmony export (immutable) */ __webpack_exports__["getTranslation"] = getTranslation;
/* harmony export (immutable) */ __webpack_exports__["translate"] = translate;
/* harmony export (immutable) */ __webpack_exports__["rotateX"] = rotateX;
/* harmony export (immutable) */ __webpack_exports__["rotateY"] = rotateY;
/* harmony export (immutable) */ __webpack_exports__["rotateZ"] = rotateZ;
/* harmony export (immutable) */ __webpack_exports__["rotateByQuatAppend"] = rotateByQuatAppend;
/* harmony export (immutable) */ __webpack_exports__["rotateByQuatPrepend"] = rotateByQuatPrepend;
/* harmony export (immutable) */ __webpack_exports__["rotateAroundAxis"] = rotateAroundAxis;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["invert"] = invert;
/* harmony export (immutable) */ __webpack_exports__["conjugate"] = conjugate;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__quat_js__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mat4_js__ = __webpack_require__(38);




/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */
function create() {
  var dq = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](8);
  if (__WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"] != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }
  dq[3] = 1;
  return dq;
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */
function clone(a) {
  var dq = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}

/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */
function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}

/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */
function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}

/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q quaternion
 * @param {vec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */
function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Creates a dual quat from a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {vec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */
function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}

/**
 * Creates a dual quat from a quaternion
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */
function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}

/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {mat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */
function fromMat4(out, a) {
  //TODO Optimize this
  var outer = __WEBPACK_IMPORTED_MODULE_1__quat_js__["create"]();
  __WEBPACK_IMPORTED_MODULE_2__mat4_js__["getRotation"](outer, a);
  var t = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](3);
  __WEBPACK_IMPORTED_MODULE_2__mat4_js__["getTranslation"](t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}

/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}

/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}

/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */
function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;

  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}

/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} real part
 */
var getReal = __WEBPACK_IMPORTED_MODULE_1__quat_js__["copy"];

/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} dual part
 */
function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}

/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */
var setReal = __WEBPACK_IMPORTED_MODULE_1__quat_js__["copy"];

/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */
function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}

/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {quat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */
function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}

/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to translate
 * @param {vec3} v vector to translate by
 * @returns {quat2} out
 */
function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}

/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */
function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  __WEBPACK_IMPORTED_MODULE_1__quat_js__["rotateX"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}

/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */
function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  __WEBPACK_IMPORTED_MODULE_1__quat_js__["rotateY"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}

/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */
function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  __WEBPACK_IMPORTED_MODULE_1__quat_js__["rotateZ"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}

/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {quat} q quaternion to rotate by
 * @returns {quat2} out
 */
function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];

  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}

/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat} q quaternion to rotate by
 * @param {quat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */
function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];

  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}

/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {vec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */
function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"]) {
    return copy(out, a);
  }
  var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);

  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);

  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;

  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;

  return out;
}

/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 * @function
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}

/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 */
function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}

/**
 * Alias for {@link quat2.multiply}
 * @function
 */
var mul = multiply;

/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}

/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
var dot = __WEBPACK_IMPORTED_MODULE_1__quat_js__["dot"];

/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */
function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;

  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;

  return out;
}

/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */
function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}

/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}

/**
 * Calculates the length of a dual quat
 *
 * @param {quat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */
var length = __WEBPACK_IMPORTED_MODULE_1__quat_js__["length"];

/**
 * Alias for {@link quat2.length}
 * @function
 */
var len = length;

/**
 * Calculates the squared length of a dual quat
 *
 * @param {quat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
var squaredLength = __WEBPACK_IMPORTED_MODULE_1__quat_js__["squaredLength"];

/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */
var sqrLen = squaredLength;

/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */
function normalize(out, a) {
  var magnitude = squaredLength(a);
  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);

    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;

    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];

    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;

    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;

    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }
  return out;
}

/**
 * Returns a string representation of a dual quatenion
 *
 * @param {quat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */
function str(a) {
  return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
}

/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat2} a the first dual quaternion.
 * @param {quat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}

/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {quat2} a the first dual quat.
 * @param {quat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["create"] = create;
/* harmony export (immutable) */ __webpack_exports__["clone"] = clone;
/* harmony export (immutable) */ __webpack_exports__["fromValues"] = fromValues;
/* harmony export (immutable) */ __webpack_exports__["copy"] = copy;
/* harmony export (immutable) */ __webpack_exports__["set"] = set;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;
/* harmony export (immutable) */ __webpack_exports__["subtract"] = subtract;
/* harmony export (immutable) */ __webpack_exports__["multiply"] = multiply;
/* harmony export (immutable) */ __webpack_exports__["divide"] = divide;
/* harmony export (immutable) */ __webpack_exports__["ceil"] = ceil;
/* harmony export (immutable) */ __webpack_exports__["floor"] = floor;
/* harmony export (immutable) */ __webpack_exports__["min"] = min;
/* harmony export (immutable) */ __webpack_exports__["max"] = max;
/* harmony export (immutable) */ __webpack_exports__["round"] = round;
/* harmony export (immutable) */ __webpack_exports__["scale"] = scale;
/* harmony export (immutable) */ __webpack_exports__["scaleAndAdd"] = scaleAndAdd;
/* harmony export (immutable) */ __webpack_exports__["distance"] = distance;
/* harmony export (immutable) */ __webpack_exports__["squaredDistance"] = squaredDistance;
/* harmony export (immutable) */ __webpack_exports__["length"] = length;
/* harmony export (immutable) */ __webpack_exports__["squaredLength"] = squaredLength;
/* harmony export (immutable) */ __webpack_exports__["negate"] = negate;
/* harmony export (immutable) */ __webpack_exports__["inverse"] = inverse;
/* harmony export (immutable) */ __webpack_exports__["normalize"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["dot"] = dot;
/* harmony export (immutable) */ __webpack_exports__["cross"] = cross;
/* harmony export (immutable) */ __webpack_exports__["lerp"] = lerp;
/* harmony export (immutable) */ __webpack_exports__["random"] = random;
/* harmony export (immutable) */ __webpack_exports__["transformMat2"] = transformMat2;
/* harmony export (immutable) */ __webpack_exports__["transformMat2d"] = transformMat2d;
/* harmony export (immutable) */ __webpack_exports__["transformMat3"] = transformMat3;
/* harmony export (immutable) */ __webpack_exports__["transformMat4"] = transformMat4;
/* harmony export (immutable) */ __webpack_exports__["rotate"] = rotate;
/* harmony export (immutable) */ __webpack_exports__["angle"] = angle;
/* harmony export (immutable) */ __webpack_exports__["str"] = str;
/* harmony export (immutable) */ __webpack_exports__["exactEquals"] = exactEquals;
/* harmony export (immutable) */ __webpack_exports__["equals"] = equals;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_js__ = __webpack_require__(0);


/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](2);
  if (__WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function clone(a) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function fromValues(x, y) {
  var out = new __WEBPACK_IMPORTED_MODULE_0__common_js__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale || 1.0;
  var r = __WEBPACK_IMPORTED_MODULE_0__common_js__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */
function rotate(out, a, b, c) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(c),
      cosC = Math.cos(c);

  //perform rotation and translate to correct position
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];

  return out;
}

/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1];

  var len1 = x1 * x1 + y1 * y1;
  if (len1 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
  }

  var len2 = x2 * x2 + y2 * y2;
  if (len2 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
  }

  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= __WEBPACK_IMPORTED_MODULE_0__common_js__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
var len = length;

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
var sub = subtract;

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link vec2.divide}
 * @function
 */
var div = divide;

/**
 * Alias for {@link vec2.distance}
 * @function
 */
var dist = distance;

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
var sqrDist = squaredDistance;

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
var sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = function () {
  var vec = create();

  return function (a, stride, offset, count, fn, arg) {
    var i = void 0,
        l = void 0;
    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 *
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 *
 * All rights reserved.
 *
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */



/*
 * Function added in the JavaScript version (was not present in the c++ version)
 */

/**
 * assert and throw an exception.
 *
 * @private
 * @param {boolean} condition   the condition which is asserted
 * @param {string} message      the message which is display is condition is falsy
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(message || "Assert Failed");
    }
}
module.exports = assert;




/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */




/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var xy = __webpack_require__(20);

// ------------------------------------------------------------------------Point
/**
 * Construct a point
 * @example
 *      var point = new poly2tri.Point(150, 150);
 * @public
 * @constructor
 * @struct
 * @param {number=} x    coordinate (0 if undefined)
 * @param {number=} y    coordinate (0 if undefined)
 */
var Point = function(x, y) {
    /**
     * @type {number}
     * @expose
     */
    this.x = +x || 0;
    /**
     * @type {number}
     * @expose
     */
    this.y = +y || 0;

    // All extra fields added to Point are prefixed with _p2t_
    // to avoid collisions if custom Point class is used.

    /**
     * The edges this point constitutes an upper ending point
     * @private
     * @type {Array.<Edge>}
     */
    this._p2t_edge_list = null;
};

/**
 * For pretty printing
 * @example
 *      "p=" + new poly2tri.Point(5,42)
 *      // → "p=(5;42)"
 * @returns {string} <code>"(x;y)"</code>
 */
Point.prototype.toString = function() {
    return xy.toStringBase(this);
};

/**
 * JSON output, only coordinates
 * @example
 *      JSON.stringify(new poly2tri.Point(1,2))
 *      // → '{"x":1,"y":2}'
 */
Point.prototype.toJSON = function() {
    return { x: this.x, y: this.y };
};

/**
 * Creates a copy of this Point object.
 * @return {Point} new cloned point
 */
Point.prototype.clone = function() {
    return new Point(this.x, this.y);
};

/**
 * Set this Point instance to the origo. <code>(0; 0)</code>
 * @return {Point} this (for chaining)
 */
Point.prototype.set_zero = function() {
    this.x = 0.0;
    this.y = 0.0;
    return this; // for chaining
};

/**
 * Set the coordinates of this instance.
 * @param {number} x   coordinate
 * @param {number} y   coordinate
 * @return {Point} this (for chaining)
 */
Point.prototype.set = function(x, y) {
    this.x = +x || 0;
    this.y = +y || 0;
    return this; // for chaining
};

/**
 * Negate this Point instance. (component-wise)
 * @return {Point} this (for chaining)
 */
Point.prototype.negate = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this; // for chaining
};

/**
 * Add another Point object to this instance. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.add = function(n) {
    this.x += n.x;
    this.y += n.y;
    return this; // for chaining
};

/**
 * Subtract this Point instance with another point given. (component-wise)
 * @param {!Point} n - Point object.
 * @return {Point} this (for chaining)
 */
Point.prototype.sub = function(n) {
    this.x -= n.x;
    this.y -= n.y;
    return this; // for chaining
};

/**
 * Multiply this Point instance by a scalar. (component-wise)
 * @param {number} s   scalar.
 * @return {Point} this (for chaining)
 */
Point.prototype.mul = function(s) {
    this.x *= s;
    this.y *= s;
    return this; // for chaining
};

/**
 * Return the distance of this Point instance from the origo.
 * @return {number} distance
 */
Point.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
};

/**
 * Normalize this Point instance (as a vector).
 * @return {number} The original distance of this instance from the origo.
 */
Point.prototype.normalize = function() {
    var len = this.length();
    this.x /= len;
    this.y /= len;
    return len;
};

/**
 * Test this Point object with another for equality.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {boolean} <code>true</code> if same x and y coordinates, <code>false</code> otherwise.
 */
Point.prototype.equals = function(p) {
    return this.x === p.x && this.y === p.y;
};


// -----------------------------------------------------Point ("static" methods)

/**
 * Negate a point component-wise and return the result as a new Point object.
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.negate = function(p) {
    return new Point(-p.x, -p.y);
};

/**
 * Add two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.add = function(a, b) {
    return new Point(a.x + b.x, a.y + b.y);
};

/**
 * Subtract two points component-wise and return the result as a new Point object.
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.sub = function(a, b) {
    return new Point(a.x - b.x, a.y - b.y);
};

/**
 * Multiply a point by a scalar and return the result as a new Point object.
 * @param {number} s - the scalar
 * @param {!XY} p - any "Point like" object with {x,y}
 * @return {Point} the resulting Point object.
 */
Point.mul = function(s, p) {
    return new Point(s * p.x, s * p.y);
};

/**
 * Perform the cross product on either two points (this produces a scalar)
 * or a point and a scalar (this produces a point).
 * This function requires two parameters, either may be a Point object or a
 * number.
 * @param  {XY|number} a - Point object or scalar.
 * @param  {XY|number} b - Point object or scalar.
 * @return {Point|number} a Point object or a number, depending on the parameters.
 */
Point.cross = function(a, b) {
    if (typeof(a) === 'number') {
        if (typeof(b) === 'number') {
            return a * b;
        } else {
            return new Point(-a * b.y, a * b.x);
        }
    } else {
        if (typeof(b) === 'number') {
            return new Point(b * a.y, -b * a.x);
        } else {
            return a.x * b.y - a.y * b.x;
        }
    }
};


// -----------------------------------------------------------------"Point-Like"
/*
 * The following functions operate on "Point" or any "Point like" object 
 * with {x,y} (duck typing).
 */

Point.toString = xy.toString;
Point.compare = xy.compare;
Point.cmp = xy.compare; // backward compatibility
Point.equals = xy.equals;

/**
 * Peform the dot product on two vectors.
 * @public
 * @param {!XY} a - any "Point like" object with {x,y}
 * @param {!XY} b - any "Point like" object with {x,y}
 * @return {number} The dot product
 */
Point.dot = function(a, b) {
    return a.x * b.x + a.y * b.y;
};


// ---------------------------------------------------------Exports (public API)

module.exports = Point;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint latedef:nofunc, maxcomplexity:9 */



/**
 * This 'Sweep' module is present in order to keep this JavaScript version
 * as close as possible to the reference C++ version, even though almost all
 * functions could be declared as methods on the {@linkcode module:sweepcontext~SweepContext} object.
 * @module
 * @private
 */

/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var assert = __webpack_require__(99);
var PointError = __webpack_require__(44);
var Triangle = __webpack_require__(45);
var Node = __webpack_require__(43).Node;


// ------------------------------------------------------------------------utils

var utils = __webpack_require__(103);

/** @const */
var EPSILON = utils.EPSILON;

/** @const */
var Orientation = utils.Orientation;
/** @const */
var orient2d = utils.orient2d;
/** @const */
var inScanArea = utils.inScanArea;
/** @const */
var isAngleObtuse = utils.isAngleObtuse;


// ------------------------------------------------------------------------Sweep

/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @private
 * @param {!SweepContext} tcx - SweepContext object
 */
function triangulate(tcx) {
    tcx.initTriangulation();
    tcx.createAdvancingFront();
    // Sweep points; build mesh
    sweepPoints(tcx);
    // Clean up
    finalizationPolygon(tcx);
}

/**
 * Start sweeping the Y-sorted point set from bottom to top
 * @param {!SweepContext} tcx - SweepContext object
 */
function sweepPoints(tcx) {
    var i, len = tcx.pointCount();
    for (i = 1; i < len; ++i) {
        var point = tcx.getPoint(i);
        var node = pointEvent(tcx, point);
        var edges = point._p2t_edge_list;
        for (var j = 0; edges && j < edges.length; ++j) {
            edgeEventByEdge(tcx, edges[j], node);
        }
    }
}

/**
 * @param {!SweepContext} tcx - SweepContext object
 */
function finalizationPolygon(tcx) {
    // Get an Internal triangle to start with
    var t = tcx.front().head().next.triangle;
    var p = tcx.front().head().next.point;
    while (!t.getConstrainedEdgeCW(p)) {
        t = t.neighborCCW(p);
    }

    // Collect interior triangles constrained by edges
    tcx.meshClean(t);
}

/**
 * Find closes node to the left of the new point and
 * create a new triangle. If needed new holes and basins
 * will be filled to.
 * @param {!SweepContext} tcx - SweepContext object
 * @param {!XY} point   Point
 */
function pointEvent(tcx, point) {
    var node = tcx.locateNode(point);
    var new_node = newFrontTriangle(tcx, point, node);

    // Only need to check +epsilon since point never have smaller
    // x value than node due to how we fetch nodes from the front
    if (point.x <= node.point.x + (EPSILON)) {
        fill(tcx, node);
    }

    //tcx.AddNode(new_node);

    fillAdvancingFront(tcx, new_node);
    return new_node;
}

function edgeEventByEdge(tcx, edge, node) {
    tcx.edge_event.constrained_edge = edge;
    tcx.edge_event.right = (edge.p.x > edge.q.x);

    if (isEdgeSideOfTriangle(node.triangle, edge.p, edge.q)) {
        return;
    }

    // For now we will do all needed filling
    // TODO: integrate with flip process might give some better performance
    //       but for now this avoid the issue with cases that needs both flips and fills
    fillEdgeEvent(tcx, edge, node);
    edgeEventByPoints(tcx, edge.p, edge.q, node.triangle, edge.q);
}

function edgeEventByPoints(tcx, ep, eq, triangle, point) {
    if (isEdgeSideOfTriangle(triangle, ep, eq)) {
        return;
    }

    var p1 = triangle.pointCCW(point);
    var o1 = orient2d(eq, p1, ep);
    if (o1 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p1, ep]);
    }

    var p2 = triangle.pointCW(point);
    var o2 = orient2d(eq, p2, ep);
    if (o2 === Orientation.COLLINEAR) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision 09880a869095 dated March 8, 2011)
        throw new PointError('poly2tri EdgeEvent: Collinear not supported!', [eq, p2, ep]);
    }

    if (o1 === o2) {
        // Need to decide if we are rotating CW or CCW to get to a triangle
        // that will cross edge
        if (o1 === Orientation.CW) {
            triangle = triangle.neighborCCW(point);
        } else {
            triangle = triangle.neighborCW(point);
        }
        edgeEventByPoints(tcx, ep, eq, triangle, point);
    } else {
        // This triangle crosses constraint so lets flippin start!
        flipEdgeEvent(tcx, ep, eq, triangle, point);
    }
}

function isEdgeSideOfTriangle(triangle, ep, eq) {
    var index = triangle.edgeIndex(ep, eq);
    if (index !== -1) {
        triangle.markConstrainedEdgeByIndex(index);
        var t = triangle.getNeighbor(index);
        if (t) {
            t.markConstrainedEdgeByPoints(ep, eq);
        }
        return true;
    }
    return false;
}

/**
 * Creates a new front triangle and legalize it
 * @param {!SweepContext} tcx - SweepContext object
 */
function newFrontTriangle(tcx, point, node) {
    var triangle = new Triangle(point, node.point, node.next.point);

    triangle.markNeighbor(node.triangle);
    tcx.addToMap(triangle);

    var new_node = new Node(point);
    new_node.next = node.next;
    new_node.prev = node;
    node.next.prev = new_node;
    node.next = new_node;

    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    return new_node;
}

/**
 * Adds a triangle to the advancing front to fill a hole.
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - middle node, that is the bottom of the hole
 */
function fill(tcx, node) {
    var triangle = new Triangle(node.prev.point, node.point, node.next.point);

    // TODO: should copy the constrained_edge value from neighbor triangles
    //       for now constrained_edge values are copied during the legalize
    triangle.markNeighbor(node.prev.triangle);
    triangle.markNeighbor(node.triangle);

    tcx.addToMap(triangle);

    // Update the advancing front
    node.prev.next = node.next;
    node.next.prev = node.prev;


    // If it was legalized the triangle has already been mapped
    if (!legalize(tcx, triangle)) {
        tcx.mapTriangleToNodes(triangle);
    }

    //tcx.removeNode(node);
}

/**
 * Fills holes in the Advancing Front
 * @param {!SweepContext} tcx - SweepContext object
 */
function fillAdvancingFront(tcx, n) {
    // Fill right holes
    var node = n.next;
    while (node.next) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.next;
    }

    // Fill left holes
    node = n.prev;
    while (node.prev) {
        // TODO integrate here changes from C++ version
        // (C++ repo revision acf81f1f1764 dated April 7, 2012)
        if (isAngleObtuse(node.point, node.next.point, node.prev.point)) {
            break;
        }
        fill(tcx, node);
        node = node.prev;
    }

    // Fill right basins
    if (n.next && n.next.next) {
        if (isBasinAngleRight(n)) {
            fillBasin(tcx, n);
        }
    }
}

/**
 * The basin angle is decided against the horizontal line [1,0].
 * @param {Node} node
 * @return {boolean} true if angle < 3*π/4
 */
function isBasinAngleRight(node) {
    var ax = node.point.x - node.next.next.point.x;
    var ay = node.point.y - node.next.next.point.y;
    assert(ay >= 0, "unordered y");
    return (ax >= 0 || Math.abs(ax) < ay);
}

/**
 * Returns true if triangle was legalized
 * @param {!SweepContext} tcx - SweepContext object
 * @return {boolean}
 */
function legalize(tcx, t) {
    // To legalize a triangle we start by finding if any of the three edges
    // violate the Delaunay condition
    for (var i = 0; i < 3; ++i) {
        if (t.delaunay_edge[i]) {
            continue;
        }
        var ot = t.getNeighbor(i);
        if (ot) {
            var p = t.getPoint(i);
            var op = ot.oppositePoint(t, p);
            var oi = ot.index(op);

            // If this is a Constrained Edge or a Delaunay Edge(only during recursive legalization)
            // then we should not try to legalize
            if (ot.constrained_edge[oi] || ot.delaunay_edge[oi]) {
                t.constrained_edge[i] = ot.constrained_edge[oi];
                continue;
            }

            var inside = inCircle(p, t.pointCCW(p), t.pointCW(p), op);
            if (inside) {
                // Lets mark this shared edge as Delaunay
                t.delaunay_edge[i] = true;
                ot.delaunay_edge[oi] = true;

                // Lets rotate shared edge one vertex CW to legalize it
                rotateTrianglePair(t, p, ot, op);

                // We now got one valid Delaunay Edge shared by two triangles
                // This gives us 4 new edges to check for Delaunay

                // Make sure that triangle to node mapping is done only one time for a specific triangle
                var not_legalized = !legalize(tcx, t);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(t);
                }

                not_legalized = !legalize(tcx, ot);
                if (not_legalized) {
                    tcx.mapTriangleToNodes(ot);
                }
                // Reset the Delaunay edges, since they only are valid Delaunay edges
                // until we add a new triangle or point.
                // XXX: need to think about this. Can these edges be tried after we
                //      return to previous recursive level?
                t.delaunay_edge[i] = false;
                ot.delaunay_edge[oi] = false;

                // If triangle have been legalized no need to check the other edges since
                // the recursive legalization will handles those so we can end here.
                return true;
            }
        }
    }
    return false;
}

/**
 * <b>Requirement</b>:<br>
 * 1. a,b and c form a triangle.<br>
 * 2. a and d is know to be on opposite side of bc<br>
 * <pre>
 *                a
 *                +
 *               / \
 *              /   \
 *            b/     \c
 *            +-------+
 *           /    d    \
 *          /           \
 * </pre>
 * <b>Fact</b>: d has to be in area B to have a chance to be inside the circle formed by
 *  a,b and c<br>
 *  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW<br>
 *  This preknowledge gives us a way to optimize the incircle test
 * @param pa - triangle point, opposite d
 * @param pb - triangle point
 * @param pc - triangle point
 * @param pd - point opposite a
 * @return {boolean} true if d is inside circle, false if on circle edge
 */
function inCircle(pa, pb, pc, pd) {
    var adx = pa.x - pd.x;
    var ady = pa.y - pd.y;
    var bdx = pb.x - pd.x;
    var bdy = pb.y - pd.y;

    var adxbdy = adx * bdy;
    var bdxady = bdx * ady;
    var oabd = adxbdy - bdxady;
    if (oabd <= 0) {
        return false;
    }

    var cdx = pc.x - pd.x;
    var cdy = pc.y - pd.y;

    var cdxady = cdx * ady;
    var adxcdy = adx * cdy;
    var ocad = cdxady - adxcdy;
    if (ocad <= 0) {
        return false;
    }

    var bdxcdy = bdx * cdy;
    var cdxbdy = cdx * bdy;

    var alift = adx * adx + ady * ady;
    var blift = bdx * bdx + bdy * bdy;
    var clift = cdx * cdx + cdy * cdy;

    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;
    return det > 0;
}

/**
 * Rotates a triangle pair one vertex CW
 *<pre>
 *       n2                    n2
 *  P +-----+             P +-----+
 *    | t  /|               |\  t |
 *    |   / |               | \   |
 *  n1|  /  |n3           n1|  \  |n3
 *    | /   |    after CW   |   \ |
 *    |/ oT |               | oT \|
 *    +-----+ oP            +-----+
 *       n4                    n4
 * </pre>
 */
function rotateTrianglePair(t, p, ot, op) {
    var n1, n2, n3, n4;
    n1 = t.neighborCCW(p);
    n2 = t.neighborCW(p);
    n3 = ot.neighborCCW(op);
    n4 = ot.neighborCW(op);

    var ce1, ce2, ce3, ce4;
    ce1 = t.getConstrainedEdgeCCW(p);
    ce2 = t.getConstrainedEdgeCW(p);
    ce3 = ot.getConstrainedEdgeCCW(op);
    ce4 = ot.getConstrainedEdgeCW(op);

    var de1, de2, de3, de4;
    de1 = t.getDelaunayEdgeCCW(p);
    de2 = t.getDelaunayEdgeCW(p);
    de3 = ot.getDelaunayEdgeCCW(op);
    de4 = ot.getDelaunayEdgeCW(op);

    t.legalize(p, op);
    ot.legalize(op, p);

    // Remap delaunay_edge
    ot.setDelaunayEdgeCCW(p, de1);
    t.setDelaunayEdgeCW(p, de2);
    t.setDelaunayEdgeCCW(op, de3);
    ot.setDelaunayEdgeCW(op, de4);

    // Remap constrained_edge
    ot.setConstrainedEdgeCCW(p, ce1);
    t.setConstrainedEdgeCW(p, ce2);
    t.setConstrainedEdgeCCW(op, ce3);
    ot.setConstrainedEdgeCW(op, ce4);

    // Remap neighbors
    // XXX: might optimize the markNeighbor by keeping track of
    //      what side should be assigned to what neighbor after the
    //      rotation. Now mark neighbor does lots of testing to find
    //      the right side.
    t.clearNeighbors();
    ot.clearNeighbors();
    if (n1) {
        ot.markNeighbor(n1);
    }
    if (n2) {
        t.markNeighbor(n2);
    }
    if (n3) {
        t.markNeighbor(n3);
    }
    if (n4) {
        ot.markNeighbor(n4);
    }
    t.markNeighbor(ot);
}

/**
 * Fills a basin that has formed on the Advancing Front to the right
 * of given node.<br>
 * First we decide a left,bottom and right node that forms the
 * boundaries of the basin. Then we do a reqursive fill.
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - starting node, this or next node will be left node
 */
function fillBasin(tcx, node) {
    if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
        tcx.basin.left_node = node.next.next;
    } else {
        tcx.basin.left_node = node.next;
    }

    // Find the bottom and right node
    tcx.basin.bottom_node = tcx.basin.left_node;
    while (tcx.basin.bottom_node.next && tcx.basin.bottom_node.point.y >= tcx.basin.bottom_node.next.point.y) {
        tcx.basin.bottom_node = tcx.basin.bottom_node.next;
    }
    if (tcx.basin.bottom_node === tcx.basin.left_node) {
        // No valid basin
        return;
    }

    tcx.basin.right_node = tcx.basin.bottom_node;
    while (tcx.basin.right_node.next && tcx.basin.right_node.point.y < tcx.basin.right_node.next.point.y) {
        tcx.basin.right_node = tcx.basin.right_node.next;
    }
    if (tcx.basin.right_node === tcx.basin.bottom_node) {
        // No valid basins
        return;
    }

    tcx.basin.width = tcx.basin.right_node.point.x - tcx.basin.left_node.point.x;
    tcx.basin.left_highest = tcx.basin.left_node.point.y > tcx.basin.right_node.point.y;

    fillBasinReq(tcx, tcx.basin.bottom_node);
}

/**
 * Recursive algorithm to fill a Basin with triangles
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param node - bottom_node
 */
function fillBasinReq(tcx, node) {
    // if shallow stop filling
    if (isShallow(tcx, node)) {
        return;
    }

    fill(tcx, node);

    var o;
    if (node.prev === tcx.basin.left_node && node.next === tcx.basin.right_node) {
        return;
    } else if (node.prev === tcx.basin.left_node) {
        o = orient2d(node.point, node.next.point, node.next.next.point);
        if (o === Orientation.CW) {
            return;
        }
        node = node.next;
    } else if (node.next === tcx.basin.right_node) {
        o = orient2d(node.point, node.prev.point, node.prev.prev.point);
        if (o === Orientation.CCW) {
            return;
        }
        node = node.prev;
    } else {
        // Continue with the neighbor node with lowest Y value
        if (node.prev.point.y < node.next.point.y) {
            node = node.prev;
        } else {
            node = node.next;
        }
    }

    fillBasinReq(tcx, node);
}

function isShallow(tcx, node) {
    var height;
    if (tcx.basin.left_highest) {
        height = tcx.basin.left_node.point.y - node.point.y;
    } else {
        height = tcx.basin.right_node.point.y - node.point.y;
    }

    // if shallow stop filling
    if (tcx.basin.width > height) {
        return true;
    }
    return false;
}

function fillEdgeEvent(tcx, edge, node) {
    if (tcx.edge_event.right) {
        fillRightAboveEdgeEvent(tcx, edge, node);
    } else {
        fillLeftAboveEdgeEvent(tcx, edge, node);
    }
}

function fillRightAboveEdgeEvent(tcx, edge, node) {
    while (node.next.point.x < edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            fillRightBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.next;
        }
    }
}

function fillRightBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x < edge.p.x) {
        if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
            // Concave
            fillRightConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillRightConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillRightBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillRightConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.next);
    if (node.next.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.next.point, edge.p) === Orientation.CCW) {
            // Below
            if (orient2d(node.point, node.next.point, node.next.next.point) === Orientation.CCW) {
                // Next is concave
                fillRightConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function fillRightConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.next.point, node.next.next.point, node.next.next.next.point) === Orientation.CCW) {
        // Concave
        fillRightConcaveEdgeEvent(tcx, edge, node.next);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.next.next.point, edge.p) === Orientation.CCW) {
            // Below
            fillRightConvexEdgeEvent(tcx, edge, node.next);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftAboveEdgeEvent(tcx, edge, node) {
    while (node.prev.point.x > edge.p.x) {
        // Check if next node is below the edge
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            fillLeftBelowEdgeEvent(tcx, edge, node);
        } else {
            node = node.prev;
        }
    }
}

function fillLeftBelowEdgeEvent(tcx, edge, node) {
    if (node.point.x > edge.p.x) {
        if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
            // Concave
            fillLeftConcaveEdgeEvent(tcx, edge, node);
        } else {
            // Convex
            fillLeftConvexEdgeEvent(tcx, edge, node);
            // Retry this one
            fillLeftBelowEdgeEvent(tcx, edge, node);
        }
    }
}

function fillLeftConvexEdgeEvent(tcx, edge, node) {
    // Next concave or convex?
    if (orient2d(node.prev.point, node.prev.prev.point, node.prev.prev.prev.point) === Orientation.CW) {
        // Concave
        fillLeftConcaveEdgeEvent(tcx, edge, node.prev);
    } else {
        // Convex
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.prev.point, edge.p) === Orientation.CW) {
            // Below
            fillLeftConvexEdgeEvent(tcx, edge, node.prev);
        } else {
            // Above
            /* jshint noempty:false */
        }
    }
}

function fillLeftConcaveEdgeEvent(tcx, edge, node) {
    fill(tcx, node.prev);
    if (node.prev.point !== edge.p) {
        // Next above or below edge?
        if (orient2d(edge.q, node.prev.point, edge.p) === Orientation.CW) {
            // Below
            if (orient2d(node.point, node.prev.point, node.prev.prev.point) === Orientation.CW) {
                // Next is concave
                fillLeftConcaveEdgeEvent(tcx, edge, node);
            } else {
                // Next is convex
                /* jshint noempty:false */
            }
        }
    }
}

function flipEdgeEvent(tcx, ep, eq, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle!");

    var op = ot.oppositePoint(t, p);

    // Additional check from Java version (see issue #88)
    if (t.getConstrainedEdgeAcross(p)) {
        var index = t.index(p);
        throw new PointError("poly2tri Intersecting Constraints",
                [p, op, t.getPoint((index + 1) % 3), t.getPoint((index + 2) % 3)]);
    }

    if (inScanArea(p, t.pointCCW(p), t.pointCW(p), op)) {
        // Lets rotate shared edge one vertex CW
        rotateTrianglePair(t, p, ot, op);
        tcx.mapTriangleToNodes(t);
        tcx.mapTriangleToNodes(ot);

        // XXX: in the original C++ code for the next 2 lines, we are
        // comparing point values (and not pointers). In this JavaScript
        // code, we are comparing point references (pointers). This works
        // because we can't have 2 different points with the same values.
        // But to be really equivalent, we should use "Point.equals" here.
        if (p === eq && op === ep) {
            if (eq === tcx.edge_event.constrained_edge.q && ep === tcx.edge_event.constrained_edge.p) {
                t.markConstrainedEdgeByPoints(ep, eq);
                ot.markConstrainedEdgeByPoints(ep, eq);
                legalize(tcx, t);
                legalize(tcx, ot);
            } else {
                // XXX: I think one of the triangles should be legalized here?
                /* jshint noempty:false */
            }
        } else {
            var o = orient2d(eq, op, ep);
            t = nextFlipTriangle(tcx, o, t, ot, p, op);
            flipEdgeEvent(tcx, ep, eq, t, p);
        }
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
        edgeEventByPoints(tcx, ep, eq, t, p);
    }
}

/**
 * After a flip we have two triangles and know that only one will still be
 * intersecting the edge. So decide which to contiune with and legalize the other
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param o - should be the result of an orient2d( eq, op, ep )
 * @param t - triangle 1
 * @param ot - triangle 2
 * @param p - a point shared by both triangles
 * @param op - another point shared by both triangles
 * @return returns the triangle still intersecting the edge
 */
function nextFlipTriangle(tcx, o, t, ot, p, op) {
    var edge_index;
    if (o === Orientation.CCW) {
        // ot is not crossing edge after flip
        edge_index = ot.edgeIndex(p, op);
        ot.delaunay_edge[edge_index] = true;
        legalize(tcx, ot);
        ot.clearDelaunayEdges();
        return t;
    }

    // t is not crossing edge after flip
    edge_index = t.edgeIndex(p, op);

    t.delaunay_edge[edge_index] = true;
    legalize(tcx, t);
    t.clearDelaunayEdges();
    return ot;
}

/**
 * When we need to traverse from one triangle to the next we need
 * the point in current triangle that is the opposite point to the next
 * triangle.
 */
function nextFlipPoint(ep, eq, ot, op) {
    var o2d = orient2d(eq, op, ep);
    if (o2d === Orientation.CW) {
        // Right
        return ot.pointCCW(op);
    } else if (o2d === Orientation.CCW) {
        // Left
        return ot.pointCW(op);
    } else {
        throw new PointError("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [eq, op, ep]);
    }
}

/**
 * Scan part of the FlipScan algorithm<br>
 * When a triangle pair isn't flippable we will scan for the next
 * point that is inside the flip triangle scan area. When found
 * we generate a new flipEdgeEvent
 *
 * @param {!SweepContext} tcx - SweepContext object
 * @param ep - last point on the edge we are traversing
 * @param eq - first point on the edge we are traversing
 * @param {!Triangle} flip_triangle - the current triangle sharing the point eq with edge
 * @param t
 * @param p
 */
function flipScanEdgeEvent(tcx, ep, eq, flip_triangle, t, p) {
    var ot = t.neighborAcross(p);
    assert(ot, "FLIP failed due to missing triangle");

    var op = ot.oppositePoint(t, p);

    if (inScanArea(eq, flip_triangle.pointCCW(eq), flip_triangle.pointCW(eq), op)) {
        // flip with new edge op.eq
        flipEdgeEvent(tcx, eq, op, ot, op);
    } else {
        var newP = nextFlipPoint(ep, eq, ot, op);
        flipScanEdgeEvent(tcx, ep, eq, flip_triangle, ot, newP);
    }
}


// ----------------------------------------------------------------------Exports

exports.triangulate = triangulate;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */

/* jshint maxcomplexity:6 */




/*
 * Note
 * ====
 * the structure of this JavaScript version of poly2tri intentionally follows
 * as closely as possible the structure of the reference C++ version, to make it 
 * easier to keep the 2 versions in sync.
 */

var PointError = __webpack_require__(44);
var Point = __webpack_require__(100);
var Triangle = __webpack_require__(45);
var sweep = __webpack_require__(101);
var AdvancingFront = __webpack_require__(43);
var Node = AdvancingFront.Node;


// ------------------------------------------------------------------------utils

/**
 * Initial triangle factor, seed triangle will extend 30% of
 * PointSet width to both left and right.
 * @private
 * @const
 */
var kAlpha = 0.3;


// -------------------------------------------------------------------------Edge
/**
 * Represents a simple polygon's edge
 * @constructor
 * @struct
 * @private
 * @param {Point} p1
 * @param {Point} p2
 * @throw {PointError} if p1 is same as p2
 */
var Edge = function(p1, p2) {
    this.p = p1;
    this.q = p2;

    if (p1.y > p2.y) {
        this.q = p1;
        this.p = p2;
    } else if (p1.y === p2.y) {
        if (p1.x > p2.x) {
            this.q = p1;
            this.p = p2;
        } else if (p1.x === p2.x) {
            throw new PointError('poly2tri Invalid Edge constructor: repeated points!', [p1]);
        }
    }

    if (!this.q._p2t_edge_list) {
        this.q._p2t_edge_list = [];
    }
    this.q._p2t_edge_list.push(this);
};


// ------------------------------------------------------------------------Basin
/**
 * @constructor
 * @struct
 * @private
 */
var Basin = function() {
    /** @type {Node} */
    this.left_node = null;
    /** @type {Node} */
    this.bottom_node = null;
    /** @type {Node} */
    this.right_node = null;
    /** @type {number} */
    this.width = 0.0;
    /** @type {boolean} */
    this.left_highest = false;
};

Basin.prototype.clear = function() {
    this.left_node = null;
    this.bottom_node = null;
    this.right_node = null;
    this.width = 0.0;
    this.left_highest = false;
};

// --------------------------------------------------------------------EdgeEvent
/**
 * @constructor
 * @struct
 * @private
 */
var EdgeEvent = function() {
    /** @type {Edge} */
    this.constrained_edge = null;
    /** @type {boolean} */
    this.right = false;
};

// ----------------------------------------------------SweepContext (public API)
/**
 * SweepContext constructor option
 * @typedef {Object} SweepContextOptions
 * @property {boolean=} cloneArrays - if <code>true</code>, do a shallow copy of the Array parameters
 *                  (contour, holes). Points inside arrays are never copied.
 *                  Default is <code>false</code> : keep a reference to the array arguments,
 *                  who will be modified in place.
 */
/**
 * Constructor for the triangulation context.
 * It accepts a simple polyline (with non repeating points), 
 * which defines the constrained edges.
 *
 * @example
 *          var contour = [
 *              new poly2tri.Point(100, 100),
 *              new poly2tri.Point(100, 300),
 *              new poly2tri.Point(300, 300),
 *              new poly2tri.Point(300, 100)
 *          ];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @example
 *          var contour = [{x:100, y:100}, {x:100, y:300}, {x:300, y:300}, {x:300, y:100}];
 *          var swctx = new poly2tri.SweepContext(contour, {cloneArrays: true});
 * @constructor
 * @public
 * @struct
 * @param {Array.<XY>} contour - array of point objects. The points can be either {@linkcode Point} instances,
 *          or any "Point like" custom class with <code>{x, y}</code> attributes.
 * @param {SweepContextOptions=} options - constructor options
 */
var SweepContext = function(contour, options) {
    options = options || {};
    this.triangles_ = [];
    this.map_ = [];
    this.points_ = (options.cloneArrays ? contour.slice(0) : contour);
    this.edge_list = [];

    // Bounding box of all points. Computed at the start of the triangulation, 
    // it is stored in case it is needed by the caller.
    this.pmin_ = this.pmax_ = null;

    /**
     * Advancing front
     * @private
     * @type {AdvancingFront}
     */
    this.front_ = null;

    /**
     * head point used with advancing front
     * @private
     * @type {Point}
     */
    this.head_ = null;

    /**
     * tail point used with advancing front
     * @private
     * @type {Point}
     */
    this.tail_ = null;

    /**
     * @private
     * @type {Node}
     */
    this.af_head_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_middle_ = null;
    /**
     * @private
     * @type {Node}
     */
    this.af_tail_ = null;

    this.basin = new Basin();
    this.edge_event = new EdgeEvent();

    this.initEdges(this.points_);
};


/**
 * Add a hole to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var hole = [
 *          new poly2tri.Point(200, 200),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addHole(hole);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addHole([{x:200, y:200}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} polyline - array of "Point like" objects with {x,y}
 */
SweepContext.prototype.addHole = function(polyline) {
    this.initEdges(polyline);
    var i, len = polyline.length;
    for (i = 0; i < len; i++) {
        this.points_.push(polyline[i]);
    }
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addHole} instead
 */
SweepContext.prototype.AddHole = SweepContext.prototype.addHole;


/**
 * Add several holes to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [ new poly2tri.Point(200, 200), new poly2tri.Point(200, 250), new poly2tri.Point(250, 250) ],
 *          [ new poly2tri.Point(300, 300), new poly2tri.Point(300, 350), new poly2tri.Point(350, 350) ]
 *      ];
 *      swctx.addHoles(holes);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var holes = [
 *          [{x:200, y:200}, {x:200, y:250}, {x:250, y:250}],
 *          [{x:300, y:300}, {x:300, y:350}, {x:350, y:350}]
 *      ];
 *      swctx.addHoles(holes);
 * @public
 * @param {Array.<Array.<XY>>} holes - array of array of "Point like" objects with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addHoles = function(holes) {
    var i, len = holes.length;
    for (i = 0; i < len; i++) {
        this.initEdges(holes[i]);
    }
    this.points_ = this.points_.concat.apply(this.points_, holes);
    return this; // for chaining
};


/**
 * Add a Steiner point to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var point = new poly2tri.Point(150, 150);
 *      swctx.addPoint(point);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoint({x:150, y:150});
 * @public
 * @param {XY} point - any "Point like" object with {x,y}
 */
SweepContext.prototype.addPoint = function(point) {
    this.points_.push(point);
    return this; // for chaining
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#addPoint} instead
 */
SweepContext.prototype.AddPoint = SweepContext.prototype.addPoint;


/**
 * Add several Steiner points to the constraints
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      var points = [
 *          new poly2tri.Point(150, 150),
 *          new poly2tri.Point(200, 250),
 *          new poly2tri.Point(250, 250)
 *      ];
 *      swctx.addPoints(points);
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.addPoints([{x:150, y:150}, {x:200, y:250}, {x:250, y:250}]);
 * @public
 * @param {Array.<XY>} points - array of "Point like" object with {x,y}
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.addPoints = function(points) {
    this.points_ = this.points_.concat(points);
    return this; // for chaining
};


/**
 * Triangulate the polygon with holes and Steiner points.
 * Do this AFTER you've added the polyline, holes, and Steiner points
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @public
 */
// Shortcut method for sweep.triangulate(SweepContext).
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.triangulate = function() {
    sweep.triangulate(this);
    return this; // for chaining
};


/**
 * Get the bounding box of the provided constraints (contour, holes and 
 * Steinter points). Warning : these values are not available if the triangulation 
 * has not been done yet.
 * @public
 * @returns {{min:Point,max:Point}} object with 'min' and 'max' Point
 */
// Method added in the JavaScript version (was not present in the c++ version)
SweepContext.prototype.getBoundingBox = function() {
    return {min: this.pmin_, max: this.pmax_};
};

/**
 * Get result of triangulation.
 * The output triangles have vertices which are references
 * to the initial input points (not copies): any custom fields in the
 * initial points can be retrieved in the output triangles.
 * @example
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 * @example
 *      var contour = [{x:100, y:100, id:1}, {x:100, y:300, id:2}, {x:300, y:300, id:3}];
 *      var swctx = new poly2tri.SweepContext(contour);
 *      swctx.triangulate();
 *      var triangles = swctx.getTriangles();
 *      typeof triangles[0].getPoint(0).id
 *      // → "number"
 * @public
 * @returns {array<Triangle>}   array of triangles
 */
SweepContext.prototype.getTriangles = function() {
    return this.triangles_;
};

/**
 * For backward compatibility
 * @function
 * @deprecated use {@linkcode SweepContext#getTriangles} instead
 */
SweepContext.prototype.GetTriangles = SweepContext.prototype.getTriangles;


// ---------------------------------------------------SweepContext (private API)

/** @private */
SweepContext.prototype.front = function() {
    return this.front_;
};

/** @private */
SweepContext.prototype.pointCount = function() {
    return this.points_.length;
};

/** @private */
SweepContext.prototype.head = function() {
    return this.head_;
};

/** @private */
SweepContext.prototype.setHead = function(p1) {
    this.head_ = p1;
};

/** @private */
SweepContext.prototype.tail = function() {
    return this.tail_;
};

/** @private */
SweepContext.prototype.setTail = function(p1) {
    this.tail_ = p1;
};

/** @private */
SweepContext.prototype.getMap = function() {
    return this.map_;
};

/** @private */
SweepContext.prototype.initTriangulation = function() {
    var xmax = this.points_[0].x;
    var xmin = this.points_[0].x;
    var ymax = this.points_[0].y;
    var ymin = this.points_[0].y;

    // Calculate bounds
    var i, len = this.points_.length;
    for (i = 1; i < len; i++) {
        var p = this.points_[i];
        /* jshint expr:true */
        (p.x > xmax) && (xmax = p.x);
        (p.x < xmin) && (xmin = p.x);
        (p.y > ymax) && (ymax = p.y);
        (p.y < ymin) && (ymin = p.y);
    }
    this.pmin_ = new Point(xmin, ymin);
    this.pmax_ = new Point(xmax, ymax);

    var dx = kAlpha * (xmax - xmin);
    var dy = kAlpha * (ymax - ymin);
    this.head_ = new Point(xmax + dx, ymin - dy);
    this.tail_ = new Point(xmin - dx, ymin - dy);

    // Sort points along y-axis
    this.points_.sort(Point.compare);
};

/** @private */
SweepContext.prototype.initEdges = function(polyline) {
    var i, len = polyline.length;
    for (i = 0; i < len; ++i) {
        this.edge_list.push(new Edge(polyline[i], polyline[(i + 1) % len]));
    }
};

/** @private */
SweepContext.prototype.getPoint = function(index) {
    return this.points_[index];
};

/** @private */
SweepContext.prototype.addToMap = function(triangle) {
    this.map_.push(triangle);
};

/** @private */
SweepContext.prototype.locateNode = function(point) {
    return this.front_.locateNode(point.x);
};

/** @private */
SweepContext.prototype.createAdvancingFront = function() {
    var head;
    var middle;
    var tail;
    // Initial triangle
    var triangle = new Triangle(this.points_[0], this.tail_, this.head_);

    this.map_.push(triangle);

    head = new Node(triangle.getPoint(1), triangle);
    middle = new Node(triangle.getPoint(0), triangle);
    tail = new Node(triangle.getPoint(2));

    this.front_ = new AdvancingFront(head, tail);

    head.next = middle;
    middle.next = tail;
    middle.prev = head;
    tail.prev = middle;
};

/** @private */
SweepContext.prototype.removeNode = function(node) {
    // do nothing
    /* jshint unused:false */
};

/** @private */
SweepContext.prototype.mapTriangleToNodes = function(t) {
    for (var i = 0; i < 3; ++i) {
        if (!t.getNeighbor(i)) {
            var n = this.front_.locatePoint(t.pointCW(t.getPoint(i)));
            if (n) {
                n.triangle = t;
            }
        }
    }
};

/** @private */
SweepContext.prototype.removeFromMap = function(triangle) {
    var i, map = this.map_, len = map.length;
    for (i = 0; i < len; i++) {
        if (map[i] === triangle) {
            map.splice(i, 1);
            break;
        }
    }
};

/**
 * Do a depth first traversal to collect triangles
 * @private
 * @param {Triangle} triangle start
 */
SweepContext.prototype.meshClean = function(triangle) {
    // New implementation avoids recursive calls and use a loop instead.
    // Cf. issues # 57, 65 and 69.
    var triangles = [triangle], t, i;
    /* jshint boss:true */
    while (t = triangles.pop()) {
        if (!t.isInterior()) {
            t.setInterior(true);
            this.triangles_.push(t);
            for (i = 0; i < 3; i++) {
                if (!t.constrained_edge[i]) {
                    triangles.push(t.getNeighbor(i));
                }
            }
        }
    }
};

// ----------------------------------------------------------------------Exports

module.exports = SweepContext;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * Poly2Tri Copyright (c) 2009-2014, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 * 
 * poly2tri.js (JavaScript port) (c) 2009-2014, Poly2Tri Contributors
 * https://github.com/r3mi/poly2tri.js
 * 
 * All rights reserved.
 * 
 * Distributed under the 3-clause BSD License, see LICENSE.txt
 */



/**
 * Precision to detect repeated or collinear points
 * @private
 * @const {number}
 * @default
 */
var EPSILON = 1e-12;
exports.EPSILON = EPSILON;

/**
 * @private
 * @enum {number}
 * @readonly
 */
var Orientation = {
    "CW": 1,
    "CCW": -1,
    "COLLINEAR": 0
};
exports.Orientation = Orientation;


/**
 * Formula to calculate signed area<br>
 * Positive if CCW<br>
 * Negative if CW<br>
 * 0 if collinear<br>
 * <pre>
 * A[P1,P2,P3]  =  (x1*y2 - y1*x2) + (x2*y3 - y2*x3) + (x3*y1 - y3*x1)
 *              =  (x1-x3)*(y2-y3) - (y1-y3)*(x2-x3)
 * </pre>
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {Orientation}
 */
function orient2d(pa, pb, pc) {
    var detleft = (pa.x - pc.x) * (pb.y - pc.y);
    var detright = (pa.y - pc.y) * (pb.x - pc.x);
    var val = detleft - detright;
    if (val > -(EPSILON) && val < (EPSILON)) {
        return Orientation.COLLINEAR;
    } else if (val > 0) {
        return Orientation.CCW;
    } else {
        return Orientation.CW;
    }
}
exports.orient2d = orient2d;


/**
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @param {!XY} pd  point object with {x,y}
 * @return {boolean}
 */
function inScanArea(pa, pb, pc, pd) {
    var oadb = (pa.x - pb.x) * (pd.y - pb.y) - (pd.x - pb.x) * (pa.y - pb.y);
    if (oadb >= -EPSILON) {
        return false;
    }

    var oadc = (pa.x - pc.x) * (pd.y - pc.y) - (pd.x - pc.x) * (pa.y - pc.y);
    if (oadc <= EPSILON) {
        return false;
    }
    return true;
}
exports.inScanArea = inScanArea;


/**
 * Check if the angle between (pa,pb) and (pa,pc) is obtuse i.e. (angle > π/2 || angle < -π/2)
 *
 * @private
 * @param {!XY} pa  point object with {x,y}
 * @param {!XY} pb  point object with {x,y}
 * @param {!XY} pc  point object with {x,y}
 * @return {boolean} true if angle is obtuse
 */
function isAngleObtuse(pa, pb, pc) {
    var ax = pb.x - pa.x;
    var ay = pb.y - pa.y;
    var bx = pc.x - pa.x;
    var by = pc.y - pa.y;
    return (ax * bx + ay * by) < 0;
}
exports.isAngleObtuse = isAngleObtuse;



/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony default export */ __webpack_exports__["default"] = ("\n\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(Module) { ..generated code.. }\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = typeof Module !== 'undefined' ? Module : {};\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n// {{PRE_JSES}}\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = {};\nvar key;\nfor (key in Module) {\n  if (Module.hasOwnProperty(key)) {\n    moduleOverrides[key] = Module[key];\n  }\n}\n\nvar arguments_ = [];\nvar thisProgram = './this.program';\nvar quit_ = function(status, toThrow) {\n  throw toThrow;\n};\n\n// Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n\nvar ENVIRONMENT_IS_WEB = true;\nvar ENVIRONMENT_IS_WORKER = false;\nvar ENVIRONMENT_IS_NODE = false;\nvar ENVIRONMENT_IS_SHELL = false;\n\n// `/` should be present at the end if `scriptDirectory` is not empty\nvar scriptDirectory = '';\nfunction locateFile(path) {\n  if (Module['locateFile']) {\n    return Module['locateFile'](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\n\n// Hooks that are implemented differently in different runtime environments.\nvar read_,\n    readAsync,\n    readBinary,\n    setWindowTitle;\n\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n// ENVIRONMENT_IS_NODE.\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\n    scriptDirectory = self.location.href;\n  } else if (typeof document !== 'undefined' && document.currentScript) { // web\n    scriptDirectory = document.currentScript.src;\n  }\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n  // otherwise, slice off the final part of the url to find the script directory.\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n  // and scriptDirectory will correctly be replaced with an empty string.\n  if (scriptDirectory.indexOf('blob:') !== 0) {\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);\n  } else {\n    scriptDirectory = '';\n  }\n\n  // Differentiate the Web Worker from the Node Worker case, as reading must\n  // be done differently.\n  {\n\n// include: web_or_worker_shell_read.js\n\n\n  read_ = function(url) {\n    try {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, false);\n      xhr.send(null);\n      return xhr.responseText;\n    } catch (err) {\n      var data = tryParseAsDataURI(url);\n      if (data) {\n        return intArrayToString(data);\n      }\n      throw err;\n    }\n  };\n\n  if (ENVIRONMENT_IS_WORKER) {\n    readBinary = function(url) {\n      try {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.responseType = 'arraybuffer';\n        xhr.send(null);\n        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));\n      } catch (err) {\n        var data = tryParseAsDataURI(url);\n        if (data) {\n          return data;\n        }\n        throw err;\n      }\n    };\n  }\n\n  readAsync = function(url, onload, onerror) {\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.responseType = 'arraybuffer';\n    xhr.onload = function() {\n      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n        onload(xhr.response);\n        return;\n      }\n      var data = tryParseAsDataURI(url);\n      if (data) {\n        onload(data.buffer);\n        return;\n      }\n      onerror();\n    };\n    xhr.onerror = onerror;\n    xhr.send(null);\n  };\n\n// end include: web_or_worker_shell_read.js\n  }\n\n  setWindowTitle = function(title) { document.title = title };\n} else\n{\n}\n\n// Set up the out() and err() hooks, which are how we can print to stdout or\n// stderr, respectively.\nvar out = Module['print'] || console.log.bind(console);\nvar err = Module['printErr'] || console.warn.bind(console);\n\n// Merge back in the overrides\nfor (key in moduleOverrides) {\n  if (moduleOverrides.hasOwnProperty(key)) {\n    Module[key] = moduleOverrides[key];\n  }\n}\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\nmoduleOverrides = null;\n\n// Emit code to handle expected values on the Module object. This applies Module.x\n// to the proper local x. This has two benefits: first, we only emit it if it is\n// expected to arrive, and second, by using a local everywhere else that can be\n// minified.\n\nif (Module['arguments']) arguments_ = Module['arguments'];\n\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];\n\nif (Module['quit']) quit_ = Module['quit'];\n\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n\n\n\n\nvar STACK_ALIGN = 16;\n\nfunction alignMemory(size, factor) {\n  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n  return Math.ceil(size / factor) * factor;\n}\n\nfunction getNativeTypeSize(type) {\n  switch (type) {\n    case 'i1': case 'i8': return 1;\n    case 'i16': return 2;\n    case 'i32': return 4;\n    case 'i64': return 8;\n    case 'float': return 4;\n    case 'double': return 8;\n    default: {\n      if (type[type.length-1] === '*') {\n        return 4; // A pointer\n      } else if (type[0] === 'i') {\n        var bits = Number(type.substr(1));\n        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);\n        return bits / 8;\n      } else {\n        return 0;\n      }\n    }\n  }\n}\n\nfunction warnOnce(text) {\n  if (!warnOnce.shown) warnOnce.shown = {};\n  if (!warnOnce.shown[text]) {\n    warnOnce.shown[text] = 1;\n    err(text);\n  }\n}\n\n// include: runtime_functions.js\n\n\n// Wraps a JS function as a wasm function with a given signature.\nfunction convertJsFunctionToWasm(func, sig) {\n\n  // If the type reflection proposal is available, use the new\n  // \"WebAssembly.Function\" constructor.\n  // Otherwise, construct a minimal wasm module importing the JS function and\n  // re-exporting it.\n  if (typeof WebAssembly.Function === \"function\") {\n    var typeNames = {\n      'i': 'i32',\n      'j': 'i64',\n      'f': 'f32',\n      'd': 'f64'\n    };\n    var type = {\n      parameters: [],\n      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]\n    };\n    for (var i = 1; i < sig.length; ++i) {\n      type.parameters.push(typeNames[sig[i]]);\n    }\n    return new WebAssembly.Function(type, func);\n  }\n\n  // The module is static, with the exception of the type section, which is\n  // generated based on the signature passed in.\n  var typeSection = [\n    0x01, // id: section,\n    0x00, // length: 0 (placeholder)\n    0x01, // count: 1\n    0x60, // form: func\n  ];\n  var sigRet = sig.slice(0, 1);\n  var sigParam = sig.slice(1);\n  var typeCodes = {\n    'i': 0x7f, // i32\n    'j': 0x7e, // i64\n    'f': 0x7d, // f32\n    'd': 0x7c, // f64\n  };\n\n  // Parameters, length + signatures\n  typeSection.push(sigParam.length);\n  for (var i = 0; i < sigParam.length; ++i) {\n    typeSection.push(typeCodes[sigParam[i]]);\n  }\n\n  // Return values, length + signatures\n  // With no multi-return in MVP, either 0 (void) or 1 (anything else)\n  if (sigRet == 'v') {\n    typeSection.push(0x00);\n  } else {\n    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);\n  }\n\n  // Write the overall length of the type section back into the section header\n  // (excepting the 2 bytes for the section id and length)\n  typeSection[1] = typeSection.length - 2;\n\n  // Rest of the module is static\n  var bytes = new Uint8Array([\n    0x00, 0x61, 0x73, 0x6d, // magic (\"\\0asm\")\n    0x01, 0x00, 0x00, 0x00, // version: 1\n  ].concat(typeSection, [\n    0x02, 0x07, // import section\n      // (import \"e\" \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,\n    0x07, 0x05, // export section\n      // (export \"f\" (func 0 (type 0)))\n      0x01, 0x01, 0x66, 0x00, 0x00,\n  ]));\n\n   // We can compile this wasm module synchronously because it is very small.\n  // This accepts an import (at \"e.f\"), that it reroutes to an export (at \"f\")\n  var module = new WebAssembly.Module(bytes);\n  var instance = new WebAssembly.Instance(module, {\n    'e': {\n      'f': func\n    }\n  });\n  var wrappedFunc = instance.exports['f'];\n  return wrappedFunc;\n}\n\nvar freeTableIndexes = [];\n\n// Weak map of functions in the table to their indexes, created on first use.\nvar functionsInTableMap;\n\nfunction getEmptyTableSlot() {\n  // Reuse a free index if there is one, otherwise grow.\n  if (freeTableIndexes.length) {\n    return freeTableIndexes.pop();\n  }\n  // Grow the table\n  try {\n    wasmTable.grow(1);\n  } catch (err) {\n    if (!(err instanceof RangeError)) {\n      throw err;\n    }\n    throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';\n  }\n  return wasmTable.length - 1;\n}\n\n// Add a wasm function to the table.\nfunction addFunctionWasm(func, sig) {\n  // Check if the function is already in the table, to ensure each function\n  // gets a unique index. First, create the map if this is the first use.\n  if (!functionsInTableMap) {\n    functionsInTableMap = new WeakMap();\n    for (var i = 0; i < wasmTable.length; i++) {\n      var item = wasmTable.get(i);\n      // Ignore null values.\n      if (item) {\n        functionsInTableMap.set(item, i);\n      }\n    }\n  }\n  if (functionsInTableMap.has(func)) {\n    return functionsInTableMap.get(func);\n  }\n\n  // It's not in the table, add it now.\n\n  var ret = getEmptyTableSlot();\n\n  // Set the new value.\n  try {\n    // Attempting to call this with JS function will cause of table.set() to fail\n    wasmTable.set(ret, func);\n  } catch (err) {\n    if (!(err instanceof TypeError)) {\n      throw err;\n    }\n    var wrapped = convertJsFunctionToWasm(func, sig);\n    wasmTable.set(ret, wrapped);\n  }\n\n  functionsInTableMap.set(func, ret);\n\n  return ret;\n}\n\nfunction removeFunction(index) {\n  functionsInTableMap.delete(wasmTable.get(index));\n  freeTableIndexes.push(index);\n}\n\n// 'sig' parameter is required for the llvm backend but only when func is not\n// already a WebAssembly function.\nfunction addFunction(func, sig) {\n\n  return addFunctionWasm(func, sig);\n}\n\n// end include: runtime_functions.js\n// include: runtime_debug.js\n\n\n// end include: runtime_debug.js\nfunction makeBigInt(low, high, unsigned) {\n  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));\n}\n\nvar tempRet0 = 0;\n\nvar setTempRet0 = function(value) {\n  tempRet0 = value;\n};\n\nvar getTempRet0 = function() {\n  return tempRet0;\n};\n\n\n\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\nvar wasmBinary;\nif (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\nvar noExitRuntime = Module['noExitRuntime'] || true;\n\nif (typeof WebAssembly !== 'object') {\n  abort('no native wasm support detected');\n}\n\n// include: runtime_safe_heap.js\n\n\n// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.\n// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)\n\n/** @param {number} ptr\n    @param {number} value\n    @param {string} type\n    @param {number|boolean=} noSafe */\nfunction setValue(ptr, value, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': HEAP8[((ptr)>>0)] = value; break;\n      case 'i8': HEAP8[((ptr)>>0)] = value; break;\n      case 'i16': HEAP16[((ptr)>>1)] = value; break;\n      case 'i32': HEAP32[((ptr)>>2)] = value; break;\n      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;\n      case 'float': HEAPF32[((ptr)>>2)] = value; break;\n      case 'double': HEAPF64[((ptr)>>3)] = value; break;\n      default: abort('invalid type for setValue: ' + type);\n    }\n}\n\n/** @param {number} ptr\n    @param {string} type\n    @param {number|boolean=} noSafe */\nfunction getValue(ptr, type, noSafe) {\n  type = type || 'i8';\n  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit\n    switch(type) {\n      case 'i1': return HEAP8[((ptr)>>0)];\n      case 'i8': return HEAP8[((ptr)>>0)];\n      case 'i16': return HEAP16[((ptr)>>1)];\n      case 'i32': return HEAP32[((ptr)>>2)];\n      case 'i64': return HEAP32[((ptr)>>2)];\n      case 'float': return HEAPF32[((ptr)>>2)];\n      case 'double': return HEAPF64[((ptr)>>3)];\n      default: abort('invalid type for getValue: ' + type);\n    }\n  return null;\n}\n\n// end include: runtime_safe_heap.js\n// Wasm globals\n\nvar wasmMemory;\n\n//========================================\n// Runtime essentials\n//========================================\n\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\nvar ABORT = false;\n\n// set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\nvar EXITSTATUS;\n\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed: ' + text);\n  }\n}\n\n// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\nfunction getCFunc(ident) {\n  var func = Module['_' + ident]; // closure exported function\n  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n  return func;\n}\n\n// C calling interface.\n/** @param {string|null=} returnType\n    @param {Array=} argTypes\n    @param {Arguments|Array=} args\n    @param {Object=} opts */\nfunction ccall(ident, returnType, argTypes, args, opts) {\n  // For fast lookup of conversion functions\n  var toC = {\n    'string': function(str) {\n      var ret = 0;\n      if (str !== null && str !== undefined && str !== 0) { // null string\n        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n        var len = (str.length << 2) + 1;\n        ret = stackAlloc(len);\n        stringToUTF8(str, ret, len);\n      }\n      return ret;\n    },\n    'array': function(arr) {\n      var ret = stackAlloc(arr.length);\n      writeArrayToMemory(arr, ret);\n      return ret;\n    }\n  };\n\n  function convertReturnValue(ret) {\n    if (returnType === 'string') return UTF8ToString(ret);\n    if (returnType === 'boolean') return Boolean(ret);\n    return ret;\n  }\n\n  var func = getCFunc(ident);\n  var cArgs = [];\n  var stack = 0;\n  if (args) {\n    for (var i = 0; i < args.length; i++) {\n      var converter = toC[argTypes[i]];\n      if (converter) {\n        if (stack === 0) stack = stackSave();\n        cArgs[i] = converter(args[i]);\n      } else {\n        cArgs[i] = args[i];\n      }\n    }\n  }\n  var ret = func.apply(null, cArgs);\n\n  ret = convertReturnValue(ret);\n  if (stack !== 0) stackRestore(stack);\n  return ret;\n}\n\n/** @param {string=} returnType\n    @param {Array=} argTypes\n    @param {Object=} opts */\nfunction cwrap(ident, returnType, argTypes, opts) {\n  argTypes = argTypes || [];\n  // When the function takes numbers and returns a number, we can just return\n  // the original function\n  var numericArgs = argTypes.every(function(type){ return type === 'number'});\n  var numericRet = returnType !== 'string';\n  if (numericRet && numericArgs && !opts) {\n    return getCFunc(ident);\n  }\n  return function() {\n    return ccall(ident, returnType, argTypes, arguments, opts);\n  }\n}\n\nvar ALLOC_NORMAL = 0; // Tries to use _malloc()\nvar ALLOC_STACK = 1; // Lives for the duration of the current function call\n\n// allocate(): This is for internal use. You can use it yourself as well, but the interface\n//             is a little tricky (see docs right below). The reason is that it is optimized\n//             for multiple syntaxes to save space in generated code. So you should\n//             normally not use allocate(), and instead allocate memory using _malloc(),\n//             initialize it with setValue(), and so forth.\n// @slab: An array of data.\n// @allocator: How to allocate memory, see ALLOC_*\n/** @type {function((Uint8Array|Array<number>), number)} */\nfunction allocate(slab, allocator) {\n  var ret;\n\n  if (allocator == ALLOC_STACK) {\n    ret = stackAlloc(slab.length);\n  } else {\n    ret = _malloc(slab.length);\n  }\n\n  if (slab.subarray || slab.slice) {\n    HEAPU8.set(/** @type {!Uint8Array} */(slab), ret);\n  } else {\n    HEAPU8.set(new Uint8Array(slab), ret);\n  }\n  return ret;\n}\n\n// include: runtime_strings.js\n\n\n// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n\n/**\n * @param {number} idx\n * @param {number=} maxBytesToRead\n * @return {string}\n */\nfunction UTF8ArrayToString(heap, idx, maxBytesToRead) {\n  var endIdx = idx + maxBytesToRead;\n  var endPtr = idx;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)\n  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n\n  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {\n    return UTF8Decoder.decode(heap.subarray(idx, endPtr));\n  } else {\n    var str = '';\n    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that\n    while (idx < endPtr) {\n      // For UTF8 byte structure, see:\n      // http://en.wikipedia.org/wiki/UTF-8#Description\n      // https://www.ietf.org/rfc/rfc2279.txt\n      // https://tools.ietf.org/html/rfc3629\n      var u0 = heap[idx++];\n      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n      var u1 = heap[idx++] & 63;\n      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n      var u2 = heap[idx++] & 63;\n      if ((u0 & 0xF0) == 0xE0) {\n        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n      } else {\n        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);\n      }\n\n      if (u0 < 0x10000) {\n        str += String.fromCharCode(u0);\n      } else {\n        var ch = u0 - 0x10000;\n        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n      }\n    }\n  }\n  return str;\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a\n// copy of that string as a Javascript String object.\n// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit\n//                 this parameter to scan the string until the first \\0 byte. If maxBytesToRead is\n//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the\n//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will\n//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)\n//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may\n//                 throw JS JIT optimizations off, so it is worth to consider consistently using one\n//                 style or the other.\n/**\n * @param {number} ptr\n * @param {number=} maxBytesToRead\n * @return {string}\n */\nfunction UTF8ToString(ptr, maxBytesToRead) {\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n}\n\n// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n//   outIdx: The starting offset in the array to begin the copying.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array.\n//                    This count should include the null terminator,\n//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n    return 0;\n\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) {\n      var u1 = str.charCodeAt(++i);\n      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\n    }\n    if (u <= 0x7F) {\n      if (outIdx >= endIdx) break;\n      heap[outIdx++] = u;\n    } else if (u <= 0x7FF) {\n      if (outIdx + 1 >= endIdx) break;\n      heap[outIdx++] = 0xC0 | (u >> 6);\n      heap[outIdx++] = 0x80 | (u & 63);\n    } else if (u <= 0xFFFF) {\n      if (outIdx + 2 >= endIdx) break;\n      heap[outIdx++] = 0xE0 | (u >> 12);\n      heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n      heap[outIdx++] = 0x80 | (u & 63);\n    } else {\n      if (outIdx + 3 >= endIdx) break;\n      heap[outIdx++] = 0xF0 | (u >> 18);\n      heap[outIdx++] = 0x80 | ((u >> 12) & 63);\n      heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n      heap[outIdx++] = 0x80 | (u & 63);\n    }\n  }\n  // Null-terminate the pointer to the buffer.\n  heap[outIdx] = 0;\n  return outIdx - startIdx;\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF8(str, outPtr, maxBytesToWrite) {\n  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\nfunction lengthBytesUTF8(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    if (u <= 0x7F) ++len;\n    else if (u <= 0x7FF) len += 2;\n    else if (u <= 0xFFFF) len += 3;\n    else len += 4;\n  }\n  return len;\n}\n\n// end include: runtime_strings.js\n// include: runtime_strings_extra.js\n\n\n// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.\n\n// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nfunction AsciiToString(ptr) {\n  var str = '';\n  while (1) {\n    var ch = HEAPU8[((ptr++)>>0)];\n    if (!ch) return str;\n    str += String.fromCharCode(ch);\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\nfunction stringToAscii(str, outPtr) {\n  return writeAsciiToMemory(str, outPtr, false);\n}\n\n// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n// a copy of that string as a Javascript String object.\n\nvar UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\n\nfunction UTF16ToString(ptr, maxBytesToRead) {\n  var endPtr = ptr;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n  var idx = endPtr >> 1;\n  var maxIdx = idx + maxBytesToRead / 2;\n  // If maxBytesToRead is not passed explicitly, it will be undefined, and this\n  // will always evaluate to true. This saves on code size.\n  while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\n  endPtr = idx << 1;\n\n  if (endPtr - ptr > 32 && UTF16Decoder) {\n    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n  } else {\n    var str = '';\n\n    // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition\n    // will always evaluate to true. The loop is then terminated on the first null char.\n    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\n      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\n      if (codeUnit == 0) break;\n      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n      str += String.fromCharCode(codeUnit);\n    }\n\n    return str;\n  }\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF16(str, outPtr, maxBytesToWrite) {\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 2) return 0;\n  maxBytesToWrite -= 2; // Null terminator.\n  var startPtr = outPtr;\n  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\n  for (var i = 0; i < numCharsToWrite; ++i) {\n    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    HEAP16[((outPtr)>>1)] = codeUnit;\n    outPtr += 2;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP16[((outPtr)>>1)] = 0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF16(str) {\n  return str.length*2;\n}\n\nfunction UTF32ToString(ptr, maxBytesToRead) {\n  var i = 0;\n\n  var str = '';\n  // If maxBytesToRead is not passed explicitly, it will be undefined, and this\n  // will always evaluate to true. This saves on code size.\n  while (!(i >= maxBytesToRead / 4)) {\n    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\n    if (utf32 == 0) break;\n    ++i;\n    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    if (utf32 >= 0x10000) {\n      var ch = utf32 - 0x10000;\n      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n    } else {\n      str += String.fromCharCode(utf32);\n    }\n  }\n  return str;\n}\n\n// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n// Parameters:\n//   str: the Javascript string to copy.\n//   outPtr: Byte address in Emscripten HEAP where to write the string to.\n//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n// Returns the number of bytes written, EXCLUDING the null terminator.\n\nfunction stringToUTF32(str, outPtr, maxBytesToWrite) {\n  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n  if (maxBytesToWrite === undefined) {\n    maxBytesToWrite = 0x7FFFFFFF;\n  }\n  if (maxBytesToWrite < 4) return 0;\n  var startPtr = outPtr;\n  var endPtr = startPtr + maxBytesToWrite - 4;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n      var trailSurrogate = str.charCodeAt(++i);\n      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\n    }\n    HEAP32[((outPtr)>>2)] = codeUnit;\n    outPtr += 4;\n    if (outPtr + 4 > endPtr) break;\n  }\n  // Null-terminate the pointer to the HEAP.\n  HEAP32[((outPtr)>>2)] = 0;\n  return outPtr - startPtr;\n}\n\n// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\nfunction lengthBytesUTF32(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var codeUnit = str.charCodeAt(i);\n    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n    len += 4;\n  }\n\n  return len;\n}\n\n// Allocate heap space for a JS string, and write it there.\n// It is the responsibility of the caller to free() that memory.\nfunction allocateUTF8(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = _malloc(size);\n  if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\n// Allocate stack space for a JS string, and write it there.\nfunction allocateUTF8OnStack(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = stackAlloc(size);\n  stringToUTF8Array(str, HEAP8, ret, size);\n  return ret;\n}\n\n// Deprecated: This function should not be called because it is unsafe and does not provide\n// a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n// function stringToUTF8Array() instead, which takes in a maximum length that can be used\n// to be secure from out of bounds writes.\n/** @deprecated\n    @param {boolean=} dontAddNull */\nfunction writeStringToMemory(string, buffer, dontAddNull) {\n  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n\n  var /** @type {number} */ lastChar, /** @type {number} */ end;\n  if (dontAddNull) {\n    // stringToUTF8Array always appends null. If we don't want to do that, remember the\n    // character that existed at the location where the null will be placed, and restore\n    // that after the write (below).\n    end = buffer + lengthBytesUTF8(string);\n    lastChar = HEAP8[end];\n  }\n  stringToUTF8(string, buffer, Infinity);\n  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n}\n\nfunction writeArrayToMemory(array, buffer) {\n  HEAP8.set(array, buffer);\n}\n\n/** @param {boolean=} dontAddNull */\nfunction writeAsciiToMemory(str, buffer, dontAddNull) {\n  for (var i = 0; i < str.length; ++i) {\n    HEAP8[((buffer++)>>0)] = str.charCodeAt(i);\n  }\n  // Null-terminate the pointer to the HEAP.\n  if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;\n}\n\n// end include: runtime_strings_extra.js\n// Memory management\n\nfunction alignUp(x, multiple) {\n  if (x % multiple > 0) {\n    x += multiple - (x % multiple);\n  }\n  return x;\n}\n\nvar HEAP,\n/** @type {ArrayBuffer} */\n  buffer,\n/** @type {Int8Array} */\n  HEAP8,\n/** @type {Uint8Array} */\n  HEAPU8,\n/** @type {Int16Array} */\n  HEAP16,\n/** @type {Uint16Array} */\n  HEAPU16,\n/** @type {Int32Array} */\n  HEAP32,\n/** @type {Uint32Array} */\n  HEAPU32,\n/** @type {Float32Array} */\n  HEAPF32,\n/** @type {Float64Array} */\n  HEAPF64;\n\nfunction updateGlobalBufferAndViews(buf) {\n  buffer = buf;\n  Module['HEAP8'] = HEAP8 = new Int8Array(buf);\n  Module['HEAP16'] = HEAP16 = new Int16Array(buf);\n  Module['HEAP32'] = HEAP32 = new Int32Array(buf);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);\n}\n\nvar TOTAL_STACK = 5242880;\n\nvar INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;\n\n// include: runtime_init_table.js\n// In regular non-RELOCATABLE mode the table is exported\n// from the wasm module and this will be assigned once\n// the exports are available.\nvar wasmTable;\n\n// end include: runtime_init_table.js\n// include: runtime_stack_check.js\n\n\n// end include: runtime_stack_check.js\n// include: runtime_assertions.js\n\n\n// end include: runtime_assertions.js\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\nvar __ATINIT__    = []; // functions called during startup\nvar __ATMAIN__    = []; // functions called when main() is to be run\nvar __ATEXIT__    = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\nvar runtimeExited = false;\n\n__ATINIT__.push({ func: function() { ___wasm_call_ctors() } });\n\nfunction preRun() {\n\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPRERUN__);\n}\n\nfunction initRuntime() {\n  runtimeInitialized = true;\n\n  \n  callRuntimeCallbacks(__ATINIT__);\n}\n\nfunction preMain() {\n  \n  callRuntimeCallbacks(__ATMAIN__);\n}\n\nfunction exitRuntime() {\n  runtimeExited = true;\n}\n\nfunction postRun() {\n\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\n\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\n\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\n\nfunction addOnPreMain(cb) {\n  __ATMAIN__.unshift(cb);\n}\n\nfunction addOnExit(cb) {\n}\n\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\n// include: runtime_math.js\n\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n\n// end include: runtime_math.js\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// Module.preRun (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\nfunction getUniqueRunDependency(id) {\n  return id;\n}\n\nfunction addRunDependency(id) {\n  runDependencies++;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n}\n\nfunction removeRunDependency(id) {\n  runDependencies--;\n\n  if (Module['monitorRunDependencies']) {\n    Module['monitorRunDependencies'](runDependencies);\n  }\n\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\nModule[\"preloadedImages\"] = {}; // maps url to image data\nModule[\"preloadedAudios\"] = {}; // maps url to audio data\n\n/** @param {string|number=} what */\nfunction abort(what) {\n  if (Module['onAbort']) {\n    Module['onAbort'](what);\n  }\n\n  what += '';\n  err(what);\n\n  ABORT = true;\n  EXITSTATUS = 1;\n\n  what = 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.';\n\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\n  // exception, which means we'd run destructors on it. We need the error to\n  // simply make the program stop.\n  var e = new WebAssembly.RuntimeError(what);\n\n  // Throw the error whether or not MODULARIZE is set because abort is used\n  // in code paths apart from instantiation where an exception is expected\n  // to be thrown when abort is called.\n  throw e;\n}\n\n// {{MEM_INITIALIZER}}\n\n// include: memoryprofiler.js\n\n\n// end include: memoryprofiler.js\n// include: URIUtils.js\n\n\nfunction hasPrefix(str, prefix) {\n  return String.prototype.startsWith ?\n      str.startsWith(prefix) :\n      str.indexOf(prefix) === 0;\n}\n\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\n\n// Indicates whether filename is a base64 data URI.\nfunction isDataURI(filename) {\n  return hasPrefix(filename, dataURIPrefix);\n}\n\nvar fileURIPrefix = \"file://\";\n\n// Indicates whether filename is delivered via file protocol (as opposed to http/https)\nfunction isFileURI(filename) {\n  return hasPrefix(filename, fileURIPrefix);\n}\n\n// end include: URIUtils.js\nvar wasmBinaryFile = 'data:application/octet-stream;base64,AGFzbQEAAAAB0oOAgAA/YAF/AX9gAn9/AX9gAn9/AGADf39/AGADf39/AX9gAX8AYAR/f39/AGAFf39/f38AYAR/f39/AX9gBX9/f39/AX9gBn9/f39/fwF/YAZ/f39/f38AYAABf2ABfwF8YAJ/fwF8YAV/fn5+fgBgBH5+fn4Bf2AAAGAGf39+fn9/AGACf3wBf2ABfAF8YAJ/fwF+YAN/f38BfGACfH8BfGAIf39/f39/f38AYAl/f39/f39/f38AYAR/fn5/AGAFf35+f38AYAZ/fn5/f38AYAd/fn5/f39/AGAEfHx/fwBgAXwBf2ACf34Bf2AFf35+fn4Bf2AGf3x/f39/AX9gAn5/AX9gA39+fwF+YAABfGADfHx/AXxgB39/f39/f38AYAp/f39/f39/f39/AGAGf39/f398AGAKf39/f398fH9/fwBgBX9/f398AGADf39+AGACf34AYAJ/fABgB39/f39/f38Bf2AEf35+fwF/YAl/fn5+fn5+fn4Bf2ADf3x/AX9gA398fAF/YAR/fHx/AX9gBH98fHwBf2ADfn9/AX9gAn5+AX9gAnx/AX9gAXwBfmADf39/AX5gBH9/fn8BfmACfn4BfGAEfn5+fgF8YAJ8fAF8AquBgIAABwNlbnYYX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uAAADZW52C19fY3hhX3Rocm93AAMDZW52BWFib3J0ABEDZW52FmVtc2NyaXB0ZW5fcmVzaXplX2hlYXAAAANlbnYVZW1zY3JpcHRlbl9tZW1jcHlfYmlnAAQWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQhmZF93cml0ZQAIA2VudgtzZXRUZW1wUmV0MAAFA4KbgIAAgBsRBwABAAEAAAEBBgABAAEGAAACAAAEAgAAAAACAgAFAAAAAgIFAAEBAQAABAABAAAAAAAHBQAAAwAAAAACAwACAgIDAwIFAAAEAAMAAQgCAAADAwEAAAEABAAAAQABAAABBAABAAYCAgUFAAAADAEBAQAADAQAAAABBAAABQEBAAAAAgACAAQAAAAABwUAAwAAAAACAwICAgQAAwABCAIAAwMBAAQAAQAGAgIFBQAAAAAAAAAAAQQAAAAAAwAAAwMCAAIAKAAAAAAHAAABAAAAAQMCBQMCAAIBAQEBAAEAAgUBAAABAAAABwABAQEAAQIBAgMDAwIAAAMAAgEAAQICAgAAAQABAwAAAQIAAAEAAwAAAAEDAQABHQEEBAwBAAAAAwACAAAGAAAAAAICBQUFAAQBAAAAAAcFAAADAAAAAAIDAAICAgABAAEBAQgCAAEAAAACAgAAAAQAAwABCAIAAAMDAQAEAAEABgICBQUAAAAAAAAAAAEEAAAAAAMAAAMDAgACAAEBAAAACAIAAAACAgAABAQAAAQAAAIDAgAAAwABAQMCAAAEAAAAAQEDAgICBQAEAQAAAAAEAAEABgICBQUAAwAAAAAAAQQAAAAAAAAHAAADAAAAAwADAQECAwACAgICAAQDAAEDAwEBAQAAAAAAAAAAAAAAAgIAAAICAAQBAQMGAAECAgAEBQAFAAQBAAAEAQAAAAQAAAADAAABCAIAAAMAAwAAAAQAAQAGAgIFBQADAAAAAAAAAAAAAAABBAAAAAAHAAIDAAICAgIAAAQAAAADAAEIAgAAAwADAQAAAAQAAQAGAgIFBQADAAAAAAAAAAAAAAABBAAAAAAHAAMAAAMDAQIDAAICAgIAAQACAgAGAAAABgAAAQEAAAEAAAEAAQABAAEBAAIAAAMGAAAAAQgAAgQAAAgAAwcHBQABAAQAAAEAAgQAAgABAAAAAAQAAAAABwAAAAAAAAAAAAACAgABAAQAAAAAAQABAAAAAAAAAAIDAgMAAAICAAMBAgEAAAMAAAEBAQAAAgEAAQARCwAAAgEBAQEBAQEAAAEBAgIADAQBAgIAAAEAAAEACgMCAQEBAQAAAQAFAAUABAEAAAACAgQEAgEAAAAIAgAAAAICAAQBAQAEAwMDAgACAgMEAggJCgMEAQIBAgABAAAEAAEABgICBQUAAwAAAAAAAQQAAAAAAAAHAAAAAgMAAgICAgAEAAMAAQMDAAAAAAAABAEAAAABAAICAQAEAAAAAwAAAQgCAAADAAMAAAAEAAEABgICBQUAAwAAAAAAAAAAAAAAAQQAAAAABwACAwACAgICAAEABAAAAAABAAAEAAAABwAGAAABBAEAAAAAAAQABAABBAQAAAcAAgAAAAIAAAAAAAQAAAAABAAEBwAAAAAAAQABBwEEAAAAAAAABQUAAgAAAgIDAgMAAQEABQIFAgUCAgABAAgBBAEAAAgAAAwCBgICAgABAQAAAQkKAwECAQEBAQAEBAAIBAQBBgMAAwMCAgIDBAIICQoDBAECAQECAgEBBAMEAQQECDEhAQQGAAADAgICAhAAAAEAAAMDAwEBAQMBAwEDAAEEAxAMAAIhAQICMAICAgIAAgIDAwMDAwMBAwMABgAABAMABgAAAQQAAAAEAAEEBAAAAwAAAAACAAAAAAAEAAQDAAAAAAABAAEDAAAAAAICAwIDAgICAwQICQoDBAQEAgUCBQIAAQECBgYEAwQAAAMDBAAAAAECBgQAAAQEAAYABAQAAQIDAwQICQoDBAQABQMCAwICAgAAAgEAAwMDAQUCAQADAwUCBQICAAUCAwMCCAkKAwQBAAAAAgIBAQADCQEAEhwBAQEEAgIEAQAFAAQBAAAABAAAAAMAAAEIAgAAAwADAAAABAABAAYCAgUFAAMAAAAAAAAAAAAAAAEEAAAAAAcAAgMAAgICAgABAwIICQoDBAQIBAQEAQQAAAgBAQESGwABAgIABAUDBAgJCgMECAQEBAEGAwADAwEFAgYFBgMDAwICAiorAAAAAAYAAAEAAwAAAAABAAICCQACBwABAAAAAQACAAABAAAAAAAAAAAGAAAAAwIFAwEAAAAAAQEDAAgBAw0GDggCAAAAASkAAAAAAAUAAAACBwAAAgEAAAABAQAFAgYJBCUBAQAABQAAAQADAwAAAAAAAAAAAAEBBAECAAEBBAQDAAIFAgAAAQICAAAEAAUFBQcBAQAABgYBAQICAQECAAEBAQMBAAAAAAECAAABAAMAAAABAwEAAR0AAQQEAAAGDQAGBgMAAgIAARYGAAAAAAAAAAUABAEAAAAEAAAGAAABCAIAAAYABgQAAAAEAAEABgICBQUAAwAAAAAAAAAAAAAAAQQAAAAABwADAAADAAMCAwACAgICAAAAAAQBAAAEAQAABAEAAAAAAAABAQAEAQAAAAQBAAAAAAAEAQAAAAQAAAAAAAAABAAAAAABAAAAAAABAAAAAgIAAAAEAAAAAwABCAIAAAMAAwAAAAQAAQAFBgICBQUAAwAAAAAAAAAAAAAAAQQAAAAABwACAwACAgICAAMDAgICAAMBBAQBAQACAAEAAAABAAICAAAAAQEAAAABBQEBAQEAAQAAAAoABwAAAgAAAScBAQAADg0ONAAABQEBBQAAAQAABAACAQIAAgACAQQEAAICAAAAAQAAAAIAAAQEAAAAAAEAAAAAAAAACAIAAAAACAIAAAAIAgAAAAQAAQAFBgIAAgUFAAMAAAAAAAEEAAAAAAAABwAAAAIDAAICAgIAAAAEAAEABQYCAAIFBQADAAAAAAABBAAAAAAAAAcAAAACAwACAgICAAAABAABAAUGAgACBQUAAwAAAAAAAQQAAAAAAAAHAAAAAgMAAgICAgADAQEEAgIBAwQCCAkKAwQABD0fAAAADgEBAgIABAQBAAAEAQEAAAQCAAAEBgEBBAQAAgIEAAMAAQMDAAAAAAAAAAQEAAMCAAECAAQEBAIAAAECAwEABAEAAAACAAADAAAEAAEAAgIABAQAAwABAwMAAAAAAAAACAkAAwAGAAABAQAABAAABAQBAAABBAQAAAMAAAAAAgEAAAQAAAIAAQEIBggJCAAWCRYAAAAQDQAAAgAABAAEAwAAAAAAAAEAAQMAAAAAAgIDAgMAAgIBBgEABAAAAAMAAAEIAgAAAwADAAAABAABAAUGAgIFBQADAAAAAAAAAAAAAAABBAAAAAAHAAIDAAICAgIAAQAABAEAAQAAAQAEBAQIAwMDAwEAAAEAAAMFAQEBAAAAAAkEAQEAAAYCAgcCAAIAAgICAQACAAgAAAAIBwkLCQsIBwQCAAIAADMAAQECDTUNGAAAEwMDAwIDAQICAgMZAQABAwEZAxgNASADAw4DEw0TEwAAAQEEDQMDAwIEAAAABwcLAAQCIAADAQYOAgYAAQ0GAAADAwMDBQYCAwAAMgIBBSwABgIABgADAAADAAMAAAAAAgAAAwAAAAEEBAADAAAAAAIABAAEAAABAAEDAAAAAgADAwACAgEGAQAEAAAAAwAAAQgCAAADAAMAAAAEAAEABQYCAgUFAAMAAAAAAAAAAAAAAAEEAAAAAAcAAgMAAgICAgABAAAEAAEEBAEBBAIAAAEAAgIEAAMAAQMDAAAAAAAAAAMFAgIGAgIHAAICAgICAQEAAAEBBAICAAEBAAEBAQQCAgABAQABAAICAAQBAAECAgAEAQACAAIABAAAAwABCAIAAAMAAwAAAAQAAQAGAgIFBQADAAAAAAAAAAAAAAEAAQQAAAAABwACAwACAgICAAEHBwcAAgICAAMDAwUCBQIFAgIAAQMDAggJCgMEAAAAAAICAQEAAwkBABIcAQEBBAICBAEABQAEAQAAAAQAAAADAAABCAIAAAMAAwAA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eCB3IHhGIXlBASF6QQEheyB5IHtxIXwgeiF9AkAgfA0AIAUoArACIX4gBSgC2AEhf0EUIYABIH8ggAFqIYEBIIEBEA0hggEgfiGDASCCASGEASCDASCEAUYhhQEghQEhfQsgfSGGASAFKALcASGHAUEBIYgBIIYBIIgBcSGJASCHASCJAToAIEHoASGKASAFIIoBaiGLASCLASGMASCMARCXAhoMAAsAC0GgAiGNASAFII0BaiGOASCOASGPASCPARCYAiGQASAFIJABNgLQAUGgAiGRASAFIJEBaiGSASCSASGTASCTARCZAiGUASAFIJQBNgLIASAFKALQASGVASAFKALIASGWAUEDIZcBIJUBIJYBIJcBEJsCQaACIZgBIAUgmAFqIZkBIJkBIZoBIJoBEJgCIZsBIAUgmwE2AsABAkADQEGgAiGcASAFIJwBaiGdASCdASGeASCeARCZAiGfASAFIJ8BNgK4AUHAASGgASAFIKABaiGhASChASGiAUG4ASGjASAFIKMBaiGkASCkASGlASCiASClARCUAiGmAUEBIacBIKYBIKcBcSGoASCoAUUNAUHAASGpASAFIKkBaiGqASCqASGrAUEBIawBIKsBIKwBEJwCIa0BIAUgrQE2ArABQcABIa4BIAUgrgFqIa8BIK8BIbABILABEJ0CIbEBILEBLQAgIbIBQQEhswEgsgEgswFxIbQBAkAgtAFFDQADQEGgAiG1ASAFILUBaiG2ASC2ASG3ASC3ARCZAiG4ASAFILgBNgKoAUGwASG5ASAFILkBaiG6ASC6ASG7AUGoASG8ASAFILwBaiG9ASC9ASG+ASC7ASC+ARCUAiG/AUEAIcABQQEhwQEgvwEgwQFxIcIBIMABIcMBAkAgwgFFDQBBsAEhxAEgBSDEAWohxQEgxQEhxgEgxgEQnQIhxwEgxwEtACAhyAFBACHJAUEBIcoBIMgBIMoBcSHLASDJASHDASDLAUUNAEGwASHMASAFIMwBaiHNASDNARCdAiHOAUEYIc8BIM4BIM8BaiHQASDQASkDACGABCDOASkDECGBBEHAASHRASAFINEBaiHSASDSARCdAiHTASDTASDPAWoh1AEg1AEpAwAhggQg0wEpAxAhgwQggQQggAQggwQgggQQpRoh1QEg1QFFIdYBINYBIcMBCyDDASHXAUEBIdgB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IAUoAlAhXCBcKAIAIV0gBSgCQCFeIAUoAkwhXyBeIF8gXREBACFgQQEhYSBgIGFxIWICQCBiRQ0AIAUoAkAhYyBjEPcVIWRBECFlIAUgZWohZiBmIWcgZCkCACHWASBnINYBNwIAQSghaCBnIGhqIWkgZCBoaiFqIGooAgAhayBpIGs2AgBBICFsIGcgbGohbSBkIGxqIW4gbikCACHXASBtINcBNwIAQRghbyBnIG9qIXAgZCBvaiFxIHEpAgAh2AEgcCDYATcCAEEQIXIgZyByaiFzIGQgcmohdCB0KQIAIdkBIHMg2QE3AgBBCCF1IGcgdWohdiBkIHVqIXcgdykCACHaASB2INoBNwIAIAUoAkwheCAFIHg2AgwgBSgCQCF5IAUgeTYCTANAIAUoAgwheiB6EPcVIXsgBSgCTCF8IHspAgAh2wEgfCDbATcCAEEoIX0gfCB9aiF+IHsgfWohfyB/KAIAIYABIH4ggAE2AgBBICGBASB8IIEBaiGCASB7IIEBaiGDASCDASkCACHcASCCASDcATcCAEEYIYQBIHwghAFqIYUBIHsghAFqIYYBIIYBKQIAId0BIIUBIN0BNwIAQRAhhwEgfCCHAWohiAEgeyCHAWohiQEgiQEpAgAh3gEgiAEg3gE3AgBBCCGKASB8IIoBaiGLASB7IIoBaiGMASCMASkCACHfASCLASDfATcCACAFKAIMIY0BIAUgjQE2AkwgBSgCTCGOASAFKAJYIY8BII4BIZABII8BIZEBIJABIJEBRyGSAUEAIZMBQQEhlAEgkgEglAFxIZUBIJMBIZYBAkAglQFFDQAgBSgCUCGXASCXASgCACGYASAFKAIMIZkBQVQhmgEgmQEgmgFqIZsBIAUgmwE2AgxBECGcASAFIJwBaiGdASCdASGeASCeASCbASCYAREBACGfASCfASGWAQsglgEhoAFBASGhASCgASChAXEhogEgogENAAtBECGjASAFIKMBaiGkASCkASGlASClARD3FSGmASAFKAJMIacBIKYBKQIAIeABIKcBIOABNwIAQSghqAEgpwEgqAFqIakBIKYBIKgBaiGqASCqASgCACGrASCpASCrATYCAEEgIawBIKcBIKwBaiGtASCmASCsAWohrgEgrgEpAgAh4QEgrQEg4QE3AgBBGCGvASCnASCvAWohsAEgpgEg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AAAAAADwv6AhAAwBCyAAIAOgIQAgA0QAAAAAAADgv2VBAXMNACAARAAAAAAAAPA/oCEACyAAIACaIAFCf1UbIQALIAALJAACQCAAEKIaIgCZRAAAAAAAAOBBY0UNACAAqg8LQYCAgIB4CxEBAX8gACAAQR91IgFqIAFzC+ABAgF/An5BASEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AAkAgAiAAhCAGIAWEhFBFDQBBAA8LAkAgAyABg0IAUw0AQX8hBCAAIAJUIAEgA1MgASADURsNASAAIAKFIAEgA4WEQgBSDwtBfyEEIAAgAlYgASADVSABIANRGw0AIAAgAoUgASADhYRCAFIhBAsgBAvYAQIBfwJ+QX8hBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNAAJAIAIgAIQgBiAFhIRQRQ0AQQAPCwJAIAMgAYNCAFMNACAAIAJUIAEgA1MgASADURsNASAAIAKFIAEgA4WEQgBSDwsgACACViABIANVIAEgA1EbDQAgACAChSABIAOFhEIAUiEECyAEC1MBAX4CQAJAIANBwABxRQ0AIAEgA0FAaq2GIQJCACEBDAELIANFDQAgAUHAACADa62IIAIgA60iBIaEIQIgASAEhiEBCyAAIAE3AwAgACACNwMIC48BAgJ/AX4jAEEQayICJAACQAJAIAFQRQ0AQgAhAUIAIQQMAQsgAiABIAFCP4ciBHwgBIUiBEIAIAR5pyIDQTFqEKcaIAJBCGopAwBCgICAgICAwACFQb6AASADa61CMIZ8IAFCgICAgICAgICAf4OEIQQgAikDACEBCyAAIAE3AwAgACAENwMIIAJBEGokAAsEAEEACwQAQQAL+AoCBH8EfiMAQfAAayIFJAAgBEL///////////8AgyEJAkACQAJAIAFCf3wiCkJ/USACQv///////////wCDIgsgCiABVK18Qn98IgpC////////v///AFYgCkL///////+///8AURsNACADQn98IgpCf1IgCSAKIANUrXxCf3wiCkL///////+///8AVCAKQv///////7///wBRGw0BCwJAIAFQIAtCgICAgICAwP//AFQgC0KAgICAgIDA//8AURsNACACQoCAgICAgCCEIQQgASEDDAILAkAgA1AgCUKAgICAgIDA//8AVCAJQoCAgICAgMD//wBRGw0AIARCgICAgICAIIQhBAwCCwJAIAEgC0KAgICAgIDA//8AhYRCAFINAEKAgICAgIDg//8AIAIgAyABhSAEIAKFQoCAgICAgICAgH+FhFAiBhshBEIAIAEgBhshAwwCCyADIAlCgICAgICAwP//AIWEUA0BAkAgASALhEIAUg0AIAMgCYRCAFINAiADIAGDIQMgBCACgyEEDAILIAMgCYRQRQ0AIAEhAyACIQQMAQsgAyABIAMgAVYgCSALViAJIAtRGyIHGyEJIAQgAiAHGyILQv///////z+DIQogAiAEIAcbIgJCMIinQf//AXEhCAJAIAtCMIinQf//AXEiBg0AIAVB4ABqIAkgCiAJIAogClAiBht5IAZBBnStfKciBkFxahCnGkEQIAZrIQYgBUHoAGopAwAhCiAFKQNgIQkLIAEgAyAHGyEDIAJC////////P4MhBAJAIAgNACAFQdAAaiADIAQgAyAEIARQIgcbeSAHQQZ0rXynIgdBcWoQpxpBECAHayEIIAVB2ABqKQMAIQQgBSkDUCEDCyAEQgOGIANCPYiEQoCAgICAgIAEhCEEIApCA4YgCUI9iIQhASADQgOGIQMgCyAChSEKAkAgBiAIayIHRQ0AAkAgB0H/AE0NAEIAIQRCASEDDAELIAVBwABqIAMgBEGAASAHaxCnGiAFQTBqIAMgBCAHEKwaIAUpAzAgBSkDQCAFQcAAakEIaikDAIRCAFKthCEDIAVBMGpBCGopAwAhBAsgAUKAgICAgICABIQhDCAJQgOGIQICQAJAIApCf1UNAAJAIAIgA30iASAMIAR9IAIgA1StfSIEhFBFDQBCACEDQgAhBAwDCyAEQv////////8DVg0BIAVBIGogASAEIAEgBCAEUCIHG3kgB0EGdK18p0F0aiIHEKcaIAYgB2shBiAFQShqKQMAIQQgBSkDICEBDAELIAQgDHwgAyACfCIBIANUrXwiBEKAgICAgICACINQDQAgAUIBiCAEQj+GhCABQgGDhCEBIAZBAWohBiAEQgGIIQQLIAtCgICAgICAgICAf4MhAgJAIAZB//8BSA0AIAJCgICAgICAwP//AIQhBEIAIQMMAQtBACEHAkACQCAGQQBMDQAgBiEHDAELIAVBEGogASAEIAZB/wBqEKcaIAUgASAEQQEgBmsQrBogBSkDACAFKQMQIAVBEGpBCGopAwCEQgBSrYQhASAFQQhqKQMAIQQLIAFCA4ggBEI9hoQhAyAHrUIwhiAEQgOIQv///////z+DhCAChCEEIAGnQQdxIQYCQAJAAkACQAJAEKkaDgMAAQIDCyAEIAMgBkEES618IgEgA1StfCEEAkAgBkEERg0AIAEhAwwDCyAEIAFCAYMiAiABfCIDIAJUrXwhBAwDCyAEIAMgAkIAUiAGQQBHca18IgEgA1StfCEEIAEhAwwBCyAEIAMgAlAgBkEAR3GtfCIBIANUrXwhBCABIQMLIAZFDQELEKoaGgsgACADNwMAIAAgBDcDCCAFQfAAaiQAC1MBAX4CQAJAIANBwABxRQ0AIAIgA0FAaq2IIQFCACECDAELIANFDQAgAkHAACADa62GIAEgA60iBIiEIQEgAiAEiCECCyAAIAE3AwAgACACNwMIC40BAQN/IwBBEGsiAiQAQQAhAwJAIAFCMIinQf//AXEiBEH//wBJDQACQCAEQYGAf2pBIEkNAEH/////B0GAgICAeCABQn9VGyEDDAELIAIgACABQv///////z+DQoCAgICAgMAAhEHvgAEgBGsQrBogAigCACIDQQAgA2sgAUJ/VRshAwsgAkEQaiQAIAMLjgICAn8DfiMAQRBrIgIkAAJAAkAgAb0iBEL///////////8AgyIFQoCAgICAgIB4fEL/////////7/8AVg0AIAVCPIYhBiAFQgSIQoCAgICAgICAPHwhBQwBCwJAIAVCgICAgICAgPj/AFQNACAEQjyGIQYgBEIEiEKAgICAgIDA//8AhCEFDAELAkAgBVBFDQBCACEGQgAhBQwBCyACIAVCACAEp2dBIGogBUIgiKdnIAVCgICAgBBUGyIDQTFqEKcaIAJBCGopAwBCgICAgICAwACFQYz4ACADa61CMIaEIQUgAikDACEGCyAAIAY3AwAgACAFIARCgICAgICAgICAf4OENwMIIAJBEGokAAvrCwIFfw9+IwBB4ABrIgUkACABQiCIIAJCIIaEIQogA0IRiCAEQi+GhCELIANCMYggBEL///////8/gyIMQg+GhCENIAQgAoVCgICAgICAgICAf4MhDiACQv///////z+DIg9CIIghECAMQhGIIREgBEIwiKdB//8BcSEGAkACQAJAIAJCMIinQf//AXEiB0F/akH9/wFLDQBBACEIIAZBf2pB/v8BSQ0BCwJAIAFQIAJC////////////AIMiEkKAgICAgIDA//8AVCASQoCAgICAgMD//wBRGw0AIAJCgICAgICAIIQhDgwCCwJAIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRGw0AIARCgICAgICAIIQhDiADIQEMAgsCQCABIBJCgICAgICAwP//AIWEQgBSDQACQCADIAKEUEUNAEKAgICAgIDg//8AIQ5CACEBDAMLIA5CgICAgICAwP//AIQhDkIAIQEMAgsCQCADIAJCgICAgICAwP//AIWEQgBSDQAgASAShCECQgAhAQJAIAJQRQ0AQoCAgICAgOD//wAhDgwDCyAOQoCAgICAgMD//wCEIQ4MAgsCQCABIBKEQgBSDQBCACEBDAILAkAgAyAChEIAUg0AQgAhAQwCC0EAIQgCQCASQv///////z9WDQAgBUHQAGogASAPIAEgDyAPUCIIG3kgCEEGdK18pyIIQXFqEKcaQRAgCGshCCAFKQNQIgFCIIggBUHYAGopAwAiD0IghoQhCiAPQiCIIRALIAJC////////P1YNACAFQcAAaiADIAwgAyAMIAxQIgkbeSAJQQZ0rXynIglBcWoQpxogCCAJa0EQaiEIIAUpA0AiA0IxiCAFQcgAaikDACICQg+GhCENIANCEYggAkIvhoQhCyACQhGIIRELIAtC/////w+DIgIgAUL/////D4MiBH4iEyADQg+GQoCA/v8PgyIBIApC/////w+DIgN+fCIKQiCGIgwgASAEfnwiCyAMVK0gAiADfiIUIAEgD0L/////D4MiDH58IhIgDUL/////D4MiDyAEfnwiDSAKQiCIIAogE1StQiCGhHwiEyACIAx+IhUgASAQQoCABIQiCn58IhAgDyADfnwiFiARQv////8Hg0KAgICACIQiASAEfnwiEUIghnwiF3whBCAHIAZqIAhqQYGAf2ohBgJAAkAgDyAMfiIYIAIgCn58IgIgGFStIAIgASADfnwiAyACVK18IAMgEiAUVK0gDSASVK18fCICIANUrXwgASAKfnwgASAMfiIDIA8gCn58IgEgA1StQiCGIAFCIIiEfCACIAFCIIZ8IgEgAlStfCABIBFCIIggECAVVK0gFiAQVK18IBEgFlStfEIghoR8IgMgAVStfCADIBMgDVStIBcgE1StfHwiAiADVK18IgFCgICAgICAwACDUA0AIAZBAWohBgwBCyALQj+IIQMgAUIBhiACQj+IhCEBIAJCAYYgBEI/iIQhAiALQgGGIQsgAyAEQgGGhCEECwJAIAZB//8BSA0AIA5CgICAgICAwP//AIQhDkIAIQEMAQsCQAJAIAZBAEoNAAJAQQEgBmsiB0GAAUkNAEIAIQEMAwsgBUEwaiALIAQgBkH/AGoiBhCnGiAFQSBqIAIgASAGEKcaIAVBEGogCyAEIAcQrBogBSACIAEgBxCsGiAFKQMgIAUpAxCEIAUpAzAgBUEwakEIaikDAIRCAFKthCELIAVBIGpBCGopAwAgBUEQakEIaikDAIQhBCAFQQhqKQMAIQEgBSkDACECDAELIAatQjCGIAFC////////P4OEIQELIAEgDoQhDgJAIAtQIARCf1UgBEKAgICAgICAgIB/URsNACAOIAJCAXwiASACVK18IQ4MAQsCQCALIARCgICAgICAgICAf4WEQgBRDQAgAiEBDAELIA4gAiACQgGDfCIBIAJUrXwhDgsgACABNwMAIAAgDjcDCCAFQeAAaiQAC0EBAX8jAEEQayIFJAAgBSABIAIgAyAEQoCAgICAgICAgH+FEKsaIAAgBSkDADcDACAAIAUpAwg3AwggBUEQaiQAC40BAgJ/An4jAEEQayICJAACQAJAIAENAEIAIQRCACEFDAELIAIgASABQR91IgNqIANzIgOtQgAgA2ciA0HRAGoQpxogAkEIaikDAEKAgICAgIDAAIVBnoABIANrrUIwhnwgAUGAgICAeHGtQiCGhCEFIAIpAwAhBAsgACAENwMAIAAgBTcDCCACQRBqJAALdQEBfiAAIAQgAX4gAiADfnwgA0IgiCIEIAFCIIgiAn58IANC/////w+DIgMgAUL/////D4MiAX4iBUIgiCADIAJ+fCIDQiCIfCADQv////8PgyAEIAF+fCIDQiCIfDcDCCAAIANCIIYgBUL/////D4OENwMAC58SAgV/DH4jAEHAAWsiBSQAIARC////////P4MhCiACQv///////z+DIQsgBCAChUKAgICAgICAgIB/gyEMIARCMIinQf//AXEhBgJAAkACQAJAIAJCMIinQf//AXEiB0F/akH9/wFLDQBBACEIIAZBf2pB/v8BSQ0BCwJAIAFQIAJC////////////AIMiDUKAgICAgIDA//8AVCANQoCAgICAgMD//wBRGw0AIAJCgICAgICAIIQhDAwCCwJAIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRGw0AIARCgICAgICAIIQhDCADIQEMAgsCQCABIA1CgICAgICAwP//AIWEQgBSDQACQCADIAJCgICAgICAwP//AIWEUEUNAEIAIQFCgICAgICA4P//ACEMDAMLIAxCgICAgICAwP//AIQhDEIAIQEMAgsCQCADIAJCgICAgICAwP//AIWEQgBSDQBCACEBDAILIAEgDYRCAFENAgJAIAMgAoRCAFINACAMQoCAgICAgMD//wCEIQxCACEBDAILQQAhCAJAIA1C////////P1YNACAFQbABaiABIAsgASALIAtQIggbeSAIQQZ0rXynIghBcWoQpxpBECAIayEIIAVBuAFqKQMAIQsgBSkDsAEhAQsgAkL///////8/Vg0AIAVBoAFqIAMgCiADIAogClAiCRt5IAlBBnStfKciCUFxahCnGiAJIAhqQXBqIQggBUGoAWopAwAhCiAFKQOgASEDCyAFQZABaiADQjGIIApCgICAgICAwACEIg5CD4aEIgJCAEKEyfnOv+a8gvUAIAJ9IgRCABCyGiAFQYABakIAIAVBkAFqQQhqKQMAfUIAIARCABCyGiAFQfAAaiAFKQOAAUI/iCAFQYABakEIaikDAEIBhoQiBEIAIAJCABCyGiAFQeAAaiAEQgBCACAFQfAAakEIaikDAH1CABCyGiAFQdAAaiAFKQNgQj+IIAVB4ABqQQhqKQMAQgGGhCIEQgAgAkIAELIaIAVBwABqIARCAEIAIAVB0ABqQQhqKQMAfUIAELIaIAVBMGogBSkDQEI/iCAFQcAAakEIaikDAEIBhoQiBEIAIAJCABCyGiAFQSBqIARCAEIAIAVBMGpBCGopAwB9QgAQshogBUEQaiAFKQMgQj+IIAVBIGpBCGopAwBCAYaEIgRCACACQgAQshogBSAEQgBCACAFQRBqQQhqKQMAfUIAELIaIAggByAGa2ohBgJAAkBCACAFKQMAQj+IIAVBCGopAwBCAYaEQn98Ig1C/////w+DIgQgAkIgiCIPfiIQIA1CIIgiDSACQv////8PgyIRfnwiAkIgiCACIBBUrUIghoQgDSAPfnwgAkIghiIPIAQgEX58IgIgD1StfCACIAQgA0IRiEL/////D4MiEH4iESANIANCD4ZCgID+/w+DIhJ+fCIPQiCGIhMgBCASfnwgE1StIA9CIIggDyARVK1CIIaEIA0gEH58fHwiDyACVK18IA9CAFKtfH0iAkL/////D4MiECAEfiIRIBAgDX4iEiAEIAJCIIgiE358IgJCIIZ8IhAgEVStIAJCIIggAiASVK1CIIaEIA0gE358fCAQQgAgD30iAkIgiCIPIAR+IhEgAkL/////D4MiEiANfnwiAkIghiITIBIgBH58IBNUrSACQiCIIAIgEVStQiCGhCAPIA1+fHx8IgIgEFStfCACQn58IhEgAlStfEJ/fCIPQv////8PgyICIAFCPoggC0IChoRC/////w+DIgR+IhAgAUIeiEL/////D4MiDSAPQiCIIg9+fCISIBBUrSASIBFCIIgiECALQh6IQv//7/8Pg0KAgBCEIgt+fCITIBJUrXwgCyAPfnwgAiALfiIUIAQgD358IhIgFFStQiCGIBJCIIiEfCATIBJCIIZ8IhIgE1StfCASIBAgDX4iFCARQv////8PgyIRIAR+fCITIBRUrSATIAIgAUIChkL8////D4MiFH58IhUgE1StfHwiEyASVK18IBMgFCAPfiISIBEgC358Ig8gECAEfnwiBCACIA1+fCICQiCIIA8gElStIAQgD1StfCACIARUrXxCIIaEfCIPIBNUrXwgDyAVIBAgFH4iBCARIA1+fCINQiCIIA0gBFStQiCGhHwiBCAVVK0gBCACQiCGfCAEVK18fCIEIA9UrXwiAkL/////////AFYNACABQjGGIARC/////w+DIgEgA0L/////D4MiDX4iD0IAUq19QgAgD30iESAEQiCIIg8gDX4iEiABIANCIIgiEH58IgtCIIYiE1StfSAEIA5CIIh+IAMgAkIgiH58IAIgEH58IA8gCn58QiCGIAJC/////w+DIA1+IAEgCkL/////D4N+fCAPIBB+fCALQiCIIAsgElStQiCGhHx8fSENIBEgE30hASAGQX9qIQYMAQsgBEIhiCEQIAFCMIYgBEIBiCACQj+GhCIEQv////8PgyIBIANC/////w+DIg1+Ig9CAFKtfUIAIA99IgsgASADQiCIIg9+IhEgECACQh+GhCISQv////8PgyITIA1+fCIQQiCGIhRUrX0gBCAOQiCIfiADIAJCIYh+fCACQgGIIgIgD358IBIgCn58QiCGIBMgD34gAkL/////D4MgDX58IAEgCkL/////D4N+fCAQQiCIIBAgEVStQiCGhHx8fSENIAsgFH0hASACIQILAkAgBkGAgAFIDQAgDEKAgICAgIDA//8AhCEMQgAhAQwBCyAGQf//AGohBwJAIAZBgYB/Sg0AAkAgBw0AIAJC////////P4MgBCABQgGGIANWIA1CAYYgAUI/iIQiASAOViABIA5RG618IgEgBFStfCIDQoCAgICAgMAAg1ANACADIAyEIQwMAgtCACEBDAELIAJC////////P4MgBCABQgGGIANaIA1CAYYgAUI/iIQiASAOWiABIA5RG618IgEgBFStfCAHrUIwhnwgDIQhDAsgACABNwMAIAAgDDcDCCAFQcABaiQADwsgAEIANwMAIABCgICAgICA4P//ACAMIAMgAoRQGzcDCCAFQcABaiQAC+oDAgJ/An4jAEEgayICJAACQAJAIAFC////////////AIMiBEKAgICAgIDA/0N8IARCgICAgICAwIC8f3xaDQAgAEI8iCABQgSGhCEEAkAgAEL//////////w+DIgBCgYCAgICAgIAIVA0AIARCgYCAgICAgIDAAHwhBQwCCyAEQoCAgICAgICAwAB8IQUgAEKAgICAgICAgAiFQgBSDQEgBSAEQgGDfCEFDAELAkAgAFAgBEKAgICAgIDA//8AVCAEQoCAgICAgMD//wBRGw0AIABCPIggAUIEhoRC/////////wODQoCAgICAgID8/wCEIQUMAQtCgICAgICAgPj/ACEFIARC////////v//DAFYNAEIAIQUgBEIwiKciA0GR9wBJDQAgAkEQaiAAIAFC////////P4NCgICAgICAwACEIgQgA0H/iH9qEKcaIAIgACAEQYH4ACADaxCsGiACKQMAIgRCPIggAkEIaikDAEIEhoQhBQJAIARC//////////8PgyACKQMQIAJBEGpBCGopAwCEQgBSrYQiBEKBgICAgICAgAhUDQAgBUIBfCEFDAELIARCgICAgICAgIAIhUIAUg0AIAVCAYMgBXwhBQsgAkEgaiQAIAUgAUKAgICAgICAgIB/g4S/CwkAQfAhEIMBAAszAQF/IABBASAAGyEBAkADQCABEN8aIgANAQJAEL4aIgBFDQAgABERAAwBCwsQAgALIAALBwAgABDgGgsPACAAQYgiQQhqNgIAIAALPAECfyABEIEbIgJBDWoQthoiA0EANgIIIAMgAjYCBCADIAI2AgAgACADELoaIAEgAkEBahDjGjYCACAACwcAIABBDGoLIAAgABC4GhogAEG0IkEIajYCACAAQQRqIAEQuRoaIAALBABBAQsHACAAKAIACwgAQcQsEL0aCwQAIAALBwAgABC3GgsFAEH3IQsbACAAQbwiNgIAIABBBGoQwxoaIAAQvxoaIAALKwEBfwJAIAAQvBpFDQAgACgCABDEGiIBQQhqEMUaQX9KDQAgARC3GgsgAAsHACAAQXRqCxUBAX8gACAAKAIAQX9qIgE2AgAgAQsKACAAEMIaELcaCwoAIABBBGoQyBoLBwAgACgCAAsNACAAEMIaGiAAELcaCwQAIAALWQECfyABLQAAIQICQCAALQAAIgNFDQAgAyACQf8BcUcNAANAIAEtAAEhAiAALQABIgNFDQEgAUEBaiEBIABBAWohACADIAJB/wFxRg0ACwsgAyACQf8BcWsLCgAgABDKGhogAAsCAAsCAAsNACAAEMwaGiAAELcaCw0AIAAQzBoaIAAQtxoLMAACQCACDQAgACgCBCABKAIERg8LAkAgACABRw0AQQEPCyAAENIaIAEQ0hoQyxpFCwcAIAAoAgQLrgEBAn8jAEHAAGsiAyQAQQEhBAJAIAAgAUEAENEaDQBBACEEIAFFDQBBACEEIAFB1CNBhCRBABDUGiIBRQ0AIANBCGpBBHJBAEE0EOQaGiADQQE2AjggA0F/NgIUIAMgADYCECADIAE2AgggASADQQhqIAIoAgBBASABKAIAKAIcEQYAAkAgAygCICIEQQFHDQAg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aiABNgIAIAJBdGogATYCACAEQRlJDQAgAyABNgIYIAMgATYCFCADIAE2AhAgAyABNgIMIAJBcGogATYCACACQWxqIAE2AgAgAkFoaiABNgIAIAJBZGogATYCACAEIANBBHFBGHIiBWsiAkEgSQ0AIAGtQoGAgIAQfiEGIAMgBWohAQNAIAEgBjcDGCABIAY3AxAgASAGNwMIIAEgBjcDACABQSBqIQEgAkFgaiICQR9LDQALCyAAC/gCAQF/AkAgACABRg0AAkAgASAAayACa0EAIAJBAXRrSw0AIAAgASACEOMaDwsgASAAc0EDcSEDAkACQAJAIAAgAU8NAAJAIANFDQAgACEDDAMLAkAgAEEDcQ0AIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcUUNAgwACwALAkAgAw0AAkAgACACakEDcUUNAANAIAJFDQUgACACQX9qIgJqIgMgASACai0AADoAACADQQNxDQALCyACQQNNDQADQCAAIAJBfGoiAmogASACaigCADYCACACQQNLDQALCyACRQ0CA0AgACACQX9qIgJqIAEgAmotAAA6AAAgAg0ADAMLAAsgAkEDTQ0AA0AgAyABKAIANgIAIAFBBGohASADQQRqIQMgAkF8aiICQQNLDQALCyACRQ0AA0AgAyABLQAAOgAAIANBAWohAyABQQFqIQEgAkF/aiICDQALCyAACxYAAkAgAA0AQQAPCxDeGiAANgIAQX8L2AIBB38jAEEgayIDJAAgAyAAKAIcIgQ2AhAgACgCFCEFIAMgAjYCHCADIAE2AhggAyAFIARrIgE2AhQgASACaiEGQQIhByADQRBqIQECQAJAAkACQCAAKAI8IANBEGpBAiADQQxqEAUQ5hoNAANAIAYgAygCDCIERg0CIARBf0wNAyABIAQgASgCBCIISyIFQQN0aiIJIAkoAgAgBCAIQQAgBRtrIghqNgIAIAFBDEEEIAUbaiIJIAkoAgAgCGs2AgAgBiAEayEGIAAoAjwgAUEIaiABIAUbIgEgByAFayIHIANBDGoQBRDmGkUNAAsLIAZBf0cNAQsgACAAKAIsIgE2AhwgACABNgIUIAAgASAAKAIwajYCECACIQQMAQtBACEEIABBADYCHCAAQgA3AxAgACAAKAIAQSBy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EPkaIAAgDCAPEPMaIABBICABIA4gDUGAwABzEPkaDAELC0EAIRQLIAdB0ABqJAAgFAsZAAJAIAAtAABBIHENACABIAIgABDwGhoLC0sBA39BACEBAkAgACgCACwAABDqGkUNAANAIAAoAgAiAiwAACEDIAAgAkEBajYCACADIAFBCmxqQVBqIQEgAiwAARDqGg0ACwsgAQu7AgACQCABQRRLDQACQAJAAkACQAJAAkACQAJAAkACQCABQXdqDgoAAQIDBAUGBwgJCgsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAgALCzUAAkAgAFANAANAIAFBf2oiASAAp0EPcUGAKWotAAAgAnI6AAAgAEIEiCIAQgBSDQALCyABCy4AAkAgAFANAANAIAFBf2oiASAAp0EHcUEwcjoAACAAQgOIIgBCAFINAAsLIAELiAECAX4DfwJAAkAgAEKAgICAEFoNACAAIQIMAQsDQCABQX9qIgEgACAAQgqAIgJCCn59p0EwcjoAACAAQv////+fAVYhAyACIQAgAw0ACwsCQCACpyIDRQ0AA0AgAUF/aiIBIAMgA0EKbiIEQQpsa0EwcjoAACADQQlLIQUgBCEDIAUNAAsLIAELcwEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABQf8BcSACIANrIgJBgAIgAkGAAkkiAxsQ5BoaAkAgAw0AA0AgACAFQYACEPMaIAJBgH5qIgJB/wFLDQALCyAAIAUgAhDzGgsgBUGAAmokAAsPACAAIAEgAkEbQRwQ8RoLqhgDEn8CfgF8IwBBsARrIgYkAEEAIQcgBkEANgIsAkACQCABEP0aIhhCf1UNAEEBIQhBkCkhCSABmiIB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';\nif (!isDataURI(wasmBinaryFile)) {\n  wasmBinaryFile = locateFile(wasmBinaryFile);\n}\n\nfunction getBinary(file) {\n  try {\n    if (file == wasmBinaryFile && wasmBinary) {\n      return new Uint8Array(wasmBinary);\n    }\n    var binary = tryParseAsDataURI(file);\n    if (binary) {\n      return binary;\n    }\n    if (readBinary) {\n      return readBinary(file);\n    } else {\n      throw \"both async and sync fetching of the wasm failed\";\n    }\n  }\n  catch (err) {\n    abort(err);\n  }\n}\n\nfunction getBinaryPromise() {\n  // If we don't have the binary yet, try to to load it asynchronously.\n  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\n  // See https://github.com/github/fetch/pull/92#issuecomment-140665932\n  // Cordova or Electron apps are typically loaded from a file:// url.\n  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.\n  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n    if (typeof fetch === 'function'\n    ) {\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {\n        if (!response['ok']) {\n          throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n        }\n        return response['arrayBuffer']();\n      }).catch(function () {\n          return getBinary(wasmBinaryFile);\n      });\n    }\n  }\n    \n  // Otherwise, getBinary should be able to get it synchronously\n  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });\n}\n\n// Create the wasm instance.\n// Receives the wasm imports, returns the exports.\nfunction createWasm() {\n  // prepare imports\n  var info = {\n    'env': asmLibraryArg,\n    'wasi_snapshot_preview1': asmLibraryArg,\n  };\n  // Load the wasm module and create an instance of using native support in the JS engine.\n  // handle a generated wasm instance, receiving its exports and\n  // performing other necessary setup\n  /** @param {WebAssembly.Module=} module*/\n  function receiveInstance(instance, module) {\n    var exports = instance.exports;\n\n    Module['asm'] = exports;\n\n    wasmMemory = Module['asm']['memory'];\n    updateGlobalBufferAndViews(wasmMemory.buffer);\n\n    wasmTable = Module['asm']['__indirect_function_table'];\n\n    removeRunDependency('wasm-instantiate');\n  }\n  // we can't run yet (except in a pthread, where we have a custom sync instantiator)\n  addRunDependency('wasm-instantiate');\n\n  function receiveInstantiatedSource(output) {\n    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.\n    receiveInstance(output['instance']);\n  }\n\n  function instantiateArrayBuffer(receiver) {\n    return getBinaryPromise().then(function(binary) {\n      return WebAssembly.instantiate(binary, info);\n    }).then(receiver, function(reason) {\n      err('failed to asynchronously prepare wasm: ' + reason);\n\n      abort(reason);\n    });\n  }\n\n  // Prefer streaming instantiation if available.\n  function instantiateAsync() {\n    if (!wasmBinary &&\n        typeof WebAssembly.instantiateStreaming === 'function' &&\n        !isDataURI(wasmBinaryFile) &&\n        typeof fetch === 'function') {\n      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {\n        var result = WebAssembly.instantiateStreaming(response, info);\n        return result.then(receiveInstantiatedSource, function(reason) {\n            // We expect the most common failure cause to be a bad MIME type for the binary,\n            // in which case falling back to ArrayBuffer instantiation should work.\n            err('wasm streaming compile failed: ' + reason);\n            err('falling back to ArrayBuffer instantiation');\n            return instantiateArrayBuffer(receiveInstantiatedSource);\n          });\n      });\n    } else {\n      return instantiateArrayBuffer(receiveInstantiatedSource);\n    }\n  }\n\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n  // to any other async startup actions they are performing.\n  if (Module['instantiateWasm']) {\n    try {\n      var exports = Module['instantiateWasm'](info, receiveInstance);\n      return exports;\n    } catch(e) {\n      err('Module.instantiateWasm callback failed with error: ' + e);\n      return false;\n    }\n  }\n\n  instantiateAsync();\n  return {}; // no exports yet; we'll fill them in later\n}\n\n// Globals used by JS i64 conversions (see makeSetValue)\nvar tempDouble;\nvar tempI64;\n\n// === Body ===\n\nvar ASM_CONSTS = {\n  \n};\n\n\n\n\n\n\n  function callRuntimeCallbacks(callbacks) {\n      while(callbacks.length > 0) {\n        var callback = callbacks.shift();\n        if (typeof callback == 'function') {\n          callback(Module); // Pass the module as the first argument.\n          continue;\n        }\n        var func = callback.func;\n        if (typeof func === 'number') {\n          if (callback.arg === undefined) {\n            wasmTable.get(func)();\n          } else {\n            wasmTable.get(func)(callback.arg);\n          }\n        } else {\n          func(callback.arg === undefined ? null : callback.arg);\n        }\n      }\n    }\n\n  function demangle(func) {\n      return func;\n    }\n\n  function demangleAll(text) {\n      var regex =\n        /\\b_Z[\\w\\d_]+/g;\n      return text.replace(regex,\n        function(x) {\n          var y = demangle(x);\n          return x === y ? x : (y + ' [' + x + ']');\n        });\n    }\n\n  function jsStackTrace() {\n      var error = new Error();\n      if (!error.stack) {\n        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n        // so try that as a special-case.\n        try {\n          throw new Error();\n        } catch(e) {\n          error = e;\n        }\n        if (!error.stack) {\n          return '(no stack trace available)';\n        }\n      }\n      return error.stack.toString();\n    }\n\n  function stackTrace() {\n      var js = jsStackTrace();\n      if (Module['extraStackTrace']) js += '\\n' + Module['extraStackTrace']();\n      return demangleAll(js);\n    }\n\n  var ExceptionInfoAttrs={DESTRUCTOR_OFFSET:0,REFCOUNT_OFFSET:4,TYPE_OFFSET:8,CAUGHT_OFFSET:12,RETHROWN_OFFSET:13,SIZE:16};\n  function ___cxa_allocate_exception(size) {\n      // Thrown object is prepended by exception metadata block\n      return _malloc(size + ExceptionInfoAttrs.SIZE) + ExceptionInfoAttrs.SIZE;\n    }\n\n  function ExceptionInfo(excPtr) {\n      this.excPtr = excPtr;\n      this.ptr = excPtr - ExceptionInfoAttrs.SIZE;\n  \n      this.set_type = function(type) {\n        HEAP32[(((this.ptr)+(ExceptionInfoAttrs.TYPE_OFFSET))>>2)] = type;\n      };\n  \n      this.get_type = function() {\n        return HEAP32[(((this.ptr)+(ExceptionInfoAttrs.TYPE_OFFSET))>>2)];\n      };\n  \n      this.set_destructor = function(destructor) {\n        HEAP32[(((this.ptr)+(ExceptionInfoAttrs.DESTRUCTOR_OFFSET))>>2)] = destructor;\n      };\n  \n      this.get_destructor = function() {\n        return HEAP32[(((this.ptr)+(ExceptionInfoAttrs.DESTRUCTOR_OFFSET))>>2)];\n      };\n  \n      this.set_refcount = function(refcount) {\n        HEAP32[(((this.ptr)+(ExceptionInfoAttrs.REFCOUNT_OFFSET))>>2)] = refcount;\n      };\n  \n      this.set_caught = function (caught) {\n        caught = caught ? 1 : 0;\n        HEAP8[(((this.ptr)+(ExceptionInfoAttrs.CAUGHT_OFFSET))>>0)] = caught;\n      };\n  \n      this.get_caught = function () {\n        return HEAP8[(((this.ptr)+(ExceptionInfoAttrs.CAUGHT_OFFSET))>>0)] != 0;\n      };\n  \n      this.set_rethrown = function (rethrown) {\n        rethrown = rethrown ? 1 : 0;\n        HEAP8[(((this.ptr)+(ExceptionInfoAttrs.RETHROWN_OFFSET))>>0)] = rethrown;\n      };\n  \n      this.get_rethrown = function () {\n        return HEAP8[(((this.ptr)+(ExceptionInfoAttrs.RETHROWN_OFFSET))>>0)] != 0;\n      };\n  \n      // Initialize native structure fields. Should be called once after allocated.\n      this.init = function(type, destructor) {\n        this.set_type(type);\n        this.set_destructor(destructor);\n        this.set_refcount(0);\n        this.set_caught(false);\n        this.set_rethrown(false);\n      }\n  \n      this.add_ref = function() {\n        var value = HEAP32[(((this.ptr)+(ExceptionInfoAttrs.REFCOUNT_OFFSET))>>2)];\n        HEAP32[(((this.ptr)+(ExceptionInfoAttrs.REFCOUNT_OFFSET))>>2)] = value + 1;\n      };\n  \n      // Returns true if last reference released.\n      this.release_ref = function() {\n        var prev = HEAP32[(((this.ptr)+(ExceptionInfoAttrs.REFCOUNT_OFFSET))>>2)];\n        HEAP32[(((this.ptr)+(ExceptionInfoAttrs.REFCOUNT_OFFSET))>>2)] = prev - 1;\n        return prev === 1;\n      };\n    }\n  \n  var exceptionLast=0;\n  \n  var uncaughtExceptionCount=0;\n  function ___cxa_throw(ptr, type, destructor) {\n      var info = new ExceptionInfo(ptr);\n      // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.\n      info.init(type, destructor);\n      exceptionLast = ptr;\n      uncaughtExceptionCount++;\n      throw ptr;\n    }\n\n  function _abort() {\n      abort();\n    }\n\n  function _emscripten_memcpy_big(dest, src, num) {\n      HEAPU8.copyWithin(dest, src, src + num);\n    }\n\n  function _emscripten_get_heap_size() {\n      return HEAPU8.length;\n    }\n  \n  function emscripten_realloc_buffer(size) {\n      try {\n        // round size grow request up to wasm page size (fixed 64KB per spec)\n        wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16); // .grow() takes a delta compared to the previous size\n        updateGlobalBufferAndViews(wasmMemory.buffer);\n        return 1 /*success*/;\n      } catch(e) {\n      }\n      // implicit 0 return to save code size (caller will cast \"undefined\" into 0\n      // anyhow)\n    }\n  function _emscripten_resize_heap(requestedSize) {\n      var oldSize = _emscripten_get_heap_size();\n      // With pthreads, races can happen (another thread might increase the size in between), so return a failure, and let the caller retry.\n  \n      // Memory resize rules:\n      // 1. Always increase heap size to at least the requested size, rounded up to next page multiple.\n      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap geometrically: increase the heap size according to \n      //                                         MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%),\n      //                                         At most overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).\n      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap linearly: increase the heap size by at least MEMORY_GROWTH_LINEAR_STEP bytes.\n      // 3. Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest\n      // 4. If we were unable to allocate as much memory, it may be due to over-eager decision to excessively reserve due to (3) above.\n      //    Hence if an allocation fails, cut down on the amount of excess growth, in an attempt to succeed to perform a smaller allocation.\n  \n      // A limit was set for how much we can grow. We should not exceed that\n      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).\n      // In CAN_ADDRESS_2GB mode, stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate full 4GB Wasm memories, the size will wrap\n      // back to 0 bytes in Wasm side for any code that deals with heap sizes, which would require special casing all heap size related code to treat\n      // 0 specially.\n      var maxHeapSize = 2147483648;\n      if (requestedSize > maxHeapSize) {\n        return false;\n      }\n  \n      // Loop through potential heap size increases. If we attempt a too eager reservation that fails, cut down on the\n      // attempted size and reserve a smaller bump instead. (max 3 times, chosen somewhat arbitrarily)\n      for(var cutDown = 1; cutDown <= 4; cutDown *= 2) {\n        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth\n        // but limit overreserving (default to capping at +96MB overgrowth at most)\n        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );\n  \n        var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n  \n        var replacement = emscripten_realloc_buffer(newSize);\n        if (replacement) {\n  \n          return true;\n        }\n      }\n      return false;\n    }\n\n  function flush_NO_FILESYSTEM() {\n      // flush anything remaining in the buffers during shutdown\n      if (typeof _fflush !== 'undefined') _fflush(0);\n      var buffers = SYSCALLS.buffers;\n      if (buffers[1].length) SYSCALLS.printChar(1, 10);\n      if (buffers[2].length) SYSCALLS.printChar(2, 10);\n    }\n  \n  var SYSCALLS={mappings:{},buffers:[null,[],[]],printChar:function(stream, curr) {\n        var buffer = SYSCALLS.buffers[stream];\n        if (curr === 0 || curr === 10) {\n          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));\n          buffer.length = 0;\n        } else {\n          buffer.push(curr);\n        }\n      },varargs:undefined,get:function() {\n        SYSCALLS.varargs += 4;\n        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];\n        return ret;\n      },getStr:function(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },get64:function(low, high) {\n        return low;\n      }};\n  function _fd_write(fd, iov, iovcnt, pnum) {\n      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\n      var num = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAP32[(((iov)+(i*8))>>2)];\n        var len = HEAP32[(((iov)+(i*8 + 4))>>2)];\n        for (var j = 0; j < len; j++) {\n          SYSCALLS.printChar(fd, HEAPU8[ptr+j]);\n        }\n        num += len;\n      }\n      HEAP32[((pnum)>>2)] = num\n      return 0;\n    }\n\n  function _setTempRet0($i) {\n      setTempRet0(($i) | 0);\n    }\nvar ASSERTIONS = false;\n\n\n\n/** @type {function(string, boolean=, number=)} */\nfunction intArrayFromString(stringy, dontAddNull, length) {\n  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\n  var u8array = new Array(len);\n  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n  if (dontAddNull) u8array.length = numBytesWritten;\n  return u8array;\n}\n\nfunction intArrayToString(array) {\n  var ret = [];\n  for (var i = 0; i < array.length; i++) {\n    var chr = array[i];\n    if (chr > 0xFF) {\n      if (ASSERTIONS) {\n        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n      }\n      chr &= 0xFF;\n    }\n    ret.push(String.fromCharCode(chr));\n  }\n  return ret.join('');\n}\n\n\n// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149\n\n// This code was written by Tyler Akins and has been placed in the\n// public domain.  It would be nice if you left this header intact.\n// Base64 code from Tyler Akins -- http://rumkin.com\n\n/**\n * Decodes a base64 string.\n * @param {string} input The string to decode.\n */\nvar decodeBase64 = typeof atob === 'function' ? atob : function (input) {\n  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  var output = '';\n  var chr1, chr2, chr3;\n  var enc1, enc2, enc3, enc4;\n  var i = 0;\n  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n  input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n  do {\n    enc1 = keyStr.indexOf(input.charAt(i++));\n    enc2 = keyStr.indexOf(input.charAt(i++));\n    enc3 = keyStr.indexOf(input.charAt(i++));\n    enc4 = keyStr.indexOf(input.charAt(i++));\n\n    chr1 = (enc1 << 2) | (enc2 >> 4);\n    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n    chr3 = ((enc3 & 3) << 6) | enc4;\n\n    output = output + String.fromCharCode(chr1);\n\n    if (enc3 !== 64) {\n      output = output + String.fromCharCode(chr2);\n    }\n    if (enc4 !== 64) {\n      output = output + String.fromCharCode(chr3);\n    }\n  } while (i < input.length);\n  return output;\n};\n\n// Converts a string of base64 into a byte array.\n// Throws error on invalid input.\nfunction intArrayFromBase64(s) {\n\n  try {\n    var decoded = decodeBase64(s);\n    var bytes = new Uint8Array(decoded.length);\n    for (var i = 0 ; i < decoded.length ; ++i) {\n      bytes[i] = decoded.charCodeAt(i);\n    }\n    return bytes;\n  } catch (_) {\n    throw new Error('Converting base64 string to bytes failed.');\n  }\n}\n\n// If filename is a base64 data URI, parses and returns data (Buffer on node,\n// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.\nfunction tryParseAsDataURI(filename) {\n  if (!isDataURI(filename)) {\n    return;\n  }\n\n  return intArrayFromBase64(filename.slice(dataURIPrefix.length));\n}\n\n\nvar asmLibraryArg = {\n  \"__cxa_allocate_exception\": ___cxa_allocate_exception,\n  \"__cxa_throw\": ___cxa_throw,\n  \"abort\": _abort,\n  \"emscripten_memcpy_big\": _emscripten_memcpy_big,\n  \"emscripten_resize_heap\": _emscripten_resize_heap,\n  \"fd_write\": _fd_write,\n  \"setTempRet0\": _setTempRet0\n};\nvar asm = createWasm();\n/** @type {function(...*):?} */\nvar ___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = function() {\n  return (___wasm_call_ctors = Module[\"___wasm_call_ctors\"] = Module[\"asm\"][\"__wasm_call_ctors\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar _malloc = Module[\"_malloc\"] = function() {\n  return (_malloc = Module[\"_malloc\"] = Module[\"asm\"][\"malloc\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar _separateTabs = Module[\"_separateTabs\"] = function() {\n  return (_separateTabs = Module[\"_separateTabs\"] = Module[\"asm\"][\"separateTabs\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar _vCarve = Module[\"_vCarve\"] = function() {\n  return (_vCarve = Module[\"_vCarve\"] = Module[\"asm\"][\"vCarve\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar ___errno_location = Module[\"___errno_location\"] = function() {\n  return (___errno_location = Module[\"___errno_location\"] = Module[\"asm\"][\"__errno_location\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar stackSave = Module[\"stackSave\"] = function() {\n  return (stackSave = Module[\"stackSave\"] = Module[\"asm\"][\"stackSave\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar stackRestore = Module[\"stackRestore\"] = function() {\n  return (stackRestore = Module[\"stackRestore\"] = Module[\"asm\"][\"stackRestore\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar stackAlloc = Module[\"stackAlloc\"] = function() {\n  return (stackAlloc = Module[\"stackAlloc\"] = Module[\"asm\"][\"stackAlloc\"]).apply(null, arguments);\n};\n\n/** @type {function(...*):?} */\nvar dynCall_jiji = Module[\"dynCall_jiji\"] = function() {\n  return (dynCall_jiji = Module[\"dynCall_jiji\"] = Module[\"asm\"][\"dynCall_jiji\"]).apply(null, arguments);\n};\n\n\n\n\n\n// === Auto-generated postamble setup entry stuff ===\n\n\n\nvar calledRun;\n\n/**\n * @constructor\n * @this {ExitStatus}\n */\nfunction ExitStatus(status) {\n  this.name = \"ExitStatus\";\n  this.message = \"Program terminated with exit(\" + status + \")\";\n  this.status = status;\n}\n\nvar calledMain = false;\n\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!calledRun) run();\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n};\n\n/** @type {function(Array=)} */\nfunction run(args) {\n  args = args || arguments_;\n\n  if (runDependencies > 0) {\n    return;\n  }\n\n  preRun();\n\n  // a preRun added a dependency, run will be called later\n  if (runDependencies > 0) {\n    return;\n  }\n\n  function doRun() {\n    // run may have just been called through dependencies being fulfilled just in this very frame,\n    // or while the async setStatus time below was happening\n    if (calledRun) return;\n    calledRun = true;\n    Module['calledRun'] = true;\n\n    if (ABORT) return;\n\n    initRuntime();\n\n    preMain();\n\n    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();\n\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function() {\n      setTimeout(function() {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else\n  {\n    doRun();\n  }\n}\nModule['run'] = run;\n\n/** @param {boolean|number=} implicit */\nfunction exit(status, implicit) {\n\n  // if this is just main exit-ing implicitly, and the status is 0, then we\n  // don't need to do anything here and can just leave. if the status is\n  // non-zero, though, then we need to report it.\n  // (we may have warned about this earlier, if a situation justifies doing so)\n  if (implicit && noExitRuntime && status === 0) {\n    return;\n  }\n\n  if (noExitRuntime) {\n  } else {\n\n    EXITSTATUS = status;\n\n    exitRuntime();\n\n    if (Module['onExit']) Module['onExit'](status);\n\n    ABORT = true;\n  }\n\n  quit_(status, new ExitStatus(status));\n}\n\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n}\n\nrun();\n\n\n\n\n\n");

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*!
 * XRegExp.build 4.2.4
 * <xregexp.com>
 * Steven Levithan (c) 2012-present MIT License
 */
var _default = function _default(XRegExp) {
  var REGEX_DATA = 'xregexp';
  var subParts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
  var parts = XRegExp.union([/\({{([\w$]+)}}\)|{{([\w$]+)}}/, subParts], 'g', {
    conjunction: 'or'
  });
  /**
   * Strips a leading `^` and trailing unescaped `$`, if both are present.
   *
   * @private
   * @param {String} pattern Pattern to process.
   * @returns {String} Pattern with edge anchors removed.
   */

  function deanchor(pattern) {
    // Allow any number of empty noncapturing groups before/after anchors, because regexes
    // built/generated by XRegExp sometimes include them
    var leadingAnchor = /^(?:\(\?:\))*\^/;
    var trailingAnchor = /\$(?:\(\?:\))*$/;

    if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern) && // Ensure that the trailing `$` isn't escaped
    trailingAnchor.test(pattern.replace(/\\[\s\S]/g, ''))) {
      return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');
    }

    return pattern;
  }
  /**
   * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.
   *
   * @private
   * @param {String|RegExp} value Value to convert.
   * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not
   *   already a regex generated by XRegExp
   * @returns {RegExp} XRegExp object with XRegExp syntax applied.
   */


  function asXRegExp(value, addFlagX) {
    var flags = addFlagX ? 'x' : '';
    return XRegExp.isRegExp(value) ? value[REGEX_DATA] && value[REGEX_DATA].captureNames ? // Don't recompile, to preserve capture names
    value : // Recompile as XRegExp
    XRegExp(value.source, flags) : // Compile string as XRegExp
    XRegExp(value, flags);
  }

  function interpolate(substitution) {
    return substitution instanceof RegExp ? substitution : XRegExp.escape(substitution);
  }

  function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {
    subpatterns["subpattern".concat(subpatternIndex)] = interpolated;
    return subpatterns;
  }

  function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {
    var hasSubpattern = subpatternIndex < rawLiterals.length - 1;
    return raw + (hasSubpattern ? "{{subpattern".concat(subpatternIndex, "}}") : '');
  }
  /**
   * Provides tagged template literals that create regexes with XRegExp syntax and flags. The
   * provided pattern is handled as a raw string, so backslashes don't need to be escaped.
   *
   * Interpolation of strings and regexes shares the features of `XRegExp.build`. Interpolated
   * patterns are treated as atomic units when quantified, interpolated strings have their special
   * characters escaped, a leading `^` and trailing unescaped `$` are stripped from interpolated
   * regexes if both are present, and any backreferences within an interpolated regex are
   * rewritten to work within the overall pattern.
   *
   * @memberOf XRegExp
   * @param {String} [flags] Any combination of XRegExp flags.
   * @returns {Function} Handler for template literals that construct regexes with XRegExp syntax.
   * @example
   *
   * const h12 = /1[0-2]|0?[1-9]/;
   * const h24 = /2[0-3]|[01][0-9]/;
   * const hours = XRegExp.tag('x')`${h12} : | ${h24}`;
   * const minutes = /^[0-5][0-9]$/;
   * // Note that explicitly naming the 'minutes' group is required for named backreferences
   * const time = XRegExp.tag('x')`^ ${hours} (?<minutes>${minutes}) $`;
   * time.test('10:59'); // -> true
   * XRegExp.exec('10:59', time).minutes; // -> '59'
   */


  XRegExp.tag = function (flags) {
    return function (literals) {
      for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        substitutions[_key - 1] = arguments[_key];
      }

      var subpatterns = substitutions.map(interpolate).reduce(reduceToSubpatternsObject, {});
      var pattern = literals.raw.map(embedSubpatternAfter).join('');
      return XRegExp.build(pattern, subpatterns, flags);
    };
  };
  /**
   * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in
   * the outer pattern and provided subpatterns are automatically renumbered to work correctly.
   * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.
   *
   * @memberOf XRegExp
   * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows
   *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within
   *   character classes.
   * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A
   *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.
   * @param {String} [flags] Any combination of XRegExp flags.
   * @returns {RegExp} Regex with interpolated subpatterns.
   * @example
   *
   * const time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {
   *   hours: XRegExp.build('{{h12}} : | {{h24}}', {
   *     h12: /1[0-2]|0?[1-9]/,
   *     h24: /2[0-3]|[01][0-9]/
   *   }, 'x'),
   *   minutes: /^[0-5][0-9]$/
   * });
   * time.test('10:59'); // -> true
   * XRegExp.exec('10:59', time).minutes; // -> '59'
   */


  XRegExp.build = function (pattern, subs, flags) {
    flags = flags || ''; // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how
    // some browsers convert `RegExp('\n')` to a regex that contains the literal characters `\`
    // and `n`. See more details at <https://github.com/slevithan/xregexp/pull/163>.

    var addFlagX = flags.indexOf('x') !== -1;
    var inlineFlags = /^\(\?([\w$]+)\)/.exec(pattern); // Add flags within a leading mode modifier to the overall pattern's flags

    if (inlineFlags) {
      flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);
    }

    var data = {};

    for (var p in subs) {
      if (subs.hasOwnProperty(p)) {
        // Passing to XRegExp enables extended syntax and ensures independent validity,
        // lest an unescaped `(`, `)`, `[`, or trailing `\` breaks the `(?:)` wrapper. For
        // subpatterns provided as native regexes, it dies on octals and adds the property
        // used to hold extended regex instance data, for simplicity.
        var sub = asXRegExp(subs[p], addFlagX);
        data[p] = {
          // Deanchoring allows embedding independently useful anchored regexes. If you
          // really need to keep your anchors, double them (i.e., `^^...$$`).
          pattern: deanchor(sub.source),
          names: sub[REGEX_DATA].captureNames || []
        };
      }
    } // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;
    // helps keep this simple. Named captures will be put back.


    var patternAsRegex = asXRegExp(pattern, addFlagX); // 'Caps' is short for 'captures'

    var numCaps = 0;
    var numPriorCaps;
    var numOuterCaps = 0;
    var outerCapsMap = [0];
    var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];
    var output = patternAsRegex.source.replace(parts, function ($0, $1, $2, $3, $4) {
      var subName = $1 || $2;
      var capName;
      var intro;
      var localCapIndex; // Named subpattern

      if (subName) {
        if (!data.hasOwnProperty(subName)) {
          throw new ReferenceError("Undefined property ".concat($0));
        } // Named subpattern was wrapped in a capturing group


        if ($1) {
          capName = outerCapNames[numOuterCaps];
          outerCapsMap[++numOuterCaps] = ++numCaps; // If it's a named group, preserve the name. Otherwise, use the subpattern name
          // as the capture name

          intro = "(?<".concat(capName || subName, ">");
        } else {
          intro = '(?:';
        }

        numPriorCaps = numCaps;
        var rewrittenSubpattern = data[subName].pattern.replace(subParts, function (match, paren, backref) {
          // Capturing group
          if (paren) {
            capName = data[subName].names[numCaps - numPriorCaps];
            ++numCaps; // If the current capture has a name, preserve the name

            if (capName) {
              return "(?<".concat(capName, ">");
            } // Backreference

          } else if (backref) {
            localCapIndex = +backref - 1; // Rewrite the backreference

            return data[subName].names[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`
            "\\k<".concat(data[subName].names[localCapIndex], ">") : "\\".concat(+backref + numPriorCaps);
          }

          return match;
        });
        return "".concat(intro).concat(rewrittenSubpattern, ")");
      } // Capturing group


      if ($3) {
        capName = outerCapNames[numOuterCaps];
        outerCapsMap[++numOuterCaps] = ++numCaps; // If the current capture has a name, preserve the name

        if (capName) {
          return "(?<".concat(capName, ">");
        } // Backreference

      } else if ($4) {
        localCapIndex = +$4 - 1; // Rewrite the backreference

        return outerCapNames[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`
        "\\k<".concat(outerCapNames[localCapIndex], ">") : "\\".concat(outerCapsMap[+$4]);
      }

      return $0;
    });
    return XRegExp(output, flags);
  };
};

exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*!
 * XRegExp.matchRecursive 4.2.4
 * <xregexp.com>
 * Steven Levithan (c) 2009-present MIT License
 */
var _default = function _default(XRegExp) {
  /**
   * Returns a match detail object composed of the provided values.
   *
   * @private
   */
  function row(name, value, start, end) {
    return {
      name: name,
      value: value,
      start: start,
      end: end
    };
  }
  /**
   * Returns an array of match strings between outermost left and right delimiters, or an array of
   * objects with detailed match parts and position data. An error is thrown if delimiters are
   * unbalanced within the data.
   *
   * @memberOf XRegExp
   * @param {String} str String to search.
   * @param {String} left Left delimiter as an XRegExp pattern.
   * @param {String} right Right delimiter as an XRegExp pattern.
   * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.
   * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.
   * @returns {Array} Array of matches, or an empty array.
   * @example
   *
   * // Basic usage
   * let str = '(t((e))s)t()(ing)';
   * XRegExp.matchRecursive(str, '\\(', '\\)', 'g');
   * // -> ['t((e))s', '', 'ing']
   *
   * // Extended information mode with valueNames
   * str = 'Here is <div> <div>an</div></div> example';
   * XRegExp.matchRecursive(str, '<div\\s*>', '</div>', 'gi', {
   *   valueNames: ['between', 'left', 'match', 'right']
   * });
   * // -> [
   * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},
   * // {name: 'left',    value: '<div>',          start: 8,  end: 13},
   * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},
   * // {name: 'right',   value: '</div>',         start: 27, end: 33},
   * // {name: 'between', value: ' example',       start: 33, end: 41}
   * // ]
   *
   * // Omitting unneeded parts with null valueNames, and using escapeChar
   * str = '...{1}.\\{{function(x,y){return {y:x}}}';
   * XRegExp.matchRecursive(str, '{', '}', 'g', {
   *   valueNames: ['literal', null, 'value', null],
   *   escapeChar: '\\'
   * });
   * // -> [
   * // {name: 'literal', value: '...',  start: 0, end: 3},
   * // {name: 'value',   value: '1',    start: 4, end: 5},
   * // {name: 'literal', value: '.\\{', start: 6, end: 9},
   * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}
   * // ]
   *
   * // Sticky mode via flag y
   * str = '<1><<<2>>><3>4<5>';
   * XRegExp.matchRecursive(str, '<', '>', 'gy');
   * // -> ['1', '<<2>>', '3']
   */


  XRegExp.matchRecursive = function (str, left, right, flags, options) {
    flags = flags || '';
    options = options || {};
    var global = flags.indexOf('g') !== -1;
    var sticky = flags.indexOf('y') !== -1; // Flag `y` is controlled internally

    var basicFlags = flags.replace(/y/g, '');
    var _options = options,
        escapeChar = _options.escapeChar;
    var vN = options.valueNames;
    var output = [];
    var openTokens = 0;
    var delimStart = 0;
    var delimEnd = 0;
    var lastOuterEnd = 0;
    var outerStart;
    var innerStart;
    var leftMatch;
    var rightMatch;
    var esc;
    left = XRegExp(left, basicFlags);
    right = XRegExp(right, basicFlags);

    if (escapeChar) {
      if (escapeChar.length > 1) {
        throw new Error('Cannot use more than one escape character');
      }

      escapeChar = XRegExp.escape(escapeChar); // Example of concatenated `esc` regex:
      // `escapeChar`: '%'
      // `left`: '<'
      // `right`: '>'
      // Regex is: /(?:%[\S\s]|(?:(?!<|>)[^%])+)+/

      esc = new RegExp("(?:".concat(escapeChar, "[\\S\\s]|(?:(?!").concat( // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.
      // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax
      // transformation resulting from those flags was already applied to `left` and
      // `right` when they were passed through the XRegExp constructor above.
      XRegExp.union([left, right], '', {
        conjunction: 'or'
      }).source, ")[^").concat(escapeChar, "])+)+"), // Flags `gy` not needed here
      flags.replace(/[^imu]+/g, ''));
    }

    while (true) {
      // If using an escape character, advance to the delimiter's next starting position,
      // skipping any escaped characters in between
      if (escapeChar) {
        delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;
      }

      leftMatch = XRegExp.exec(str, left, delimEnd);
      rightMatch = XRegExp.exec(str, right, delimEnd); // Keep the leftmost match only

      if (leftMatch && rightMatch) {
        if (leftMatch.index <= rightMatch.index) {
          rightMatch = null;
        } else {
          leftMatch = null;
        }
      } // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):
      // LM | RM | OT | Result
      // 1  | 0  | 1  | loop
      // 1  | 0  | 0  | loop
      // 0  | 1  | 1  | loop
      // 0  | 1  | 0  | throw
      // 0  | 0  | 1  | throw
      // 0  | 0  | 0  | break
      // The paths above don't include the sticky mode special case. The loop ends after the
      // first completed match if not `global`.


      if (leftMatch || rightMatch) {
        delimStart = (leftMatch || rightMatch).index;
        delimEnd = delimStart + (leftMatch || rightMatch)[0].length;
      } else if (!openTokens) {
        break;
      }

      if (sticky && !openTokens && delimStart > lastOuterEnd) {
        break;
      }

      if (leftMatch) {
        if (!openTokens) {
          outerStart = delimStart;
          innerStart = delimEnd;
        }

        ++openTokens;
      } else if (rightMatch && openTokens) {
        if (! --openTokens) {
          if (vN) {
            if (vN[0] && outerStart > lastOuterEnd) {
              output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));
            }

            if (vN[1]) {
              output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));
            }

            if (vN[2]) {
              output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));
            }

            if (vN[3]) {
              output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));
            }
          } else {
            output.push(str.slice(innerStart, delimStart));
          }

          lastOuterEnd = delimEnd;

          if (!global) {
            break;
          }
        }
      } else {
        throw new Error('Unbalanced delimiter found in string');
      } // If the delimiter matched an empty string, avoid an infinite loop


      if (delimStart === delimEnd) {
        ++delimEnd;
      }
    }

    if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {
      output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));
    }

    return output;
  };
};

exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

/*!
 * XRegExp Unicode Base 4.2.4
 * <xregexp.com>
 * Steven Levithan (c) 2008-present MIT License
 */
var _default = function _default(XRegExp) {
  /**
   * Adds base support for Unicode matching:
   * - Adds syntax `\p{..}` for matching Unicode tokens. Tokens can be inverted using `\P{..}` or
   *   `\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the
   *   braces for token names that are a single letter (e.g. `\pL` or `PL`).
   * - Adds flag A (astral), which enables 21-bit Unicode support.
   * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.
   *
   * Unicode Base relies on externally provided Unicode character data. Official addons are
   * available to provide data for Unicode categories, scripts, blocks, and properties.
   *
   * @requires XRegExp
   */
  // ==--------------------------==
  // Private stuff
  // ==--------------------------==
  // Storage for Unicode data
  var unicode = {}; // Reuse utils

  var dec = XRegExp._dec;
  var hex = XRegExp._hex;
  var pad4 = XRegExp._pad4; // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed

  function normalize(name) {
    return name.replace(/[- _]+/g, '').toLowerCase();
  } // Gets the decimal code of a literal code unit, \xHH, \uHHHH, or a backslash-escaped literal


  function charCode(chr) {
    var esc = /^\\[xu](.+)/.exec(chr);
    return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === '\\' ? 1 : 0);
  } // Inverts a list of ordered BMP characters and ranges


  function invertBmp(range) {
    var output = '';
    var lastEnd = -1;
    XRegExp.forEach(range, /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/, function (m) {
      var start = charCode(m[1]);

      if (start > lastEnd + 1) {
        output += "\\u".concat(pad4(hex(lastEnd + 1)));

        if (start > lastEnd + 2) {
          output += "-\\u".concat(pad4(hex(start - 1)));
        }
      }

      lastEnd = charCode(m[2] || m[1]);
    });

    if (lastEnd < 0xFFFF) {
      output += "\\u".concat(pad4(hex(lastEnd + 1)));

      if (lastEnd < 0xFFFE) {
        output += '-\\uFFFF';
      }
    }

    return output;
  } // Generates an inverted BMP range on first use


  function cacheInvertedBmp(slug) {
    var prop = 'b!';
    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));
  } // Combines and optionally negates BMP and astral data


  function buildAstral(slug, isNegated) {
    var item = unicode[slug];
    var combined = '';

    if (item.bmp && !item.isBmpLast) {
      combined = "[".concat(item.bmp, "]").concat(item.astral ? '|' : '');
    }

    if (item.astral) {
      combined += item.astral;
    }

    if (item.isBmpLast && item.bmp) {
      combined += "".concat(item.astral ? '|' : '', "[").concat(item.bmp, "]");
    } // Astral Unicode tokens always match a code point, never a code unit


    return isNegated ? "(?:(?!".concat(combined, ")(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|[\0-\uFFFF]))") : "(?:".concat(combined, ")");
  } // Builds a complete astral pattern on first use


  function cacheAstral(slug, isNegated) {
    var prop = isNegated ? 'a!' : 'a=';
    return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));
  } // ==--------------------------==
  // Core functionality
  // ==--------------------------==

  /*
   * Add astral mode (flag A) and Unicode token syntax: `\p{..}`, `\P{..}`, `\p{^..}`, `\pC`.
   */


  XRegExp.addToken( // Use `*` instead of `+` to avoid capturing `^` as the token name in `\p{^}`
  /\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/, function (match, scope, flags) {
    var ERR_DOUBLE_NEG = 'Invalid double negation ';
    var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';
    var ERR_UNKNOWN_REF = 'Unicode token missing data ';
    var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';
    var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes'; // Negated via \P{..} or \p{^..}

    var isNegated = match[1] === 'P' || !!match[2]; // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A

    var isAstralMode = flags.indexOf('A') !== -1; // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\p{}`

    var slug = normalize(match[4] || match[3]); // Token data object

    var item = unicode[slug];

    if (match[1] === 'P' && match[2]) {
      throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);
    }

    if (!unicode.hasOwnProperty(slug)) {
      throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);
    } // Switch to the negated form of the referenced Unicode token


    if (item.inverseOf) {
      slug = normalize(item.inverseOf);

      if (!unicode.hasOwnProperty(slug)) {
        throw new ReferenceError("".concat(ERR_UNKNOWN_REF + match[0], " -> ").concat(item.inverseOf));
      }

      item = unicode[slug];
      isNegated = !isNegated;
    }

    if (!(item.bmp || isAstralMode)) {
      throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);
    }

    if (isAstralMode) {
      if (scope === 'class') {
        throw new SyntaxError(ERR_ASTRAL_IN_CLASS);
      }

      return cacheAstral(slug, isNegated);
    }

    return scope === 'class' ? isNegated ? cacheInvertedBmp(slug) : item.bmp : "".concat((isNegated ? '[^' : '[') + item.bmp, "]");
  }, {
    scope: 'all',
    optionalFlags: 'A',
    leadChar: '\\'
  });
  /**
   * Adds to the list of Unicode tokens that XRegExp regexes can match via `\p` or `\P`.
   *
   * @memberOf XRegExp
   * @param {Array} data Objects with named character ranges. Each object may have properties
   *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are
   *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If
   *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,
   *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are
   *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and
   *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan
   *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and
   *   `astral` data should be a combination of literal characters and `\xHH` or `\uHHHH` escape
   *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be
   *   escaped, apart from range-creating hyphens. The `astral` data can additionally use
   *   character classes and alternation, and should use surrogate pairs to represent astral code
   *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is
   *   defined as the exact inverse of another token.
   * @example
   *
   * // Basic use
   * XRegExp.addUnicodeData([{
   *   name: 'XDigit',
   *   alias: 'Hexadecimal',
   *   bmp: '0-9A-Fa-f'
   * }]);
   * XRegExp('\\p{XDigit}:\\p{Hexadecimal}+').test('0:3D'); // -> true
   */

  XRegExp.addUnicodeData = function (data) {
    var ERR_NO_NAME = 'Unicode token requires name';
    var ERR_NO_DATA = 'Unicode token has no character data ';
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator2.default)(data), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;

        if (!item.name) {
          throw new Error(ERR_NO_NAME);
        }

        if (!(item.inverseOf || item.bmp || item.astral)) {
          throw new Error(ERR_NO_DATA + item.name);
        }

        unicode[normalize(item.name)] = item;

        if (item.alias) {
          unicode[normalize(item.alias)] = item;
        }
      } // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and
      // flags might now produce different results

    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    XRegExp.cache.flush('patterns');
  };
  /**
   * @ignore
   *
   * Return a reference to the internal Unicode definition structure for the given Unicode
   * Property if the given name is a legal Unicode Property for use in XRegExp `\p` or `\P` regex
   * constructs.
   *
   * @memberOf XRegExp
   * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),
   *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode
   *   Properties and Property Aliases.
   * @returns {Object} Reference to definition structure when the name matches a Unicode Property.
   *
   * @note
   * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.
   *
   * @note
   * This method is *not* part of the officially documented API and may change or be removed in
   * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode
   * structures set up by XRegExp.
   */


  XRegExp._getUnicodeProperty = function (name) {
    var slug = normalize(name);
    return unicode[slug];
  };
};

exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _blocks = _interopRequireDefault(__webpack_require__(114));

/*!
 * XRegExp Unicode Blocks 4.2.4
 * <xregexp.com>
 * Steven Levithan (c) 2010-present MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */
var _default = function _default(XRegExp) {
  /**
   * Adds support for all Unicode blocks. Block names use the prefix 'In'. E.g.,
   * `\p{InBasicLatin}`. Token names are case insensitive, and any spaces, hyphens, and
   * underscores are ignored.
   *
   * Uses Unicode 11.0.0.
   *
   * @requires XRegExp, Unicode Base
   */
  if (!XRegExp.addUnicodeData) {
    throw new ReferenceError('Unicode Base must be loaded before Unicode Blocks');
  }

  XRegExp.addUnicodeData(_blocks.default);
};

exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _categories = _interopRequireDefault(__webpack_require__(115));

/*!
 * XRegExp Unicode Categories 4.2.4
 * <xregexp.com>
 * Steven Levithan (c) 2010-present MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */
var _default = function _default(XRegExp) {
  /**
   * Adds support for Unicode's general categories. E.g., `\p{Lu}` or `\p{Uppercase Letter}`. See
   * category descriptions in UAX #44 <http://unicode.org/reports/tr44/#GC_Values_Table>. Token
   * names are case insensitive, and any spaces, hyphens, and underscores are ignored.
   *
   * Uses Unicode 11.0.0.
   *
   * @requires XRegExp, Unicode Base
   */
  if (!XRegExp.addUnicodeData) {
    throw new ReferenceError('Unicode Base must be loaded before Unicode Categories');
  }

  XRegExp.addUnicodeData(_categories.default);
};

exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _properties = _interopRequireDefault(__webpack_require__(116));

/*!
 * XRegExp Unicode Properties 4.2.4
 * <xregexp.com>
 * Steven Levithan (c) 2012-present MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */
var _default = function _default(XRegExp) {
  /**
   * Adds properties to meet the UTS #18 Level 1 RL1.2 requirements for Unicode regex support. See
   * <http://unicode.org/reports/tr18/#RL1.2>. Following are definitions of these properties from
   * UAX #44 <http://unicode.org/reports/tr44/>:
   *
   * - Alphabetic
   *   Characters with the Alphabetic property. Generated from: Lowercase + Uppercase + Lt + Lm +
   *   Lo + Nl + Other_Alphabetic.
   *
   * - Default_Ignorable_Code_Point
   *   For programmatic determination of default ignorable code points. New characters that should
   *   be ignored in rendering (unless explicitly supported) will be assigned in these ranges,
   *   permitting programs to correctly handle the default rendering of such characters when not
   *   otherwise supported.
   *
   * - Lowercase
   *   Characters with the Lowercase property. Generated from: Ll + Other_Lowercase.
   *
   * - Noncharacter_Code_Point
   *   Code points permanently reserved for internal use.
   *
   * - Uppercase
   *   Characters with the Uppercase property. Generated from: Lu + Other_Uppercase.
   *
   * - White_Space
   *   Spaces, separator characters and other control characters which should be treated by
   *   programming languages as "white space" for the purpose of parsing elements.
   *
   * The properties ASCII, Any, and Assigned are also included but are not defined in UAX #44. UTS
   * #18 RL1.2 additionally requires support for Unicode scripts and general categories. These are
   * included in XRegExp's Unicode Categories and Unicode Scripts addons.
   *
   * Token names are case insensitive, and any spaces, hyphens, and underscores are ignored.
   *
   * Uses Unicode 11.0.0.
   *
   * @requires XRegExp, Unicode Base
   */
  if (!XRegExp.addUnicodeData) {
    throw new ReferenceError('Unicode Base must be loaded before Unicode Properties');
  }

  var unicodeData = _properties.default; // Add non-generated data

  unicodeData.push({
    name: 'Assigned',
    // Since this is defined as the inverse of Unicode category Cn (Unassigned), the Unicode
    // Categories addon is required to use this property
    inverseOf: 'Cn'
  });
  XRegExp.addUnicodeData(unicodeData);
};

exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _scripts = _interopRequireDefault(__webpack_require__(117));

/*!
 * XRegExp Unicode Scripts 4.2.4
 * <xregexp.com>
 * Steven Levithan (c) 2010-present MIT License
 * Unicode data by Mathias Bynens <mathiasbynens.be>
 */
var _default = function _default(XRegExp) {
  /**
   * Adds support for all Unicode scripts. E.g., `\p{Latin}`. Token names are case insensitive,
   * and any spaces, hyphens, and underscores are ignored.
   *
   * Uses Unicode 11.0.0.
   *
   * @requires XRegExp, Unicode Base
   */
  if (!XRegExp.addUnicodeData) {
    throw new ReferenceError('Unicode Base must be loaded before Unicode Scripts');
  }

  XRegExp.addUnicodeData(_scripts.default);
};

exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _xregexp = _interopRequireDefault(__webpack_require__(113));

var _build = _interopRequireDefault(__webpack_require__(105));

var _matchrecursive = _interopRequireDefault(__webpack_require__(106));

var _unicodeBase = _interopRequireDefault(__webpack_require__(107));

var _unicodeBlocks = _interopRequireDefault(__webpack_require__(108));

var _unicodeCategories = _interopRequireDefault(__webpack_require__(109));

var _unicodeProperties = _interopRequireDefault(__webpack_require__(110));

var _unicodeScripts = _interopRequireDefault(__webpack_require__(111));

(0, _build.default)(_xregexp.default);
(0, _matchrecursive.default)(_xregexp.default);
(0, _unicodeBase.default)(_xregexp.default);
(0, _unicodeBlocks.default)(_xregexp.default);
(0, _unicodeCategories.default)(_xregexp.default);
(0, _unicodeProperties.default)(_xregexp.default);
(0, _unicodeScripts.default)(_xregexp.default);
var _default = _xregexp.default;
exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _create = _interopRequireDefault(__webpack_require__(49));

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(54));

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _parseInt2 = _interopRequireDefault(__webpack_require__(50));

/*!
 * XRegExp 4.2.4
 * <xregexp.com>
 * Steven Levithan (c) 2007-present MIT License
 */

/**
 * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and
 * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to
 * make your client-side grepping simpler and more powerful, while freeing you from related
 * cross-browser inconsistencies.
 */
// ==--------------------------==
// Private stuff
// ==--------------------------==
// Property name used for extended regex instance data
var REGEX_DATA = 'xregexp'; // Optional features that can be installed and uninstalled

var features = {
  astral: false,
  namespacing: false
}; // Native methods to use and restore ('native' is an ES3 reserved keyword)

var nativ = {
  exec: RegExp.prototype.exec,
  test: RegExp.prototype.test,
  match: String.prototype.match,
  replace: String.prototype.replace,
  split: String.prototype.split
}; // Storage for fixed/extended native methods

var fixed = {}; // Storage for regexes cached by `XRegExp.cache`

var regexCache = {}; // Storage for pattern details cached by the `XRegExp` constructor

var patternCache = {}; // Storage for regex syntax tokens added internally or by `XRegExp.addToken`

var tokens = []; // Token scopes

var defaultScope = 'default';
var classScope = 'class'; // Regexes that match native regex syntax, including octals

var nativeTokens = {
  // Any native multicharacter token in default scope, or any single character
  'default': /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?(?:[:=!]|<[=!])|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,
  // Any native multicharacter token in character class scope, or any single character
  'class': /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/
}; // Any backreference or dollar-prefixed character in replacement strings

var replacementToken = /\$(?:{([\w$]+)}|<([\w$]+)>|(\d\d?|[\s\S]))/g; // Check for correct `exec` handling of nonparticipating capturing groups

var correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined; // Check for ES6 `flags` prop support

var hasFlagsProp = /x/.flags !== undefined; // Shortcut to `Object.prototype.toString`

var _ref = {},
    toString = _ref.toString;

function hasNativeFlag(flag) {
  // Can't check based on the presence of properties/getters since browsers might support such
  // properties even when they don't support the corresponding flag in regex construction (tested
  // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`
  // throws an error)
  var isSupported = true;

  try {
    // Can't use regex literals for testing even in a `try` because regex literals with
    // unsupported flags cause a compilation error in IE
    new RegExp('', flag);
  } catch (exception) {
    isSupported = false;
  }

  return isSupported;
} // Check for ES6 `u` flag support


var hasNativeU = hasNativeFlag('u'); // Check for ES6 `y` flag support

var hasNativeY = hasNativeFlag('y'); // Tracker for known flags, including addon flags

var registeredFlags = {
  g: true,
  i: true,
  m: true,
  u: hasNativeU,
  y: hasNativeY
};
/**
 * Attaches extended data and `XRegExp.prototype` properties to a regex object.
 *
 * @private
 * @param {RegExp} regex Regex to augment.
 * @param {Array} captureNames Array with capture names, or `null`.
 * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.
 * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.
 * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal
 *   operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *   skipping some operations like attaching `XRegExp.prototype` properties.
 * @returns {RegExp} Augmented regex.
 */

function augment(regex, captureNames, xSource, xFlags, isInternalOnly) {
  regex[REGEX_DATA] = {
    captureNames: captureNames
  };

  if (isInternalOnly) {
    return regex;
  } // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value


  if (regex.__proto__) {
    regex.__proto__ = XRegExp.prototype;
  } else {
    for (var p in XRegExp.prototype) {
      // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this
      // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`
      // extensions exist on `regex.prototype` anyway
      regex[p] = XRegExp.prototype[p];
    }
  }

  regex[REGEX_DATA].source = xSource; // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order

  regex[REGEX_DATA].flags = xFlags ? xFlags.split('').sort().join('') : xFlags;
  return regex;
}
/**
 * Removes any duplicate characters from the provided string.
 *
 * @private
 * @param {String} str String to remove duplicate characters from.
 * @returns {String} String with any duplicate characters removed.
 */


function clipDuplicates(str) {
  return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, '');
}
/**
 * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`
 * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing
 * flags g and y while copying the regex.
 *
 * @private
 * @param {RegExp} regex Regex to copy.
 * @param {Object} [options] Options object with optional properties:
 *   - `addG` {Boolean} Add flag g while copying the regex.
 *   - `addY` {Boolean} Add flag y while copying the regex.
 *   - `removeG` {Boolean} Remove flag g while copying the regex.
 *   - `removeY` {Boolean} Remove flag y while copying the regex.
 *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal
 *     operations, and never exposed to users. For internal-only regexes, we can improve perf by
 *     skipping some operations like attaching `XRegExp.prototype` properties.
 *   - `source` {String} Overrides `<regex>.source`, for special cases.
 * @returns {RegExp} Copy of the provided regex, possibly with modified flags.
 */


function copyRegex(regex, options) {
  if (!XRegExp.isRegExp(regex)) {
    throw new TypeError('Type RegExp expected');
  }

  var xData = regex[REGEX_DATA] || {};
  var flags = getNativeFlags(regex);
  var flagsToAdd = '';
  var flagsToRemove = '';
  var xregexpSource = null;
  var xregexpFlags = null;
  options = options || {};

  if (options.removeG) {
    flagsToRemove += 'g';
  }

  if (options.removeY) {
    flagsToRemove += 'y';
  }

  if (flagsToRemove) {
    flags = nativ.replace.call(flags, new RegExp("[".concat(flagsToRemove, "]+"), 'g'), '');
  }

  if (options.addG) {
    flagsToAdd += 'g';
  }

  if (options.addY) {
    flagsToAdd += 'y';
  }

  if (flagsToAdd) {
    flags = clipDuplicates(flags + flagsToAdd);
  }

  if (!options.isInternalOnly) {
    if (xData.source !== undefined) {
      xregexpSource = xData.source;
    } // null or undefined; don't want to add to `flags` if the previous value was null, since
    // that indicates we're not tracking original precompilation flags


    if (xData.flags != null) {
      // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never
      // removed for non-internal regexes, so don't need to handle it
      xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;
    }
  } // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid
  // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and
  // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the
  // translation to native regex syntax


  regex = augment(new RegExp(options.source || regex.source, flags), hasNamedCapture(regex) ? xData.captureNames.slice(0) : null, xregexpSource, xregexpFlags, options.isInternalOnly);
  return regex;
}
/**
 * Converts hexadecimal to decimal.
 *
 * @private
 * @param {String} hex
 * @returns {Number}
 */


function dec(hex) {
  return (0, _parseInt2.default)(hex, 16);
}
/**
 * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an
 * inline comment or whitespace with flag x. This is used directly as a token handler function
 * passed to `XRegExp.addToken`.
 *
 * @private
 * @param {String} match Match arg of `XRegExp.addToken` handler
 * @param {String} scope Scope arg of `XRegExp.addToken` handler
 * @param {String} flags Flags arg of `XRegExp.addToken` handler
 * @returns {String} Either '' or '(?:)', depending on which is needed in the context of the match.
 */


function getContextualTokenSeparator(match, scope, flags) {
  if ( // No need to separate tokens if at the beginning or end of a group
  match.input[match.index - 1] === '(' || match.input[match.index + match[0].length] === ')' || // No need to separate tokens if before or after a `|`
  match.input[match.index - 1] === '|' || match.input[match.index + match[0].length] === '|' || // No need to separate tokens if at the beginning or end of the pattern
  match.index < 1 || match.index + match[0].length >= match.input.length || // No need to separate tokens if at the beginning of a noncapturing group or lookahead.
  // The way this is written relies on:
  // - The search regex matching only 3-char strings.
  // - Although `substr` gives chars from the end of the string if given a negative index,
  //   the resulting substring will be too short to match. Ex: `'abcd'.substr(-1, 3) === 'd'`
  nativ.test.call(/^\(\?[:=!]/, match.input.substr(match.index - 3, 3)) || // Avoid separating tokens when the following token is a quantifier
  isQuantifierNext(match.input, match.index + match[0].length, flags)) {
    return '';
  } // Keep tokens separated. This avoids e.g. inadvertedly changing `\1 1` or `\1(?#)1` to `\11`.
  // This also ensures all tokens remain as discrete atoms, e.g. it avoids converting the syntax
  // error `(? :` into `(?:`.


  return '(?:)';
}
/**
 * Returns native `RegExp` flags used by a regex object.
 *
 * @private
 * @param {RegExp} regex Regex to check.
 * @returns {String} Native flags in use.
 */


function getNativeFlags(regex) {
  return hasFlagsProp ? regex.flags : // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation
  // with an empty string) allows this to continue working predictably when
  // `XRegExp.proptotype.toString` is overridden
  nativ.exec.call(/\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];
}
/**
 * Determines whether a regex has extended instance data used to track capture names.
 *
 * @private
 * @param {RegExp} regex Regex to check.
 * @returns {Boolean} Whether the regex uses named capture.
 */


function hasNamedCapture(regex) {
  return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);
}
/**
 * Converts decimal to hexadecimal.
 *
 * @private
 * @param {Number|String} dec
 * @returns {String}
 */


function hex(dec) {
  return (0, _parseInt2.default)(dec, 10).toString(16);
}
/**
 * Checks whether the next nonignorable token after the specified position is a quantifier.
 *
 * @private
 * @param {String} pattern Pattern to search within.
 * @param {Number} pos Index in `pattern` to search at.
 * @param {String} flags Flags used by the pattern.
 * @returns {Boolean} Whether the next nonignorable token is a quantifier.
 */


function isQuantifierNext(pattern, pos, flags) {
  var inlineCommentPattern = '\\(\\?#[^)]*\\)';
  var lineCommentPattern = '#[^#\\n]*';
  var quantifierPattern = '[?*+]|{\\d+(?:,\\d*)?}';
  return nativ.test.call(flags.indexOf('x') !== -1 ? // Ignore any leading whitespace, line comments, and inline comments
  /^(?:\s|#[^#\n]*|\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/ : // Ignore any leading inline comments
  /^(?:\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/, pattern.slice(pos));
}
/**
 * Determines whether a value is of the specified type, by resolving its internal [[Class]].
 *
 * @private
 * @param {*} value Object to check.
 * @param {String} type Type to check for, in TitleCase.
 * @returns {Boolean} Whether the object matches the type.
 */


function isType(value, type) {
  return toString.call(value) === "[object ".concat(type, "]");
}
/**
 * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.
 *
 * @private
 * @param {String} str
 * @returns {String}
 */


function pad4(str) {
  while (str.length < 4) {
    str = "0".concat(str);
  }

  return str;
}
/**
 * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads
 * the flag preparation logic from the `XRegExp` constructor.
 *
 * @private
 * @param {String} pattern Regex pattern, possibly with a leading mode modifier.
 * @param {String} flags Any combination of flags.
 * @returns {Object} Object with properties `pattern` and `flags`.
 */


function prepareFlags(pattern, flags) {
  // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags
  if (clipDuplicates(flags) !== flags) {
    throw new SyntaxError("Invalid duplicate regex flag ".concat(flags));
  } // Strip and apply a leading mode modifier with any combination of flags except g or y


  pattern = nativ.replace.call(pattern, /^\(\?([\w$]+)\)/, function ($0, $1) {
    if (nativ.test.call(/[gy]/, $1)) {
      throw new SyntaxError("Cannot use flag g or y in mode modifier ".concat($0));
    } // Allow duplicate flags within the mode modifier


    flags = clipDuplicates(flags + $1);
    return '';
  }); // Throw on unknown native or nonnative flags

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator2.default)(flags), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var flag = _step.value;

      if (!registeredFlags[flag]) {
        throw new SyntaxError("Unknown regex flag ".concat(flag));
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return {
    pattern: pattern,
    flags: flags
  };
}
/**
 * Prepares an options object from the given value.
 *
 * @private
 * @param {String|Object} value Value to convert to an options object.
 * @returns {Object} Options object.
 */


function prepareOptions(value) {
  var options = {};

  if (isType(value, 'String')) {
    XRegExp.forEach(value, /[^\s,]+/, function (match) {
      options[match] = true;
    });
    return options;
  }

  return value;
}
/**
 * Registers a flag so it doesn't throw an 'unknown flag' error.
 *
 * @private
 * @param {String} flag Single-character flag to register.
 */


function registerFlag(flag) {
  if (!/^[\w$]$/.test(flag)) {
    throw new Error('Flag must be a single character A-Za-z0-9_$');
  }

  registeredFlags[flag] = true;
}
/**
 * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified
 * position, until a match is found.
 *
 * @private
 * @param {String} pattern Original pattern from which an XRegExp object is being built.
 * @param {String} flags Flags being used to construct the regex.
 * @param {Number} pos Position to search for tokens within `pattern`.
 * @param {Number} scope Regex scope to apply: 'default' or 'class'.
 * @param {Object} context Context object to use for token handler functions.
 * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.
 */


function runTokens(pattern, flags, pos, scope, context) {
  var i = tokens.length;
  var leadChar = pattern[pos];
  var result = null;
  var match;
  var t; // Run in reverse insertion order

  while (i--) {
    t = tokens[i];

    if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== 'all' || t.flag && !(flags.indexOf(t.flag) !== -1)) {
      continue;
    }

    match = XRegExp.exec(pattern, t.regex, pos, 'sticky');

    if (match) {
      result = {
        matchLength: match[0].length,
        output: t.handler.call(context, match, scope, flags),
        reparse: t.reparse
      }; // Finished with token tests

      break;
    }
  }

  return result;
}
/**
 * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to
 * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if
 * the Unicode Base addon is not available, since flag A is registered by that addon.
 *
 * @private
 * @param {Boolean} on `true` to enable; `false` to disable.
 */


function setAstral(on) {
  features.astral = on;
}
/**
 * Adds named capture groups to the `groups` property of match arrays. See here for details:
 * https://github.com/tc39/proposal-regexp-named-groups
 *
 * @private
 * @param {Boolean} on `true` to enable; `false` to disable.
 */


function setNamespacing(on) {
  features.namespacing = on;
}
/**
 * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow
 * the ES5 abstract operation `ToObject`.
 *
 * @private
 * @param {*} value Object to check and return.
 * @returns {*} The provided object.
 */


function toObject(value) {
  // null or undefined
  if (value == null) {
    throw new TypeError('Cannot convert null or undefined to object');
  }

  return value;
} // ==--------------------------==
// Constructor
// ==--------------------------==

/**
 * Creates an extended regular expression object for matching text with a pattern. Differs from a
 * native regular expression in that additional syntax and flags are supported. The returned object
 * is in fact a native `RegExp` and works with all native methods.
 *
 * @class XRegExp
 * @constructor
 * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.
 * @param {String} [flags] Any combination of flags.
 *   Native flags:
 *     - `g` - global
 *     - `i` - ignore case
 *     - `m` - multiline anchors
 *     - `u` - unicode (ES6)
 *     - `y` - sticky (Firefox 3+, ES6)
 *   Additional XRegExp flags:
 *     - `n` - explicit capture
 *     - `s` - dot matches all (aka singleline)
 *     - `x` - free-spacing and line comments (aka extended)
 *     - `A` - astral (requires the Unicode Base addon)
 *   Flags cannot be provided when constructing one `RegExp` from another.
 * @returns {RegExp} Extended regular expression object.
 * @example
 *
 * // With named capture and flag x
 * XRegExp(`(?<year>  [0-9]{4} ) -?  # year
 *          (?<month> [0-9]{2} ) -?  # month
 *          (?<day>   [0-9]{2} )     # day`, 'x');
 *
 * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)
 * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and
 * // have fresh `lastIndex` properties (set to zero).
 * XRegExp(/regex/);
 */


function XRegExp(pattern, flags) {
  if (XRegExp.isRegExp(pattern)) {
    if (flags !== undefined) {
      throw new TypeError('Cannot supply flags when copying a RegExp');
    }

    return copyRegex(pattern);
  } // Copy the argument behavior of `RegExp`


  pattern = pattern === undefined ? '' : String(pattern);
  flags = flags === undefined ? '' : String(flags);

  if (XRegExp.isInstalled('astral') && !(flags.indexOf('A') !== -1)) {
    // This causes an error to be thrown if the Unicode Base addon is not available
    flags += 'A';
  }

  if (!patternCache[pattern]) {
    patternCache[pattern] = {};
  }

  if (!patternCache[pattern][flags]) {
    var context = {
      hasNamedCapture: false,
      captureNames: []
    };
    var scope = defaultScope;
    var output = '';
    var pos = 0;
    var result; // Check for flag-related errors, and strip/apply flags in a leading mode modifier

    var applied = prepareFlags(pattern, flags);
    var appliedPattern = applied.pattern;
    var appliedFlags = applied.flags; // Use XRegExp's tokens to translate the pattern to a native regex pattern.
    // `appliedPattern.length` may change on each iteration if tokens use `reparse`

    while (pos < appliedPattern.length) {
      do {
        // Check for custom tokens at the current position
        result = runTokens(appliedPattern, appliedFlags, pos, scope, context); // If the matched token used the `reparse` option, splice its output into the
        // pattern before running tokens again at the same position

        if (result && result.reparse) {
          appliedPattern = appliedPattern.slice(0, pos) + result.output + appliedPattern.slice(pos + result.matchLength);
        }
      } while (result && result.reparse);

      if (result) {
        output += result.output;
        pos += result.matchLength || 1;
      } else {
        // Get the native token at the current position
        var _XRegExp$exec = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky'),
            _XRegExp$exec2 = (0, _slicedToArray2.default)(_XRegExp$exec, 1),
            token = _XRegExp$exec2[0];

        output += token;
        pos += token.length;

        if (token === '[' && scope === defaultScope) {
          scope = classScope;
        } else if (token === ']' && scope === classScope) {
          scope = defaultScope;
        }
      }
    }

    patternCache[pattern][flags] = {
      // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty
      // groups are sometimes inserted during regex transpilation in order to keep tokens
      // separated. However, more than one empty group in a row is never needed.
      pattern: nativ.replace.call(output, /(?:\(\?:\))+/g, '(?:)'),
      // Strip all but native flags
      flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),
      // `context.captureNames` has an item for each capturing group, even if unnamed
      captures: context.hasNamedCapture ? context.captureNames : null
    };
  }

  var generated = patternCache[pattern][flags];
  return augment(new RegExp(generated.pattern, generated.flags), generated.captures, pattern, flags);
} // Add `RegExp.prototype` to the prototype chain


XRegExp.prototype = /(?:)/; // ==--------------------------==
// Public properties
// ==--------------------------==

/**
 * The XRegExp version number as a string containing three dot-separated parts. For example,
 * '2.0.0-beta-3'.
 *
 * @static
 * @memberOf XRegExp
 * @type String
 */

XRegExp.version = '4.2.4'; // ==--------------------------==
// Public methods
// ==--------------------------==
// Intentionally undocumented; used in tests and addons

XRegExp._clipDuplicates = clipDuplicates;
XRegExp._hasNativeFlag = hasNativeFlag;
XRegExp._dec = dec;
XRegExp._hex = hex;
XRegExp._pad4 = pad4;
/**
 * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to
 * create XRegExp addons. If more than one token can match the same string, the last added wins.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex object that matches the new token.
 * @param {Function} handler Function that returns a new pattern string (using native regex syntax)
 *   to replace the matched token within all future XRegExp regexes. Has access to persistent
 *   properties of the regex being built, through `this`. Invoked with three arguments:
 *   - The match array, with named backreference properties.
 *   - The regex scope where the match was found: 'default' or 'class'.
 *   - The flags used by the regex, including any flags in a leading mode modifier.
 *   The handler function becomes part of the XRegExp construction process, so be careful not to
 *   construct XRegExps within the function or you will trigger infinite recursion.
 * @param {Object} [options] Options object with optional properties:
 *   - `scope` {String} Scope where the token applies: 'default', 'class', or 'all'.
 *   - `flag` {String} Single-character flag that triggers the token. This also registers the
 *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.
 *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are
 *     not required to trigger the token. This registers the flags, to prevent XRegExp from
 *     throwing an 'unknown flag' error when any of the flags are used.
 *   - `reparse` {Boolean} Whether the `handler` function's output should not be treated as
 *     final, and instead be reparseable by other tokens (including the current token). Allows
 *     token chaining or deferring.
 *   - `leadChar` {String} Single character that occurs at the beginning of any successful match
 *     of the token (not always applicable). This doesn't change the behavior of the token unless
 *     you provide an erroneous value. However, providing it can increase the token's performance
 *     since the token can be skipped at any positions where this character doesn't appear.
 * @example
 *
 * // Basic usage: Add \a for the ALERT control code
 * XRegExp.addToken(
 *   /\\a/,
 *   () => '\\x07',
 *   {scope: 'all'}
 * );
 * XRegExp('\\a[\\a-\\n]+').test('\x07\n\x07'); // -> true
 *
 * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.
 * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of
 * // character classes only)
 * XRegExp.addToken(
 *   /([?*+]|{\d+(?:,\d*)?})(\??)/,
 *   (match) => `${match[1]}${match[2] ? '' : '?'}`,
 *   {flag: 'U'}
 * );
 * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'
 * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'
 */

XRegExp.addToken = function (regex, handler, options) {
  options = options || {};
  var _options = options,
      optionalFlags = _options.optionalFlags;

  if (options.flag) {
    registerFlag(options.flag);
  }

  if (optionalFlags) {
    optionalFlags = nativ.split.call(optionalFlags, '');
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = (0, _getIterator2.default)(optionalFlags), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var flag = _step2.value;
        registerFlag(flag);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  } // Add to the private list of syntax tokens


  tokens.push({
    regex: copyRegex(regex, {
      addG: true,
      addY: hasNativeY,
      isInternalOnly: true
    }),
    handler: handler,
    scope: options.scope || defaultScope,
    flag: options.flag,
    reparse: options.reparse,
    leadChar: options.leadChar
  }); // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags
  // might now produce different results

  XRegExp.cache.flush('patterns');
};
/**
 * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with
 * the same pattern and flag combination, the cached copy of the regex is returned.
 *
 * @memberOf XRegExp
 * @param {String} pattern Regex pattern string.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @returns {RegExp} Cached XRegExp object.
 * @example
 *
 * while (match = XRegExp.cache('.', 'gs').exec(str)) {
 *   // The regex is compiled once only
 * }
 */


XRegExp.cache = function (pattern, flags) {
  if (!regexCache[pattern]) {
    regexCache[pattern] = {};
  }

  return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags));
}; // Intentionally undocumented; used in tests


XRegExp.cache.flush = function (cacheName) {
  if (cacheName === 'patterns') {
    // Flush the pattern cache used by the `XRegExp` constructor
    patternCache = {};
  } else {
    // Flush the regex cache populated by `XRegExp.cache`
    regexCache = {};
  }
};
/**
 * Escapes any regular expression metacharacters, for use when matching literal strings. The result
 * can safely be used at any point within a regex that uses any flags.
 *
 * @memberOf XRegExp
 * @param {String} str String to escape.
 * @returns {String} String with regex metacharacters escaped.
 * @example
 *
 * XRegExp.escape('Escaped? <.>');
 * // -> 'Escaped\?\ <\.>'
 */


XRegExp.escape = function (str) {
  return nativ.replace.call(toObject(str), /[-\[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};
/**
 * Executes a regex search in a specified string. Returns a match array or `null`. If the provided
 * regex uses named capture, named backreference properties are included on the match array.
 * Optional `pos` and `sticky` arguments specify the search start position, and whether the match
 * must start at the specified position only. The `lastIndex` property of the provided regex is not
 * used, but is updated for compatibility. Also fixes browser bugs compared to the native
 * `RegExp.prototype.exec` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `'sticky'` is accepted as an alternative to `true`.
 * @returns {Array} Match array with named backreference properties, or `null`.
 * @example
 *
 * // Basic use, with named backreference
 * let match = XRegExp.exec('U+2620', XRegExp('U\\+(?<hex>[0-9A-F]{4})'));
 * match.hex; // -> '2620'
 *
 * // With pos and sticky, in a loop
 * let pos = 2, result = [], match;
 * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\d)>/, pos, 'sticky')) {
 *   result.push(match[1]);
 *   pos = match.index + match[0].length;
 * }
 * // result -> ['2', '3', '4']
 */


XRegExp.exec = function (str, regex, pos, sticky) {
  var cacheKey = 'g';
  var addY = false;
  var fakeY = false;
  var match;
  addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false);

  if (addY) {
    cacheKey += 'y';
  } else if (sticky) {
    // Simulate sticky matching by appending an empty capture to the original regex. The
    // resulting regex will succeed no matter what at the current index (set with `lastIndex`),
    // and will not search the rest of the subject string. We'll know that the original regex
    // has failed if that last capture is `''` rather than `undefined` (i.e., if that last
    // capture participated in the match).
    fakeY = true;
    cacheKey += 'FakeY';
  }

  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.match`/`replace`

  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
    addG: true,
    addY: addY,
    source: fakeY ? "".concat(regex.source, "|()") : undefined,
    removeY: sticky === false,
    isInternalOnly: true
  }));
  pos = pos || 0;
  r2.lastIndex = pos; // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.

  match = fixed.exec.call(r2, str); // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means
  // the original regexp failed (see above).

  if (fakeY && match && match.pop() === '') {
    match = null;
  }

  if (regex.global) {
    regex.lastIndex = match ? r2.lastIndex : 0;
  }

  return match;
};
/**
 * Executes a provided function once per regex match. Searches always start at the beginning of the
 * string and continue until the end, regardless of the state of the regex's `global` property and
 * initial `lastIndex`.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Function} callback Function to execute for each match. Invoked with four arguments:
 *   - The match array, with named backreference properties.
 *   - The zero-based match index.
 *   - The string being traversed.
 *   - The regex object being used to traverse the string.
 * @example
 *
 * // Extracts every other digit from a string
 * const evens = [];
 * XRegExp.forEach('1a2345', /\d/, (match, i) => {
 *   if (i % 2) evens.push(+match[0]);
 * });
 * // evens -> [2, 4]
 */


XRegExp.forEach = function (str, regex, callback) {
  var pos = 0;
  var i = -1;
  var match;

  while (match = XRegExp.exec(str, regex, pos)) {
    // Because `regex` is provided to `callback`, the function could use the deprecated/
    // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`
    // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,
    // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of
    // regexes, mutating the regex will not have any effect on the iteration or matched strings,
    // which is a nice side effect that brings extra safety.
    callback(match, ++i, str, regex);
    pos = match.index + (match[0].length || 1);
  }
};
/**
 * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with
 * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native
 * regexes are not recompiled using XRegExp syntax.
 *
 * @memberOf XRegExp
 * @param {RegExp} regex Regex to globalize.
 * @returns {RegExp} Copy of the provided regex with flag `g` added.
 * @example
 *
 * const globalCopy = XRegExp.globalize(/regex/);
 * globalCopy.global; // -> true
 */


XRegExp.globalize = function (regex) {
  return copyRegex(regex, {
    addG: true
  });
};
/**
 * Installs optional features according to the specified options. Can be undone using
 * `XRegExp.uninstall`.
 *
 * @memberOf XRegExp
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.install({
 *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)
 *   astral: true,
 *
 *   // Adds named capture groups to the `groups` property of matches
 *   namespacing: true
 * });
 *
 * // With an options string
 * XRegExp.install('astral namespacing');
 */


XRegExp.install = function (options) {
  options = prepareOptions(options);

  if (!features.astral && options.astral) {
    setAstral(true);
  }

  if (!features.namespacing && options.namespacing) {
    setNamespacing(true);
  }
};
/**
 * Checks whether an individual optional feature is installed.
 *
 * @memberOf XRegExp
 * @param {String} feature Name of the feature to check. One of:
 *   - `astral`
 *   - `namespacing`
 * @returns {Boolean} Whether the feature is installed.
 * @example
 *
 * XRegExp.isInstalled('astral');
 */


XRegExp.isInstalled = function (feature) {
  return !!features[feature];
};
/**
 * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes
 * created in another frame, when `instanceof` and `constructor` checks would fail.
 *
 * @memberOf XRegExp
 * @param {*} value Object to check.
 * @returns {Boolean} Whether the object is a `RegExp` object.
 * @example
 *
 * XRegExp.isRegExp('string'); // -> false
 * XRegExp.isRegExp(/regex/i); // -> true
 * XRegExp.isRegExp(RegExp('^', 'm')); // -> true
 * XRegExp.isRegExp(XRegExp('(?s).')); // -> true
 */


XRegExp.isRegExp = function (value) {
  return toString.call(value) === '[object RegExp]';
}; // isType(value, 'RegExp');

/**
 * Returns the first matched string, or in global mode, an array containing all matched strings.
 * This is essentially a more convenient re-implementation of `String.prototype.match` that gives
 * the result types you actually want (string instead of `exec`-style array in match-first mode,
 * and an empty array instead of `null` when no matches are found in match-all mode). It also lets
 * you override flag g and ignore `lastIndex`, and fixes browser bugs.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to
 *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,
 *   `scope` is 'all'.
 * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all
 *   mode: Array of all matched strings, or an empty array.
 * @example
 *
 * // Match first
 * XRegExp.match('abc', /\w/); // -> 'a'
 * XRegExp.match('abc', /\w/g, 'one'); // -> 'a'
 * XRegExp.match('abc', /x/g, 'one'); // -> null
 *
 * // Match all
 * XRegExp.match('abc', /\w/g); // -> ['a', 'b', 'c']
 * XRegExp.match('abc', /\w/, 'all'); // -> ['a', 'b', 'c']
 * XRegExp.match('abc', /x/, 'all'); // -> []
 */


XRegExp.match = function (str, regex, scope) {
  var global = regex.global && scope !== 'one' || scope === 'all';
  var cacheKey = (global ? 'g' : '') + (regex.sticky ? 'y' : '') || 'noGY';
  regex[REGEX_DATA] = regex[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`replace`

  var r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, {
    addG: !!global,
    removeG: scope === 'one',
    isInternalOnly: true
  }));
  var result = nativ.match.call(toObject(str), r2);

  if (regex.global) {
    regex.lastIndex = scope === 'one' && result ? // Can't use `r2.lastIndex` since `r2` is nonglobal in this case
    result.index + result[0].length : 0;
  }

  return global ? result || [] : result && result[0];
};
/**
 * Retrieves the matches from searching a string using a chain of regexes that successively search
 * within previous matches. The provided `chain` array can contain regexes and or objects with
 * `regex` and `backref` properties. When a backreference is specified, the named or numbered
 * backreference is passed forward to the next regex or returned.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {Array} chain Regexes that each search for matches within preceding results.
 * @returns {Array} Matches by the last regex in the chain, or an empty array.
 * @example
 *
 * // Basic usage; matches numbers within <b> tags
 * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [
 *   XRegExp('(?is)<b>.*?</b>'),
 *   /\d+/
 * ]);
 * // -> ['2', '4', '56']
 *
 * // Passing forward and returning specific backreferences
 * html = '<a href="http://xregexp.com/api/">XRegExp</a>\
 *         <a href="http://www.google.com/">Google</a>';
 * XRegExp.matchChain(html, [
 *   {regex: /<a href="([^"]+)">/i, backref: 1},
 *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}
 * ]);
 * // -> ['xregexp.com', 'www.google.com']
 */


XRegExp.matchChain = function (str, chain) {
  return function recurseChain(values, level) {
    var item = chain[level].regex ? chain[level] : {
      regex: chain[level]
    };
    var matches = [];

    function addMatch(match) {
      if (item.backref) {
        var ERR_UNDEFINED_GROUP = "Backreference to undefined group: ".concat(item.backref);
        var isNamedBackref = isNaN(item.backref);

        if (isNamedBackref && XRegExp.isInstalled('namespacing')) {
          // `groups` has `null` as prototype, so using `in` instead of `hasOwnProperty`
          if (!(item.backref in match.groups)) {
            throw new ReferenceError(ERR_UNDEFINED_GROUP);
          }
        } else if (!match.hasOwnProperty(item.backref)) {
          throw new ReferenceError(ERR_UNDEFINED_GROUP);
        }

        var backrefValue = isNamedBackref && XRegExp.isInstalled('namespacing') ? match.groups[item.backref] : match[item.backref];
        matches.push(backrefValue || '');
      } else {
        matches.push(match[0]);
      }
    }

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = (0, _getIterator2.default)(values), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var value = _step3.value;
        XRegExp.forEach(value, item.regex, addMatch);
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return level === chain.length - 1 || !matches.length ? matches : recurseChain(matches, level + 1);
  }([str], 0);
};
/**
 * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string
 * or regex, and the replacement can be a string or a function to be called for each match. To
 * perform a global search and replace, use the optional `scope` argument or include flag g if using
 * a regex. Replacement strings can use `${n}` or `$<n>` for named and numbered backreferences.
 * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser
 * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 *   Replacement strings can include special replacement syntax:
 *     - $$ - Inserts a literal $ character.
 *     - $&, $0 - Inserts the matched substring.
 *     - $` - Inserts the string that precedes the matched substring (left context).
 *     - $' - Inserts the string that follows the matched substring (right context).
 *     - $n, $nn - Where n/nn are digits referencing an existent capturing group, inserts
 *       backreference n/nn.
 *     - ${n}, $<n> - Where n is a name or any number of digits that reference an existent capturing
 *       group, inserts backreference n.
 *   Replacement functions are invoked with three or more arguments:
 *     - The matched substring (corresponds to $& above). Named backreferences are accessible as
 *       properties of this first argument.
 *     - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).
 *     - The zero-based index of the match within the total search string.
 *     - The total string being searched.
 * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not
 *   explicitly specified and using a regex with flag g, `scope` is 'all'.
 * @returns {String} New string with one or all matches replaced.
 * @example
 *
 * // Regex search, using named backreferences in replacement string
 * const name = XRegExp('(?<first>\\w+) (?<last>\\w+)');
 * XRegExp.replace('John Smith', name, '$<last>, $<first>');
 * // -> 'Smith, John'
 *
 * // Regex search, using named backreferences in replacement function
 * XRegExp.replace('John Smith', name, (match) => `${match.last}, ${match.first}`);
 * // -> 'Smith, John'
 *
 * // String search, with replace-all
 * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');
 * // -> 'XRegExp builds XRegExps'
 */


XRegExp.replace = function (str, search, replacement, scope) {
  var isRegex = XRegExp.isRegExp(search);
  var global = search.global && scope !== 'one' || scope === 'all';
  var cacheKey = (global ? 'g' : '') + (search.sticky ? 'y' : '') || 'noGY';
  var s2 = search;

  if (isRegex) {
    search[REGEX_DATA] = search[REGEX_DATA] || {}; // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s
    // `lastIndex` isn't updated *during* replacement iterations

    s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, {
      addG: !!global,
      removeG: scope === 'one',
      isInternalOnly: true
    }));
  } else if (global) {
    s2 = new RegExp(XRegExp.escape(String(search)), 'g');
  } // Fixed `replace` required for named backreferences, etc.


  var result = fixed.replace.call(toObject(str), s2, replacement);

  if (isRegex && search.global) {
    // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
    search.lastIndex = 0;
  }

  return result;
};
/**
 * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an
 * array of replacement details. Later replacements operate on the output of earlier replacements.
 * Replacement details are accepted as an array with a regex or string to search for, the
 * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp
 * replacement text syntax, which supports named backreference properties via `${name}` or
 * `$<name>`.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {Array} replacements Array of replacement detail arrays.
 * @returns {String} New string with all replacements.
 * @example
 *
 * str = XRegExp.replaceEach(str, [
 *   [XRegExp('(?<name>a)'), 'z${name}'],
 *   [/b/gi, 'y'],
 *   [/c/g, 'x', 'one'], // scope 'one' overrides /g
 *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g
 *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings
 *   [/f/g, ($0) => $0.toUpperCase()]
 * ]);
 */


XRegExp.replaceEach = function (str, replacements) {
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = (0, _getIterator2.default)(replacements), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var r = _step4.value;
      str = XRegExp.replace(str, r[0], r[1], r[2]);
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
        _iterator4.return();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return str;
};
/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * XRegExp.split('a b c', ' ');
 * // -> ['a', 'b', 'c']
 *
 * // With limit
 * XRegExp.split('a b c', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * XRegExp.split('..word1..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', '..']
 */


XRegExp.split = function (str, separator, limit) {
  return fixed.split.call(toObject(str), separator, limit);
};
/**
 * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and
 * `sticky` arguments specify the search start position, and whether the match must start at the
 * specified position only. The `lastIndex` property of the provided regex is not used, but is
 * updated for compatibility. Also fixes browser bugs compared to the native
 * `RegExp.prototype.test` and can be used reliably cross-browser.
 *
 * @memberOf XRegExp
 * @param {String} str String to search.
 * @param {RegExp} regex Regex to search with.
 * @param {Number} [pos=0] Zero-based index at which to start the search.
 * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position
 *   only. The string `'sticky'` is accepted as an alternative to `true`.
 * @returns {Boolean} Whether the regex matched the provided value.
 * @example
 *
 * // Basic use
 * XRegExp.test('abc', /c/); // -> true
 *
 * // With pos and sticky
 * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false
 * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true
 */
// Do this the easy way :-)


XRegExp.test = function (str, regex, pos, sticky) {
  return !!XRegExp.exec(str, regex, pos, sticky);
};
/**
 * Uninstalls optional features according to the specified options. All optional features start out
 * uninstalled, so this is used to undo the actions of `XRegExp.install`.
 *
 * @memberOf XRegExp
 * @param {Object|String} options Options object or string.
 * @example
 *
 * // With an options object
 * XRegExp.uninstall({
 *   // Disables support for astral code points in Unicode addons
 *   astral: true,
 *
 *   // Don't add named capture groups to the `groups` property of matches
 *   namespacing: true
 * });
 *
 * // With an options string
 * XRegExp.uninstall('astral namespacing');
 */


XRegExp.uninstall = function (options) {
  options = prepareOptions(options);

  if (features.astral && options.astral) {
    setAstral(false);
  }

  if (features.namespacing && options.namespacing) {
    setNamespacing(false);
  }
};
/**
 * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as
 * regex objects or strings. Metacharacters are escaped in patterns provided as strings.
 * Backreferences in provided regex objects are automatically renumbered to work correctly within
 * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the
 * `flags` argument.
 *
 * @memberOf XRegExp
 * @param {Array} patterns Regexes and strings to combine.
 * @param {String} [flags] Any combination of XRegExp flags.
 * @param {Object} [options] Options object with optional properties:
 *   - `conjunction` {String} Type of conjunction to use: 'or' (default) or 'none'.
 * @returns {RegExp} Union of the provided regexes and strings.
 * @example
 *
 * XRegExp.union(['a+b*c', /(dogs)\1/, /(cats)\1/], 'i');
 * // -> /a\+b\*c|(dogs)\1|(cats)\2/i
 *
 * XRegExp.union([/man/, /bear/, /pig/], 'i', {conjunction: 'none'});
 * // -> /manbearpig/i
 */


XRegExp.union = function (patterns, flags, options) {
  options = options || {};
  var conjunction = options.conjunction || 'or';
  var numCaptures = 0;
  var numPriorCaptures;
  var captureNames;

  function rewrite(match, paren, backref) {
    var name = captureNames[numCaptures - numPriorCaptures]; // Capturing group

    if (paren) {
      ++numCaptures; // If the current capture has a name, preserve the name

      if (name) {
        return "(?<".concat(name, ">");
      } // Backreference

    } else if (backref) {
      // Rewrite the backreference
      return "\\".concat(+backref + numPriorCaptures);
    }

    return match;
  }

  if (!(isType(patterns, 'Array') && patterns.length)) {
    throw new TypeError('Must provide a nonempty array of patterns to merge');
  }

  var parts = /(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g;
  var output = [];
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = (0, _getIterator2.default)(patterns), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var pattern = _step5.value;

      if (XRegExp.isRegExp(pattern)) {
        numPriorCaptures = numCaptures;
        captureNames = pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames || []; // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are
        // independently valid; helps keep this simple. Named captures are put back

        output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));
      } else {
        output.push(XRegExp.escape(pattern));
      }
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
        _iterator5.return();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  var separator = conjunction === 'none' ? '' : '|';
  return XRegExp(output.join(separator), flags);
}; // ==--------------------------==
// Fixed/extended native methods
// ==--------------------------==

/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `RegExp.prototype.exec`. Use via `XRegExp.exec`.
 *
 * @memberOf RegExp
 * @param {String} str String to search.
 * @returns {Array} Match array with named backreference properties, or `null`.
 */


fixed.exec = function (str) {
  var origLastIndex = this.lastIndex;
  var match = nativ.exec.apply(this, arguments);

  if (match) {
    // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing
    // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9
    // in standards mode follows the spec.
    if (!correctExecNpcg && match.length > 1 && match.indexOf('') !== -1) {
      var r2 = copyRegex(this, {
        removeG: true,
        isInternalOnly: true
      }); // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed
      // matching due to characters outside the match

      nativ.replace.call(String(str).slice(match.index), r2, function () {
        var len = arguments.length; // Skip index 0 and the last 2

        for (var i = 1; i < len - 2; ++i) {
          if ((i < 0 || arguments.length <= i ? undefined : arguments[i]) === undefined) {
            match[i] = undefined;
          }
        }
      });
    } // Attach named capture properties


    var groupsObject = match;

    if (XRegExp.isInstalled('namespacing')) {
      // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec
      match.groups = (0, _create.default)(null);
      groupsObject = match.groups;
    }

    if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {
      // Skip index 0
      for (var i = 1; i < match.length; ++i) {
        var name = this[REGEX_DATA].captureNames[i - 1];

        if (name) {
          groupsObject[name] = match[i];
        }
      }
    } // Fix browsers that increment `lastIndex` after zero-length matches


    if (this.global && !match[0].length && this.lastIndex > match.index) {
      this.lastIndex = match.index;
    }
  }

  if (!this.global) {
    // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
    this.lastIndex = origLastIndex;
  }

  return match;
};
/**
 * Fixes browser bugs in the native `RegExp.prototype.test`.
 *
 * @memberOf RegExp
 * @param {String} str String to search.
 * @returns {Boolean} Whether the regex matched the provided value.
 */


fixed.test = function (str) {
  // Do this the easy way :-)
  return !!fixed.exec.call(this, str);
};
/**
 * Adds named capture support (with backreferences returned as `result.name`), and fixes browser
 * bugs in the native `String.prototype.match`.
 *
 * @memberOf String
 * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.
 * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,
 *   the result of calling `regex.exec(this)`.
 */


fixed.match = function (regex) {
  if (!XRegExp.isRegExp(regex)) {
    // Use the native `RegExp` rather than `XRegExp`
    regex = new RegExp(regex);
  } else if (regex.global) {
    var result = nativ.match.apply(this, arguments); // Fixes IE bug

    regex.lastIndex = 0;
    return result;
  }

  return fixed.exec.call(regex, toObject(this));
};
/**
 * Adds support for `${n}` (or `$<n>`) tokens for named and numbered backreferences in replacement
 * text, and provides named backreferences to replacement functions as `arguments[0].name`. Also
 * fixes browser bugs in replacement text syntax when performing a replacement using a nonregex
 * search value, and the value of a replacement regex's `lastIndex` property during replacement
 * iterations and upon completion. Note that this doesn't support SpiderMonkey's proprietary third
 * (`flags`) argument. Use via `XRegExp.replace`.
 *
 * @memberOf String
 * @param {RegExp|String} search Search pattern to be replaced.
 * @param {String|Function} replacement Replacement string or a function invoked to create it.
 * @returns {String} New string with one or all matches replaced.
 */


fixed.replace = function (search, replacement) {
  var isRegex = XRegExp.isRegExp(search);
  var origLastIndex;
  var captureNames;
  var result;

  if (isRegex) {
    if (search[REGEX_DATA]) {
      captureNames = search[REGEX_DATA].captureNames;
    } // Only needed if `search` is nonglobal


    origLastIndex = search.lastIndex;
  } else {
    search += ''; // Type-convert
  } // Don't use `typeof`; some older browsers return 'function' for regex objects


  if (isType(replacement, 'Function')) {
    // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement
    // functions isn't type-converted to a string
    result = nativ.replace.call(String(this), search, function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (captureNames) {
        var groupsObject;

        if (XRegExp.isInstalled('namespacing')) {
          // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec
          groupsObject = (0, _create.default)(null);
          args.push(groupsObject);
        } else {
          // Change the `args[0]` string primitive to a `String` object that can store
          // properties. This really does need to use `String` as a constructor
          args[0] = new String(args[0]);
          groupsObject = args[0];
        } // Store named backreferences


        for (var i = 0; i < captureNames.length; ++i) {
          if (captureNames[i]) {
            groupsObject[captureNames[i]] = args[i + 1];
          }
        }
      } // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari
      // bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)


      if (isRegex && search.global) {
        search.lastIndex = args[args.length - 2] + args[0].length;
      } // ES6 specs the context for replacement functions as `undefined`


      return replacement.apply(void 0, args);
    });
  } else {
    // Ensure that the last value of `args` will be a string when given nonstring `this`,
    // while still throwing on null or undefined context
    result = nativ.replace.call(this == null ? this : String(this), search, function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return nativ.replace.call(String(replacement), replacementToken, replacer);

      function replacer($0, bracketed, angled, dollarToken) {
        bracketed = bracketed || angled; // Named or numbered backreference with curly or angled braces

        if (bracketed) {
          // XRegExp behavior for `${n}` or `$<n>`:
          // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the
          //    entire match. Any number of leading zeros may be used.
          // 2. Backreference to named capture `n`, if it exists and is not an integer
          //    overridden by numbered capture. In practice, this does not overlap with
          //    numbered capture since XRegExp does not allow named capture to use a bare
          //    integer as the name.
          // 3. If the name or number does not refer to an existing capturing group, it's
          //    an error.
          var n = +bracketed; // Type-convert; drop leading zeros

          if (n <= args.length - 3) {
            return args[n] || '';
          } // Groups with the same name is an error, else would need `lastIndexOf`


          n = captureNames ? captureNames.indexOf(bracketed) : -1;

          if (n < 0) {
            throw new SyntaxError("Backreference to undefined group ".concat($0));
          }

          return args[n + 1] || '';
        } // Else, special variable or numbered backreference without curly braces


        if (dollarToken === '$') {
          // $$
          return '$';
        }

        if (dollarToken === '&' || +dollarToken === 0) {
          // $&, $0 (not followed by 1-9), $00
          return args[0];
        }

        if (dollarToken === '`') {
          // $` (left context)
          return args[args.length - 1].slice(0, args[args.length - 2]);
        }

        if (dollarToken === "'") {
          // $' (right context)
          return args[args.length - 1].slice(args[args.length - 2] + args[0].length);
        } // Else, numbered backreference without braces


        dollarToken = +dollarToken; // Type-convert; drop leading zero
        // XRegExp behavior for `$n` and `$nn`:
        // - Backrefs end after 1 or 2 digits. Use `${..}` or `$<..>` for more digits.
        // - `$1` is an error if no capturing groups.
        // - `$10` is an error if less than 10 capturing groups. Use `${1}0` or `$<1>0`
        //   instead.
        // - `$01` is `$1` if at least one capturing group, else it's an error.
        // - `$0` (not followed by 1-9) and `$00` are the entire match.
        // Native behavior, for comparison:
        // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.
        // - `$1` is a literal `$1` if no capturing groups.
        // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.
        // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.
        // - `$0` is a literal `$0`.

        if (!isNaN(dollarToken)) {
          if (dollarToken > args.length - 3) {
            throw new SyntaxError("Backreference to undefined group ".concat($0));
          }

          return args[dollarToken] || '';
        } // `$` followed by an unsupported char is an error, unlike native JS


        throw new SyntaxError("Invalid token ".concat($0));
      }
    });
  }

  if (isRegex) {
    if (search.global) {
      // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)
      search.lastIndex = 0;
    } else {
      // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)
      search.lastIndex = origLastIndex;
    }
  }

  return result;
};
/**
 * Fixes browser bugs in the native `String.prototype.split`. Use via `XRegExp.split`.
 *
 * @memberOf String
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 */


fixed.split = function (separator, limit) {
  if (!XRegExp.isRegExp(separator)) {
    // Browsers handle nonregex split correctly, so use the faster native method
    return nativ.split.apply(this, arguments);
  }

  var str = String(this);
  var output = [];
  var origLastIndex = separator.lastIndex;
  var lastLastIndex = 0;
  var lastLength; // Values for `limit`, per the spec:
  // If undefined: pow(2,32) - 1
  // If 0, Infinity, or NaN: 0
  // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);
  // If negative number: pow(2,32) - floor(abs(limit))
  // If other: Type-convert, then use the above rules
  // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless
  // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+

  limit = (limit === undefined ? -1 : limit) >>> 0;
  XRegExp.forEach(str, separator, function (match) {
    // This condition is not the same as `if (match[0].length)`
    if (match.index + match[0].length > lastLastIndex) {
      output.push(str.slice(lastLastIndex, match.index));

      if (match.length > 1 && match.index < str.length) {
        Array.prototype.push.apply(output, match.slice(1));
      }

      lastLength = match[0].length;
      lastLastIndex = match.index + lastLength;
    }
  });

  if (lastLastIndex === str.length) {
    if (!nativ.test.call(separator, '') || lastLength) {
      output.push('');
    }
  } else {
    output.push(str.slice(lastLastIndex));
  }

  separator.lastIndex = origLastIndex;
  return output.length > limit ? output.slice(0, limit) : output;
}; // ==--------------------------==
// Built-in syntax/flag tokens
// ==--------------------------==

/*
 * Letter escapes that natively match literal characters: `\a`, `\A`, etc. These should be
 * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser
 * consistency and to reserve their syntax, but lets them be superseded by addons.
 */


XRegExp.addToken(/\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/, function (match, scope) {
  // \B is allowed in default scope only
  if (match[1] === 'B' && scope === defaultScope) {
    return match[0];
  }

  throw new SyntaxError("Invalid escape ".concat(match[0]));
}, {
  scope: 'all',
  leadChar: '\\'
});
/*
 * Unicode code point escape with curly braces: `\u{N..}`. `N..` is any one or more digit
 * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag
 * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to
 * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior
 * if you follow a `\u{N..}` token that references a code point above U+FFFF with a quantifier, or
 * if you use the same in a character class.
 */

XRegExp.addToken(/\\u{([\dA-Fa-f]+)}/, function (match, scope, flags) {
  var code = dec(match[1]);

  if (code > 0x10FFFF) {
    throw new SyntaxError("Invalid Unicode code point ".concat(match[0]));
  }

  if (code <= 0xFFFF) {
    // Converting to \uNNNN avoids needing to escape the literal character and keep it
    // separate from preceding tokens
    return "\\u".concat(pad4(hex(code)));
  } // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling


  if (hasNativeU && flags.indexOf('u') !== -1) {
    return match[0];
  }

  throw new SyntaxError('Cannot use Unicode code point above \\u{FFFF} without flag u');
}, {
  scope: 'all',
  leadChar: '\\'
});
/*
 * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.
 * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because
 * character class endings can't be determined.
 */

XRegExp.addToken(/\[(\^?)\]/, // For cross-browser compatibility with ES3, convert [] to \b\B and [^] to [\s\S].
// (?!) should work like \b\B, but is unreliable in some versions of Firefox

/* eslint-disable no-confusing-arrow */
function (match) {
  return match[1] ? '[\\s\\S]' : '\\b\\B';
},
/* eslint-enable no-confusing-arrow */
{
  leadChar: '['
});
/*
 * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in
 * free-spacing mode (flag x).
 */

XRegExp.addToken(/\(\?#[^)]*\)/, getContextualTokenSeparator, {
  leadChar: '('
});
/*
 * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.
 */

XRegExp.addToken(/\s+|#[^\n]*\n?/, getContextualTokenSeparator, {
  flag: 'x'
});
/*
 * Dot, in dotall mode (aka singleline mode, flag s) only.
 */

XRegExp.addToken(/\./, function () {
  return '[\\s\\S]';
}, {
  flag: 's',
  leadChar: '.'
});
/*
 * Named backreference: `\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,
 * and $ only. Also allows numbered backreferences as `\k<n>`.
 */

XRegExp.addToken(/\\k<([\w$]+)>/, function (match) {
  // Groups with the same name is an error, else would need `lastIndexOf`
  var index = isNaN(match[1]) ? this.captureNames.indexOf(match[1]) + 1 : +match[1];
  var endIndex = match.index + match[0].length;

  if (!index || index > this.captureNames.length) {
    throw new SyntaxError("Backreference to undefined group ".concat(match[0]));
  } // Keep backreferences separate from subsequent literal numbers. This avoids e.g.
  // inadvertedly changing `(?<n>)\k<n>1` to `()\11`.


  return "\\".concat(index).concat(endIndex === match.input.length || isNaN(match.input[endIndex]) ? '' : '(?:)');
}, {
  leadChar: '\\'
});
/*
 * Numbered backreference or octal, plus any following digits: `\0`, `\11`, etc. Octals except `\0`
 * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches
 * are returned unaltered. IE < 9 doesn't support backreferences above `\99` in regex syntax.
 */

XRegExp.addToken(/\\(\d+)/, function (match, scope) {
  if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== '0') {
    throw new SyntaxError("Cannot use octal escape or backreference to undefined group ".concat(match[0]));
  }

  return match[0];
}, {
  scope: 'all',
  leadChar: '\\'
});
/*
 * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the
 * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style
 * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively
 * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to
 * Python-style named capture as octals.
 */

XRegExp.addToken(/\(\?P?<([\w$]+)>/, function (match) {
  // Disallow bare integers as names because named backreferences are added to match arrays
  // and therefore numeric properties may lead to incorrect lookups
  if (!isNaN(match[1])) {
    throw new SyntaxError("Cannot use integer as capture name ".concat(match[0]));
  }

  if (!XRegExp.isInstalled('namespacing') && (match[1] === 'length' || match[1] === '__proto__')) {
    throw new SyntaxError("Cannot use reserved word as capture name ".concat(match[0]));
  }

  if (this.captureNames.indexOf(match[1]) !== -1) {
    throw new SyntaxError("Cannot use same name for multiple groups ".concat(match[0]));
  }

  this.captureNames.push(match[1]);
  this.hasNamedCapture = true;
  return '(';
}, {
  leadChar: '('
});
/*
 * Capturing group; match the opening parenthesis only. Required for support of named capturing
 * groups. Also adds explicit capture mode (flag n).
 */

XRegExp.addToken(/\((?!\?)/, function (match, scope, flags) {
  if (flags.indexOf('n') !== -1) {
    return '(?:';
  }

  this.captureNames.push(null);
  return '(';
}, {
  optionalFlags: 'n',
  leadChar: '('
});
var _default = XRegExp;
exports.default = _default;
module.exports = exports["default"];

/***/ }),
/* 114 */
/***/ (function(module, exports) {

module.exports = [
    {
        'name': 'InAdlam',
        'astral': '\uD83A[\uDD00-\uDD5F]'
    },
    {
        'name': 'InAegean_Numbers',
        'astral': '\uD800[\uDD00-\uDD3F]'
    },
    {
        'name': 'InAhom',
        'astral': '\uD805[\uDF00-\uDF3F]'
    },
    {
        'name': 'InAlchemical_Symbols',
        'astral': '\uD83D[\uDF00-\uDF7F]'
    },
    {
        'name': 'InAlphabetic_Presentation_Forms',
        'bmp': '\uFB00-\uFB4F'
    },
    {
        'name': 'InAnatolian_Hieroglyphs',
        'astral': '\uD811[\uDC00-\uDE7F]'
    },
    {
        'name': 'InAncient_Greek_Musical_Notation',
        'astral': '\uD834[\uDE00-\uDE4F]'
    },
    {
        'name': 'InAncient_Greek_Numbers',
        'astral': '\uD800[\uDD40-\uDD8F]'
    },
    {
        'name': 'InAncient_Symbols',
        'astral': '\uD800[\uDD90-\uDDCF]'
    },
    {
        'name': 'InArabic',
        'bmp': '\u0600-\u06FF'
    },
    {
        'name': 'InArabic_Extended_A',
        'bmp': '\u08A0-\u08FF'
    },
    {
        'name': 'InArabic_Mathematical_Alphabetic_Symbols',
        'astral': '\uD83B[\uDE00-\uDEFF]'
    },
    {
        'name': 'InArabic_Presentation_Forms_A',
        'bmp': '\uFB50-\uFDFF'
    },
    {
        'name': 'InArabic_Presentation_Forms_B',
        'bmp': '\uFE70-\uFEFF'
    },
    {
        'name': 'InArabic_Supplement',
        'bmp': '\u0750-\u077F'
    },
    {
        'name': 'InArmenian',
        'bmp': '\u0530-\u058F'
    },
    {
        'name': 'InArrows',
        'bmp': '\u2190-\u21FF'
    },
    {
        'name': 'InAvestan',
        'astral': '\uD802[\uDF00-\uDF3F]'
    },
    {
        'name': 'InBalinese',
        'bmp': '\u1B00-\u1B7F'
    },
    {
        'name': 'InBamum',
        'bmp': '\uA6A0-\uA6FF'
    },
    {
        'name': 'InBamum_Supplement',
        'astral': '\uD81A[\uDC00-\uDE3F]'
    },
    {
        'name': 'InBasic_Latin',
        'bmp': '\0-\x7F'
    },
    {
        'name': 'InBassa_Vah',
        'astral': '\uD81A[\uDED0-\uDEFF]'
    },
    {
        'name': 'InBatak',
        'bmp': '\u1BC0-\u1BFF'
    },
    {
        'name': 'InBengali',
        'bmp': '\u0980-\u09FF'
    },
    {
        'name': 'InBhaiksuki',
        'astral': '\uD807[\uDC00-\uDC6F]'
    },
    {
        'name': 'InBlock_Elements',
        'bmp': '\u2580-\u259F'
    },
    {
        'name': 'InBopomofo',
        'bmp': '\u3100-\u312F'
    },
    {
        'name': 'InBopomofo_Extended',
        'bmp': '\u31A0-\u31BF'
    },
    {
        'name': 'InBox_Drawing',
        'bmp': '\u2500-\u257F'
    },
    {
        'name': 'InBrahmi',
        'astral': '\uD804[\uDC00-\uDC7F]'
    },
    {
        'name': 'InBraille_Patterns',
        'bmp': '\u2800-\u28FF'
    },
    {
        'name': 'InBuginese',
        'bmp': '\u1A00-\u1A1F'
    },
    {
        'name': 'InBuhid',
        'bmp': '\u1740-\u175F'
    },
    {
        'name': 'InByzantine_Musical_Symbols',
        'astral': '\uD834[\uDC00-\uDCFF]'
    },
    {
        'name': 'InCJK_Compatibility',
        'bmp': '\u3300-\u33FF'
    },
    {
        'name': 'InCJK_Compatibility_Forms',
        'bmp': '\uFE30-\uFE4F'
    },
    {
        'name': 'InCJK_Compatibility_Ideographs',
        'bmp': '\uF900-\uFAFF'
    },
    {
        'name': 'InCJK_Compatibility_Ideographs_Supplement',
        'astral': '\uD87E[\uDC00-\uDE1F]'
    },
    {
        'name': 'InCJK_Radicals_Supplement',
        'bmp': '\u2E80-\u2EFF'
    },
    {
        'name': 'InCJK_Strokes',
        'bmp': '\u31C0-\u31EF'
    },
    {
        'name': 'InCJK_Symbols_And_Punctuation',
        'bmp': '\u3000-\u303F'
    },
    {
        'name': 'InCJK_Unified_Ideographs',
        'bmp': '\u4E00-\u9FFF'
    },
    {
        'name': 'InCJK_Unified_Ideographs_Extension_A',
        'bmp': '\u3400-\u4DBF'
    },
    {
        'name': 'InCJK_Unified_Ideographs_Extension_B',
        'astral': '[\uD840-\uD868][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF]'
    },
    {
        'name': 'InCJK_Unified_Ideographs_Extension_C',
        'astral': '\uD869[\uDF00-\uDFFF]|[\uD86A-\uD86C][\uDC00-\uDFFF]|\uD86D[\uDC00-\uDF3F]'
    },
    {
        'name': 'InCJK_Unified_Ideographs_Extension_D',
        'astral': '\uD86D[\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1F]'
    },
    {
        'name': 'InCJK_Unified_Ideographs_Extension_E',
        'astral': '\uD86E[\uDC20-\uDFFF]|[\uD86F-\uD872][\uDC00-\uDFFF]|\uD873[\uDC00-\uDEAF]'
    },
    {
        'name': 'InCJK_Unified_Ideographs_Extension_F',
        'astral': '\uD873[\uDEB0-\uDFFF]|[\uD874-\uD879][\uDC00-\uDFFF]|\uD87A[\uDC00-\uDFEF]'
    },
    {
        'name': 'InCarian',
        'astral': '\uD800[\uDEA0-\uDEDF]'
    },
    {
        'name': 'InCaucasian_Albanian',
        'astral': '\uD801[\uDD30-\uDD6F]'
    },
    {
        'name': 'InChakma',
        'astral': '\uD804[\uDD00-\uDD4F]'
    },
    {
        'name': 'InCham',
        'bmp': '\uAA00-\uAA5F'
    },
    {
        'name': 'InCherokee',
        'bmp': '\u13A0-\u13FF'
    },
    {
        'name': 'InCherokee_Supplement',
        'bmp': '\uAB70-\uABBF'
    },
    {
        'name': 'InChess_Symbols',
        'astral': '\uD83E[\uDE00-\uDE6F]'
    },
    {
        'name': 'InCombining_Diacritical_Marks',
        'bmp': '\u0300-\u036F'
    },
    {
        'name': 'InCombining_Diacritical_Marks_Extended',
        'bmp': '\u1AB0-\u1AFF'
    },
    {
        'name': 'InCombining_Diacritical_Marks_For_Symbols',
        'bmp': '\u20D0-\u20FF'
    },
    {
        'name': 'InCombining_Diacritical_Marks_Supplement',
        'bmp': '\u1DC0-\u1DFF'
    },
    {
        'name': 'InCombining_Half_Marks',
        'bmp': '\uFE20-\uFE2F'
    },
    {
        'name': 'InCommon_Indic_Number_Forms',
        'bmp': '\uA830-\uA83F'
    },
    {
        'name': 'InControl_Pictures',
        'bmp': '\u2400-\u243F'
    },
    {
        'name': 'InCoptic',
        'bmp': '\u2C80-\u2CFF'
    },
    {
        'name': 'InCoptic_Epact_Numbers',
        'astral': '\uD800[\uDEE0-\uDEFF]'
    },
    {
        'name': 'InCounting_Rod_Numerals',
        'astral': '\uD834[\uDF60-\uDF7F]'
    },
    {
        'name': 'InCuneiform',
        'astral': '\uD808[\uDC00-\uDFFF]'
    },
    {
        'name': 'InCuneiform_Numbers_And_Punctuation',
        'astral': '\uD809[\uDC00-\uDC7F]'
    },
    {
        'name': 'InCurrency_Symbols',
        'bmp': '\u20A0-\u20CF'
    },
    {
        'name': 'InCypriot_Syllabary',
        'astral': '\uD802[\uDC00-\uDC3F]'
    },
    {
        'name': 'InCyrillic',
        'bmp': '\u0400-\u04FF'
    },
    {
        'name': 'InCyrillic_Extended_A',
        'bmp': '\u2DE0-\u2DFF'
    },
    {
        'name': 'InCyrillic_Extended_B',
        'bmp': '\uA640-\uA69F'
    },
    {
        'name': 'InCyrillic_Extended_C',
        'bmp': '\u1C80-\u1C8F'
    },
    {
        'name': 'InCyrillic_Supplement',
        'bmp': '\u0500-\u052F'
    },
    {
        'name': 'InDeseret',
        'astral': '\uD801[\uDC00-\uDC4F]'
    },
    {
        'name': 'InDevanagari',
        'bmp': '\u0900-\u097F'
    },
    {
        'name': 'InDevanagari_Extended',
        'bmp': '\uA8E0-\uA8FF'
    },
    {
        'name': 'InDingbats',
        'bmp': '\u2700-\u27BF'
    },
    {
        'name': 'InDogra',
        'astral': '\uD806[\uDC00-\uDC4F]'
    },
    {
        'name': 'InDomino_Tiles',
        'astral': '\uD83C[\uDC30-\uDC9F]'
    },
    {
        'name': 'InDuployan',
        'astral': '\uD82F[\uDC00-\uDC9F]'
    },
    {
        'name': 'InEarly_Dynastic_Cuneiform',
        'astral': '\uD809[\uDC80-\uDD4F]'
    },
    {
        'name': 'InEgyptian_Hieroglyphs',
        'astral': '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F]'
    },
    {
        'name': 'InElbasan',
        'astral': '\uD801[\uDD00-\uDD2F]'
    },
    {
        'name': 'InEmoticons',
        'astral': '\uD83D[\uDE00-\uDE4F]'
    },
    {
        'name': 'InEnclosed_Alphanumeric_Supplement',
        'astral': '\uD83C[\uDD00-\uDDFF]'
    },
    {
        'name': 'InEnclosed_Alphanumerics',
        'bmp': '\u2460-\u24FF'
    },
    {
        'name': 'InEnclosed_CJK_Letters_And_Months',
        'bmp': '\u3200-\u32FF'
    },
    {
        'name': 'InEnclosed_Ideographic_Supplement',
        'astral': '\uD83C[\uDE00-\uDEFF]'
    },
    {
        'name': 'InEthiopic',
        'bmp': '\u1200-\u137F'
    },
    {
        'name': 'InEthiopic_Extended',
        'bmp': '\u2D80-\u2DDF'
    },
    {
        'name': 'InEthiopic_Extended_A',
        'bmp': '\uAB00-\uAB2F'
    },
    {
        'name': 'InEthiopic_Supplement',
        'bmp': '\u1380-\u139F'
    },
    {
        'name': 'InGeneral_Punctuation',
        'bmp': '\u2000-\u206F'
    },
    {
        'name': 'InGeometric_Shapes',
        'bmp': '\u25A0-\u25FF'
    },
    {
        'name': 'InGeometric_Shapes_Extended',
        'astral': '\uD83D[\uDF80-\uDFFF]'
    },
    {
        'name': 'InGeorgian',
        'bmp': '\u10A0-\u10FF'
    },
    {
        'name': 'InGeorgian_Extended',
        'bmp': '\u1C90-\u1CBF'
    },
    {
        'name': 'InGeorgian_Supplement',
        'bmp': '\u2D00-\u2D2F'
    },
    {
        'name': 'InGlagolitic',
        'bmp': '\u2C00-\u2C5F'
    },
    {
        'name': 'InGlagolitic_Supplement',
        'astral': '\uD838[\uDC00-\uDC2F]'
    },
    {
        'name': 'InGothic',
        'astral': '\uD800[\uDF30-\uDF4F]'
    },
    {
        'name': 'InGrantha',
        'astral': '\uD804[\uDF00-\uDF7F]'
    },
    {
        'name': 'InGreek_And_Coptic',
        'bmp': '\u0370-\u03FF'
    },
    {
        'name': 'InGreek_Extended',
        'bmp': '\u1F00-\u1FFF'
    },
    {
        'name': 'InGujarati',
        'bmp': '\u0A80-\u0AFF'
    },
    {
        'name': 'InGunjala_Gondi',
        'astral': '\uD807[\uDD60-\uDDAF]'
    },
    {
        'name': 'InGurmukhi',
        'bmp': '\u0A00-\u0A7F'
    },
    {
        'name': 'InHalfwidth_And_Fullwidth_Forms',
        'bmp': '\uFF00-\uFFEF'
    },
    {
        'name': 'InHangul_Compatibility_Jamo',
        'bmp': '\u3130-\u318F'
    },
    {
        'name': 'InHangul_Jamo',
        'bmp': '\u1100-\u11FF'
    },
    {
        'name': 'InHangul_Jamo_Extended_A',
        'bmp': '\uA960-\uA97F'
    },
    {
        'name': 'InHangul_Jamo_Extended_B',
        'bmp': '\uD7B0-\uD7FF'
    },
    {
        'name': 'InHangul_Syllables',
        'bmp': '\uAC00-\uD7AF'
    },
    {
        'name': 'InHanifi_Rohingya',
        'astral': '\uD803[\uDD00-\uDD3F]'
    },
    {
        'name': 'InHanunoo',
        'bmp': '\u1720-\u173F'
    },
    {
        'name': 'InHatran',
        'astral': '\uD802[\uDCE0-\uDCFF]'
    },
    {
        'name': 'InHebrew',
        'bmp': '\u0590-\u05FF'
    },
    {
        'name': 'InHigh_Private_Use_Surrogates',
        'bmp': '\uDB80-\uDBFF'
    },
    {
        'name': 'InHigh_Surrogates',
        'bmp': '\uD800-\uDB7F'
    },
    {
        'name': 'InHiragana',
        'bmp': '\u3040-\u309F'
    },
    {
        'name': 'InIPA_Extensions',
        'bmp': '\u0250-\u02AF'
    },
    {
        'name': 'InIdeographic_Description_Characters',
        'bmp': '\u2FF0-\u2FFF'
    },
    {
        'name': 'InIdeographic_Symbols_And_Punctuation',
        'astral': '\uD81B[\uDFE0-\uDFFF]'
    },
    {
        'name': 'InImperial_Aramaic',
        'astral': '\uD802[\uDC40-\uDC5F]'
    },
    {
        'name': 'InIndic_Siyaq_Numbers',
        'astral': '\uD83B[\uDC70-\uDCBF]'
    },
    {
        'name': 'InInscriptional_Pahlavi',
        'astral': '\uD802[\uDF60-\uDF7F]'
    },
    {
        'name': 'InInscriptional_Parthian',
        'astral': '\uD802[\uDF40-\uDF5F]'
    },
    {
        'name': 'InJavanese',
        'bmp': '\uA980-\uA9DF'
    },
    {
        'name': 'InKaithi',
        'astral': '\uD804[\uDC80-\uDCCF]'
    },
    {
        'name': 'InKana_Extended_A',
        'astral': '\uD82C[\uDD00-\uDD2F]'
    },
    {
        'name': 'InKana_Supplement',
        'astral': '\uD82C[\uDC00-\uDCFF]'
    },
    {
        'name': 'InKanbun',
        'bmp': '\u3190-\u319F'
    },
    {
        'name': 'InKangxi_Radicals',
        'bmp': '\u2F00-\u2FDF'
    },
    {
        'name': 'InKannada',
        'bmp': '\u0C80-\u0CFF'
    },
    {
        'name': 'InKatakana',
        'bmp': '\u30A0-\u30FF'
    },
    {
        'name': 'InKatakana_Phonetic_Extensions',
        'bmp': '\u31F0-\u31FF'
    },
    {
        'name': 'InKayah_Li',
        'bmp': '\uA900-\uA92F'
    },
    {
        'name': 'InKharoshthi',
        'astral': '\uD802[\uDE00-\uDE5F]'
    },
    {
        'name': 'InKhmer',
        'bmp': '\u1780-\u17FF'
    },
    {
        'name': 'InKhmer_Symbols',
        'bmp': '\u19E0-\u19FF'
    },
    {
        'name': 'InKhojki',
        'astral': '\uD804[\uDE00-\uDE4F]'
    },
    {
        'name': 'InKhudawadi',
        'astral': '\uD804[\uDEB0-\uDEFF]'
    },
    {
        'name': 'InLao',
        'bmp': '\u0E80-\u0EFF'
    },
    {
        'name': 'InLatin_1_Supplement',
        'bmp': '\x80-\xFF'
    },
    {
        'name': 'InLatin_Extended_A',
        'bmp': '\u0100-\u017F'
    },
    {
        'name': 'InLatin_Extended_Additional',
        'bmp': '\u1E00-\u1EFF'
    },
    {
        'name': 'InLatin_Extended_B',
        'bmp': '\u0180-\u024F'
    },
    {
        'name': 'InLatin_Extended_C',
        'bmp': '\u2C60-\u2C7F'
    },
    {
        'name': 'InLatin_Extended_D',
        'bmp': '\uA720-\uA7FF'
    },
    {
        'name': 'InLatin_Extended_E',
        'bmp': '\uAB30-\uAB6F'
    },
    {
        'name': 'InLepcha',
        'bmp': '\u1C00-\u1C4F'
    },
    {
        'name': 'InLetterlike_Symbols',
        'bmp': '\u2100-\u214F'
    },
    {
        'name': 'InLimbu',
        'bmp': '\u1900-\u194F'
    },
    {
        'name': 'InLinear_A',
        'astral': '\uD801[\uDE00-\uDF7F]'
    },
    {
        'name': 'InLinear_B_Ideograms',
        'astral': '\uD800[\uDC80-\uDCFF]'
    },
    {
        'name': 'InLinear_B_Syllabary',
        'astral': '\uD800[\uDC00-\uDC7F]'
    },
    {
        'name': 'InLisu',
        'bmp': '\uA4D0-\uA4FF'
    },
    {
        'name': 'InLow_Surrogates',
        'bmp': '\uDC00-\uDFFF'
    },
    {
        'name': 'InLycian',
        'astral': '\uD800[\uDE80-\uDE9F]'
    },
    {
        'name': 'InLydian',
        'astral': '\uD802[\uDD20-\uDD3F]'
    },
    {
        'name': 'InMahajani',
        'astral': '\uD804[\uDD50-\uDD7F]'
    },
    {
        'name': 'InMahjong_Tiles',
        'astral': '\uD83C[\uDC00-\uDC2F]'
    },
    {
        'name': 'InMakasar',
        'astral': '\uD807[\uDEE0-\uDEFF]'
    },
    {
        'name': 'InMalayalam',
        'bmp': '\u0D00-\u0D7F'
    },
    {
        'name': 'InMandaic',
        'bmp': '\u0840-\u085F'
    },
    {
        'name': 'InManichaean',
        'astral': '\uD802[\uDEC0-\uDEFF]'
    },
    {
        'name': 'InMarchen',
        'astral': '\uD807[\uDC70-\uDCBF]'
    },
    {
        'name': 'InMasaram_Gondi',
        'astral': '\uD807[\uDD00-\uDD5F]'
    },
    {
        'name': 'InMathematical_Alphanumeric_Symbols',
        'astral': '\uD835[\uDC00-\uDFFF]'
    },
    {
        'name': 'InMathematical_Operators',
        'bmp': '\u2200-\u22FF'
    },
    {
        'name': 'InMayan_Numerals',
        'astral': '\uD834[\uDEE0-\uDEFF]'
    },
    {
        'name': 'InMedefaidrin',
        'astral': '\uD81B[\uDE40-\uDE9F]'
    },
    {
        'name': 'InMeetei_Mayek',
        'bmp': '\uABC0-\uABFF'
    },
    {
        'name': 'InMeetei_Mayek_Extensions',
        'bmp': '\uAAE0-\uAAFF'
    },
    {
        'name': 'InMende_Kikakui',
        'astral': '\uD83A[\uDC00-\uDCDF]'
    },
    {
        'name': 'InMeroitic_Cursive',
        'astral': '\uD802[\uDDA0-\uDDFF]'
    },
    {
        'name': 'InMeroitic_Hieroglyphs',
        'astral': '\uD802[\uDD80-\uDD9F]'
    },
    {
        'name': 'InMiao',
        'astral': '\uD81B[\uDF00-\uDF9F]'
    },
    {
        'name': 'InMiscellaneous_Mathematical_Symbols_A',
        'bmp': '\u27C0-\u27EF'
    },
    {
        'name': 'InMiscellaneous_Mathematical_Symbols_B',
        'bmp': '\u2980-\u29FF'
    },
    {
        'name': 'InMiscellaneous_Symbols',
        'bmp': '\u2600-\u26FF'
    },
    {
        'name': 'InMiscellaneous_Symbols_And_Arrows',
        'bmp': '\u2B00-\u2BFF'
    },
    {
        'name': 'InMiscellaneous_Symbols_And_Pictographs',
        'astral': '\uD83C[\uDF00-\uDFFF]|\uD83D[\uDC00-\uDDFF]'
    },
    {
        'name': 'InMiscellaneous_Technical',
        'bmp': '\u2300-\u23FF'
    },
    {
        'name': 'InModi',
        'astral': '\uD805[\uDE00-\uDE5F]'
    },
    {
        'name': 'InModifier_Tone_Letters',
        'bmp': '\uA700-\uA71F'
    },
    {
        'name': 'InMongolian',
        'bmp': '\u1800-\u18AF'
    },
    {
        'name': 'InMongolian_Supplement',
        'astral': '\uD805[\uDE60-\uDE7F]'
    },
    {
        'name': 'InMro',
        'astral': '\uD81A[\uDE40-\uDE6F]'
    },
    {
        'name': 'InMultani',
        'astral': '\uD804[\uDE80-\uDEAF]'
    },
    {
        'name': 'InMusical_Symbols',
        'astral': '\uD834[\uDD00-\uDDFF]'
    },
    {
        'name': 'InMyanmar',
        'bmp': '\u1000-\u109F'
    },
    {
        'name': 'InMyanmar_Extended_A',
        'bmp': '\uAA60-\uAA7F'
    },
    {
        'name': 'InMyanmar_Extended_B',
        'bmp': '\uA9E0-\uA9FF'
    },
    {
        'name': 'InNKo',
        'bmp': '\u07C0-\u07FF'
    },
    {
        'name': 'InNabataean',
        'astral': '\uD802[\uDC80-\uDCAF]'
    },
    {
        'name': 'InNew_Tai_Lue',
        'bmp': '\u1980-\u19DF'
    },
    {
        'name': 'InNewa',
        'astral': '\uD805[\uDC00-\uDC7F]'
    },
    {
        'name': 'InNumber_Forms',
        'bmp': '\u2150-\u218F'
    },
    {
        'name': 'InNushu',
        'astral': '\uD82C[\uDD70-\uDEFF]'
    },
    {
        'name': 'InOgham',
        'bmp': '\u1680-\u169F'
    },
    {
        'name': 'InOl_Chiki',
        'bmp': '\u1C50-\u1C7F'
    },
    {
        'name': 'InOld_Hungarian',
        'astral': '\uD803[\uDC80-\uDCFF]'
    },
    {
        'name': 'InOld_Italic',
        'astral': '\uD800[\uDF00-\uDF2F]'
    },
    {
        'name': 'InOld_North_Arabian',
        'astral': '\uD802[\uDE80-\uDE9F]'
    },
    {
        'name': 'InOld_Permic',
        'astral': '\uD800[\uDF50-\uDF7F]'
    },
    {
        'name': 'InOld_Persian',
        'astral': '\uD800[\uDFA0-\uDFDF]'
    },
    {
        'name': 'InOld_Sogdian',
        'astral': '\uD803[\uDF00-\uDF2F]'
    },
    {
        'name': 'InOld_South_Arabian',
        'astral': '\uD802[\uDE60-\uDE7F]'
    },
    {
        'name': 'InOld_Turkic',
        'astral': '\uD803[\uDC00-\uDC4F]'
    },
    {
        'name': 'InOptical_Character_Recognition',
        'bmp': '\u2440-\u245F'
    },
    {
        'name': 'InOriya',
        'bmp': '\u0B00-\u0B7F'
    },
    {
        'name': 'InOrnamental_Dingbats',
        'astral': '\uD83D[\uDE50-\uDE7F]'
    },
    {
        'name': 'InOsage',
        'astral': '\uD801[\uDCB0-\uDCFF]'
    },
    {
        'name': 'InOsmanya',
        'astral': '\uD801[\uDC80-\uDCAF]'
    },
    {
        'name': 'InPahawh_Hmong',
        'astral': '\uD81A[\uDF00-\uDF8F]'
    },
    {
        'name': 'InPalmyrene',
        'astral': '\uD802[\uDC60-\uDC7F]'
    },
    {
        'name': 'InPau_Cin_Hau',
        'astral': '\uD806[\uDEC0-\uDEFF]'
    },
    {
        'name': 'InPhags_Pa',
        'bmp': '\uA840-\uA87F'
    },
    {
        'name': 'InPhaistos_Disc',
        'astral': '\uD800[\uDDD0-\uDDFF]'
    },
    {
        'name': 'InPhoenician',
        'astral': '\uD802[\uDD00-\uDD1F]'
    },
    {
        'name': 'InPhonetic_Extensions',
        'bmp': '\u1D00-\u1D7F'
    },
    {
        'name': 'InPhonetic_Extensions_Supplement',
        'bmp': '\u1D80-\u1DBF'
    },
    {
        'name': 'InPlaying_Cards',
        'astral': '\uD83C[\uDCA0-\uDCFF]'
    },
    {
        'name': 'InPrivate_Use_Area',
        'bmp': '\uE000-\uF8FF'
    },
    {
        'name': 'InPsalter_Pahlavi',
        'astral': '\uD802[\uDF80-\uDFAF]'
    },
    {
        'name': 'InRejang',
        'bmp': '\uA930-\uA95F'
    },
    {
        'name': 'InRumi_Numeral_Symbols',
        'astral': '\uD803[\uDE60-\uDE7F]'
    },
    {
        'name': 'InRunic',
        'bmp': '\u16A0-\u16FF'
    },
    {
        'name': 'InSamaritan',
        'bmp': '\u0800-\u083F'
    },
    {
        'name': 'InSaurashtra',
        'bmp': '\uA880-\uA8DF'
    },
    {
        'name': 'InSharada',
        'astral': '\uD804[\uDD80-\uDDDF]'
    },
    {
        'name': 'InShavian',
        'astral': '\uD801[\uDC50-\uDC7F]'
    },
    {
        'name': 'InShorthand_Format_Controls',
        'astral': '\uD82F[\uDCA0-\uDCAF]'
    },
    {
        'name': 'InSiddham',
        'astral': '\uD805[\uDD80-\uDDFF]'
    },
    {
        'name': 'InSinhala',
        'bmp': '\u0D80-\u0DFF'
    },
    {
        'name': 'InSinhala_Archaic_Numbers',
        'astral': '\uD804[\uDDE0-\uDDFF]'
    },
    {
        'name': 'InSmall_Form_Variants',
        'bmp': '\uFE50-\uFE6F'
    },
    {
        'name': 'InSogdian',
        'astral': '\uD803[\uDF30-\uDF6F]'
    },
    {
        'name': 'InSora_Sompeng',
        'astral': '\uD804[\uDCD0-\uDCFF]'
    },
    {
        'name': 'InSoyombo',
        'astral': '\uD806[\uDE50-\uDEAF]'
    },
    {
        'name': 'InSpacing_Modifier_Letters',
        'bmp': '\u02B0-\u02FF'
    },
    {
        'name': 'InSpecials',
        'bmp': '\uFFF0-\uFFFF'
    },
    {
        'name': 'InSundanese',
        'bmp': '\u1B80-\u1BBF'
    },
    {
        'name': 'InSundanese_Supplement',
        'bmp': '\u1CC0-\u1CCF'
    },
    {
        'name': 'InSuperscripts_And_Subscripts',
        'bmp': '\u2070-\u209F'
    },
    {
        'name': 'InSupplemental_Arrows_A',
        'bmp': '\u27F0-\u27FF'
    },
    {
        'name': 'InSupplemental_Arrows_B',
        'bmp': '\u2900-\u297F'
    },
    {
        'name': 'InSupplemental_Arrows_C',
        'astral': '\uD83E[\uDC00-\uDCFF]'
    },
    {
        'name': 'InSupplemental_Mathematical_Operators',
        'bmp': '\u2A00-\u2AFF'
    },
    {
        'name': 'InSupplemental_Punctuation',
        'bmp': '\u2E00-\u2E7F'
    },
    {
        'name': 'InSupplemental_Symbols_And_Pictographs',
        'astral': '\uD83E[\uDD00-\uDDFF]'
    },
    {
        'name': 'InSupplementary_Private_Use_Area_A',
        'astral': '[\uDB80-\uDBBF][\uDC00-\uDFFF]'
    },
    {
        'name': 'InSupplementary_Private_Use_Area_B',
        'astral': '[\uDBC0-\uDBFF][\uDC00-\uDFFF]'
    },
    {
        'name': 'InSutton_SignWriting',
        'astral': '\uD836[\uDC00-\uDEAF]'
    },
    {
        'name': 'InSyloti_Nagri',
        'bmp': '\uA800-\uA82F'
    },
    {
        'name': 'InSyriac',
        'bmp': '\u0700-\u074F'
    },
    {
        'name': 'InSyriac_Supplement',
        'bmp': '\u0860-\u086F'
    },
    {
        'name': 'InTagalog',
        'bmp': '\u1700-\u171F'
    },
    {
        'name': 'InTagbanwa',
        'bmp': '\u1760-\u177F'
    },
    {
        'name': 'InTags',
        'astral': '\uDB40[\uDC00-\uDC7F]'
    },
    {
        'name': 'InTai_Le',
        'bmp': '\u1950-\u197F'
    },
    {
        'name': 'InTai_Tham',
        'bmp': '\u1A20-\u1AAF'
    },
    {
        'name': 'InTai_Viet',
        'bmp': '\uAA80-\uAADF'
    },
    {
        'name': 'InTai_Xuan_Jing_Symbols',
        'astral': '\uD834[\uDF00-\uDF5F]'
    },
    {
        'name': 'InTakri',
        'astral': '\uD805[\uDE80-\uDECF]'
    },
    {
        'name': 'InTamil',
        'bmp': '\u0B80-\u0BFF'
    },
    {
        'name': 'InTangut',
        'astral': '[\uD81C-\uD821][\uDC00-\uDFFF]'
    },
    {
        'name': 'InTangut_Components',
        'astral': '\uD822[\uDC00-\uDEFF]'
    },
    {
        'name': 'InTelugu',
        'bmp': '\u0C00-\u0C7F'
    },
    {
        'name': 'InThaana',
        'bmp': '\u0780-\u07BF'
    },
    {
        'name': 'InThai',
        'bmp': '\u0E00-\u0E7F'
    },
    {
        'name': 'InTibetan',
        'bmp': '\u0F00-\u0FFF'
    },
    {
        'name': 'InTifinagh',
        'bmp': '\u2D30-\u2D7F'
    },
    {
        'name': 'InTirhuta',
        'astral': '\uD805[\uDC80-\uDCDF]'
    },
    {
        'name': 'InTransport_And_Map_Symbols',
        'astral': '\uD83D[\uDE80-\uDEFF]'
    },
    {
        'name': 'InUgaritic',
        'astral': '\uD800[\uDF80-\uDF9F]'
    },
    {
        'name': 'InUnified_Canadian_Aboriginal_Syllabics',
        'bmp': '\u1400-\u167F'
    },
    {
        'name': 'InUnified_Canadian_Aboriginal_Syllabics_Extended',
        'bmp': '\u18B0-\u18FF'
    },
    {
        'name': 'InVai',
        'bmp': '\uA500-\uA63F'
    },
    {
        'name': 'InVariation_Selectors',
        'bmp': '\uFE00-\uFE0F'
    },
    {
        'name': 'InVariation_Selectors_Supplement',
        'astral': '\uDB40[\uDD00-\uDDEF]'
    },
    {
        'name': 'InVedic_Extensions',
        'bmp': '\u1CD0-\u1CFF'
    },
    {
        'name': 'InVertical_Forms',
        'bmp': '\uFE10-\uFE1F'
    },
    {
        'name': 'InWarang_Citi',
        'astral': '\uD806[\uDCA0-\uDCFF]'
    },
    {
        'name': 'InYi_Radicals',
        'bmp': '\uA490-\uA4CF'
    },
    {
        'name': 'InYi_Syllables',
        'bmp': '\uA000-\uA48F'
    },
    {
        'name': 'InYijing_Hexagram_Symbols',
        'bmp': '\u4DC0-\u4DFF'
    },
    {
        'name': 'InZanabazar_Square',
        'astral': '\uD806[\uDE00-\uDE4F]'
    }
];


/***/ }),
/* 115 */
/***/ (function(module, exports) {

module.exports = [
    {
        'name': 'C',
        'alias': 'Other',
        'isBmpLast': true,
        'bmp': '\0-\x1F\x7F-\x9F\xAD\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EE\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB\u07FC\u082E\u082F\u083F\u085C\u085D\u085F\u086B-\u089F\u08B5\u08BE-\u08D2\u08E2\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A77-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D04\u0D0D\u0D11\u0D45\u0D49\u0D50-\u0D53\u0D64\u0D65\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C89-\u1C8F\u1CBB\u1CBC\u1CC8-\u1CCF\u1CFA-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20C0-\u20CF\u20F1-\u20FF\u218C-\u218F\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BC9\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E4F-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FF0-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7BA-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C6-\uA8CD\uA8DA-\uA8DF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF',
        'astral': '\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE49-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD28-\uDD2F\uDD3A-\uDE5F\uDE7F-\uDEFF\uDF28-\uDF2F\uDF5A-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCBD\uDCC2-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD47-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5A\uDC5C\uDC5F-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD806[\uDC3C-\uDC9F\uDCF3-\uDCFE\uDD00-\uDDFF\uDE48-\uDE4F\uDE84\uDE85\uDEA3-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF9-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD823-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83F\uD87B-\uD87D\uD87F-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE9B-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFDF\uDFE2-\uDFFF]|\uD821[\uDFF2-\uDFFF]|\uD822[\uDEF3-\uDFFF]|\uD82C[\uDD1F-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA0-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD73-\uDD7A\uDDE9-\uDDFF\uDE46-\uDEDF\uDEF4-\uDEFF\uDF57-\uDF5F\uDF79-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4B-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDC70\uDCB5-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD6C-\uDD6F\uDDAD-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDE5F\uDE66-\uDEFF]|\uD83D[\uDED5-\uDEDF\uDEED-\uDEEF\uDEFA-\uDEFF\uDF74-\uDF7F\uDFD9-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD0F\uDD3F\uDD71\uDD72\uDD77-\uDD79\uDD7B\uDDA3-\uDDAF\uDDBA-\uDDBF\uDDC3-\uDDCF\uDE00-\uDE5F\uDE6E-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]'
    },
    {
        'name': 'Cc',
        'alias': 'Control',
        'bmp': '\0-\x1F\x7F-\x9F'
    },
    {
        'name': 'Cf',
        'alias': 'Format',
        'bmp': '\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB',
        'astral': '\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]'
    },
    {
        'name': 'Cn',
        'alias': 'Unassigned',
        'bmp': '\u0378\u0379\u0380-\u0383\u038B\u038D\u03A2\u0530\u0557\u0558\u058B\u058C\u0590\u05C8-\u05CF\u05EB-\u05EE\u05F5-\u05FF\u061D\u070E\u074B\u074C\u07B2-\u07BF\u07FB\u07FC\u082E\u082F\u083F\u085C\u085D\u085F\u086B-\u089F\u08B5\u08BE-\u08D2\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A77-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D04\u0D0D\u0D11\u0D45\u0D49\u0D50-\u0D53\u0D64\u0D65\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F6\u13F7\u13FE\u13FF\u169D-\u169F\u16F9-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE\u1AAF\u1ABF-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C89-\u1C8F\u1CBB\u1CBC\u1CC8-\u1CCF\u1CFA-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u2065\u2072\u2073\u208F\u209D-\u209F\u20C0-\u20CF\u20F1-\u20FF\u218C-\u218F\u2427-\u243F\u244B-\u245F\u2B74\u2B75\u2B96\u2B97\u2BC9\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E4F-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FF0-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA6F8-\uA6FF\uA7BA-\uA7F6\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C6-\uA8CD\uA8DA-\uA8DF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB66-\uAB6F\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD\uFEFE\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFF8\uFFFE\uFFFF',
        'astral': '\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDCFF\uDD03-\uDD06\uDD34-\uDD36\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEFC-\uDEFF\uDF24-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDFC4-\uDFC7\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDD6E\uDD70-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56\uDC9F-\uDCA6\uDCB0-\uDCDF\uDCF3\uDCF6-\uDCFA\uDD1C-\uDD1E\uDD3A-\uDD3E\uDD40-\uDD7F\uDDB8-\uDDBB\uDDD0\uDDD1\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE49-\uDE4F\uDE59-\uDE5F\uDEA0-\uDEBF\uDEE7-\uDEEA\uDEF7-\uDEFF\uDF36-\uDF38\uDF56\uDF57\uDF73-\uDF77\uDF92-\uDF98\uDF9D-\uDFA8\uDFB0-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCF9\uDD28-\uDD2F\uDD3A-\uDE5F\uDE7F-\uDEFF\uDF28-\uDF2F\uDF5A-\uDFFF]|\uD804[\uDC4E-\uDC51\uDC70-\uDC7E\uDCC2-\uDCCC\uDCCE\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD47-\uDD4F\uDD77-\uDD7F\uDDCE\uDDCF\uDDE0\uDDF5-\uDDFF\uDE12\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEAA-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC5A\uDC5C\uDC5F-\uDC7F\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDDE-\uDDFF\uDE45-\uDE4F\uDE5A-\uDE5F\uDE6D-\uDE7F\uDEB8-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF40-\uDFFF]|\uD806[\uDC3C-\uDC9F\uDCF3-\uDCFE\uDD00-\uDDFF\uDE48-\uDE4F\uDE84\uDE85\uDEA3-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC46-\uDC4F\uDC6D-\uDC6F\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF9-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F\uDC75-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD823-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83F\uD87B-\uD87D\uD87F-\uDB3F\uDB41-\uDB7F][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDE6D\uDE70-\uDECF\uDEEE\uDEEF\uDEF6-\uDEFF\uDF46-\uDF4F\uDF5A\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE9B-\uDEFF\uDF45-\uDF4F\uDF7F-\uDF8E\uDFA0-\uDFDF\uDFE2-\uDFFF]|\uD821[\uDFF2-\uDFFF]|\uD822[\uDEF3-\uDFFF]|\uD82C[\uDD1F-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A\uDC9B\uDCA4-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDDE9-\uDDFF\uDE46-\uDEDF\uDEF4-\uDEFF\uDF57-\uDF5F\uDF79-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]|\uD836[\uDE8C-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDFFF]|\uD83A[\uDCC5\uDCC6\uDCD7-\uDCFF\uDD4B-\uDD4F\uDD5A-\uDD5D\uDD60-\uDFFF]|\uD83B[\uDC00-\uDC70\uDCB5-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDCFF\uDD0D-\uDD0F\uDD6C-\uDD6F\uDDAD-\uDDE5\uDE03-\uDE0F\uDE3C-\uDE3F\uDE49-\uDE4F\uDE52-\uDE5F\uDE66-\uDEFF]|\uD83D[\uDED5-\uDEDF\uDEED-\uDEEF\uDEFA-\uDEFF\uDF74-\uDF7F\uDFD9-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD0F\uDD3F\uDD71\uDD72\uDD77-\uDD79\uDD7B\uDDA3-\uDDAF\uDDBA-\uDDBF\uDDC3-\uDDCF\uDE00-\uDE5F\uDE6E-\uDFFF]|\uD869[\uDED7-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uDB40[\uDC00\uDC02-\uDC1F\uDC80-\uDCFF\uDDF0-\uDFFF]|[\uDBBF\uDBFF][\uDFFE\uDFFF]'
    },
    {
        'name': 'Co',
        'alias': 'Private_Use',
        'bmp': '\uE000-\uF8FF',
        'astral': '[\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uDBBF\uDBFF][\uDC00-\uDFFD]'
    },
    {
        'name': 'Cs',
        'alias': 'Surrogate',
        'bmp': '\uD800-\uDFFF'
    },
    {
        'name': 'L',
        'alias': 'Letter',
        'bmp': 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7B9\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
        'astral': '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFF1]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]'
    },
    {
        'name': 'LC',
        'alias': 'Cased_Letter',
        'bmp': 'A-Za-z\xB5\xC0-\xD6\xD8-\xF6\xF8-\u01BA\u01BC-\u01BF\u01C4-\u0293\u0295-\u02AF\u0370-\u0373\u0376\u0377\u037B-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0560-\u0588\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FD-\u10FF\u13A0-\u13F5\u13F8-\u13FD\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2134\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2C7B\u2C7E-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA640-\uA66D\uA680-\uA69B\uA722-\uA76F\uA771-\uA787\uA78B-\uA78E\uA790-\uA7B9\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A',
        'astral': '\uD801[\uDC00-\uDC4F\uDCB0-\uDCD3\uDCD8-\uDCFB]|\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD806[\uDCA0-\uDCDF]|\uD81B[\uDE40-\uDE7F]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDD00-\uDD43]'
    },
    {
        'name': 'Ll',
        'alias': 'Lowercase_Letter',
        'bmp': 'a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
        'astral': '\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]'
    },
    {
        'name': 'Lm',
        'alias': 'Modifier_Letter',
        'bmp': '\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D6A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA69C\uA69D\uA717-\uA71F\uA770\uA788\uA7F8\uA7F9\uA9CF\uA9E6\uAA70\uAADD\uAAF3\uAAF4\uAB5C-\uAB5F\uFF70\uFF9E\uFF9F',
        'astral': '\uD81A[\uDF40-\uDF43]|\uD81B[\uDF93-\uDF9F\uDFE0\uDFE1]'
    },
    {
        'name': 'Lo',
        'alias': 'Other_Letter',
        'bmp': '\xAA\xBA\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05EF-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1100-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u2135-\u2138\u2D30-\u2D67\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA78F\uA7F7\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9E0-\uA9E4\uA9E7-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAAE0-\uAAEA\uAAF2\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
        'astral': '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC50-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50]|\uD821[\uDC00-\uDFF1]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]'
    },
    {
        'name': 'Lt',
        'alias': 'Titlecase_Letter',
        'bmp': '\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC'
    },
    {
        'name': 'Lu',
        'alias': 'Uppercase_Letter',
        'bmp': 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1C90-\u1CBA\u1CBD-\u1CBF\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uA7B8\uFF21-\uFF3A',
        'astral': '\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD81B[\uDE40-\uDE5F]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]'
    },
    {
        'name': 'M',
        'alias': 'Mark',
        'bmp': '\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
        'astral': '\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDF46-\uDF50]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD45\uDD46\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDC9-\uDDCC\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDF00-\uDF03\uDF3B\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDC5E\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDEAB-\uDEB7\uDF1D-\uDF2B]|\uD806[\uDC2C-\uDC3A\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE3E\uDE47\uDE51-\uDE5B\uDE8A-\uDE99]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD8A-\uDD8E\uDD90\uDD91\uDD93-\uDD97\uDEF3-\uDEF6]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]'
    },
    {
        'name': 'Mc',
        'alias': 'Spacing_Mark',
        'bmp': '\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BE-\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062-\u1064\u1067-\u106D\u1083\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF2\u1CF3\u1CF7\u302E\u302F\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAA7B\uAA7D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC',
        'astral': '\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3E\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB0-\uDCB2\uDCB9\uDCBB-\uDCBE\uDCC1\uDDAF-\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF20\uDF21\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF7E]|\uD834[\uDD65\uDD66\uDD6D-\uDD72]'
    },
    {
        'name': 'Me',
        'alias': 'Enclosing_Mark',
        'bmp': '\u0488\u0489\u1ABE\u20DD-\u20E0\u20E2-\u20E4\uA670-\uA672'
    },
    {
        'name': 'Mn',
        'alias': 'Nonspacing_Mark',
        'bmp': '\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F',
        'astral': '\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF40\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB3-\uDCB8\uDCBA\uDCBF\uDCC0\uDCC2\uDCC3\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF]'
    },
    {
        'name': 'N',
        'alias': 'Number',
        'bmp': '0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
        'astral': '\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4]|\uD83C[\uDD00-\uDD0C]'
    },
    {
        'name': 'Nd',
        'alias': 'Decimal_Number',
        'bmp': '0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19',
        'astral': '\uD801[\uDCA0-\uDCA9]|\uD803[\uDD30-\uDD39]|\uD804[\uDC66-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF39]|\uD806[\uDCE0-\uDCE9]|\uD807[\uDC50-\uDC59\uDD50-\uDD59\uDDA0-\uDDA9]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDD50-\uDD59]'
    },
    {
        'name': 'Nl',
        'alias': 'Letter_Number',
        'bmp': '\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF',
        'astral': '\uD800[\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]|\uD809[\uDC00-\uDC6E]'
    },
    {
        'name': 'No',
        'alias': 'Other_Number',
        'bmp': '\xB2\xB3\xB9\xBC-\xBE\u09F4-\u09F9\u0B72-\u0B77\u0BF0-\u0BF2\u0C78-\u0C7E\u0D58-\u0D5E\u0D70-\u0D78\u0F2A-\u0F33\u1369-\u137C\u17F0-\u17F9\u19DA\u2070\u2074-\u2079\u2080-\u2089\u2150-\u215F\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA830-\uA835',
        'astral': '\uD800[\uDD07-\uDD33\uDD75-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54]|\uD804[\uDC52-\uDC65\uDDE1-\uDDF4]|\uD805[\uDF3A\uDF3B]|\uD806[\uDCEA-\uDCF2]|\uD807[\uDC5A-\uDC6C]|\uD81A[\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD83A[\uDCC7-\uDCCF]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4]|\uD83C[\uDD00-\uDD0C]'
    },
    {
        'name': 'P',
        'alias': 'Punctuation',
        'bmp': '!-#%-\\*,-\\/:;\\?@\\[-\\]_\\{\\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65',
        'astral': '\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]'
    },
    {
        'name': 'Pc',
        'alias': 'Connector_Punctuation',
        'bmp': '_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F'
    },
    {
        'name': 'Pd',
        'alias': 'Dash_Punctuation',
        'bmp': '\\-\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u2E40\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D'
    },
    {
        'name': 'Pe',
        'alias': 'Close_Punctuation',
        'bmp': '\\)\\]\\}\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63'
    },
    {
        'name': 'Pf',
        'alias': 'Final_Punctuation',
        'bmp': '\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21'
    },
    {
        'name': 'Pi',
        'alias': 'Initial_Punctuation',
        'bmp': '\xAB\u2018\u201B\u201C\u201F\u2039\u2E02\u2E04\u2E09\u2E0C\u2E1C\u2E20'
    },
    {
        'name': 'Po',
        'alias': 'Other_Punctuation',
        'bmp': '!-#%-\'\\*,\\.\\/:;\\?@\\\xA1\xA7\xB6\xB7\xBF\u037E\u0387\u055A-\u055F\u0589\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u166D\u166E\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u1805\u1807-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2016\u2017\u2020-\u2027\u2030-\u2038\u203B-\u203E\u2041-\u2043\u2047-\u2051\u2053\u2055-\u205E\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E06-\u2E08\u2E0B\u2E0E-\u2E16\u2E18\u2E19\u2E1B\u2E1E\u2E1F\u2E2A-\u2E2E\u2E30-\u2E39\u2E3C-\u2E3F\u2E41\u2E43-\u2E4E\u3001-\u3003\u303D\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFE10-\uFE16\uFE19\uFE30\uFE45\uFE46\uFE49-\uFE4C\uFE50-\uFE52\uFE54-\uFE57\uFE5F-\uFE61\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF07\uFF0A\uFF0C\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3C\uFF61\uFF64\uFF65',
        'astral': '\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]'
    },
    {
        'name': 'Ps',
        'alias': 'Open_Punctuation',
        'bmp': '\\(\\[\\{\u0F3A\u0F3C\u169B\u201A\u201E\u2045\u207D\u208D\u2308\u230A\u2329\u2768\u276A\u276C\u276E\u2770\u2772\u2774\u27C5\u27E6\u27E8\u27EA\u27EC\u27EE\u2983\u2985\u2987\u2989\u298B\u298D\u298F\u2991\u2993\u2995\u2997\u29D8\u29DA\u29FC\u2E22\u2E24\u2E26\u2E28\u2E42\u3008\u300A\u300C\u300E\u3010\u3014\u3016\u3018\u301A\u301D\uFD3F\uFE17\uFE35\uFE37\uFE39\uFE3B\uFE3D\uFE3F\uFE41\uFE43\uFE47\uFE59\uFE5B\uFE5D\uFF08\uFF3B\uFF5B\uFF5F\uFF62'
    },
    {
        'name': 'S',
        'alias': 'Symbol',
        'bmp': '\\$\\+<->\\^`\\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20BF\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B98-\u2BC8\u2BCA-\u2BFE\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uFB29\uFBB2-\uFBC1\uFDFC\uFDFD\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD',
        'astral': '\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD83B[\uDCAC\uDCB0\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD6B\uDD70-\uDDAC\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED4\uDEE0-\uDEEC\uDEF0-\uDEF9\uDF00-\uDF73\uDF80-\uDFD8]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD00-\uDD0B\uDD10-\uDD3E\uDD40-\uDD70\uDD73-\uDD76\uDD7A\uDD7C-\uDDA2\uDDB0-\uDDB9\uDDC0-\uDDC2\uDDD0-\uDDFF\uDE60-\uDE6D]'
    },
    {
        'name': 'Sc',
        'alias': 'Currency_Symbol',
        'bmp': '\\$\xA2-\xA5\u058F\u060B\u07FE\u07FF\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BF\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6',
        'astral': '\uD83B\uDCB0'
    },
    {
        'name': 'Sk',
        'alias': 'Modifier_Symbol',
        'bmp': '\\^`\xA8\xAF\xB4\xB8\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u309B\u309C\uA700-\uA716\uA720\uA721\uA789\uA78A\uAB5B\uFBB2-\uFBC1\uFF3E\uFF40\uFFE3',
        'astral': '\uD83C[\uDFFB-\uDFFF]'
    },
    {
        'name': 'Sm',
        'alias': 'Math_Symbol',
        'bmp': '\\+<->\\|~\xAC\xB1\xD7\xF7\u03F6\u0606-\u0608\u2044\u2052\u207A-\u207C\u208A-\u208C\u2118\u2140-\u2144\u214B\u2190-\u2194\u219A\u219B\u21A0\u21A3\u21A6\u21AE\u21CE\u21CF\u21D2\u21D4\u21F4-\u22FF\u2320\u2321\u237C\u239B-\u23B3\u23DC-\u23E1\u25B7\u25C1\u25F8-\u25FF\u266F\u27C0-\u27C4\u27C7-\u27E5\u27F0-\u27FF\u2900-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2AFF\u2B30-\u2B44\u2B47-\u2B4C\uFB29\uFE62\uFE64-\uFE66\uFF0B\uFF1C-\uFF1E\uFF5C\uFF5E\uFFE2\uFFE9-\uFFEC',
        'astral': '\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD83B[\uDEF0\uDEF1]'
    },
    {
        'name': 'So',
        'alias': 'Other_Symbol',
        'bmp': '\xA6\xA9\xAE\xB0\u0482\u058D\u058E\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u09FA\u0B70\u0BF3-\u0BF8\u0BFA\u0C7F\u0D4F\u0D79\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116\u2117\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u214A\u214C\u214D\u214F\u218A\u218B\u2195-\u2199\u219C-\u219F\u21A1\u21A2\u21A4\u21A5\u21A7-\u21AD\u21AF-\u21CD\u21D0\u21D1\u21D3\u21D5-\u21F3\u2300-\u2307\u230C-\u231F\u2322-\u2328\u232B-\u237B\u237D-\u239A\u23B4-\u23DB\u23E2-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u25B6\u25B8-\u25C0\u25C2-\u25F7\u2600-\u266E\u2670-\u2767\u2794-\u27BF\u2800-\u28FF\u2B00-\u2B2F\u2B45\u2B46\u2B4D-\u2B73\u2B76-\u2B95\u2B98-\u2BC8\u2BCA-\u2BFE\u2CE5-\u2CEA\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u32FE\u3300-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA828-\uA82B\uA836\uA837\uA839\uAA77-\uAA79\uFDFD\uFFE4\uFFE8\uFFED\uFFEE\uFFFC\uFFFD',
        'astral': '\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9B\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD83B\uDCAC|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD10-\uDD6B\uDD70-\uDDAC\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFA]|\uD83D[\uDC00-\uDED4\uDEE0-\uDEEC\uDEF0-\uDEF9\uDF00-\uDF73\uDF80-\uDFD8]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD00-\uDD0B\uDD10-\uDD3E\uDD40-\uDD70\uDD73-\uDD76\uDD7A\uDD7C-\uDDA2\uDDB0-\uDDB9\uDDC0-\uDDC2\uDDD0-\uDDFF\uDE60-\uDE6D]'
    },
    {
        'name': 'Z',
        'alias': 'Separator',
        'bmp': ' \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
    },
    {
        'name': 'Zl',
        'alias': 'Line_Separator',
        'bmp': '\u2028'
    },
    {
        'name': 'Zp',
        'alias': 'Paragraph_Separator',
        'bmp': '\u2029'
    },
    {
        'name': 'Zs',
        'alias': 'Space_Separator',
        'bmp': ' \xA0\u1680\u2000-\u200A\u202F\u205F\u3000'
    }
];


/***/ }),
/* 116 */
/***/ (function(module, exports) {

module.exports = [
    {
        'name': 'ASCII',
        'bmp': '\0-\x7F'
    },
    {
        'name': 'Alphabetic',
        'bmp': 'A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0345\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05B0-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0657\u0659-\u065F\u066E-\u06D3\u06D5-\u06DC\u06E1-\u06E8\u06ED-\u06EF\u06FA-\u06FC\u06FF\u0710-\u073F\u074D-\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0817\u081A-\u082C\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08DF\u08E3-\u08E9\u08F0-\u093B\u093D-\u094C\u094E-\u0950\u0955-\u0963\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C4\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09F0\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A42\u0A47\u0A48\u0A4B\u0A4C\u0A51\u0A59-\u0A5C\u0A5E\u0A70-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC5\u0AC7-\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0-\u0AE3\u0AF9-\u0AFC\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D-\u0B44\u0B47\u0B48\u0B4B\u0B4C\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4C\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCC\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E46\u0E4D\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0ECD\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F71-\u0F81\u0F88-\u0F97\u0F99-\u0FBC\u1000-\u1036\u1038\u103B-\u103F\u1050-\u1062\u1065-\u1068\u106E-\u1086\u108E\u109C\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1713\u1720-\u1733\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17B3\u17B6-\u17C8\u17D7\u17DC\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u1938\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A1B\u1A20-\u1A5E\u1A61-\u1A74\u1AA7\u1B00-\u1B33\u1B35-\u1B43\u1B45-\u1B4B\u1B80-\u1BA9\u1BAC-\u1BAF\u1BBA-\u1BE5\u1BE7-\u1BF1\u1C00-\u1C35\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1D00-\u1DBF\u1DE7-\u1DF4\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u24B6-\u24E9\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA674-\uA67B\uA67F-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7B9\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA827\uA840-\uA873\uA880-\uA8C3\uA8C5\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA92A\uA930-\uA952\uA960-\uA97C\uA980-\uA9B2\uA9B4-\uA9BF\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA60-\uAA76\uAA7A\uAA7E-\uAABE\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC',
        'astral': '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD27\uDF00-\uDF1C\uDF27\uDF30-\uDF45]|\uD804[\uDC00-\uDC45\uDC82-\uDCB8\uDCD0-\uDCE8\uDD00-\uDD32\uDD44-\uDD46\uDD50-\uDD72\uDD76\uDD80-\uDDBF\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE34\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEE8\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D-\uDF44\uDF47\uDF48\uDF4B\uDF4C\uDF50\uDF57\uDF5D-\uDF63]|\uD805[\uDC00-\uDC41\uDC43-\uDC45\uDC47-\uDC4A\uDC80-\uDCC1\uDCC4\uDCC5\uDCC7\uDD80-\uDDB5\uDDB8-\uDDBE\uDDD8-\uDDDD\uDE00-\uDE3E\uDE40\uDE44\uDE80-\uDEB5\uDF00-\uDF1A\uDF1D-\uDF2A]|\uD806[\uDC00-\uDC38\uDCA0-\uDCDF\uDCFF\uDE00-\uDE32\uDE35-\uDE3E\uDE50-\uDE83\uDE86-\uDE97\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC3E\uDC40\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD41\uDD43\uDD46\uDD47\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD96\uDD98\uDEE0-\uDEF6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF36\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF44\uDF50-\uDF7E\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFF1]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9E]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD47]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]'
    },
    {
        'name': 'Any',
        'isBmpLast': true,
        'bmp': '\0-\uFFFF',
        'astral': '[\uD800-\uDBFF][\uDC00-\uDFFF]'
    },
    {
        'name': 'Default_Ignorable_Code_Point',
        'bmp': '\xAD\u034F\u061C\u115F\u1160\u17B4\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8',
        'astral': '\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|[\uDB40-\uDB43][\uDC00-\uDFFF]'
    },
    {
        'name': 'Lowercase',
        'bmp': 'a-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02B8\u02C0\u02C1\u02E0-\u02E4\u0345\u0371\u0373\u0377\u037A-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1DBF\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u2071\u207F\u2090-\u209C\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2170-\u217F\u2184\u24D0-\u24E9\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7D\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B-\uA69D\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7F8-\uA7FA\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A',
        'astral': '\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43]'
    },
    {
        'name': 'Noncharacter_Code_Point',
        'bmp': '\uFDD0-\uFDEF\uFFFE\uFFFF',
        'astral': '[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]'
    },
    {
        'name': 'Uppercase',
        'bmp': 'A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1C90-\u1CBA\u1CBD-\u1CBF\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2160-\u216F\u2183\u24B6-\u24CF\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AE\uA7B0-\uA7B4\uA7B6\uA7B8\uFF21-\uFF3A',
        'astral': '\uD801[\uDC00-\uDC27\uDCB0-\uDCD3]|\uD803[\uDC80-\uDCB2]|\uD806[\uDCA0-\uDCBF]|\uD81B[\uDE40-\uDE5F]|\uD835[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA]|\uD83A[\uDD00-\uDD21]|\uD83C[\uDD30-\uDD49\uDD50-\uDD69\uDD70-\uDD89]'
    },
    {
        'name': 'White_Space',
        'bmp': '\t-\r \x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000'
    }
];


/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = [
    {
        'name': 'Adlam',
        'astral': '\uD83A[\uDD00-\uDD4A\uDD50-\uDD59\uDD5E\uDD5F]'
    },
    {
        'name': 'Ahom',
        'astral': '\uD805[\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF3F]'
    },
    {
        'name': 'Anatolian_Hieroglyphs',
        'astral': '\uD811[\uDC00-\uDE46]'
    },
    {
        'name': 'Arabic',
        'bmp': '\u0600-\u0604\u0606-\u060B\u060D-\u061A\u061C\u061E\u0620-\u063F\u0641-\u064A\u0656-\u066F\u0671-\u06DC\u06DE-\u06FF\u0750-\u077F\u08A0-\u08B4\u08B6-\u08BD\u08D3-\u08E1\u08E3-\u08FF\uFB50-\uFBC1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFD\uFE70-\uFE74\uFE76-\uFEFC',
        'astral': '\uD803[\uDE60-\uDE7E]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB\uDEF0\uDEF1]'
    },
    {
        'name': 'Armenian',
        'bmp': '\u0531-\u0556\u0559-\u0588\u058A\u058D-\u058F\uFB13-\uFB17'
    },
    {
        'name': 'Avestan',
        'astral': '\uD802[\uDF00-\uDF35\uDF39-\uDF3F]'
    },
    {
        'name': 'Balinese',
        'bmp': '\u1B00-\u1B4B\u1B50-\u1B7C'
    },
    {
        'name': 'Bamum',
        'bmp': '\uA6A0-\uA6F7',
        'astral': '\uD81A[\uDC00-\uDE38]'
    },
    {
        'name': 'Bassa_Vah',
        'astral': '\uD81A[\uDED0-\uDEED\uDEF0-\uDEF5]'
    },
    {
        'name': 'Batak',
        'bmp': '\u1BC0-\u1BF3\u1BFC-\u1BFF'
    },
    {
        'name': 'Bengali',
        'bmp': '\u0980-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FE'
    },
    {
        'name': 'Bhaiksuki',
        'astral': '\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC45\uDC50-\uDC6C]'
    },
    {
        'name': 'Bopomofo',
        'bmp': '\u02EA\u02EB\u3105-\u312F\u31A0-\u31BA'
    },
    {
        'name': 'Brahmi',
        'astral': '\uD804[\uDC00-\uDC4D\uDC52-\uDC6F\uDC7F]'
    },
    {
        'name': 'Braille',
        'bmp': '\u2800-\u28FF'
    },
    {
        'name': 'Buginese',
        'bmp': '\u1A00-\u1A1B\u1A1E\u1A1F'
    },
    {
        'name': 'Buhid',
        'bmp': '\u1740-\u1753'
    },
    {
        'name': 'Canadian_Aboriginal',
        'bmp': '\u1400-\u167F\u18B0-\u18F5'
    },
    {
        'name': 'Carian',
        'astral': '\uD800[\uDEA0-\uDED0]'
    },
    {
        'name': 'Caucasian_Albanian',
        'astral': '\uD801[\uDD30-\uDD63\uDD6F]'
    },
    {
        'name': 'Chakma',
        'astral': '\uD804[\uDD00-\uDD34\uDD36-\uDD46]'
    },
    {
        'name': 'Cham',
        'bmp': '\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAA5F'
    },
    {
        'name': 'Cherokee',
        'bmp': '\u13A0-\u13F5\u13F8-\u13FD\uAB70-\uABBF'
    },
    {
        'name': 'Common',
        'bmp': '\0-@\\[-`\\{-\xA9\xAB-\xB9\xBB-\xBF\xD7\xF7\u02B9-\u02DF\u02E5-\u02E9\u02EC-\u02FF\u0374\u037E\u0385\u0387\u0589\u0605\u060C\u061B\u061F\u0640\u06DD\u08E2\u0964\u0965\u0E3F\u0FD5-\u0FD8\u10FB\u16EB-\u16ED\u1735\u1736\u1802\u1803\u1805\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u2000-\u200B\u200E-\u2064\u2066-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20BF\u2100-\u2125\u2127-\u2129\u212C-\u2131\u2133-\u214D\u214F-\u215F\u2189-\u218B\u2190-\u2426\u2440-\u244A\u2460-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B98-\u2BC8\u2BCA-\u2BFE\u2E00-\u2E4E\u2FF0-\u2FFB\u3000-\u3004\u3006\u3008-\u3020\u3030-\u3037\u303C-\u303F\u309B\u309C\u30A0\u30FB\u30FC\u3190-\u319F\u31C0-\u31E3\u3220-\u325F\u327F-\u32CF\u3358-\u33FF\u4DC0-\u4DFF\uA700-\uA721\uA788-\uA78A\uA830-\uA839\uA92E\uA9CF\uAB5B\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFF70\uFF9E\uFF9F\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD',
        'astral': '\uD800[\uDD00-\uDD02\uDD07-\uDD33\uDD37-\uDD3F\uDD90-\uDD9B\uDDD0-\uDDFC\uDEE1-\uDEFB]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD66\uDD6A-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDE8\uDEE0-\uDEF3\uDF00-\uDF56\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDFCB\uDFCE-\uDFFF]|\uD83B[\uDC71-\uDCB4]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD00-\uDD0C\uDD10-\uDD6B\uDD70-\uDDAC\uDDE6-\uDDFF\uDE01\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED4\uDEE0-\uDEEC\uDEF0-\uDEF9\uDF00-\uDF73\uDF80-\uDFD8]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDD00-\uDD0B\uDD10-\uDD3E\uDD40-\uDD70\uDD73-\uDD76\uDD7A\uDD7C-\uDDA2\uDDB0-\uDDB9\uDDC0-\uDDC2\uDDD0-\uDDFF\uDE60-\uDE6D]|\uDB40[\uDC01\uDC20-\uDC7F]'
    },
    {
        'name': 'Coptic',
        'bmp': '\u03E2-\u03EF\u2C80-\u2CF3\u2CF9-\u2CFF'
    },
    {
        'name': 'Cuneiform',
        'astral': '\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC70-\uDC74\uDC80-\uDD43]'
    },
    {
        'name': 'Cypriot',
        'astral': '\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F]'
    },
    {
        'name': 'Cyrillic',
        'bmp': '\u0400-\u0484\u0487-\u052F\u1C80-\u1C88\u1D2B\u1D78\u2DE0-\u2DFF\uA640-\uA69F\uFE2E\uFE2F'
    },
    {
        'name': 'Deseret',
        'astral': '\uD801[\uDC00-\uDC4F]'
    },
    {
        'name': 'Devanagari',
        'bmp': '\u0900-\u0950\u0953-\u0963\u0966-\u097F\uA8E0-\uA8FF'
    },
    {
        'name': 'Dogra',
        'astral': '\uD806[\uDC00-\uDC3B]'
    },
    {
        'name': 'Duployan',
        'astral': '\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9C-\uDC9F]'
    },
    {
        'name': 'Egyptian_Hieroglyphs',
        'astral': '\uD80C[\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]'
    },
    {
        'name': 'Elbasan',
        'astral': '\uD801[\uDD00-\uDD27]'
    },
    {
        'name': 'Ethiopic',
        'bmp': '\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E'
    },
    {
        'name': 'Georgian',
        'bmp': '\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u10FF\u1C90-\u1CBA\u1CBD-\u1CBF\u2D00-\u2D25\u2D27\u2D2D'
    },
    {
        'name': 'Glagolitic',
        'bmp': '\u2C00-\u2C2E\u2C30-\u2C5E',
        'astral': '\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]'
    },
    {
        'name': 'Gothic',
        'astral': '\uD800[\uDF30-\uDF4A]'
    },
    {
        'name': 'Grantha',
        'astral': '\uD804[\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]'
    },
    {
        'name': 'Greek',
        'bmp': '\u0370-\u0373\u0375-\u0377\u037A-\u037D\u037F\u0384\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126\uAB65',
        'astral': '\uD800[\uDD40-\uDD8E\uDDA0]|\uD834[\uDE00-\uDE45]'
    },
    {
        'name': 'Gujarati',
        'bmp': '\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9-\u0AFF'
    },
    {
        'name': 'Gunjala_Gondi',
        'astral': '\uD807[\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9]'
    },
    {
        'name': 'Gurmukhi',
        'bmp': '\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A76'
    },
    {
        'name': 'Han',
        'bmp': '\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u3005\u3007\u3021-\u3029\u3038-\u303B\u3400-\u4DB5\u4E00-\u9FEF\uF900-\uFA6D\uFA70-\uFAD9',
        'astral': '[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]'
    },
    {
        'name': 'Hangul',
        'bmp': '\u1100-\u11FF\u302E\u302F\u3131-\u318E\u3200-\u321E\u3260-\u327E\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC'
    },
    {
        'name': 'Hanifi_Rohingya',
        'astral': '\uD803[\uDD00-\uDD27\uDD30-\uDD39]'
    },
    {
        'name': 'Hanunoo',
        'bmp': '\u1720-\u1734'
    },
    {
        'name': 'Hatran',
        'astral': '\uD802[\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDCFF]'
    },
    {
        'name': 'Hebrew',
        'bmp': '\u0591-\u05C7\u05D0-\u05EA\u05EF-\u05F4\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFB4F'
    },
    {
        'name': 'Hiragana',
        'bmp': '\u3041-\u3096\u309D-\u309F',
        'astral': '\uD82C[\uDC01-\uDD1E]|\uD83C\uDE00'
    },
    {
        'name': 'Imperial_Aramaic',
        'astral': '\uD802[\uDC40-\uDC55\uDC57-\uDC5F]'
    },
    {
        'name': 'Inherited',
        'bmp': '\u0300-\u036F\u0485\u0486\u064B-\u0655\u0670\u0951\u0952\u1AB0-\u1ABE\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u200D\u20D0-\u20F0\u302A-\u302D\u3099\u309A\uFE00-\uFE0F\uFE20-\uFE2D',
        'astral': '\uD800[\uDDFD\uDEE0]|\uD804\uDF3B|\uD834[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD]|\uDB40[\uDD00-\uDDEF]'
    },
    {
        'name': 'Inscriptional_Pahlavi',
        'astral': '\uD802[\uDF60-\uDF72\uDF78-\uDF7F]'
    },
    {
        'name': 'Inscriptional_Parthian',
        'astral': '\uD802[\uDF40-\uDF55\uDF58-\uDF5F]'
    },
    {
        'name': 'Javanese',
        'bmp': '\uA980-\uA9CD\uA9D0-\uA9D9\uA9DE\uA9DF'
    },
    {
        'name': 'Kaithi',
        'astral': '\uD804[\uDC80-\uDCC1\uDCCD]'
    },
    {
        'name': 'Kannada',
        'bmp': '\u0C80-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2'
    },
    {
        'name': 'Katakana',
        'bmp': '\u30A1-\u30FA\u30FD-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF6F\uFF71-\uFF9D',
        'astral': '\uD82C\uDC00'
    },
    {
        'name': 'Kayah_Li',
        'bmp': '\uA900-\uA92D\uA92F'
    },
    {
        'name': 'Kharoshthi',
        'astral': '\uD802[\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F-\uDE48\uDE50-\uDE58]'
    },
    {
        'name': 'Khmer',
        'bmp': '\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u19E0-\u19FF'
    },
    {
        'name': 'Khojki',
        'astral': '\uD804[\uDE00-\uDE11\uDE13-\uDE3E]'
    },
    {
        'name': 'Khudawadi',
        'astral': '\uD804[\uDEB0-\uDEEA\uDEF0-\uDEF9]'
    },
    {
        'name': 'Lao',
        'bmp': '\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF'
    },
    {
        'name': 'Latin',
        'bmp': 'A-Za-z\xAA\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02E0-\u02E4\u1D00-\u1D25\u1D2C-\u1D5C\u1D62-\u1D65\u1D6B-\u1D77\u1D79-\u1DBE\u1E00-\u1EFF\u2071\u207F\u2090-\u209C\u212A\u212B\u2132\u214E\u2160-\u2188\u2C60-\u2C7F\uA722-\uA787\uA78B-\uA7B9\uA7F7-\uA7FF\uAB30-\uAB5A\uAB5C-\uAB64\uFB00-\uFB06\uFF21-\uFF3A\uFF41-\uFF5A'
    },
    {
        'name': 'Lepcha',
        'bmp': '\u1C00-\u1C37\u1C3B-\u1C49\u1C4D-\u1C4F'
    },
    {
        'name': 'Limbu',
        'bmp': '\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u194F'
    },
    {
        'name': 'Linear_A',
        'astral': '\uD801[\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]'
    },
    {
        'name': 'Linear_B',
        'astral': '\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA]'
    },
    {
        'name': 'Lisu',
        'bmp': '\uA4D0-\uA4FF'
    },
    {
        'name': 'Lycian',
        'astral': '\uD800[\uDE80-\uDE9C]'
    },
    {
        'name': 'Lydian',
        'astral': '\uD802[\uDD20-\uDD39\uDD3F]'
    },
    {
        'name': 'Mahajani',
        'astral': '\uD804[\uDD50-\uDD76]'
    },
    {
        'name': 'Makasar',
        'astral': '\uD807[\uDEE0-\uDEF8]'
    },
    {
        'name': 'Malayalam',
        'bmp': '\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F'
    },
    {
        'name': 'Mandaic',
        'bmp': '\u0840-\u085B\u085E'
    },
    {
        'name': 'Manichaean',
        'astral': '\uD802[\uDEC0-\uDEE6\uDEEB-\uDEF6]'
    },
    {
        'name': 'Marchen',
        'astral': '\uD807[\uDC70-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]'
    },
    {
        'name': 'Masaram_Gondi',
        'astral': '\uD807[\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]'
    },
    {
        'name': 'Medefaidrin',
        'astral': '\uD81B[\uDE40-\uDE9A]'
    },
    {
        'name': 'Meetei_Mayek',
        'bmp': '\uAAE0-\uAAF6\uABC0-\uABED\uABF0-\uABF9'
    },
    {
        'name': 'Mende_Kikakui',
        'astral': '\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6]'
    },
    {
        'name': 'Meroitic_Cursive',
        'astral': '\uD802[\uDDA0-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDDFF]'
    },
    {
        'name': 'Meroitic_Hieroglyphs',
        'astral': '\uD802[\uDD80-\uDD9F]'
    },
    {
        'name': 'Miao',
        'astral': '\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]'
    },
    {
        'name': 'Modi',
        'astral': '\uD805[\uDE00-\uDE44\uDE50-\uDE59]'
    },
    {
        'name': 'Mongolian',
        'bmp': '\u1800\u1801\u1804\u1806-\u180E\u1810-\u1819\u1820-\u1878\u1880-\u18AA',
        'astral': '\uD805[\uDE60-\uDE6C]'
    },
    {
        'name': 'Mro',
        'astral': '\uD81A[\uDE40-\uDE5E\uDE60-\uDE69\uDE6E\uDE6F]'
    },
    {
        'name': 'Multani',
        'astral': '\uD804[\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA9]'
    },
    {
        'name': 'Myanmar',
        'bmp': '\u1000-\u109F\uA9E0-\uA9FE\uAA60-\uAA7F'
    },
    {
        'name': 'Nabataean',
        'astral': '\uD802[\uDC80-\uDC9E\uDCA7-\uDCAF]'
    },
    {
        'name': 'New_Tai_Lue',
        'bmp': '\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE\u19DF'
    },
    {
        'name': 'Newa',
        'astral': '\uD805[\uDC00-\uDC59\uDC5B\uDC5D\uDC5E]'
    },
    {
        'name': 'Nko',
        'bmp': '\u07C0-\u07FA\u07FD-\u07FF'
    },
    {
        'name': 'Nushu',
        'astral': '\uD81B\uDFE1|\uD82C[\uDD70-\uDEFB]'
    },
    {
        'name': 'Ogham',
        'bmp': '\u1680-\u169C'
    },
    {
        'name': 'Ol_Chiki',
        'bmp': '\u1C50-\u1C7F'
    },
    {
        'name': 'Old_Hungarian',
        'astral': '\uD803[\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDCFF]'
    },
    {
        'name': 'Old_Italic',
        'astral': '\uD800[\uDF00-\uDF23\uDF2D-\uDF2F]'
    },
    {
        'name': 'Old_North_Arabian',
        'astral': '\uD802[\uDE80-\uDE9F]'
    },
    {
        'name': 'Old_Permic',
        'astral': '\uD800[\uDF50-\uDF7A]'
    },
    {
        'name': 'Old_Persian',
        'astral': '\uD800[\uDFA0-\uDFC3\uDFC8-\uDFD5]'
    },
    {
        'name': 'Old_Sogdian',
        'astral': '\uD803[\uDF00-\uDF27]'
    },
    {
        'name': 'Old_South_Arabian',
        'astral': '\uD802[\uDE60-\uDE7F]'
    },
    {
        'name': 'Old_Turkic',
        'astral': '\uD803[\uDC00-\uDC48]'
    },
    {
        'name': 'Oriya',
        'bmp': '\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77'
    },
    {
        'name': 'Osage',
        'astral': '\uD801[\uDCB0-\uDCD3\uDCD8-\uDCFB]'
    },
    {
        'name': 'Osmanya',
        'astral': '\uD801[\uDC80-\uDC9D\uDCA0-\uDCA9]'
    },
    {
        'name': 'Pahawh_Hmong',
        'astral': '\uD81A[\uDF00-\uDF45\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]'
    },
    {
        'name': 'Palmyrene',
        'astral': '\uD802[\uDC60-\uDC7F]'
    },
    {
        'name': 'Pau_Cin_Hau',
        'astral': '\uD806[\uDEC0-\uDEF8]'
    },
    {
        'name': 'Phags_Pa',
        'bmp': '\uA840-\uA877'
    },
    {
        'name': 'Phoenician',
        'astral': '\uD802[\uDD00-\uDD1B\uDD1F]'
    },
    {
        'name': 'Psalter_Pahlavi',
        'astral': '\uD802[\uDF80-\uDF91\uDF99-\uDF9C\uDFA9-\uDFAF]'
    },
    {
        'name': 'Rejang',
        'bmp': '\uA930-\uA953\uA95F'
    },
    {
        'name': 'Runic',
        'bmp': '\u16A0-\u16EA\u16EE-\u16F8'
    },
    {
        'name': 'Samaritan',
        'bmp': '\u0800-\u082D\u0830-\u083E'
    },
    {
        'name': 'Saurashtra',
        'bmp': '\uA880-\uA8C5\uA8CE-\uA8D9'
    },
    {
        'name': 'Sharada',
        'astral': '\uD804[\uDD80-\uDDCD\uDDD0-\uDDDF]'
    },
    {
        'name': 'Shavian',
        'astral': '\uD801[\uDC50-\uDC7F]'
    },
    {
        'name': 'Siddham',
        'astral': '\uD805[\uDD80-\uDDB5\uDDB8-\uDDDD]'
    },
    {
        'name': 'SignWriting',
        'astral': '\uD836[\uDC00-\uDE8B\uDE9B-\uDE9F\uDEA1-\uDEAF]'
    },
    {
        'name': 'Sinhala',
        'bmp': '\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4',
        'astral': '\uD804[\uDDE1-\uDDF4]'
    },
    {
        'name': 'Sogdian',
        'astral': '\uD803[\uDF30-\uDF59]'
    },
    {
        'name': 'Sora_Sompeng',
        'astral': '\uD804[\uDCD0-\uDCE8\uDCF0-\uDCF9]'
    },
    {
        'name': 'Soyombo',
        'astral': '\uD806[\uDE50-\uDE83\uDE86-\uDEA2]'
    },
    {
        'name': 'Sundanese',
        'bmp': '\u1B80-\u1BBF\u1CC0-\u1CC7'
    },
    {
        'name': 'Syloti_Nagri',
        'bmp': '\uA800-\uA82B'
    },
    {
        'name': 'Syriac',
        'bmp': '\u0700-\u070D\u070F-\u074A\u074D-\u074F\u0860-\u086A'
    },
    {
        'name': 'Tagalog',
        'bmp': '\u1700-\u170C\u170E-\u1714'
    },
    {
        'name': 'Tagbanwa',
        'bmp': '\u1760-\u176C\u176E-\u1770\u1772\u1773'
    },
    {
        'name': 'Tai_Le',
        'bmp': '\u1950-\u196D\u1970-\u1974'
    },
    {
        'name': 'Tai_Tham',
        'bmp': '\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD'
    },
    {
        'name': 'Tai_Viet',
        'bmp': '\uAA80-\uAAC2\uAADB-\uAADF'
    },
    {
        'name': 'Takri',
        'astral': '\uD805[\uDE80-\uDEB7\uDEC0-\uDEC9]'
    },
    {
        'name': 'Tamil',
        'bmp': '\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA'
    },
    {
        'name': 'Tangut',
        'astral': '\uD81B\uDFE0|[\uD81C-\uD820][\uDC00-\uDFFF]|\uD821[\uDC00-\uDFF1]|\uD822[\uDC00-\uDEF2]'
    },
    {
        'name': 'Telugu',
        'bmp': '\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7F'
    },
    {
        'name': 'Thaana',
        'bmp': '\u0780-\u07B1'
    },
    {
        'name': 'Thai',
        'bmp': '\u0E01-\u0E3A\u0E40-\u0E5B'
    },
    {
        'name': 'Tibetan',
        'bmp': '\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FD4\u0FD9\u0FDA'
    },
    {
        'name': 'Tifinagh',
        'bmp': '\u2D30-\u2D67\u2D6F\u2D70\u2D7F'
    },
    {
        'name': 'Tirhuta',
        'astral': '\uD805[\uDC80-\uDCC7\uDCD0-\uDCD9]'
    },
    {
        'name': 'Ugaritic',
        'astral': '\uD800[\uDF80-\uDF9D\uDF9F]'
    },
    {
        'name': 'Vai',
        'bmp': '\uA500-\uA62B'
    },
    {
        'name': 'Warang_Citi',
        'astral': '\uD806[\uDCA0-\uDCF2\uDCFF]'
    },
    {
        'name': 'Yi',
        'bmp': '\uA000-\uA48C\uA490-\uA4C6'
    },
    {
        'name': 'Zanabazar_Square',
        'astral': '\uD806[\uDE00-\uDE47]'
    }
];


/***/ })
/******/ ]);
//# sourceMappingURL=32cb1725c23664a8920f.worker.js.map